--- sdla_aft_te3.c	2008-02-19 18:54:10.000000000 -0500
+++ /common/wanpipe/sdla_aft_te3.c	2008-02-02 12:33:18.000000000 -0500
@@ -281,12 +281,11 @@
 #endif
 static int 	if_open   (netdevice_t* dev);
 static int 	if_close  (netdevice_t* dev);
-static int 	if_do_ioctl(netdevice_t *dev, struct ifreq *ifr, int cmd);
-
-static struct net_device_stats* if_stats (netdevice_t* dev);
+static int 	if_do_ioctl(netdevice_t*, struct ifreq*, wan_ioctl_cmd_t);
 
 #if defined(__LINUX__)
 static int 	if_send (netskb_t* skb, netdevice_t* dev);
+static struct net_device_stats* if_stats (netdevice_t* dev);
 #else
 static int if_send(netdevice_t *dev, netskb_t *skb, struct sockaddr *dst,struct rtentry *rt);
 #endif
@@ -372,8 +371,8 @@
 static int 	aft_alloc_rx_dma_buff(sdla_t *card, private_area_t *chan, int num);
 static int 	aft_init_requeue_free_skb(private_area_t *chan, netskb_t *skb);
 
-static int 	write_framer(void *pcard,unsigned short framer_off,unsigned short framer_data);
-static unsigned int 	read_framer(void *pcard,unsigned short framer_off);
+//static int 	write_framer(void *pcard,unsigned short framer_off,unsigned short framer_data);
+//static unsigned int 	read_framer(void *pcard,unsigned short framer_off);
 #if 0
 //FIXME to be taken out check with M.F.
 static void 	framer_reset(sdla_t *card);
@@ -499,9 +498,6 @@
 		return -EINVAL;
 	}
 
-#if defined(WAN_DEBUG_MEM)
-        DEBUG_EVENT("%s: Total Mem %d\n",__FUNCTION__,wan_atomic_read(&wan_debug_mem));
-#endif
 
 	if (card->adptr_subtype == AFT_SUBTYPE_SHARK) {
 		DEBUG_EVENT("%s: Starting SHARK T3/E3 Adapter!\n",
@@ -512,7 +508,7 @@
 	card->wandev.clocking 			= conf->clocking;
 	card->wandev.ignore_front_end_status 	= conf->ignore_front_end_status;
 	card->wandev.ttl 			= conf->ttl;
-	card->wandev.interface 			= conf->interface;
+	card->wandev.electrical_interface 			= conf->electrical_interface;
 	card->wandev.comm_port 			= conf->comm_port;
 	card->wandev.udp_port   		= conf->udp_port;
 	card->wandev.new_if_cnt 		= 0;
@@ -534,14 +530,16 @@
 		card->fe.write_fe_cpld	= write_fe_cpld;
 
 //		card->fe.read_cpld	= read_cpld;
-		card->fe.write_framer	= write_framer;
-		card->fe.read_framer	= read_framer;
+		card->fe.write_fe_reg	= card->hw_iface.fe_write;
+		card->fe.read_fe_reg	= card->hw_iface.fe_read;
+		//card->fe.write_framer	= write_framer;
+		//card->fe.read_framer	= read_framer;
 
 //		card->wandev.write_front_end_reg = write_front_end_reg;
 //		card->wandev.read_front_end_reg = read_front_end_reg;
 		card->wandev.fe_enable_timer = enable_timer;
 		card->wandev.te_link_state = handle_front_end_state;
-//ALEX		conf->interface =
+//ALEX		conf->electrical_interface =
 //			IS_T1_CARD(card) ? WANOPT_V35 : WANOPT_RS232;
 
 		if (card->wandev.comm_port == WANOPT_PRI){
@@ -667,12 +665,12 @@
  */
 static int update (wan_device_t* wandev)
 {
-	sdla_t* card = wandev->private;
+	sdla_t* card = wandev->priv;
  	netdevice_t* dev;
         volatile private_area_t* chan;
 
 	/* sanity checks */
-	if((wandev == NULL) || (wandev->private == NULL))
+	if((wandev == NULL) || (wandev->priv == NULL))
 		return -EFAULT;
 
 	if(wandev->state == WAN_UNCONFIGURED)
@@ -744,7 +742,7 @@
  */
 static int new_if (wan_device_t* wandev, netdevice_t* dev, wanif_conf_t* conf)
 {
-	sdla_t* card = wandev->private;
+	sdla_t* card = wandev->priv;
 	private_area_t* chan;
 	int err = 0;
 	netskb_t *skb;
@@ -1015,7 +1013,6 @@
 	chan->common.iface.close = &if_close;
 	chan->common.iface.output = &if_send;
 	chan->common.iface.ioctl = &if_do_ioctl;
-	chan->common.iface.get_stats = &if_stats;
 	chan->common.iface.tx_timeout = &if_tx_timeout;
 	if (wan_iface.attach){
 		if (!ifunit(wan_netif_name(dev))){
@@ -1211,6 +1208,8 @@
 			dev->type	= ARPHRD_PPP;
 			dev->mtu		= card->wandev.mtu;
 			dev->hard_header_len	= 16;
+			dev->hard_header	= NULL; 
+			dev->rebuild_header	= NULL;
 			dev->addr_len		= 0;
 		}
 
@@ -1286,6 +1285,7 @@
 	WAN_NETIF_STOP_QUEUE(dev);
 	WAN_NETIF_CARRIER_OFF(dev);
 
+
         /* If FRONT End is down, it means that the DMA
          * is disabled.  In this case don't try to
          * reset fifo.  Let the enable_data_error_intr()
@@ -1504,7 +1504,9 @@
 	xilinx_tx_fifo_under_recover(card,chan);
 	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
 
-	aft_enable_tx_watchdog(card,AFT_TX_TIMEOUT);
+	if (!chan->single_dma_chain){	
+		aft_enable_tx_watchdog(card,AFT_TX_TIMEOUT);
+	}
 }
 
 
@@ -1662,6 +1664,7 @@
 }
 
 
+#if defined(__LINUX__)
 /*============================================================================
  * if_stats
  *
@@ -1714,9 +1717,7 @@
 
 	return &chan->if_stats;
 }
-
-
-
+#endif
 
 /*========================================================================
  *
@@ -1737,7 +1738,8 @@
  * 	     wanpipemon debugger
  *
  */
-static int if_do_ioctl(netdevice_t *dev, struct ifreq *ifr, int cmd)
+static int
+if_do_ioctl(netdevice_t *dev, struct ifreq *ifr, wan_ioctl_cmd_t cmd)
 {
 	private_area_t* chan= (private_area_t*)wan_netif_priv(dev);
 	sdla_t *card;
@@ -1857,8 +1859,8 @@
 
 		default:
 #ifndef WANPIPE_GENERIC
-			DEBUG_EVENT("%s: Command %x not supported!\n",
-				card->devname,cmd);
+			DEBUG_IOCTL("%s: Command %x not supported!\n",
+					card->devname,cmd);
 			return -EOPNOTSUPP;
 #else
 			if (card->wandev.ioctl){
@@ -2444,10 +2446,10 @@
 static void wp_bh (void* data, int dummy)
 #endif
 {
-	private_area_t* chan = (private_area_t *)data;
-	netskb_t *new_skb,*skb;
-	unsigned char pkt_error;
-	unsigned long timeout=SYSTEM_TICKS;
+	private_area_t	*chan = (private_area_t *)data;
+	netskb_t	*new_skb,*skb;
+	unsigned char	pkt_error;
+	wan_ticks_t	timeout=SYSTEM_TICKS;
 	
 	DEBUG_TEST("%s: ------------ BEGIN --------------: %lu\n",
 			__FUNCTION__,SYSTEM_TICKS);
@@ -2621,6 +2623,9 @@
                                   card->devname);
                 return 0;
         }
+	
+	DEBUG_TEST("%s: RX FIFO=0x%08X TX FIFO=0x%08X\n",
+			card->devname,rx_status,tx_status);
 
 	if (IS_TE3(&card->fe.fe_cfg)){
 		num_of_logic_ch=1;
@@ -2879,7 +2884,6 @@
                                 XILINX_DMA_RX_INTR_PENDING_REG, 
                                 &dma_rx_reg);
 
-
 		DEBUG_TEST("%s: DMA_RX_INTR_REG(0x%X) = 0x%X  ActCH=0x%lX\n",
 				card->devname,
 				XILINX_DMA_RX_INTR_PENDING_REG,dma_rx_reg,
@@ -2998,7 +3002,9 @@
 					chan->if_name,wan_test_bit(0,&chan->up));
 			}
 			aft_reset_rx_watchdog(card);
-			aft_enable_rx_watchdog(card,AFT_MAX_WTD_TIMEOUT);
+			if (!chan->single_dma_chain){
+				aft_enable_rx_watchdog(card,AFT_MAX_WTD_TIMEOUT);
+			}
 		}
 		
 		DEBUG_TEST("%s: Rx WatchDog Expired %p!\n",
@@ -3218,34 +3224,6 @@
 			wan_udp_pkt->wan_udp_return_code = 0;
 			break;
 	
-		case WAN_GET_MEDIA_TYPE:
-		case WAN_FE_GET_STAT:
-		case WAN_FE_SET_LB_MODE:
- 		case WAN_FE_FLUSH_PMON:
-		case WAN_FE_GET_CFG:
-
-			if (IS_TE3(&card->fe.fe_cfg)){
-				WAN_FECALL(&card->wandev, process_udp,
-						(&card->fe, 
-						&wan_udp_pkt->wan_udp_cmd,
-						&wan_udp_pkt->wan_udp_data[0]));
-			}else{
-				wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
-			}
-			break;
-
-		case WAN_GET_PROTOCOL:
-		   	wan_udp_pkt->wan_udp_aft_num_frames = card->wandev.config_id;
-		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
-		    	wan_udp_pkt->wan_udp_data_len = 1;
-		    	break;
-
-		case WAN_GET_PLATFORM:
-		    	wan_udp_pkt->wan_udp_data[0] = WAN_PLATFORM_ID;
-		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
-		    	wan_udp_pkt->wan_udp_data_len = 1;
-		    	break;
-
 		case READ_OPERATIONAL_STATS:
 			wan_udp_pkt->wan_udp_return_code = 0;
 			memcpy(wan_udp_pkt->wan_udp_data,&chan->opstats,sizeof(aft_op_stats_t));
@@ -3270,7 +3248,42 @@
 			wan_udp_pkt->wan_udp_data_len=0;
 			break;
 	
+		case WAN_GET_PROTOCOL:
+		   	wan_udp_pkt->wan_udp_aft_num_frames = card->wandev.config_id;
+		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
+		    	wan_udp_pkt->wan_udp_data_len = 1;
+		    	break;
+
+		case WAN_GET_PLATFORM:
+		    	wan_udp_pkt->wan_udp_data[0] = WAN_PLATFORM_ID;
+		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
+		    	wan_udp_pkt->wan_udp_data_len = 1;
+		    	break;
+
+		case WAN_GET_MASTER_DEV_NAME:
+			wan_udp_pkt->wan_udp_data_len = 0;
+			wan_udp_pkt->wan_udp_return_code = 0xCD;
+			break;			
+
+		case WAN_GET_MEDIA_TYPE:
+			if (card->wandev.fe_iface.get_fe_media){
+				wan_udp_pkt->wan_udp_data[0] = 
+					card->wandev.fe_iface.get_fe_media(&card->fe);
+				wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
+				wan_udp_pkt->wan_udp_data_len = sizeof(unsigned char); 
+			}else{
+				wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
+			}
+			break;
+
 		default:
+			if ((wan_udp_pkt->wan_udp_command & 0xF0) == WAN_FE_UDP_CMD_START){
+				WAN_FECALL(&card->wandev, process_udp,
+							(&card->fe, 
+							&wan_udp_pkt->wan_udp_cmd,
+							&wan_udp_pkt->wan_udp_data[0]));
+				break;
+			}
 			wan_udp_pkt->wan_udp_data_len = 0;
 			wan_udp_pkt->wan_udp_return_code = 0xCD;
 	
@@ -3927,7 +3940,7 @@
 
         /* TE1 Update T1/E1 alarms */
 	if (IS_TE3(&card->fe.fe_cfg)) {
-		WAN_FECALL(&card->wandev, read_alarm, (&card->fe, 0));
+		WAN_FECALL(&card->wandev, read_alarm, (&card->fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE));
 		/* TE1 Update T1/E1 perfomance counters */
 		WAN_FECALL(&card->wandev, read_pmon, (&card->fe, 0));
          }
@@ -3971,7 +3984,9 @@
 		wanpipe_lip_kick(chan,0);
 	}
 #endif
-	aft_enable_tx_watchdog(card,AFT_TX_TIMEOUT);
+	if (!chan->single_dma_chain){
+		aft_enable_tx_watchdog(card,AFT_TX_TIMEOUT);
+	}
 }
 
 static int xilinx_write_ctrl_hdlc(sdla_t *card, u32 timeslot, u8 reg_off, u32 data)
@@ -4213,7 +4228,7 @@
 
 	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
 
-	WP_DELAY(100);
+	WP_DELAY(10);
 
 	/* Disable the chip/hdlc reset condition */
 	wan_clear_bit(CHIP_RESET_BIT,&reg);
@@ -4280,8 +4295,6 @@
 	DEBUG_CFG("--- T3 Exar Chip enable/config. -- \n");
 
 	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
-	
-	WP_DELAY(100);
 
 	xilinx_delay(1);
 #if 0
@@ -4453,6 +4466,15 @@
 		card->u.xilinx.dev_to_ch_map[0]=(void*)chan;
 	}
 
+	  /* Setup global DMA parameters */
+	if (chan->single_dma_chain){
+        	card->hw_iface.bus_read_4(card->hw,XILINX_DMA_CONTROL_REG,&reg);
+        	reg&=~DMA_CHAIN_TE3_MASK;
+        	reg|=1&DMA_CHAIN_TE3_MASK;
+        	card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
+	}
+
+
 	reg=0;
 	
 	if (chan->hdlc_eng){
@@ -4571,6 +4593,9 @@
 }
 
 
+#if 0
+/* Alex
+** This functions are moved to sdladrv_fe.c */
 #define BIT_DEV_ADDR_CLEAR      0x600
 
 static int write_framer(void *pcard, unsigned short framer_off,unsigned short framer_data)
@@ -4585,12 +4610,10 @@
 	card->hw_iface.bus_write_2(card->hw,
 				   0x46,
 				   framer_off);
-	WP_DELAY(5);
 
 	card->hw_iface.bus_write_2(card->hw,
 				   0x44,
 				   framer_data);	
-	WP_DELAY(5);
         return 0;
 }
 
@@ -4605,18 +4628,17 @@
 	card->hw_iface.bus_write_2(card->hw,
 				   0x46,
 				   framer_off);
-	WP_DELAY(5);
 
 	card->hw_iface.bus_read_4(card->hw,
 				   0x44,
 				   &framer_data);
-	WP_DELAY(5);
 	
 	DEBUG_TEST("READ FRAMER OFFSET=0x%02X DATA=0x%02X\n",
 			framer_off,framer_data);
 
         return framer_data;
 }
+#endif
 
 #if 0
 static void framer_reset(sdla_t *card)
@@ -4805,7 +4827,7 @@
 
 	wan_set_bit(TxDMA_HI_DMA_GO_READY_BIT,&reg);
 
-	DEBUG_TX("%s: TXDMA_HI=0x%X DmaDescr=0x%lX len=%i\n",
+	DEBUG_TEST("%s: TXDMA_HI=0x%X DmaDescr=0x%lX len=%i\n",
 			__FUNCTION__,reg,dma_chain->dma_addr,len);
 
 	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
@@ -4973,6 +4995,24 @@
 		}
 	}
 
+#if 0
+	if (0){
+ 		netskb_t *nskb=__dev_alloc_skb(wan_skb_len(skb),GFP_DMA|GFP_ATOMIC);
+		if (!nskb) {
+ 			wan_skb_free(skb);
+                        wan_clear_bit(0,&dma_chain->init);
+                        chan->if_stats.tx_errors++;
+                        return -EINVAL;
+		} else {
+			unsigned char *buf = wan_skb_put(nskb,wan_skb_len(skb));
+			memcpy(buf,wan_skb_data(skb),wan_skb_len(skb));
+			wan_skb_free(skb);
+			skb=nskb;
+		}
+	}
+#endif
+
+
 	dma_chain->skb=skb;
 		
 	dma_chain->dma_addr = 
@@ -5032,7 +5072,7 @@
 		if (!wan_test_bit(TX_INTR_PENDING,&chan->dma_chain_status)){
 			aft_enable_tx_watchdog(card,AFT_TX_TIMEOUT);
 		}
-	}
+	} 
 	
 	wan_clear_bit(TX_DMA_BUSY,&chan->dma_status);
 
@@ -5106,7 +5146,7 @@
 
 	wan_set_bit(RxDMA_HI_DMA_GO_READY_BIT,&reg);
 
-	DEBUG_RX("%s: RXDMA_HI = 0x%X, BusAddr=0x%X DmaDescr=0x%X\n",
+	DEBUG_TEST("%s: RXDMA_HI = 0x%X, BusAddr=0x%X DmaDescr=0x%X\n",
  	             __FUNCTION__,reg,dma_chain->dma_addr,dma_descr);
 
 	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
@@ -5406,7 +5446,7 @@
 				aft_enable_rx_watchdog(card,AFT_MAX_WTD_TIMEOUT);
 				chan->rx_no_data_cnt=-1;
 			}
-		}
+		} 
 	}
 
 reset_skip_rx_setup:
@@ -5821,11 +5861,15 @@
 static void aft_port_task (void * card_ptr, int arg)
 #endif
 {
-#if defined(__LINUX__) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))   
+#if defined(__LINUX__)
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))   
         sdla_t 		*card = (sdla_t *)container_of(work, sdla_t, u.aft.port_task);
+# else
+	sdla_t 		*card = (sdla_t *)card_ptr;
+# endif
 #else
 	sdla_t 		*card = (sdla_t *)card_ptr;
-#endif        
+#endif 
 	wan_smp_flag_t	smp_flags,isr_flags;
 
 	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
--- sdla_te3.c	2008-01-11 14:07:46.000000000 -0500
+++ /common/wanpipe/sdla_te3.c	2008-01-18 17:18:00.000000000 -0500
@@ -52,27 +52,18 @@
 **			  DEFINES AND MACROS
 ******************************************************************************/
 
-#if defined(DEBUG)
-# define WRITE_CPLD(reg,val)						\
-	DEBUG_EVENT("%s: Write to CPLD reg %d value %X\n", 		\
-			fe->name, reg, val);
-
-# define WRITE_REG(reg,val) 						\
-	DEBUG_EVENT("%s: Write to Framer off %X value %X\n", 		\
-			fe->name, reg, val);
-#else
-
-# define WRITE_CPLD(reg,val)						\
-	(fe->write_cpld) ? fe->write_cpld(fe->card, reg, val) : -EINVAL
+#define WRITE_CPLD(reg,val)						\
+		fe->write_cpld(fe->card, (reg), (val))
 
-# define WRITE_EXAR_CPLD(reg,val)						\
-	(fe->write_fe_cpld) ? fe->write_fe_cpld(fe->card, reg, val) : -EINVAL
+#define WRITE_EXAR_CPLD(reg,val)					\
+		fe->write_fe_cpld(fe->card, (reg), (val))
 
-# define WRITE_REG(reg,val)						\
-	(fe->write_framer) ? fe->write_framer(fe->card, reg, val) : -EINVAL
-# define READ_REG(reg)						\
-	(fe->read_framer) ? fe->read_framer(fe->card, reg) : 0
-#endif
+#define WRITE_REG(reg,val)						\
+	fe->write_fe_reg(						\
+		((sdla_t*)fe->card)->hw,(int)(reg),(int)(val));
+#define READ_REG(reg)							\
+	fe->read_fe_reg(						\
+		((sdla_t*)fe->card)->hw,(int)(reg));
 
 #define WAN_FE_SWAP_BIT(value, mask)					\
 	if ((value) & mask){						\
@@ -105,8 +96,9 @@
 static int sdla_e3_isr(sdla_fe_t *fe);
 static int sdla_te3_isr(sdla_fe_t *fe);
 static int sdla_te3_udp(sdla_fe_t *fe, void*, unsigned char*);
-static unsigned int sdla_te3_alarm(sdla_fe_t *fe, int);
+static unsigned int sdla_te3_read_alarms(sdla_fe_t *fe, int);
 static int sdla_te3_read_pmon(sdla_fe_t *fe, int);
+static int sdla_te3_flush_pmon(sdla_fe_t *fe);
 
 static int sdla_te3_update_alarm_info(sdla_fe_t* fe, struct seq_file* m, int* stop_cnt);
 static int sdla_te3_update_pmon_info(sdla_fe_t* fe, struct seq_file* m, int* stop_cnt);
@@ -221,6 +213,8 @@
 {
 	unsigned char	value;
 	
+	WAN_ASSERT(fe->write_fe_reg == NULL);
+	WAN_ASSERT(fe->read_fe_reg == NULL);
 	value = READ_REG(REG_TxDS3_LAPD_STATUS);
 	if (value & BIT_TxDS3_LAPD_STATUS_INT){
 		DEBUG_EVENT("%s: LAPD Interrupt!\n",
@@ -240,43 +234,35 @@
 {
 	unsigned char	value, status;
 
+	WAN_ASSERT(fe->write_fe_reg == NULL);
+	WAN_ASSERT(fe->read_fe_reg == NULL);
 	/* RxDS3 Interrupt status register (0x13) */
 	value = READ_REG(REG_RxDS3_INT_STATUS);
 	status = READ_REG(REG_RxDS3_CFG_STATUS);
 	if (fe->fe_cfg.frame == WAN_FR_DS3_Cbit && value & BIT_RxDS3_INT_STATUS_CPBIT_ERR){
-		if (WAN_NET_RATELIMIT()){
-			DEBUG_TE3("%s: CP Bit Error interrupt detected!\n",
+		DEBUG_TE3("%s: CP Bit Error interrupt detected!\n",
 						fe->name);
-		}
 	}
 	if (value & BIT_RxDS3_INT_STATUS_LOS){
 		if (status & BIT_RxDS3_CFG_STATUS_RxLOS){
-			if (WAN_NET_RATELIMIT()){
 			DEBUG_EVENT("%s: LOS Status ON!\n",
 						fe->name);
-			}
 			fe->fe_alarm |= WAN_TE3_BIT_LOS_ALARM;
 		}else{
-			if (WAN_NET_RATELIMIT()){
 			DEBUG_EVENT("%s: LOS Status OFF!\n",
 						fe->name);
-			}
 			fe->fe_alarm &= ~WAN_TE3_BIT_LOS_ALARM;
 		}
 	}
 	if (value & BIT_RxDS3_INT_STATUS_AIS){
-		if (WAN_NET_RATELIMIT()){
 		DEBUG_EVENT("%s: AIS status %s!\n",
 				fe->name,
 				(status & BIT_RxDS3_CFG_STATUS_RxAIS) ? "ON" : "OFF");
-		}
 	}
 	if (value & BIT_RxDS3_INT_STATUS_IDLE){
-		if (WAN_NET_RATELIMIT()){
-		DEBUG_TE3("%s: IDLE condition status %s!\n",
+		DEBUG_EVENT("%s: IDLE condition status %s!\n",
 				fe->name,
 				(status & BIT_RxDS3_CFG_STATUS_RxIDLE) ? "ON" : "OFF");
-		}
 	}
 	if (value & BIT_RxDS3_INT_STATUS_OOF){
 		if (status & BIT_RxDS3_CFG_STATUS_RxLOS){
@@ -302,27 +288,23 @@
 		}
 	}
 	if (fe->fe_cfg.frame == WAN_FR_DS3_Cbit && value & BIT_RxDS3_INT_STATUS_AIC){
-		if (WAN_NET_RATELIMIT()){
 		DEBUG_TE3("%s: AIC bit-field status %s!\n",
 				fe->name,
 				(status & BIT_RxDS3_STATUS_RxAIC) ? "ON" : "OFF");
-		}
 	}
 	if (value & BIT_RxDS3_INT_STATUS_PBIT_ERR){
-		if (WAN_NET_RATELIMIT()){
 		DEBUG_TE3("%s: P-Bit error interrupt!\n",
 					fe->name);
-		}
 	}
 
 	/* RxDS3 FEAC Interrupt (0x17) */
 	value = READ_REG(REG_RxDS3_FEAC_INT);
 	if (value & BIT_RxDS3_FEAC_REMOVE_INT_STATUS){
-		DEBUG_TE3("%s: RxFEAC Remove Interrupt!\n",
+		DEBUG_EVENT("%s: RxFEAC Remove Interrupt!\n",
 				fe->name);
 	}
 	if (value & BIT_RxDS3_FEAC_VALID_INT_STATUS){
-		DEBUG_TE3("%s: RxFEAC Valid Interrupt!\n",
+		DEBUG_EVENT("%s: RxFEAC Valid Interrupt!\n",
 				fe->name);
 	}
 
@@ -340,6 +322,8 @@
 {
 	unsigned char	value;
 	
+	WAN_ASSERT(fe->write_fe_reg == NULL);
+	WAN_ASSERT(fe->read_fe_reg == NULL);
 	value = READ_REG(REG_BLOCK_INT_STATUS);
 	if (value & BIT_BLOCK_INT_STATUS_RxDS3_E3){
 		sdla_ds3_rx_isr(fe);
@@ -379,6 +363,9 @@
 	unsigned char	int_status1, int_status2;
 	unsigned char	status;
 
+	WAN_ASSERT(fe->write_fe_reg == NULL);
+	WAN_ASSERT(fe->read_fe_reg == NULL);
+
 	int_status1 = READ_REG(REG_RxE3_INT_STATUS_1);
 	int_status2 = READ_REG(REG_RxE3_INT_STATUS_2);
 	status = READ_REG(REG_RxE3_CFG_STATUS_2);
@@ -457,6 +444,9 @@
 {
 	unsigned char	value;
 	
+	WAN_ASSERT(fe->write_fe_reg == NULL);
+	WAN_ASSERT(fe->read_fe_reg == NULL);
+
 	value = READ_REG(REG_BLOCK_INT_STATUS);
 	if (value & BIT_BLOCK_INT_STATUS_RxDS3_E3){
 		sdla_e3_rx_isr(fe);
@@ -478,10 +468,8 @@
 static int sdla_te3_isr(sdla_fe_t *fe)
 {
 	sdla_fe_cfg_t	*fe_cfg = &fe->fe_cfg;
-	unsigned char	value;
 	int		err = 0;
 	
-	value = READ_REG(REG_BLOCK_INT_STATUS);
 	switch(fe_cfg->media){
 	case WAN_MEDIA_DS3:
 		err = sdla_ds3_isr(fe);
@@ -490,113 +478,135 @@
 		err = sdla_e3_isr(fe);
 		break;
 	}
-	fe->fe_alarm = sdla_te3_alarm(fe, 1);
+	sdla_te3_set_status(fe);
 	return err;
 }
 
 /******************************************************************************
- *				sdla_te3_alarm()	
+ *				sdla_te3_read_alarms()	
  *
  * Description:
  * Arguments:	
  * Returns:
  ******************************************************************************
  */
-static unsigned int sdla_te3_alarm(sdla_fe_t *fe, int update)
+static unsigned int sdla_te3_read_framer_alarms(sdla_fe_t *fe)
 {
 	sdla_fe_cfg_t	*fe_cfg = &fe->fe_cfg;
-	unsigned int	alarm = 0;
+	unsigned int	alarms = 0;
 	unsigned char	value;
-	
+
+	WAN_ASSERT(fe->write_fe_reg == NULL);
+	WAN_ASSERT(fe->read_fe_reg == NULL);
+
 	if (fe_cfg->media == WAN_MEDIA_DS3){
 		value = READ_REG(REG_RxDS3_CFG_STATUS);
 		if (value & BIT_RxDS3_CFG_STATUS_RxAIS){
-			alarm |= WAN_TE3_BIT_AIS_ALARM;
-			DEBUG_TE3("%s: (T3/E3) AIS Alarm is ON\n", fe->name);
+			alarms |= WAN_TE3_BIT_AIS_ALARM;
 		}else{
-			alarm &= ~WAN_TE3_BIT_AIS_ALARM;
-			DEBUG_TE3("%s: (T3/E3) AIS Alarm is OFF\n", fe->name);
+			alarms &= ~WAN_TE3_BIT_AIS_ALARM;
 		}	
 		if (value & BIT_RxDS3_CFG_STATUS_RxLOS){
-			alarm |= WAN_TE3_BIT_LOS_ALARM;
-			DEBUG_TE3("%s: (T3/E3) LOS Alarm is ON\n", fe->name);
+			alarms |= WAN_TE3_BIT_LOS_ALARM;
 		}else{
-			alarm &= ~WAN_TE3_BIT_LOS_ALARM;
-			DEBUG_TE3("%s: (T3/E3) LOS Alarm is OFF\n", fe->name);
+			alarms &= ~WAN_TE3_BIT_LOS_ALARM;
 		}
 		if (value & BIT_RxDS3_CFG_STATUS_RxOOF){
-			alarm |= WAN_TE3_BIT_OOF_ALARM;
-			DEBUG_TE3("%s: (T3/E3) OOF Alarm is ON\n", fe->name);
+			alarms |= WAN_TE3_BIT_OOF_ALARM;
 		}else{
-			alarm &= ~WAN_TE3_BIT_OOF_ALARM;
-			DEBUG_TE3("%s: (T3/E3) OOF Alarm is OFF\n", fe->name);
+			alarms &= ~WAN_TE3_BIT_OOF_ALARM;
 		}
 		value = READ_REG(REG_RxDS3_STATUS);
 		if (value & BIT_RxDS3_STATUS_RxFERF){
-			alarm |= WAN_TE3_BIT_YEL_ALARM;
-			DEBUG_TE3("%s: (T3/E3) YEL Alarm is ON\n", fe->name);
+			alarms |= WAN_TE3_BIT_YEL_ALARM;
 		}else{
-			alarm &= ~WAN_TE3_BIT_YEL_ALARM;
-			DEBUG_TE3("%s: (T3/E3) YEL Alarm is OFF\n", fe->name);
+			alarms &= ~WAN_TE3_BIT_YEL_ALARM;
 		}
 	}else{
 		value = READ_REG(REG_RxE3_CFG_STATUS_2);
 		if (value & BIT_RxE3_CFG_STATUS_RxOOF){
-			DEBUG_TE3("%s: (T3/E3) OOF Alarm ON!\n",
-						fe->name);
-			alarm |= WAN_TE3_BIT_OOF_ALARM;
+			alarms |= WAN_TE3_BIT_OOF_ALARM;
 		}else{
-			DEBUG_TE3("%s: (T3/E3) OOF Alarm OFF!\n",
-						fe->name);
-			alarm &= ~WAN_TE3_BIT_OOF_ALARM;
+			alarms &= ~WAN_TE3_BIT_OOF_ALARM;
 		}
 
 		if (value & BIT_RxE3_CFG_STATUS_RxLOF){
-			DEBUG_TE3("%s: (T3/E3) LOF Alarm ON!\n",
-						fe->name);
-			alarm |= WAN_TE3_BIT_LOF_ALARM;
+			alarms |= WAN_TE3_BIT_LOF_ALARM;
 		}else{
-			DEBUG_TE3("%s: (T3/E3) LOF Alarm OFF!\n",
-						fe->name);
-			alarm &= ~WAN_TE3_BIT_LOF_ALARM;
+			alarms &= ~WAN_TE3_BIT_LOF_ALARM;
 		}
 
 		if (value & BIT_RxE3_CFG_STATUS_RxLOS){
-			DEBUG_TE3("%s: (T3/E3) LOS Alarm ON!\n",
-						fe->name);
-			alarm |= WAN_TE3_BIT_LOS_ALARM;
+			alarms |= WAN_TE3_BIT_LOS_ALARM;
 		}else{
-			DEBUG_TE3("%s: (T3/E3) LOS Alarm OFF!\n",
-						fe->name);
-			alarm &= ~WAN_TE3_BIT_LOS_ALARM;
+			alarms &= ~WAN_TE3_BIT_LOS_ALARM;
 		}
 	
 		if (value & BIT_RxE3_CFG_STATUS_RxAIS){
-			DEBUG_TE3("%s: (T3/E3) AIS Alarm ON!\n",
-						fe->name);
-			alarm |= WAN_TE3_BIT_AIS_ALARM;
+			alarms |= WAN_TE3_BIT_AIS_ALARM;
 		}else{
-			DEBUG_TE3("%s: (T3/E3) AIS Alarm OFF!\n",
-						fe->name);
-			alarm &= ~WAN_TE3_BIT_AIS_ALARM;
+			alarms &= ~WAN_TE3_BIT_AIS_ALARM;
 		}
 	
 		if (value & BIT_RxE3_CFG_STATUS_RxFERF){
-			DEBUG_TE3("%s: (T3/E3) Rx FERF status is ON (YELLOW)!\n",
-					fe->name);
-			alarm |= WAN_TE3_BIT_YEL_ALARM;
+			alarms |= WAN_TE3_BIT_YEL_ALARM;
 		}else{
-			DEBUG_TE3("%s: (T3/E3) Rx FERF status is OFF!\n",
-					fe->name);
-			alarm &= ~WAN_TE3_BIT_YEL_ALARM;
+			alarms &= ~WAN_TE3_BIT_YEL_ALARM;
 		}
 	}
+	return alarms;
+}
 
-	fe->fe_alarm = alarm;
-	if (update){
-		sdla_te3_set_status(fe);
+static int sdla_te3_print_alarms(sdla_fe_t *fe, unsigned int alarms)
+{
+	
+	DEBUG_EVENT("%s: %s Framer Alarms status (%X):\n",
+			fe->name,
+			FE_MEDIA_DECODE(fe),
+			alarms);
+
+	if (!alarms){
+		DEBUG_EVENT("%s: %s Alarms status: No alarms detected!\n",
+				fe->name,
+				FE_MEDIA_DECODE(fe));
+		return 0;
 	}
-	return alarm;
+	if (alarms & WAN_TE3_BIT_AIS_ALARM){
+		DEBUG_EVENT("%s:    AIS Alarm is ON\n", fe->name);
+	}
+	if (alarms & WAN_TE3_BIT_LOS_ALARM){
+		DEBUG_EVENT("%s:    LOS Alarm is ON\n", fe->name);
+	}
+	if (alarms & WAN_TE3_BIT_OOF_ALARM){
+		DEBUG_EVENT("%s:    OOF Alarm is ON\n", fe->name);
+	}
+	if (alarms & WAN_TE3_BIT_YEL_ALARM){
+		DEBUG_EVENT("%s:    YEL Alarm is ON\n", fe->name);
+	}
+	if (alarms & WAN_TE3_BIT_LOF_ALARM){
+		DEBUG_EVENT("%s:    LOF Alarm OFF!\n", fe->name);
+	}
+	
+	return 0;
+}
+
+static unsigned int sdla_te3_read_alarms(sdla_fe_t *fe, int action)
+{
+	unsigned int	alarms = 0;
+	
+	if (IS_FE_ALARM_READ(action)){
+		alarms = sdla_te3_read_framer_alarms(fe);
+	}
+
+	if (IS_FE_ALARM_PRINT(action)){
+		sdla_te3_print_alarms(fe, alarms);
+	}
+
+	if (IS_FE_ALARM_UPDATE(action)){
+		fe->fe_alarm = alarms;
+		sdla_te3_set_status(fe);
+	} 
+	return alarms;
 }
 
 
@@ -616,18 +626,20 @@
 }
 
 /******************************************************************************
- *				sdla_te3_read_pmon()	
- *
- * Description:
- * Arguments:	
- * Returns:
- ******************************************************************************
- */
+*				sdla_te3_read_pmon()	
+*
+* Description:
+* Arguments:	
+* Returns:
+******************************************************************************/
 static int sdla_te3_read_pmon(sdla_fe_t *fe, int action)
 {
 	sdla_te3_pmon_t	*pmon = (sdla_te3_pmon_t*)&fe->fe_stats.u.te3_pmon;
 	unsigned char value_msb, value_lsb;
 
+	WAN_ASSERT(fe->write_fe_reg == NULL);
+	WAN_ASSERT(fe->read_fe_reg == NULL);
+
 	value_msb = READ_REG(REG_PMON_LCV_MSB);
 	value_lsb = READ_REG(REG_PMON_LCV_LSB);
 	pmon->pmon_lcv += ((value_msb << 8) | value_lsb);
@@ -651,6 +663,112 @@
 }
 
 /******************************************************************************
+*				sdla_te3_flush_pmon()	
+*
+* Description:
+* Arguments:
+* Returns:
+******************************************************************************/
+static int sdla_te3_flush_pmon(sdla_fe_t *fe)
+{
+	sdla_te3_pmon_t	*pmon = (sdla_te3_pmon_t*)&fe->fe_stats.u.te3_pmon;
+
+	pmon->pmon_lcv		= 0;
+	pmon->pmon_framing	= 0; 
+	pmon->pmon_parity	= 0; 
+	pmon->pmon_febe		= 0; 
+	pmon->pmon_cpbit  	= 0; 
+	return 0;
+}
+
+/******************************************************************************
+*				sdla_te3_old_set_lb_modes()	
+*
+* Description:
+* Arguments:
+* Returns:
+******************************************************************************/
+static int 
+sdla_te3_old_set_lb_modes(sdla_fe_t *fe, unsigned char type, unsigned char mode)
+{
+
+	WAN_ASSERT(fe->write_cpld == NULL);
+	DEBUG_EVENT("%s: %s %s mode...\n",
+			fe->name,
+			WAN_TE3_LB_MODE_DECODE(mode),
+			WAN_TE3_LB_TYPE_DECODE(type));
+
+	if (mode == WAN_TE3_DEACTIVATE_LB){
+		fe->te3_param.cpld_status &= ~BIT_CPLD_STATUS_LLB;
+		fe->te3_param.cpld_status &= ~BIT_CPLD_STATUS_RLB;
+	}else{
+		switch(type){
+		case WAN_TE3_LIU_LB_ANALOG:
+			fe->te3_param.cpld_status |= BIT_CPLD_STATUS_LLB;
+			fe->te3_param.cpld_status &= ~BIT_CPLD_STATUS_RLB;
+			break;
+		case WAN_TE3_LIU_LB_REMOTE:
+			fe->te3_param.cpld_status &= ~BIT_CPLD_STATUS_LLB;
+			fe->te3_param.cpld_status |= BIT_CPLD_STATUS_RLB;
+			break;
+		case WAN_TE3_LIU_LB_DIGITAL:
+			fe->te3_param.cpld_status |= BIT_CPLD_STATUS_LLB;
+			fe->te3_param.cpld_status |= BIT_CPLD_STATUS_RLB;
+			break;
+		default :
+			DEBUG_EVENT("%s: (T3/E3) Unknown loopback mode!\n",
+					fe->name);
+			break;
+		}		
+	}
+	/* Write value to CPLD Status/Control register */
+	WRITE_CPLD(REG_CPLD_STATUS, fe->te3_param.cpld_status);
+	return 0;
+}
+ 
+static int 
+sdla_te3_set_lb_modes(sdla_fe_t *fe, unsigned char type, unsigned char mode) 
+{
+	unsigned char	data = 0x00;
+
+	WAN_ASSERT(fe->write_fe_reg == NULL);
+	WAN_ASSERT(fe->read_fe_reg == NULL);
+	DEBUG_EVENT("%s: %s %s mode...\n",
+			fe->name,
+			WAN_TE3_LB_MODE_DECODE(mode),
+			WAN_TE3_LB_TYPE_DECODE(type));
+
+	data = READ_REG(REG_LINE_INTERFACE_DRIVE);
+	if (mode == WAN_TE3_DEACTIVATE_LB){
+		data &= ~BIT_LINE_INTERFACE_DRIVE_LLOOP;
+		data &= ~BIT_LINE_INTERFACE_DRIVE_RLOOP;
+	}else{
+		switch(type){
+		case WAN_TE3_LIU_LB_NORMAL:
+			break;
+		case WAN_TE3_LIU_LB_ANALOG:
+			data |= BIT_LINE_INTERFACE_DRIVE_LLOOP;
+			data &= ~BIT_LINE_INTERFACE_DRIVE_RLOOP;
+			break;
+		case WAN_TE3_LIU_LB_REMOTE:
+			data &= ~BIT_LINE_INTERFACE_DRIVE_LLOOP;
+			data |= BIT_LINE_INTERFACE_DRIVE_RLOOP;
+			break;
+		case WAN_TE3_LIU_LB_DIGITAL:
+			data |= BIT_LINE_INTERFACE_DRIVE_LLOOP;
+			data |= BIT_LINE_INTERFACE_DRIVE_RLOOP;
+			break;
+		default :
+			DEBUG_EVENT("%s: (T3/E3) Unknown loopback mode!\n",
+					fe->name);
+			break;
+		}		
+	}
+	WRITE_REG(REG_LINE_INTERFACE_DRIVE, data);
+	return 0;
+}
+
+/******************************************************************************
  *				sdla_te3_udp()	
  *
  * Description:
@@ -660,7 +778,9 @@
  */
 static int sdla_te3_udp(sdla_fe_t *fe, void *pudp_cmd, unsigned char *data)
 {
+	sdla_t		*card = (sdla_t*)fe->card;
 	wan_cmd_t	*udp_cmd = (wan_cmd_t*)pudp_cmd;
+	int		err = -EINVAL;
 
 	switch(udp_cmd->wan_cmd_command){
 	case WAN_GET_MEDIA_TYPE:
@@ -671,19 +791,26 @@
 
 	case WAN_FE_SET_LB_MODE:
 		/* Activate/Deactivate Line Loopback modes */
-//		err = sdla_set_te1_lb_modes(card, data[0], data[1]); 
-//	    	udp_cmd->wan_cmd_return_code = 
-//				(!err) ? WAN_CMD_OK : WAN_UDP_FAILED_CMD;
-//	    	udp_cmd->wan_cmd_data_len = 0x00;
+		if (card->adptr_subtype == AFT_SUBTYPE_NORMAL){
+			err = sdla_te3_old_set_lb_modes(fe, data[0], data[1]); 
+		}else if (card->adptr_subtype == AFT_SUBTYPE_SHARK){
+			err = sdla_te3_set_lb_modes(fe, data[0], data[1]); 
+		}
+	    	udp_cmd->wan_cmd_return_code = 
+				(!err) ? WAN_CMD_OK : WAN_UDP_FAILED_CMD;
+	    	udp_cmd->wan_cmd_data_len = 0x00;
 		break;
 
 	case WAN_FE_GET_STAT:
  	        /* TE1_56K Read T1/E1/56K alarms */
-#if 0
-	  	*(unsigned long *)&data[0] = sdla_te3_alarm(fe, 0);
-#endif
-		/* TE1 Update T1/E1 perfomance counters */
     		sdla_te3_read_pmon(fe, 0);
+		if (udp_cmd->wan_cmd_fe_force){
+			/* force to read FE alarms */
+			DEBUG_EVENT("%s: Force to read Front-End alarms\n",
+						fe->name);
+			fe->fe_stats.alarms = 
+				sdla_te3_read_alarms(fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE);
+		}
 	        memcpy(&data[0], &fe->fe_stats, sizeof(sdla_fe_stats_t));
 	        udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
 	    	udp_cmd->wan_cmd_data_len = sizeof(sdla_fe_stats_t); 
@@ -691,7 +818,7 @@
 
  	case WAN_FE_FLUSH_PMON:
 		/* TE1 Flush T1/E1 pmon counters */
-//		memset(&fe->fe_stats.u.te3_pmon, 0, sizeof(sdla_te3_pmon_t));
+		sdla_te3_flush_pmon(fe);
 	        udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
 		break;
  
@@ -716,6 +843,9 @@
 {
 	sdla_fe_cfg_t	*fe_cfg = &fe->fe_cfg;
 
+	WAN_ASSERT(fe->write_fe_reg == NULL);
+	WAN_ASSERT(fe->read_fe_reg == NULL);
+
 	DEBUG_EVENT("%s: Enabling interrupts for %s (%d)!\n",
 					fe->name, FE_MEDIA_DECODE(fe), IS_DS3(fe_cfg));
 	/* Enable Framer Interrupts */
@@ -778,6 +908,7 @@
 	sdla_fe_cfg_t	*fe_cfg = &fe->fe_cfg;
 	unsigned char	data = 0x00;
 
+	WAN_ASSERT(fe->write_cpld == NULL);
 	if (fe_cfg->media == WAN_MEDIA_E3){
 		data |= BIT_CPLD_CNTRL_E3;
 	}
@@ -812,33 +943,7 @@
 				name);
 		data &= ~BIT_CPLD_STATUS_TAOS;
 	}
-	switch(liu->lb_mode){
-	case WAN_TE3_LIU_LB_NORMAL:
-		break;
-	case WAN_TE3_LIU_LB_ANALOG:
-		DEBUG_TE3("%s: (T3/E3) Enable Analog Loopback mode!\n",
-				name);
-		data |= BIT_CPLD_STATUS_LLB;
-		data &= ~BIT_CPLD_STATUS_RLB;
-		break;
-	case WAN_TE3_LIU_LB_REMOTE:
-		DEBUG_TE3("%s: (T3/E3) Enable Remote Loopback mode!\n",
-				name);
-		data &= ~BIT_CPLD_STATUS_LLB;
-		data |= BIT_CPLD_STATUS_RLB;
-		break;
-	case WAN_TE3_LIU_LB_DIGITAL:
-		DEBUG_TE3("%s: (T3/E3) Enable Digital Loopback mode!\n",
-				name);
-		data |= BIT_CPLD_STATUS_LLB;
-		data |= BIT_CPLD_STATUS_RLB;
-		break;
-	default :
-		DEBUG_EVENT("%s: (T3/E3) Unknown loopback mode!\n",
-				name);
-		break;
-	}		
-	/* Write value to CPLD Status/Control register */
+	/* Write value to CPLD Status register */
 	WRITE_CPLD(REG_CPLD_STATUS, data);
 	return 0;
 }
@@ -857,11 +962,13 @@
 	sdla_fe_cfg_t	*fe_cfg = &fe->fe_cfg;
 	unsigned char	data = 0x00;
 
+	WAN_ASSERT(fe->write_fe_cpld == NULL);
+	fe->te3_param.cpld_cntrl = 0x00;
 	if (fe_cfg->media == WAN_MEDIA_E3){
-		data |= BIT_EXAR_CPLD_CNTRL_E3;
+		fe->te3_param.cpld_cntrl |= BIT_EXAR_CPLD_CNTRL_E3;
 	}
 	/* Write value to CPLD Control register */
-	WRITE_EXAR_CPLD(REG_EXAR_CPLD_CNTRL, data);
+	WRITE_EXAR_CPLD(REG_EXAR_CPLD_CNTRL, fe->te3_param.cpld_cntrl);
 	
 	data = 0x00;
 	if (liu->rx_equal == WAN_TRUE){
@@ -892,33 +999,6 @@
 		data &= ~BIT_LINE_INTERFACE_DRIVE_TAOS;
 	}
 	
-	switch(liu->lb_mode){
-	case WAN_TE3_LIU_LB_NORMAL:
-		break;
-	case WAN_TE3_LIU_LB_ANALOG:
-		DEBUG_TE3("%s: (T3/E3) Enable Analog Loopback mode!\n",
-				name);
-		data |= BIT_LINE_INTERFACE_DRIVE_LLOOP;
-		data &= ~BIT_LINE_INTERFACE_DRIVE_RLOOP;
-		break;
-	case WAN_TE3_LIU_LB_REMOTE:
-		DEBUG_TE3("%s: (T3/E3) Enable Remote Loopback mode!\n",
-				name);
-		data &= ~BIT_LINE_INTERFACE_DRIVE_LLOOP;
-		data |= BIT_LINE_INTERFACE_DRIVE_RLOOP;
-		break;
-	case WAN_TE3_LIU_LB_DIGITAL:
-		DEBUG_TE3("%s: (T3/E3) Enable Digital Loopback mode!\n",
-				name);
-		data |= BIT_LINE_INTERFACE_DRIVE_LLOOP;
-		data |= BIT_LINE_INTERFACE_DRIVE_RLOOP;
-		break;
-	default :
-		DEBUG_EVENT("%s: (T3/E3) Unknown loopback mode!\n",
-				name);
-		break;
-	}		
-	WRITE_REG(REG_LINE_INTERFACE_DRIVE, data);
 	
 	return 0;
 }
@@ -934,8 +1014,9 @@
 	fe_iface->polling		= &sdla_te3_polling;
 	fe_iface->isr			= &sdla_te3_isr;
 	fe_iface->process_udp		= &sdla_te3_udp;
-	fe_iface->read_alarm		= &sdla_te3_alarm;
+	fe_iface->read_alarm		= &sdla_te3_read_alarms;
 	fe_iface->read_pmon		= &sdla_te3_read_pmon;
+	fe_iface->flush_pmon		= &sdla_te3_flush_pmon;
 	fe_iface->set_fe_alarm		= &sdla_te3_set_alarm;
 	fe_iface->get_fe_status		= &sdla_te3_get_fe_status;
 	fe_iface->get_fe_media		= &sdla_te3_get_fe_media;
@@ -954,6 +1035,9 @@
 	u16		adptr_subtype;
 	unsigned char	data = 0x00;
 	
+	WAN_ASSERT(fe->write_fe_reg == NULL);
+	WAN_ASSERT(fe->read_fe_reg == NULL);
+
 	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERSUBTYPE, &adptr_subtype);
 	
 	data = READ_REG(0x02);
@@ -1067,7 +1151,7 @@
 	fe->fe_status	= FE_DISCONNECTED;
 	DEBUG_EVENT("%s: %s disconnected!\n",
 					fe->name, FE_MEDIA_DECODE(fe));
-	sdla_te3_alarm(fe, 1);
+	sdla_te3_read_alarms(fe, 1);
 
 	sdla_te3_set_intr(fe);
 	return 0;
