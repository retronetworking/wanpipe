* Copyright:	(c) 1995-2001 Sangoma Technologies Inc.
 *  o initialize protocol-specific fields of the adapter data space.
	if (conf->config_id != WANCONFIG_BSC) {
				  card->devname, conf->config_id);
		return -EINVAL;
	conf->comm_port = WANOPT_PRI;
	/* Initialize protocol-specific fields */
	if(card->type != SDLA_S514){
		/* Alex Apr 8 2004 Sangoma ISA card -> card->mbox_off  = 0; */
		card->mbox_off  = BSC_SENDBOX;
		card->hw_iface.isa_write_1(card->hw, 0, 0);	
		if (card->hw_iface.mapmem){
			err = card->hw_iface.mapmem(card->hw, 0);
			err = -EINVAL;
		card->hw_iface.poke(card->hw,0x10,&cfg,sizeof(cfg));
		card->hw_iface.bus_write_1(card->hw, 0x00, 0xC3);   /* Z80: 'jp' opcode */
		card->hw_iface.bus_write_2(card->hw, 0x01, 0x100); 
		card->hw_iface.isa_read_1(card->hw, 0, &tmp);
		card->hw_iface.isa_write_1(card->hw, 0, tmp | 0x02);
		while((jiffies-timeout) < (HZ/10))
		card->hw_iface.isa_read_1(card->hw, 1, &tmp);
			return -EIO;
		err = (card->hw_iface.mapmem) ?
			card->hw_iface.mapmem(card->hw, BSC_SENDBOX) : -EINVAL; 
		card->mbox_off  = BSC_SENDBOX;
		card->hw_iface.io_write_1(card->hw, 0x00, S514_CPU_HALT);  
		card->hw_iface.poke(card->hw,0x10,&cfg,sizeof(cfg));
		card->hw_iface.bus_write_1(card->hw, 0x00, 0xC3);   /* Z80: 'jp' opcode */
		card->hw_iface.bus_write_2(card->hw, 0x01, 0x100); 
		card->hw_iface.io_write_1(card->hw, 0x00, S514_CPU_START);
	mbox = &card->wan_mbox;
	while((jiffies-timeout) < (HZ))
		return -EIO;
		card->devname, mbox->wan_data); 
	card->isr			= NULL;
	card->poll			= NULL;
	card->exec			= NULL;
	card->wandev.update		= &update;
 	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= NULL;
	card->wandev.udp_port   	= conf->udp_port;
	card->disable_comm		= NULL;
	card->wandev.new_if_cnt = 0;
	card->wandev.ttl = conf->ttl;
	card->wandev.electrical_interface = conf->electrical_interface; 
	card->wandev.clocking = conf->clocking;
	card->wandev.mtu = cfg.max_data_frame_size;
	printk(KERN_INFO "%s: Configuring Bisync!\n",card->devname);
	card->wandev.state = WAN_DISCONNECTED;
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical))
                return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
	if((bscmp_priv_area=dev->priv) == NULL)
		return -ENODEV;
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
			card->devname, conf->name);
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
		return -ENOMEM;
	bscmp_priv_area->card = card; 
	bscmp_priv_area->common.sk=NULL;
	bscmp_priv_area->common.state = WAN_CONNECTING;
	bscmp_priv_area->common.dev = dev;
	if(card->wandev.new_if_cnt > 0) {
		return -EEXIST;
	card->wandev.new_if_cnt++;
	if (strcmp(conf->usedby, "API") == 0) {
			wandev->name);
					wandev->name);
		return -EINVAL;
	dev->init = &if_init;
	dev->priv = bscmp_priv_area;
	bscmp_private_area_t* bscmp_priv_area = dev->priv;
	sdla_t* card = bscmp_priv_area->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->do_ioctl		= &if_ioctl;
	dev->tx_timeout		= NULL;
	dev->watchdog_timeo	= TX_TIMEOUT;
	/* Initialize media-specific parameters */
	dev->flags		|= IFF_POINTOPOINT;
	dev->flags		|= IFF_NOARP;
	if (bscmp_priv_area->true_if_encoding){
		dev->type	= ARPHRD_HDLC; /* This breaks the tcpdump */
		dev->type	= ARPHRD_PPP;
	dev->mtu		= card->wandev.mtu;
	dev->mtu += sizeof(api_tx_hdr_t);
	dev->hard_header_len	= BSTRM_HDR_LEN;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start); //ALEX_TODAY wandev->maddr;
	card->hw_iface.getcfg(card->hw, SDLA_MEMSIZE, &dev->mem_end); //ALEX_TODAY wandev->maddr + wandev->msize - 1;
        dev->tx_queue_len = 100;
	bscmp_private_area_t* bscmp_priv_area = dev->priv;
	sdla_t* card = bscmp_priv_area->card;
		return -EBUSY;
	bscmp_priv_area->router_start_time = tv.tv_sec;
	init_timer(&bscmp_priv_area->poll_timer);
	bscmp_priv_area->poll_timer.data = (unsigned long)dev;
	bscmp_priv_area->poll_timer.function = event_poll;
	bscmp_priv_area->poll_timer.expires=jiffies+POLL_WAIT;
	add_timer(&bscmp_priv_area->poll_timer);
	bscmp_private_area_t* bscmp_priv_area = dev->priv;
	sdla_t* card = bscmp_priv_area->card;
	del_timer(&bscmp_priv_area->poll_timer);
	dev->start=0;
	card->wandev.state = WAN_DISCONNECTED;
 * o set tbusy flag (marks start of the transmission) to block a timer-based
 *		non-0	packet may be re-transmitted (tbusy must be set)
	bscmp_private_area_t *bscmp_priv_area = dev->priv;
	sdla_t *card = bscmp_priv_area->card;
	int err=-EBUSY;
		 * tx-done interrupt.
			card->devname, dev->name);
	if (dev->tbusy){
		 * kick start the device by making dev->tbusy = 0.  We expect 
                ++card->wandev.stats.collisions;
		if((jiffies - bscmp_priv_area->tick_counter) < (5 * HZ)) {
			card->devname);
		clear_bit(0,&dev->tbusy);
	bsc_lock(&card->wandev.lock,smp_flag);
    	if(test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
					card->wandev.name,card->wandev.critical);
                ++card->wandev.stats.tx_dropped;
	if(card->wandev.state != WAN_CONNECTED){
       		++card->wandev.stats.tx_dropped;
	}else if(!skb->protocol){
        	++card->wandev.stats.tx_errors;
		void* data = skb->data;
		unsigned len = skb->len;
			++card->wandev.stats.tx_dropped;
		station = api_tx_hdr->station;
		misc_tx_rx_bits = api_tx_hdr->misc_tx_rx_bits;
		len -= sizeof(api_tx_hdr_t);
			++card->wandev.stats.tx_packets;
                        card->wandev.stats.tx_bytes += len;
		 	dev->trans_start = jiffies;
		bscmp_priv_area->dev_stop_timeout=jiffies;
	clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
	bsc_unlock(&card->wandev.lock,smp_flag);
	if (!dev || !(dev->flags & IFF_UP)){
		return -ENODEV;
	if (!(chan = dev->priv)){
		return -ENODEV;
	if (!(card = chan->card)){
		return -ENODEV;
	mbox = &card->wan_mbox;
			err= -EINVAL;
		spin_lock_irqsave(&card->wandev.lock,smp_flag);
		err=wan_bind_api_to_svc(chan,ifr->ifr_data);
		spin_unlock_irqrestore(&card->wandev.lock,smp_flag);
			err= -EINVAL;
		spin_lock_irqsave(&card->wandev.lock,smp_flag);
		err=wan_unbind_api_from_svc(chan,ifr->ifr_data);
		spin_unlock_irqrestore(&card->wandev.lock,smp_flag);
		err = chan->common.state;
		user_mbox= (wan_mbox_t*)ifr->ifr_data;
			err=-EINVAL;
		if (copy_from_user(&mbox->wan_command,&user_mbox->wan_command,MBOX_HEADER_SZ)){
		if (mbox->wan_data_len){
			if (copy_from_user(mbox->wan_data,user_mbox->wan_data,mbox->wan_data_len)){
		bsc_lock(&card->wandev.lock,smp_flag);
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
			bsc_unlock(&card->wandev.lock,smp_flag);
		bsc_unlock(&card->wandev.lock,smp_flag);
		if (copy_to_user(&user_mbox->wan_command,&mbox->wan_command,MBOX_HEADER_SZ)){
		if (mbox->wan_data_len){
			if (copy_to_user(user_mbox->wan_data,mbox->wan_data,mbox->wan_data_len)){
				err=-EFAULT;
		switch (mbox->wan_command){
			set_bit(0,&chan->station_change);
		err = -EOPNOTSUPP;
	bscmp_private_area_t *bscmp_priv_area = dev->priv;
	sdla_t *card = bscmp_priv_area->card;
	wan_mbox_t*	mbox = &card->wan_mbox;
	bsc_lock(&card->wandev.lock,smp_flag);
	set_bit(SEND_CRIT,&card->wandev.critical);
		if ((jiffies-bscmp_priv_area->dev_stop_timeout) > (HZ/20)){
	if (mbox->wan_data[0] == 0){
	if (!mbox->wan_data[1]){
	if (test_bit(0,&bscmp_priv_area->station_change)){
		memset(bscmp_priv_area->active_chan, 0,
		       sizeof(bscmp_priv_area->active_chan));
		clear_bit(0,&bscmp_priv_area->station_change);
		for (i=0;i<mbox->wan_data_len;){
			bscmp_priv_area->active_chan[mbox->wan_data[i]]=1;
		bscmp_priv_area->cur_dev=mbox->wan_data[0];
	printk(KERN_INFO "Starting Rx with station %i\n",bscmp_priv_area->cur_dev);
	start_dev=bscmp_priv_area->cur_dev;
					cur_dev,mbox->wan_data_len);
			skb = dev_alloc_skb(mbox->wan_data_len+sizeof(api_rx_hdr_t)+5);
						card->devname);
			rx_el->api_rx_hdr.station = cur_dev;
			buf=(api_rx_element_t*)skb_put(skb,mbox->wan_data_len);
			memcpy(buf,mbox->wan_data,mbox->wan_data_len);
			skb->protocol = htons(PVC_PROT);
			skb->dev      = dev;
               		skb->pkt_type = WAN_PACKET_DATA;
						card->devname);
				++card->wandev.stats.rx_dropped;
				++card->wandev.stats.rx_packets;
                       	 	card->wandev.stats.rx_bytes += mbox->wan_data_len;
	clear_bit(SEND_CRIT,&card->wandev.critical);
	bscmp_priv_area->poll_timer.expires=jiffies+POLL_WAIT;
	add_timer(&bscmp_priv_area->poll_timer);
	bsc_unlock(&card->wandev.lock,smp_flag);
 * Get ethernet-style interface statistics.
	if ((bscmp_priv_area=dev->priv) == NULL)
	my_card = bscmp_priv_area->card;
	return &my_card->wandev.stats; 
	wan_mbox_t*	mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = CLOSE_LINK;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t*	mb = &card->wan_mbox;
        mb->wan_data_len = 0;
	mb->wan_bsc_station = station;
        mb->wan_command = BSC_READ;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t*	mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = LINK_STATUS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t*	mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_CODE_VERSION;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t*	mb = &card->wan_mbox;
        mb->wan_data_len = sizeof(BSC_CONFIG_STRUCT);
        mb->wan_command = SET_CONFIGURATION;
	memcpy(mb->wan_data,cfg,sizeof(BSC_CONFIG_STRUCT));
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t*	mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_CONFIGURATION;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t*	mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = LIST_STATIONS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
 *	Return:	0 - o.k.
 *		1 - no transmit buffers available
	wan_mbox_t*	mbox = &card->wan_mbox;
	mbox->wan_command = BSC_WRITE;
	mbox->wan_data_len = len;
	mbox->wan_bsc_station = station;
	mbox->wan_bsc_misc_bits=misc_tx_rx_bits;
	memcpy(mbox->wan_data,data,len);
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_command;
			card->devname, cmd);
			card->devname, cmd, err);
        if (card->wandev.state != state)
                                card->devname);
                                card->devname);
                                card->devname);
                card->wandev.state  = state;
		dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
			bscmp_private_area_t* bscmp_priv_area = dev->priv;
			bscmp_priv_area->common.state = state;
	int i=bscmp_priv_area->cur_dev;
		if (bscmp_priv_area->active_chan[i]){
			bscmp_priv_area->cur_dev=i;
			if (++bscmp_priv_area->cur_dev >= MAX_ACTIVE_CHAN){
				bscmp_priv_area->cur_dev=0;
		bscmp_priv_area->cur_dev=i;
	return -ENODEV;
./sdla_bsc.c
*		This module is a library of common hardware-specific functions
* Copyright:	(c) 1995-2003 Sangoma Technologies Inc.
*				Support FreeBSD-7
* Jul 06, 2007	David Rokhvarg	Added detection of A500 - ISDN BRI modules.
 * ------
 * 1. This code is ment to be system-independent (as much as possible).  To
 *    achive this, various macros are used to hide system-specific interfaces.
 *	--------	------
 *	bit to '0' causes low-to-high transition on IRQ line (ghosty
 *	CPU control register (BASE+3) - see the next note.
#define	SDLA_IODELAY	100	/* I/O Rd/Wr delay, 10 works for 486DX2-66 */
#define IS_SUPPORTED_ADAPTER(hw) (hw->type==SDLA_S508 || hw->type==SDLA_S514 || hw->type==SDLA_ADSL)
#define IS_S514(hw)	(hw->type == SDLA_S514)
#define IS_S518(hw)	(hw->type == SDLA_ADSL)
#define IS_S508(hw)	(hw->type == SDLA_S508)
/* Entry Point for Low-Level function */
/* Hardware-specific functions */
	0x10, 0x12, 0x14, 0x16, 0x18, 0x1A, 0x1C,	/* A0000 - AC000 */
	0x20, 0x22, 0x24, 0x26, 0x28, 0x2A, 0x2C,	/* C0000 - CC000 */
	0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,	/* D0000 - DC000 */
	0x30, 0x32, 0x34, 0x36, 0x38, 0x3A, 0x3C,	/* E0000 - EC000 */
	0x10, 0x12, 0x14, 0x16, 0x18, 0x1A, 0x1C, 0x1E,	/* A0000 - AE000 */
	0x20, 0x22, 0x24, 0x26, 0x28, 0x2A, 0x2C, 0x2E,	/* C0000 - CE000 */
	0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E,	/* D0000 - DE000 */
	0x30, 0x32, 0x34, 0x36, 0x38, 0x3A, 0x3C, 0x3E,	/* E0000 - EE000 */
	0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E,	/* A0000 - AE000 */
	0x40, 0x42, 0x44, 0x46, 0x48, 0x4A, 0x4C, 0x4E,	/* B0000 - BE000 */
	0x80, 0x82, 0x84, 0x86, 0x88, 0x8A, 0x8C, 0x8E,	/* C0000 - CE000 */
	0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE,	/* E0000 - EE000 */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,	/* A0000 - AE000 */
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,	/* C0000 - CE000 */
	0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,	/* D0000 - DE000 */
	0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,	/* E0000 - EE000 */
		return -ENOMEM;
	sdla_mem_el->len=len;
	sdla_mem_el->line=line;
	sdla_mem_el->mem=mem;
	strncpy(sdla_mem_el->cmd_func,func_name,sizeof(sdla_mem_el->cmd_func)-1);
	wan_debug_mem+=sdla_mem_el->len;
			sdla_mem_el->cmd_func,sdla_mem_el->line,
			 sdla_mem_el->mem, sdla_mem_el->len,wan_debug_mem);
	int err=-1;
		if (sdla_mem_el->mem == mem) {
		wan_debug_mem-=sdla_mem_el->len;
			sdla_mem_el->mem, sdla_mem_el->len, wan_debug_mem,
			sdla_mem_el->cmd_func,sdla_mem_el->line);
			sdla_mem_el->cmd_func,sdla_mem_el->line,
			sdla_mem_el->mem, sdla_mem_el->len);
		total+=sdla_mem_el->len;
			 wan_debug_mem,total,wan_debug_mem-total);
		if (sdla_hwdev_common_unregister(tmp) == -EBUSY){
			return -EBUSY;
		if (sdla_hwcpu_unregister(tmp) == -EBUSY){
			return -EBUSY;
		if (sdla_card_unregister(tmp) == -EBUSY){
			return -EBUSY;
		if (tmp->internal_used){
					tmp->hw_info);
			return -EBUSY;
	"%-10s : IOPORT=0x%X : PORT=%s"
	"%-10s : SLOT=%d : BUS=%d : IRQ=%d : CPU=%c : PORT=%s"
	"%-10s : SLOT=%d : BUS=%d : IRQ=%d : CPU=%c : PORT=%d : V=%02X"
	"%-10s : SLOT=%d : BUS=%d : IRQ=%d : CPU=%c : PORT=%s : V=%02X"
	"%-10s : SLOT=%d : BUS=%d : IRQ=%d : CPU=%c : PORT=%d : HWEC=%d : V=%02X"
        "%-10s : SLOT=%d : BUS=%d : IRQ=%d : CPU=%c : PORT=%s : HWEC=%d : V=%02X"
	"%-10s : SLOT=%d : BUS=%d : IRQ=%d : PORT=%d : HWEC=%d : V=%02X"
	"%-10s : BUSID=%s : V=%02X"
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
		return -EINVAL;
	memset(hwprobe->hw_info, '\0', 100);
	memset(hwprobe->hw_info_verbose, '\0', 500);
	memset(hwprobe->hw_info_dump, 0, sizeof(hwprobe->hw_info_dump));
	hwcpu = hw->hwcpu;
	if (IS_HWCARD_PCI(hwcpu->hwcard)){
		switch(hwcpu->hwcard->adptr_type){
			if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no+1,			/* line_no */
					hwcpu->hwcard->hwec_chan_no,
					hwcpu->hwcard->core_rev);
				/*sprintf(tmp_hw_probe->hw_info,*/
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no ? "SEC" : "PRI",
					hwcpu->hwcard->core_rev);
			if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no+1,			/* line_no */
					hwcpu->hwcard->hwec_chan_no,
					hwcpu->hwcard->core_rev);
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no+1,
					hwcpu->hwcard->core_rev
			/*sprintf(tmp_hw_probe->hw_info,*/
			SDLA_PROBE_SPRINT(hwprobe->hw_info,
				sizeof(hwprobe->hw_info),
				hwcpu->hwcard->adptr_name,
				hwcpu->hwcard->u_pci.slot_no, 
				hwcpu->hwcard->u_pci.bus_no, 
				hwcpu->irq,
				SDLA_GET_CPU(hwcpu->cpu_no),
				hw->line_no ? "SEC" : "PRI",
				hwcpu->hwcard->hwec_chan_no,
				hwcpu->hwcard->core_rev);
			if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no+1,
					hwcpu->hwcard->core_rev);		/* line_no */
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
			sprintf(&hwprobe->hw_info_dump[strlen(hwprobe->hw_info_dump)], "|BUS_IF=%s|C=%02d",
							AFT_PCITYPE_DECODE(hwcpu->hwcard),hwcpu->hwcard->cpld_rev);
			sprintf(hwprobe->hw_info_verbose, "\n+01:C%02d",
							hwcpu->hwcard->cpld_rev);
			if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no+1,
					hwcpu->hwcard->core_rev);		/* line_no */
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
			SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					hw->line_no+1,			/* Physical line number */
					hwcpu->hwcard->hwec_chan_no,
					hwcpu->hwcard->core_rev);
			snprintf(hwprobe->hw_info, 
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					hw->line_no+1,			/* Physical line number */
					hwcpu->hwcard->hwec_chan_no,
					hwcpu->hwcard->core_rev);
			SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no+1,
					hwcpu->hwcard->core_rev);		/* line_no */
			/*sprintf(tmp_hw_probe->hw_info,*/
			SDLA_PROBE_SPRINT(hwprobe->hw_info,
				sizeof(hwprobe->hw_info),
				hwcpu->hwcard->adptr_name,
				hwcpu->hwcard->u_pci.slot_no, 
				hwcpu->hwcard->u_pci.bus_no, 
				hwcpu->irq, 
				SDLA_GET_CPU(hwcpu->cpu_no), 
	}else if (hwcpu->hwcard->hw_type == SDLA_USB_CARD){
		snprintf(hwprobe->hw_info, sizeof(hwprobe->hw_info),
				WP_USB_BUSID(hwcpu->hwcard), 
				hwcpu->hwcard->core_rev);
		/*sprintf(tmp_hw_probe->hw_info, */
		SDLA_PROBE_SPRINT(hwprobe->hw_info, sizeof(hwprobe->hw_info),
				"S508-ISA",
				hwcpu->hwcard->u_isa.ioport, 
	hw->hwport[hw->max_port_no++].hwprobe	= hwprobe;
	hwprobe->internal_used++;
	sprintf(hwcard->adptr_name, "%s%s%s",
			SDLA_ADPTR_NAME(hwcard->adptr_type),
			AFT_SUBTYPE(hwcard->adptr_subtype),
			AFT_SECURITY(hwcard->adptr_security));
		hw->adptr_type	= hwcpu->hwcard->adptr_type;
	hwcpu->lines_info[hw->adptr_type].total_line_no = max_line_no; 
		if (tmp_hw->hwcpu == hwcpu){
				return -EBUSY;
		if (hwcpu->hwcard->type == SDLA_S514){
		}else if (hwcpu->hwcard->type == SDLA_AFT){
			if (hwcpu->hwcard->cfg_type == WANOPT_AFT){
			}else if (hwcpu->hwcard->cfg_type == WANOPT_AFT101){
			}else if (hwcpu->hwcard->cfg_type == WANOPT_AFT102){
			}else if (hwcpu->hwcard->cfg_type == WANOPT_AFT104){
				if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
					if (hwcpu->hwcard->core_rev >= 0x28) {
			}else if (hwcpu->hwcard->cfg_type == WANOPT_AFT108){
		hw->adptr_type = hwcpu->hwcard->adptr_type;
		hw->max_chans_num	= 32;
		hw->chans_map		= 0xFFFFFFFF;
		sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|FE=%s|BUS_IF=%s|BRDG=%s",id_dump_str,AFT_PCITYPE_DECODE(hwcpu->hwcard),AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
		sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_verbose[0], "\n+%02d:%s: %s: %s",
				AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
	hwcpu->lines_info[hw->adptr_type].total_line_no = max_line_no; 
		switch(hwcpu->hwcard->adptr_type){
			sprintf(id_str, "AFT-A142 2 Port V.35/X.21");
			sprintf(id_str, "AFT-A144 4 Port V.35/X.21");
			sprintf(id_str, "AFT-A142 2 Port RS232");
			sprintf(id_str, "AFT-A144 4 Port RS232");
		hw->adptr_type	= hwcpu->hwcard->adptr_type;
		hw->chans_map	= 0x01;
		hw->max_chans_num	= 1;
		sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|FE=%s|BUS_IF=%s|BDRG=%s",id_dump_str,AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
		sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_verbose[0], "\n+%02d:%s: %s: %s",
				AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
	hwcpu->lines_info[hw->adptr_type].total_line_no = max_line_no;
		bits: 47-32 => reg 0x1098
		bits: 31-0  => reg 0x109C
		DEBUG_EVENT("%s: Failed to register FXO/FXS modules\n", hw->devname);
		DEBUG_EVENT("%s: No FXO/FXS modules detected\n", hw->devname);
	sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|BUS_IF=%s|BRDG=%s",AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
	/* Serial number not used in production yet - do not remove this */
	memcpy(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_verbose[off],
		DEBUG_EVENT("%s: Failed to register FXO/FXS modules\n", hw->devname);
		DEBUG_EVENT("%s: No FXO/FXS modules detected\n", hw->devname);
	sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|BUS_IF=%s|BRDG=%s",AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
	switch(hw->hwcpu->hwcard->adptr_type) {
				DEBUG_EVENT("Critical error: Not a valid BRI adapter type (0x%X)\n", hw->hwcpu->hwcard->adptr_type);
			DEBUG_EVENT("%s: Failed to register BRI modules\n", hw->devname);
			DEBUG_EVENT("%s: Failed to register FXO/FXS modules\n", hw->devname);
		DEBUG_EVENT("%s: Error: Failed to detect any Modules!\n",hw->devname);
	*lines_no = (hwcpu->lines_info[AFT_ADPTR_ISDN].total_line_no + hwcpu->lines_info[A200_ADPTR_ANALOG].total_line_no);
  		bit 0 == 1	- module 3 active (exist)
		bit 1		- type of module 1 (0 - FXS, 1 - FXO)
	/* For production test - Assume test module is there */
	hw->hwcpu->hwcard->cpld_rev=1;
							hw->devname);
							hw->devname);
							hw->devname);
 * Arguments	: pfe - pointer to Front End structure.	
		bit 0 == 1	- module 1 active (exist)
		bit 1		- type of module 1 (0 - NT, 1 - TE)
		bit 2 == 1	- module 2 active (exist)
		bit 3		- type of module 1 (0 - NT, 1 - TE)
  		bit 4 == 1	- module 3 active (exist)
		bit 5		- type of module 1 (0 - NT, 1 - TE)
		bit 6,7		- has to be zeros for active remora. if non-zero, remora does not exist.
	switch(hw->hwcpu->hwcard->adptr_type) {
				DEBUG_EVENT("%s: Remora number %d: Found 512khz Recovery clock remora.\n", hw->devname, rm_no);
				hw->hwcpu->hwcard->cpld_rev=1;
					DEBUG_TEST("%s: Remora number %d does not exist.\n", hw->devname, rm_no);
			hw->hwcpu->hwcard->cpld_rev=1;
							hw->devname);
			DEBUG_EVENT("Critical error: Not a valid BRI adapter type (0x%X)\n", hw->hwcpu->hwcard->adptr_type);
				DEBUG_TEST("module Number on REMORA (0-2): %d\n", ind / 2);
				/* 0-11, all (even and odd) numbers */
				DEBUG_TEST("mod_no_index on CARD (should be 0-11): %d\n", mod_no_index);
				/* 0-23, only even numbers */
				DEBUG_TEST("mod_no_index (line number) on CARD (should be 0-23): %d\n", mod_no_index);
							hw->devname, mod_no_index, mod_no_index, MAX_BRI_LINES);
							hw->devname, mod_no_index);
							hw->devname, mod_no_index);
							hw->devname, mod_no_index);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
			hwcard->u_pci.pci_bridge_dev = NULL;
			hwcard->u_pci.pci_bridge_bus = 0; 
			hwcard->u_pci.pci_bridge_slot = 0;
				hwcard->u_pci.pci_bridge_dev = NULL;
				hwcard->u_pci.pci_bridge_bus = 0; 
				hwcard->u_pci.pci_bridge_slot = 0;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (hwcard->type != SDLA_AFT){
		return -EINVAL;
	if (hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
		switch(hwcard->adptr_type){
				hwcard->adptr_security = AFT_SECURITY_UNCHAN;
				hwcard->adptr_security = AFT_SECURITY_CHAN;
				"%s: AFT-A101-2 Critical error: Unknown Security ID (0x%02X)!\n",
				hwcard->adptr_security = AFT_SECURITY_UNCHAN;
				hwcard->adptr_security = AFT_SECURITY_CHAN;
				hwcard->adptr_security = AFT_SECURITY_CHAN;
				"%s: AFT-A104 Critical error: Unknown Security ID (%02X)!\n",
	}else if (hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
		switch(hwcard->core_id){
			switch(hwcard->adptr_type){
				hwcard->hwec_chan_no = A104_ECCHAN(AFT_SH_SECURITY(status));
				/* By default, AFT-A300 is unchannelized! */
				hwcard->adptr_security = AFT_SECURITY_UNCHAN;
			switch(hwcard->adptr_type){
				hwcard->hwec_chan_no = A108_ECCHAN(AFT_SH_SECURITY(status));
			switch(hwcard->adptr_type){
				hwcard->hwec_chan_no = AFT_RM_ECCHAN(AFT_SH_SECURITY(status));
				if (hwcard->hwec_chan_no){
				hwcard->hwec_chan_no = A600_ECCHAN((reg >> 4) & 0x3); 
				if (hwcard->hwec_chan_no) {					
				hwcard->hwec_chan_no = A500_ECCHAN(AFT_SH_SECURITY(status));
				DEBUG_BRI("hwcard->hwec_chan_no: %d\n", hwcard->hwec_chan_no);
				if (hwcard->hwec_chan_no){
				hwcard->hwec_chan_no = 0;
				/* AFT-SERIAL: Add code here */
		if (hwcard->u_pci.pci_bridge_dev){
	switch(hwcard->adptr_type){
			hw->hwcpu->hwcard->cpld_rev = (status>>AFT_A300_VER_SHIFT)&AFT_A300_VER_MASK;
			hwcard->hwec_chan_no = 0;
	if (hwcard->hwec_chan_no && !hwcard->hwec_ind){
		hwcard->hwec_ind = get_card_serial_number(hw);
		hwcard->hwec_ind = ++sdla_hwec_no;
	hwcard->cfg_type = WANOPT_S51X;
	hwcard->type = SDLA_S514;
	switch(hwcard->adptr_type){
			return -EINVAL;
			hwcard->adptr_name,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			return -EINVAL;
			hwcard->adptr_name,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			return -EINVAL;
				hwcard->adptr_name,
				hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			sdla_adapter_cnt.s514x_adapters--;
			return -EINVAL;
			return -EINVAL;
			hwcard->adptr_name,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			return -EINVAL;
				hwcard->adptr_name, 
				hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			sdla_adapter_cnt.s514x_adapters--;
			return -EINVAL;
		hwcard->adptr_type = S5144_ADPTR_1_CPU_T1E1;
			return -EINVAL;
		"%s: S514-8-PCI T1/E1 card found, cpu(s) 1, bus #%d, slot #%d, irq #%d\n",
			wan_drvname, hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			return -EINVAL;
		"%s: S514-1-PCI V35/RS232/FT1 card found, cpu(s) 1, bus #%d, slot #%d, irq #%d\n",
	        	wan_drvname, hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
	hwcard->cfg_type = WANOPT_ADSL;
	hwcard->type = SDLA_ADSL;
	switch(hwcard->adptr_type){
			hwcard->adptr_name,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
                       	wan_drvname, hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
	hwcard->type = SDLA_AFT;
	switch(hwcard->adptr_type){
		hwcard->cfg_type = WANOPT_AFT;
		if (hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
			hwcard->cfg_type = WANOPT_AFT;
		}else if (hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
			hwcard->cfg_type = WANOPT_AFT101;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		if (hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
			hwcard->cfg_type = WANOPT_AFT;
			if (hwcard->u_pci.pci_dev->resource[1].flags){
					hwcard->adptr_name, 
					AFT_CORE_ID_DECODE(hwcard->core_id),
					hwcard->core_rev,
					hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
				sdla_adapter_cnt.aft101_adapters--;
		}else if (hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
			hwcard->cfg_type = WANOPT_AFT102;
				hwcard->adptr_name,
				AFT_CORE_ID_DECODE(hwcard->core_id),
				hwcard->core_rev,
				hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT104;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT108;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT300;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT_ANALOG;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT_ISDN;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT_ISDN;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT_56K;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		if (hwcard->adptr_type == AFT_ADPTR_2SERIAL_V35X21 || 
		    hwcard->adptr_type == AFT_ADPTR_2SERIAL_RS232){
		hwcard->cfg_type = WANOPT_AFT_SERIAL;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev, lines_no,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT_ANALOG;
					hwcard->adptr_name,
					AFT_CORE_ID_DECODE(hwcard->core_id),
					hwcard->core_rev,
					hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			hwcard->adptr_type,
			hwcard->u_pci.bus_no,
			hwcard->u_pci.slot_no,
	WAN_ASSERT(hwcard->u_pci.pci_dev == NULL);
	if (hwcard->u_pci.pci_dev->bus == NULL) return 0;
	bus = hwcard->u_pci.pci_dev->bus;
	if (bus->self == NULL) return 0;
	pcibridge_dev = bus->self;
	if (pcibridge_dev->vendor == PLX_VENDOR_ID && 
	    (pcibridge_dev->device == PLX_DEVICE_ID ||
	     pcibridge_dev->device == PLX2_DEVICE_ID)){
		hwcard->u_pci.pci_bridge_dev = pcibridge_dev;
		hwcard->u_pci.pci_bridge_bus = hwcard->u_pci.bus_no; 
		hwcard->u_pci.pci_bridge_slot = hwcard->u_pci.slot_no;
		DEBUG_TEST("%s: PCI-Express card (PLX PCI Bridge, bus:%d, slot:%d)\n",
			wan_drvname, hwcard->bus_no, hwcard->slot_no);
	}else if (pcibridge_dev->vendor == TUNDRA_VENDOR_ID && 
	          pcibridge_dev->device == TUNDRA_DEVICE_ID){
		hwcard->u_pci.pci_bridge_dev = pcibridge_dev;
		hwcard->u_pci.pci_bridge_bus = hwcard->u_pci.bus_no; 
		hwcard->u_pci.pci_bridge_slot = hwcard->u_pci.slot_no;
		DEBUG_TEST("%s: PCI-Express card (TUNDRA PCI Bridge, bus:%d, slot:%d)\n",
			wan_drvname, hwcard->bus_no, hwcard->slot_no);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
	hwcard->adptr_type	= pci_subsystem_id & 0xFF;
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
	hwcard->adptr_type	= pci_subsystem_id & 0xFF;
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
	hwcard->adptr_type	= pci_subsystem_id & 0xFF;
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard->u_pci.pci_dev == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
		/* Old A-series cards, keep original sequence */
		hwcard->adptr_type	= A101_ADPTR_1TE1;
		hwcard->adptr_type	= A101_ADPTR_2TE1;
		hwcard->adptr_type	= A104_ADPTR_4TE1;
		hwcard->adptr_type	= A101_ADPTR_1TE1;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A101_ADPTR_2TE1;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A104_ADPTR_4TE1;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A108_ADPTR_8TE1;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A300_ADPTR_U_1TE3;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A305_ADPTR_C_1TE3;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A200_ADPTR_ANALOG;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A400_ADPTR_ANALOG;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_FLEXBRI;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_ISDN;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_56K;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_2SERIAL_V35X21;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_4SERIAL_V35X21;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_2SERIAL_RS232;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_4SERIAL_RS232;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_A600;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	hwcard->core_id	= AFT_CORE_ID(pci_subsystem_id);
	hwcard->core_rev= AFT_CORE_REV(pci_subsystem_id);
	if (hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
		switch(hwcard->core_id){
					wan_drvname, hwcard->core_id);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
		hwcard->adptr_type	= A101_ADPTR_1TE1;
		hwcard->adptr_type	= A101_ADPTR_2TE1;
		hwcard->adptr_type	= A300_ADPTR_U_1TE3;
	hwcard->core_id	= AFT_CORE_ID(pci_subsystem_id);
	hwcard->core_rev= AFT_CORE_REV(pci_subsystem_id);
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
		hwcard->adptr_type	= A101_ADPTR_1TE1;
		hwcard->adptr_type	= A101_ADPTR_2TE1;
		hwcard->adptr_type	= A104_ADPTR_4TE1;
		hwcard->adptr_type	= A104_ADPTR_4TE1;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
	hwcard->core_id = AFT_CORE_ID(pci_subsystem_id);
	hwcard->core_rev= AFT_CORE_REV(pci_subsystem_id);
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
		hwcard->adptr_type	= A101_ADPTR_1TE1;
		hwcard->adptr_type	= A101_ADPTR_2TE1;
		hwcard->adptr_type	= A300_ADPTR_U_1TE3;
	hwcard->core_id	= AFT_CORE_ID(pci_subsystem_id);
	hwcard->core_rev= AFT_CORE_REV(pci_subsystem_id);
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	WAN_ASSERT_RC(hw->hwcpu == NULL,0);
	WAN_ASSERT_RC(hw->hwcpu->hwcard == NULL,0);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
		tmp_hwcard->u_pci.pci_dev = pci_dev;
					((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
					pci_dev->bus->number,
					pci_dev->irq);
		tmp_hwcard->u_pci.pci_dev = pci_dev;
				 	((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
				 	pci_dev->bus->number,
					pci_dev->irq);
		tmp_hwcard->u_pci.pci_dev = pci_dev;	
				 	((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
				 	pci_dev->bus->number,
					pci_dev->irq);
		tmp_hwcard->u_pci.pci_dev = pci_dev;	
					pci_dev->bus->number,
					((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
					pci_dev->irq);
		tmp_hwcard->u_pci.pci_dev = pci_dev;	
					pci_dev->bus->number,
					((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
					pci_dev->irq);
		tmp_hwcard->u_pci.pci_dev = pci_dev;	
					pci_dev->bus->number,
					((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
					pci_dev->irq);
		tmp_hwcard->u_pci.pci_dev = pci_dev;
					pci_dev->bus->number,
					((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
					pci_dev->irq);
		bus = pci_bus_b(pci_dev->bus->children.next);
					bus->self->vendor,
					bus->self->device,
					bus->self->subsystem_vendor,
					bus->self->subsystem_device,
       				 	((bus->self->devfn >> 3) & PCI_DEV_SLOT_MASK),
					bus->number);
		bus = pci_bus_b(pci_dev->bus->children.prev);
					bus->self->vendor,
					bus->self->device,
					bus->self->subsystem_vendor,
					bus->self->subsystem_device,
       				 	((bus->self->devfn >> 3) & PCI_DEV_SLOT_MASK),
					bus->number);
		tmp = pci_dev_b(pci_dev->bus->devices.next);
					tmp->vendor,
					tmp->device,
					tmp->subsystem_vendor,
					tmp->subsystem_device,
       				 	((tmp->devfn >> 3) & PCI_DEV_SLOT_MASK),
					tmp->bus->number);
		tmp = pci_dev_b(pci_dev->bus->devices.prev);
					tmp->vendor,
					tmp->device,
					tmp->subsystem_vendor,
					tmp->subsystem_device,
       				 	((tmp->devfn >> 3) & PCI_DEV_SLOT_MASK),
					tmp->bus->number);
					 pci_dev->bus->number,
					 ((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
		//hwcard->adptr_type	= pci_subsystem_id & 0xFF;	
		//hwcard->adptr_type	= A104_ADPTR_X_4TE1;
		//hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->u_pci.pci_dev		= pci_dev;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
		if (dinfo->cfg.vendor == V3_VENDOR_ID && dinfo->cfg.device == V3_DEVICE_ID){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
					pci_get_slot(dinfo->cfg.dev), 
					pci_get_bus(dinfo->cfg.dev),
					dinfo->cfg.intline);
		if (dinfo->cfg.vendor == PCI_VENDOR_ID_GSI && dinfo->cfg.device == PCI_DEVICE_ID_GSI_ADSL){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
						pci_get_slot(dinfo->cfg.dev), 
						pci_get_bus(dinfo->cfg.dev),
						dinfo->cfg.intline);
		if (dinfo->cfg.vendor == PCI_VENDOR_ID_GSI && dinfo->cfg.device == PCI_DEVICE_ID_GSI_ADSL_V2){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
						pci_get_slot(dinfo->cfg.dev), 
						pci_get_bus(dinfo->cfg.dev),
						dinfo->cfg.intline);
		if (dinfo->cfg.vendor == SANGOMA_PCI_VENDOR){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
						pci_get_bus(dinfo->cfg.dev),
						pci_get_slot(dinfo->cfg.dev), 
						dinfo->cfg.intline);
		if (dinfo->cfg.vendor == SANGOMA_PCI_VENDOR && dinfo->cfg.device == SANGOMA_PCI_DEVICE){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
						pci_get_bus(dinfo->cfg.dev),
						pci_get_slot(dinfo->cfg.dev), 
						dinfo->cfg.intline);
		if (dinfo->cfg.vendor == SANGOMA_PCI_VENDOR && dinfo->cfg.device == SANGOMA_PCI_4_DEVICE){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
						pci_get_bus(dinfo->cfg.dev),
						pci_get_slot(dinfo->cfg.dev), 
						dinfo->cfg.intline);
		if (dinfo->cfg.vendor == SANGOMA_PCI_VENDOR_OLD && dinfo->cfg.device == SANGOMA_PCI_DEVICE){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
						pci_get_bus(dinfo->cfg.dev),
						pci_get_slot(dinfo->cfg.dev), 
						dinfo->cfg.intline);
	tmp_hwcpu->hwcard = tmp_hwcard;
	tmp_hw->hwcpu = tmp_hwcpu;
	tmp_hw->magic = SDLADRV_MAGIC;
		tmp_hwcard->hw_type = SDLA_ISA_CARD;
		tmp_hwcard->u_isa.ioport = opt[i];
			DEBUG_EVENT("%s: S508-ISA card found, port 0x%x\n",
				wan_drvname, tmp_hwcard->u_isa.ioport);
					SDLA_ISA_CARD, 0, 0, tmp_hwcard->u_isa.ioport, NULL);
			hwcard->adptr_type	= 0x00;
			hwcard->cfg_type 	= WANOPT_S50X;
		tmp_hwcard->u_isa.ioport = 0x00;
	tmp_hwcard->hw_type = SDLA_PCI_CARD;
	tmp_hwcard->u_pci.bus_no = 0;
	tmp_hwcard->u_pci.slot_no = 0;
		if (dev->type == SDLA_S508){
			DEBUG_EVENT( "%s: S508-ISA card found, port 0x%x\n",
			hwcard->adptr_type	= 0x00;
			hwcard->cfg_type 	= WANOPT_S50X;
	    		hwcpu->irq    	= sdladev_irq(dev);
	    		hwcpu->dpmbase 	= sdladev_maddr(dev);
			hwcard->u_isa.ioh	= dev->u.isa.ioh;
    			hwcard->u_isa.iot    	= dev->sc->ia.ia_iot;
	    		hwcard->u_isa.memt   	= dev->sc->ia.ia_memt;
	tmp_hw->hwcpu = tmp_hwcpu;
	tmp_hw->magic = SDLADRV_MAGIC;
	tmp_hwcpu->hwcard = tmp_hwcard;	
	tmp_hwcard->hw_type = SDLA_PCI_CARD;
	tmp_hwcard->u_pci.bus_no = 0;
	tmp_hwcard->u_pci.slot_no = 0;
	/* Probe PCI/PCI-Exp cards */
		pci_dev = dev->sc->dev;
    		pci_dev = dev->u.pci.pci_dev;
	    	pci_dev = &dev->sc->pa;
		hwcard->adptr_type	= dev->adapter_type;
		hwcard->adptr_subtype	= dev->adapter_subtype;
		hwcard->u_pci.pci_dev	= pci_dev;
	    	hwcard->memt		= pci_dev->pa_memt;
		switch(dev->vendor_id){
			if (dev->subvendor_id == SANGOMA_SUBSYS_VENDOR){
			}else if (dev->device_id == SANGOMA_PCI_DEVICE){
				hwcard->core_id	= AFT_CORE_ID(dev->subsystem_id);
				hwcard->core_rev= AFT_CORE_REV(dev->subsystem_id);
					wan_drvname, dev->device_id);
			hwcard->core_id	= AFT_CORE_ID(dev->subsystem_id);
			hwcard->core_rev= AFT_CORE_REV(dev->subsystem_id);
					wan_drvname, dev->vendor_id);
				hwcard->u_pci.bus_no,
				hwcard->u_pci.slot_no); 
				hwcard->u_isa.ioport);
	new_hwcard->hw_type	= hw_type;
	switch(new_hwcard->hw_type){
		new_hwcard->u_isa.ioport 	= ioport;
		new_hwcard->u_pci.bus_no  	= bus_no;
		new_hwcard->u_pci.slot_no	= slot_no;
//		new_hwcard->u_usb.devnum  	= bus_no;
	wan_spin_lock_init(&new_hwcard->pcard_lock,"wan_hwcard_lock");
	wan_spin_lock_init(&new_hwcard->pcard_ec_lock,"wan_hwcard_ec_lock");
	if (hwcard->internal_used){
				hwcard->internal_used);
		return -EBUSY;
		if (tmp->hw_type != hw_type){
		switch(tmp->hw_type){
			if (tmp->u_pci.bus_no == bus_no && 
			    tmp->u_pci.slot_no == slot_no){
			if (tmp->u_isa.ioport == ioport){
//			if (tmp->u_usb.devnum == bus_no){
	WAN_ASSERT(hwcpu->hwcard == NULL);
	if (IS_HWCARD_PCI(hwcpu->hwcard)){
				hwcpu->hwcard->u_pci.slot_no,
				hwcpu->hwcard->u_pci.bus_no, 
				SDLA_GET_CPU(hwcpu->cpu_no));
	}else if (IS_HWCARD_USB(hwcpu->hwcard)){
				__FUNCTION__, WP_USB_BUSID(hwcpu->hwcard));
				hwcpu->hwcard->u_isa.ioport);
		hwcpu = sdla_hwcpu_search(	(u8)hwcard->hw_type,
						hwcard->u_isa.ioport,
		hwcpu = sdla_hwcpu_search(	(u8)hwcard->hw_type, 
						hwcard->u_pci.bus_no,
						hwcard->u_pci.slot_no,
		hwcpu = sdla_hwcpu_search(	(u8)hwcard->hw_type, 
	hwcpu->cpu_no	= cpu_no;
	hwcpu->irq	= irq;
	hwcpu->hwcard	= hwcard;
	hwcpu->sdla_dev	= dev;	/* Internal kernel BSD structure */
	hwcpu->magic	= SDLADRV_MAGIC;
	hwcard->internal_used++;
	if (hwcpu->internal_used){
					hwcpu->internal_used);
		return -EBUSY;
	hwcpu->hwcard->internal_used--;			/* Decrement card usage */
	hwcpu->hwcard = NULL;
		WAN_ASSERT_RC(tmp->hwcard == NULL, NULL);
		if (tmp->hwcard->hw_type != hw_type){
			if (tmp->hwcard->u_pci.bus_no == bus_no && 
			    tmp->hwcard->u_pci.slot_no == slot_no && 
			    tmp->cpu_no == cpu_no){ 
			if (tmp->hwcard->u_isa.ioport == ioport){
//			if (tmp->hwcard->u_usb.devnum == bus_no){
			if (strcmp(WP_USB_BUSID(tmp->hwcard), bus_id) == 0){
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	if (IS_HWCARD_PCI(hw->hwcpu->hwcard)){
				hw->hwcpu->hwcard->u_pci.bus_no, 
				hw->hwcpu->hwcard->u_pci.slot_no,
				SDLA_GET_CPU(hw->hwcpu->cpu_no),
				hw->line_no);
	}else if (IS_HWCARD_USB(hw->hwcpu->hwcard)){
				__FUNCTION__, WP_USB_BUSID(hw->hwcpu->hwcard));
				hw->hwcpu->hwcard->u_isa.ioport,
				hw->line_no);
					hwcpu->hwcard->u_pci.bus_no,
					hwcpu->hwcard->u_pci.slot_no,
					hwcpu->cpu_no,
	new_hw->devname	= SDLA_HWPROBE_NAME;
	new_hw->hwcpu	= hwcpu;
	new_hw->magic	= SDLADRV_MAGIC;
	new_hw->line_no	= dev_no;
	new_hw->cfg_type = hwcpu->hwcard->cfg_type;
	if (hwcpu->hwcard->adptr_type == AFT_ADPTR_FLEXBRI) {
			new_hw->cfg_type = WANOPT_AFT_ANALOG;
			new_hw->cfg_type = WANOPT_AFT_ISDN;
	hwcpu->internal_used++;
	hwcpu->max_lines_num++;
	hwcpu->hwdev[dev_no] = new_hw;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	if (hw->internal_used){
					hw->internal_used);
		return -EBUSY;
	for(port = 0; port < hw->max_port_no; port++){
		if (hw->hwport[port].hwprobe){
			hwprobe = hw->hwport[port].hwprobe;
			hwprobe->internal_used--;
			if (hwprobe->internal_used == 0){
			hw->hwport[port].hwprobe = NULL;
	hw->hwcpu->hwdev[hw->line_no] = NULL;
	hw->hwcpu->internal_used--;	/* Decrement card usage */
	hw->hwcpu = NULL;
		WAN_ASSERT_RC(tmp_hw->hwcpu == NULL, NULL);
		if (tmp_hw->hwcpu != hwcpu || tmp_hw->line_no != line_no){
	hw = hw_iface->hw;
	if (hw == NULL || hw->used >= hw->max_port_no){
	WAN_ASSERT_RC(hw->hwcpu == NULL, NULL);
	WAN_ASSERT_RC(hw->hwcpu->hwcard == NULL, NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	hw_iface->setup		= sdla_setup;
	hw_iface->hw_down	= sdla_down;
	hw_iface->load		= sdla_load;
	hw_iface->intack	= sdla_intack;
	hw_iface->read_int_stat	= sdla_read_int_stat;
	hw_iface->mapmem	= sdla_mapmem;
	hw_iface->check_mismatch= sdla_check_mismatch;
	hw_iface->peek		= sdla_peek;
	hw_iface->poke		= sdla_poke;
	hw_iface->poke_byte	= sdla_poke_byte;
	hw_iface->getcfg	= sdla_getcfg;
	hw_iface->get_totalines	= sdla_get_totalines;
	hw_iface->setcfg	= sdla_setcfg;
	hw_iface->isa_read_1	= sdla_isa_read_1;
	hw_iface->isa_write_1	= sdla_isa_write_1;
	hw_iface->io_read_1	= sdla_io_read_1;
	hw_iface->io_write_1	= sdla_io_write_1;
	hw_iface->bus_read_1	= sdla_bus_read_1;
	hw_iface->bus_read_2	= sdla_bus_read_2;
	hw_iface->bus_read_4	= sdla_bus_read_4;
	hw_iface->bus_write_1	= sdla_bus_write_1;
	hw_iface->bus_write_2	= sdla_bus_write_2;
	hw_iface->bus_write_4	= sdla_bus_write_4;
	hw_iface->set_intrhand	= sdla_set_intrhand;
	hw_iface->restore_intrhand= sdla_restore_intrhand;
	hw_iface->is_te1	= sdla_is_te1;
	hw_iface->is_56k	= sdla_is_56k;
	hw_iface->get_hwcard	= sdla_get_hwcard;
	hw_iface->get_hwprobe	= sdla_get_hwprobe;
	hw_iface->hw_lock	= sdla_hw_lock;
	hw_iface->hw_unlock	= sdla_hw_unlock;
	hw_iface->hw_ec_trylock	= sdla_hw_ec_trylock;
	hw_iface->hw_ec_lock	= sdla_hw_ec_lock;
	hw_iface->hw_ec_unlock	= sdla_hw_ec_unlock;
	hw_iface->pci_map_dma	= sdla_pci_map_dma;
	hw_iface->pci_unmap_dma = sdla_pci_unmap_dma;
	hw_iface->hw_same	= sdla_is_same_hwcard;
	hw_iface->hwcpu_same	= sdla_is_same_hwcpu;
	hw_iface->fe_test_and_set_bit = sdla_hw_fe_test_and_set_bit;
	hw_iface->fe_set_bit = sdla_hw_fe_set_bit;
	hw_iface->fe_test_bit = sdla_hw_fe_test_bit;
	hw_iface->fe_clear_bit =  sdla_hw_fe_clear_bit;
	switch(hwcard->cfg_type){
		hwcard->type		= SDLA_S508;
		hw_iface->cmd		= sdla_cmd;
		hw_iface->set_bit	= sdla_set_bit;
		hw_iface->clear_bit	= sdla_clear_bit;
					SDLA_DECODE_CARDTYPE(hwcard->cfg_type),
					hwcard->u_isa.ioport,
					hwcpu->irq);
		hwcard->type			= SDLA_S514;
		hw_iface->load			= sdla_load;	/* For Edukit */
		hw_iface->hw_halt		= sdla_halt;	/* For Edukit */
		hw_iface->start			= sdla_start;	/* For Edukit */
		hw_iface->cmd			= sdla_cmd;
		hw_iface->set_bit		= sdla_set_bit;
		hw_iface->clear_bit		= sdla_clear_bit;
		hw_iface->pci_read_config_byte 	= sdla_pci_read_config_byte;
		hw_iface->pci_read_config_word 	= sdla_pci_read_config_word;
		hw_iface->pci_read_config_dword = sdla_pci_read_config_dword;
		hw_iface->pci_write_config_byte = sdla_pci_write_config_byte;
		hw_iface->pci_write_config_word = sdla_pci_write_config_word;
		hw_iface->pci_write_config_dword = sdla_pci_write_config_dword;
		hw_iface->fe_read = sdla_legacy_read_fe;
		hw_iface->fe_write = sdla_legacy_write_fe;
				SDLA_DECODE_CARDTYPE(hwcard->cfg_type),
				SDLA_GET_CPU(hwcpu->cpu_no), 
				hwcard->u_pci.bus_no, 
				hwcard->u_pci.slot_no);
		hwcard->type			= SDLA_ADSL;
		hw_iface->pci_read_config_byte 	= sdla_pci_read_config_byte;
		hw_iface->pci_read_config_word 	= sdla_pci_read_config_word;
		hw_iface->pci_read_config_dword = sdla_pci_read_config_dword;
		hw_iface->pci_write_config_byte = sdla_pci_write_config_byte;
		hw_iface->pci_write_config_word = sdla_pci_write_config_word;
		hw_iface->pci_write_config_dword = sdla_pci_write_config_dword;
					SDLA_DECODE_CARDTYPE(hwcard->cfg_type),
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hwcard->u_pci.bus_no, 
					hwcard->u_pci.slot_no);
		hwcard->type			= SDLA_AFT;
		hw_iface->set_bit		= sdla_set_bit;
		hw_iface->clear_bit		= sdla_clear_bit;
		hw_iface->pci_read_config_byte 	= sdla_pci_read_config_byte;
		hw_iface->pci_read_config_word 	= sdla_pci_read_config_word;
		hw_iface->pci_read_config_dword = sdla_pci_read_config_dword;
		hw_iface->pci_write_config_byte = sdla_pci_write_config_byte;
		hw_iface->pci_write_config_word = sdla_pci_write_config_word;
		hw_iface->pci_write_config_dword = sdla_pci_write_config_dword;
		hw_iface->pci_bridge_read_config_dword	= sdla_pci_bridge_read_config_dword;
		hw_iface->pci_bridge_read_config_byte	= sdla_pci_bridge_read_config_byte;
		hw_iface->pci_bridge_write_config_dword = sdla_pci_bridge_write_config_dword;
		hw_iface->pci_bridge_write_config_byte = sdla_pci_bridge_write_config_byte;
		hw_iface->read_cpld		= sdla_hw_read_cpld;
		hw_iface->write_cpld		= sdla_hw_write_cpld;
		hw_iface->busdma_descr_alloc	= sdla_busdma_descr_alloc;
		hw_iface->busdma_descr_free	= sdla_busdma_descr_free;
		hw_iface->busdma_tag_create	= sdla_busdma_tag_create;
		hw_iface->busdma_tag_destroy	= sdla_busdma_tag_destroy;
		hw_iface->busdma_create		= sdla_busdma_create;
		hw_iface->busdma_destroy	= sdla_busdma_destroy;
		hw_iface->busdma_alloc		= sdla_busdma_alloc;
		hw_iface->busdma_free		= sdla_busdma_free;
		hw_iface->busdma_load		= sdla_busdma_load;
		hw_iface->busdma_unload		= sdla_busdma_unload;
		hw_iface->busdma_map		= sdla_busdma_map;
		hw_iface->busdma_unmap		= sdla_busdma_unmap;
		hw_iface->busdma_sync		= sdla_busdma_sync;
		hw_iface->pci_map_dma		= sdla_pci_map_dma;
		hw_iface->pci_unmap_dma 	= sdla_pci_unmap_dma;
		hw_iface->get_hwec_index	= sdla_get_hwec_index;
		switch(hwcard->adptr_type){
			if (hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
				hw_iface->fe_read = sdla_te1_read_fe;
				hw_iface->fe_write = sdla_te1_write_fe;
				hw_iface->fe_read = sdla_shark_te1_read_fe;
				hw_iface->__fe_read = __sdla_shark_te1_read_fe; 
				hw_iface->fe_write = sdla_shark_te1_write_fe;
			hw_iface->fe_read = sdla_shark_te1_read_fe;
			hw_iface->__fe_read = __sdla_shark_te1_read_fe; 
			hw_iface->fe_write = sdla_shark_te1_write_fe;
			hw_iface->fe_read = sdla_shark_56k_read_fe;
			hw_iface->__fe_read = __sdla_shark_56k_read_fe;
			hw_iface->fe_write = sdla_shark_56k_write_fe;
			hw_iface->fe_read = sdla_shark_rm_read_fe;
			hw_iface->__fe_read = __sdla_shark_rm_read_fe;
			hw_iface->fe_write = sdla_shark_rm_write_fe;
			hw_iface->reset_fe = sdla_a200_reset_fe;
			hw_iface->fe_read = sdla_te3_read_fe;
			hw_iface->fe_write = sdla_te3_write_fe;
			hw_iface->fe_read = sdla_shark_bri_read_fe;
			hw_iface->fe_write = sdla_shark_bri_write_fe;
			if (hw->cfg_type == WANOPT_AFT_ISDN) {
				hw_iface->fe_read = sdla_shark_bri_read_fe;
				hw_iface->fe_write = sdla_shark_bri_write_fe;
				hw_iface->fe_read = sdla_a700_analog_read_fe;
				hw_iface->fe_write = sdla_a700_analog_write_fe;
				hw_iface->__fe_read = __sdla_a700_analog_read_fe;
				hw_iface->reset_fe = sdla_a700_reset_fe;
			hw_iface->fe_read = sdla_shark_serial_read_fe;
			hw_iface->fe_write = sdla_shark_serial_write_fe;
			hw_iface->fe_read = sdla_a600_read_fe;
			hw_iface->__fe_read = __sdla_a600_read_fe;
			hw_iface->fe_write = sdla_a600_write_fe;
			hw_iface->reset_fe = sdla_a600_reset_fe;
		switch(hwcard->adptr_type){
					SDLA_DECODE_CARDTYPE(hwcard->cfg_type),
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hwcard->u_pci.bus_no,
					hwcard->u_pci.slot_no, 
					hw->line_no);		//(conf) ? conf->comm_port : hw->used);
					SDLA_DECODE_CARDTYPE(hwcard->cfg_type),
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hwcard->u_pci.bus_no, 
					hwcard->u_pci.slot_no);
					SDLA_DECODE_CARDTYPE(hwcard->cfg_type),
					hw->used);
		hwcard->type			= SDLA_USB;
		hw_iface->fe_read		= sdla_usb_fxo_read;
		hw_iface->fe_write		= sdla_usb_fxo_write;
		hw_iface->usb_cpu_read		= sdla_usb_cpu_read;
		hw_iface->usb_cpu_write		= sdla_usb_cpu_write;
		hw_iface->usb_write_poll	= sdla_usb_write_poll;
		hw_iface->usb_read_poll		= sdla_usb_read_poll;
		hw_iface->usb_rxevent_enable	= sdla_usb_rxevent_enable;
		hw_iface->usb_rxevent		= sdla_usb_rxevent;
		hw_iface->usb_rxtx_data_init	= sdla_usb_rxtx_data_init;
		hw_iface->usb_rxdata_enable	= sdla_usb_rxdata_enable;
		hw_iface->usb_rxdata		= sdla_usb_rxdata;
		hw_iface->usb_txdata		= sdla_usb_txdata;
		hw_iface->usb_txdata_ready	= sdla_usb_txdata_ready;
		hw_iface->usb_err_stats		= sdla_usb_err_stats;
		hw_iface->usb_flush_err_stats	= sdla_usb_flush_err_stats;
		hw_iface->set_intrhand		= sdla_usb_set_intrhand;
		hw_iface->restore_intrhand	= sdla_usb_restore_intrhand;
					hwcard->cfg_type);
	if (!hw->used){
		hw->devname = devname;
	hw->hwport[(conf)?conf->comm_port:hw->used].used++;
	hw->hwport[(conf)?conf->comm_port:hw->used].devname = devname;
	hw->used++;
	hw->hwcpu->used++;
	hw->hwcpu->lines_info[hw->cfg_type].usage++;
	wan_spin_lock_init(&hw->hwcpu->lines_info[hw->cfg_type].pcard_lock, "wan_pcard_lock");
	/* ISDN-BRI logial used cnt */
	if (hwcard->adptr_type == AFT_ADPTR_ISDN ||
		hwcard->adptr_type == AFT_ADPTR_FLEXBRI){
			port = hw->line_no / 2;
			hw->hwcpu->reg_line[port]++;
			hw->hwcpu->reg_line[port+1]++;
			hw->hwcpu->reg_line[0]++;
	wan_set_bit(hw->line_no,&hw->hwcpu->reg_line_map);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	/* ISDN-BRI logial used cnt */
	if (hwcpu->hwcard->adptr_type == AFT_ADPTR_ISDN ||
		hwcpu->hwcard->adptr_type == AFT_ADPTR_FLEXBRI) {
		port = hw->line_no / 2;
		hw->hwcpu->reg_line[port]--;
		hw->hwcpu->reg_line[port+1]--;
		hw->hwcpu->reg_line[0]--;
	for(port = 0; port < hw->max_port_no; port++){
		if (hw->hwport[port].devname == devname){
			hw->hwport[port].devname = NULL;
			hw->hwport[port].used --;
	if (hwcpu->hwcard->adptr_type == AFT_ADPTR_FLEXBRI) {
		if (hw->cfg_type == WANOPT_AFT_ANALOG) {
			hw->hwport[1].used--;
	wan_clear_bit(hw->line_no, &hw->hwcpu->reg_line_map);
	hw->used--;
	hw->hwcpu->used--;
	hw->hwcpu->lines_info[hw->cfg_type].usage--;	
	if (!hw->used){
		hw->devname = SDLA_HWPROBE_NAME;
	if (conf->card_type != WANOPT_S50X){
	if (conf->card_type==WANOPT_S50X){
			SDLA_DECODE_CARDTYPE(conf->card_type),
			conf->ioport,
			conf->irq);
	}else if (conf->auto_hw_detect){
		if (conf->card_type == WANOPT_USB_ANALOG){
					SDLA_DECODE_CARDTYPE(conf->card_type));
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->S514_CPU_no[0]);
	}else if (conf->card_type == WANOPT_USB_ANALOG){
				SDLA_DECODE_CARDTYPE(conf->card_type),
				conf->usb_busid);
				SDLA_DECODE_CARDTYPE(conf->card_type),
				conf->usb_devnum);
				SDLA_DECODE_CARDTYPE(conf->card_type),
				conf->S514_CPU_no[0],
				conf->pci_bus_no,
				conf->PCI_slot_no); 
	switch(conf->card_type){
		if (conf->auto_hw_detect && sdla_adapter_cnt.s514x_adapters > 1){
				return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.s518_adapters > 1){
				return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft101_adapters > 1){
 			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-101/102 cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft104_adapters > 1){
			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-104 cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft108_adapters > 1){
			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-108 cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft200_adapters > 1){
 			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-ANALOG cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft200_adapters > 1){
 			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-ISDN BRI cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft300_adapters > 1){
			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-300 cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft_56k_adapters > 1){
 			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-56K cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft_serial_adapters > 1){
 			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-SERIAL cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft_a600_adapters > 1){
			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-A600 cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.usb_adapters > 1){
			return -EINVAL;
				devname,conf->card_type);
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch(hwcard->type){
		hw->port = conf->ioport;
		hwcpu->irq = (conf && conf->irq == 9) ? 2 : conf->irq;
		if(conf && conf->maddr){
			hwcpu->dpmbase = (sdla_mem_handle_t)phys_to_virt(conf->maddr);
		if (conf && !conf->S514_CPU_no[0]){
					hw->devname);
			return -EINVAL;
		if (conf->S514_CPU_no[0] == 'A'){
			hw->cpu_no = SDLA_CPU_A;
		}else if (conf->S514_CPU_no[0] == 'B'){
			hw->cpu_no = SDLA_CPU_B;
		hw->slot_no = conf->PCI_slot_no;
		hw->bus_no  = conf->pci_bus_no;
		hw->auto_hw_detect = conf->auto_hw_detect;
		if (hw->auto_hw_detect == WANOPT_YES){
					hw->devname, 
					SDLA_GET_CPU(hw->cpu_no));
					hw->devname, 
					SDLA_GET_CPU(hw->cpu_no),
					hwcard->slot_no);
		hw->dpmbase = (sdla_mem_handle_t)conf->maddr;
		hw->cpu_no = SDLA_CPU_A;
		hw->slot_no = conf->PCI_slot_no;
		hw->auto_hw_detect = conf->auto_hw_detect;
		hw->bus_no  = conf->pci_bus_no;
		if (hw->auto_hw_detect == WANOPT_YES){
					hw->devname);
					hw->devname, 
					hwcard->slot_no,
					hwcard->bus_no);
		hw->dpmbase = (sdla_mem_handle_t)conf->maddr;
		hwcpu->fwid = SFID_ADSL; 
		switch(hwcard->adptr_type){
			if (hwcpu->used > 1){
				if (conf) conf->irq = hwcpu->irq;
		hwcpu->fwid = SFID_AFT; 
			return -EINVAL;
				hw->devname, hwcard->type);
		return -EINVAL;
	hwcpu->dpmsize		= SDLA_WINDOWSIZE;
		hwcard->u_isa.pclk	= (conf) ? conf->hw_opt[1] : 0;
		return -ENODEV;
	switch(hwcard->type){
                		hw->devname, hwcard->type, hwcard->u_isa.ioport);
                hwcpu->dpmsize = SDLA_WINDOWSIZE;
		switch(hwcard->type){
                        hwcard->u_isa.io_range    = S502A_IORANGE;
                        hwcard->u_isa.io_range    = S502E_IORANGE;
                        hwcard->u_isa.io_range    = S503_IORANGE;
                        hwcard->u_isa.io_range    = S507_IORANGE;
                        hwcard->u_isa.io_range    = S508_IORANGE;
                        	hw->devname, hwcard->type);
                     	return -EINVAL;
                if (!sdla_get_option_index(irq_opt, hwcpu->irq)) {
                        	hw->devname, hwcpu->irq);
                      return -EINVAL;
                if (hwcard->u_isa.pclk == 0)
                        hwcard->u_isa.pclk = pclk_opt[1];  /* use default */
                else if (!sdla_get_option_index(pclk_opt, hwcard->u_isa.pclk)) {
				hw->devname, hwcard->u_isa.pclk);
                        return -EINVAL;
			hw->devname, hwcard->u_isa.pclk);
                /* Setup adapter dual-port memory window and test memory */
                if (hwcpu->dpmbase == 0) {
							hw->devname);
			virt_to_phys((void*)hwcpu->dpmbase))) {
						hw->devname, 
						(unsigned long)virt_to_phys((void*)hwcpu->dpmbase));
                        return -EINVAL;
						hw->devname, 
						(unsigned long)virt_to_phys((void*)hwcpu->dpmbase));
                        return -EINVAL;
		DEBUG_EVENT("%s: dual-port memory window is set at 0x%lX.\n",
				hw->devname, (unsigned long)virt_to_phys((void*)hwcpu->dpmbase));
		if (virt_to_phys((void*)hwcpu->dpmbase) >= 0xE0000){
			DEBUG_EVENT("\n(WARNING) %s: !!!!!!!!  WARNING !!!!!!!!\n",hw->devname);
						hw->devname, 
						(unsigned long)virt_to_phys((void*)hwcpu->dpmbase));
			DEBUG_EVENT("(WARNING) %s: !!!!!!!!  WARNING !!!!!!!!\n\n",hw->devname);
		if (conf) conf->irq = hwcpu->irq;
		if (conf && conf->config_id == WANCONFIG_DEBUG){
			hwcpu->memory = MAX_SIZEOF_S514_MEMORY;
		hwcpu->memory = sdla_test_memregion(hw, MAX_SIZEOF_S514_MEMORY);
		if(hwcpu->memory < (256 * 1024)) {
					hw->devname, hwcpu->memory);
			return -EINVAL;
		if (conf) conf->irq = hwcpu->irq;
		if (conf) conf->irq = hwcpu->irq;
				hw->devname, hwcard->type);
		return -EINVAL;
	DEBUG_EVENT("%s: found %luK bytes of on-board memory\n",
		hw->devname, hwcpu->memory / 1024);
		err = sdla_load(hw, conf->data, conf->data_size);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->u_isa.pclk) {
	switch (hwcard->type) {
 * Prepare boot-time firmware configuration data.
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	if (!sfminfo->datasize) return 0;	/* nothing to do */
	if (sdla_mapmem(hw, sfminfo->dataoffs) != 0)
		return -EIO;
	if (hwcard->type == SDLA_S514){
		offset = sfminfo->dataoffs;
		offset = sfminfo->dataoffs - (unsigned long)hwcard->u_isa.vector;
	sdla_bus_set_region_1(hw, 0x00, 0x00, sfminfo->datasize);
	switch (sfminfo->codeid) {
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (!hwcard->u_isa.ioport && (hwcard->type != SDLA_S514)) return -EFAULT;
 	switch (hwcard->type) {
		return -EINVAL;
	switch (hwcard->type) {
		hwcard->u_isa.regs[0] = 0x10;
		hwcard->u_isa.regs[3] = 0x01;
			hwcard->u_isa.regs[0] = 0;
		else return -EIO;
		tmp = hwcard->u_isa.regs[0] | 0x09;	/* set bits 0 and 3 */
		hwcard->u_isa.regs[0] = tmp;		/* update mirror */
			return -EIO;
		tmp = hwcard->u_isa.regs[0] | 0x02;
		hwcard->u_isa.regs[0] = tmp;		/* update mirror */
			return -EIO;
		tmp = hwcard->u_isa.regs[0] | 0x02;
		hwcard->u_isa.regs[0] = tmp;	/* update mirror */
			return -EIO;
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (strcmp(sfm->signature, SFM_SIGNATURE)) {
			hw->devname);
		return -EINVAL;
	if (sfm->version != SFM_VERSION) {
			hw->devname, sfm->version, SFM_VERSION);
		return -EINVAL;
	if ((len - offsetof(sfm_t, image) != sfm->info.codesize) ||
		(sdla_checksum((void*)&sfm->info,
		sizeof(sfm_info_t) + sfm->info.codesize) != sfm->checksum)) {
		DEBUG_EVENT("%s: firmware corrupted!\n", hw->devname);
		return -EINVAL;
	DEBUG_EVENT("%s: loading %s (ID=%u)...\n", hw->devname,
		(sfm->descr[0] != '\0') ? sfm->descr : "unknown firmware",
		sfm->info.codeid);
	if (hwcard->type == SDLA_S514){
			hw->devname, SDLA_GET_CPU(hwcpu->cpu_no));
	     (i < SFM_MAX_SDLA) && (sfm->info.adapter[i] != hwcard->type);
			hw->devname, hwcard->type);
		return -EINVAL;
	/* Make sure there is enough on-board memory */
	if (hwcpu->memory < sfm->info.memsize){
		DEBUG_EVENT("%s: firmware needs %u bytes of on-board memory!\n",
			hw->devname, sfm->info.memsize);
		return -EINVAL;
	if (sdla_poke(hw, sfm->info.codeoffs, sfm->image, sfm->info.codesize)) {
			hw->devname);
		return -EIO;
	if (sdla_peek(hw, sfm->info.codeoffs, test, 100)){
				hw->devname);
		return -EIO;
	if (strncmp(sfm->image, test, 100) != 0){
			hw->devname);
		return -EIO;
	/* Prepare boot-time configuration data and kick-off CPU */
	sdla_bootcfg(hw, &sfm->info);
	if (sfm->info.codeid != SFID_BSCMP514 && sfm->info.codeid != SFID_POS){
		if (sdla_start(hw, sfm->info.startoffs)) {
				hw->devname);
			return -EIO;
        if (sdla_mapmem(hw, sfm->info.winoffs) || sdla_inten(hw)) {
			hw->devname);
		return -EIO;
	hwcpu->fwid = sfm->info.codeid;		/* set firmware ID */
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
        if(!hwcard->u_isa.ioport && (hwcard->type != SDLA_S514))
                return -EFAULT;
	switch (hwcard->type) {
		hwcard->u_isa.regs[0] = 0x08;
		hwcard->u_isa.regs[1] = 0xFF;
			hwcard->u_isa.regs[i] = 0
		hwcard->u_isa.regs[0] = 0;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type) {
		if (!hwcard->u_isa.ioport){
			return -EFAULT;
		hwcard->u_isa.regs[0] = 0x08;
		hwcard->u_isa.regs[1] = 0xFF;
	 	if (!hwcard->u_isa.ioport){
                        return -EFAULT;
			hwcard->u_isa.regs[i] = 0
	 	if (!hwcard->u_isa.ioport){
                        return -EFAULT;
		hwcard->u_isa.regs[0] = 0;
        	CPU_no = hwcpu->cpu_no;
	        int_config &= (hwcpu->cpu_no == SDLA_CPU_A) ? ~PCI_DISABLE_IRQ_CPU_A : ~PCI_DISABLE_IRQ_CPU_B;
		if (hwcpu->cpu_no == SDLA_CPU_A){
		if (hwcpu->status & SDLA_MEM_MAPPED){
			sdla_bus_space_unmap(hw, hwcpu->dpmbase, MAX_SIZEOF_S514_MEMORY);
			hwcpu->status &= ~SDLA_MEM_MAPPED;
		if (hwcpu->status & SDLA_IO_MAPPED){
			sdla_bus_space_unmap(hw, hwcard->u_isa.vector, 16);
			hwcpu->status &= ~SDLA_IO_MAPPED;
		if (hw->status & SDLA_MEM_RESERVED){
			sdla_release_mem_region(hw, hw->mem_base_addr, GSI_PCI_MEMORY_SIZE);
			hw->status &= ~SDLA_MEM_RESERVED;
		if (hw->status & SDLA_MEM_MAPPED){
			sdla_bus_space_unmap(hw, hw->dpmbase, GSI_PCI_MEMORY_SIZE);
			hw->status &= ~SDLA_MEM_MAPPED;
		switch(hwcard->adptr_type){
			if (hwcpu->used > 1){
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type) {
			hwcard->u_isa.regs[0] = 0x06;
		else return -EIO;
		tmp = hwcard->u_isa.regs[0] | 0x04;
		hwcard->u_isa.regs[0] = tmp;		/* update mirror */
			return -EIO;
		tmp = hwcard->u_isa.regs[0] | 0x10;
		hwcard->u_isa.regs[0] = tmp;		/* update mirror */
			return -EIO;
		return -EINVAL;
	WAN_ASSERT(hw->hwcard == NULL);
	card = hw->hwcard;
	switch (card->type){
			sdla_isa_write_1(hw, 0x00, hw->regs[0] & ~0x04);
			hw->regs[0] &= ~0x04;
		else return -EIO;
		tmp = hw->regs[0] & ~0x04;
		hw->regs[0] = tmp;			/* update mirror */
			return -EIO;
		tmp = hw->regs[0] & ~0x10;
		hw->regs[0] = tmp;			/* update mirror */
			return -EIO;
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch(hwcard->type){
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type){
			tmp = hwcard->u_isa.regs[0] & ~0x04;
			hwcard->u_isa.regs[0] = tmp;
		else return -EIO;
			tmp = hwcard->u_isa.regs[0] & ~0x08;
			hwcard->u_isa.regs[0] = tmp;
		return -EINVAL;
	WAN_ASSERT(hw->hwcard == NULL);
	card = hw->hwcard;
	switch (card->type) {
			hw->regs[0] = 0x10;
		else return -EIO;
		else return -EIO;
		else return -EIO;
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	len += mbox->wan_data_len;
				hw->devname,mbox->wan_command);
	/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &value); */
				hw->devname);
	mbox->wan_opp_flag = 0x00;
					hw->devname, mbox->wan_command);
	if (mbox->wan_data_len < (sizeof(wan_mbox_t) - sizeof(wan_cmd_t))){
			  mbox->wan_data, mbox->wan_data_len);
				hw->devname,mbox->wan_data_len);
				hw->devname,mbox->wan_command);
	return mbox->wan_return_code;	
 * o Busy-wait until flag is reset.
	/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &value); */
						hw->devname);
	/* Sangoma ISA card -> sdla_bus_write_1(hw, offset, 0x01); */
	/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &value); */
				(unsigned long)(SYSTEM_TICKS-tstop+EXEC_TIMEOUT),
		/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &value); */
 * Care should be taken when crossing dual-port memory window boundary.
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (addr + len > hwcpu->memory)	/* verify arguments */
		return -EINVAL;
	switch(hwcard->type){
		unsigned long oldvec = (unsigned long)hwcard->u_isa.vector;
		unsigned winsize = hwcpu->dpmsize;
			curvec = addr - curpos;   /* current window vector */
			curlen = (len > (winsize - curpos)) ?
						(winsize - curpos) : len;
			len        -= curlen;
			__FUNCTION__,hwcard->type);
		err = -EINVAL;
 * Read data from adapter's memory to a data buffer in 4-byte chunks.
 * Note that we ensure that the SDLA memory address is on a 4-byte boundary
 * before we begin moving the data in 4-byte chunks.
	/* byte copy data until we get to a 4-byte boundary */
		len --;
	/* copy data in 4-byte chunks */
		len -= 4;
		len --;
 * Care should be taken when crossing dual-port memory window boundary.
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (addr + len > hwcpu->memory){	/* verify arguments */
		return -EINVAL;
	switch (hwcard->type){
		unsigned long oldvec = (unsigned long)hwcard->u_isa.vector;
		unsigned winsize = hwcpu->dpmsize;
			curvec = addr - curpos;     /* current window vector */
			curlen = (len > (winsize - curpos)) ?
				(winsize - curpos) : len;
			len        -= curlen;
			__FUNCTION__,hwcard->type);
		err = -EINVAL;
 * Write from a data buffer to adapter's memory in 4-byte chunks.
 * Note that we ensure that the SDLA memory address is on a 4-byte boundary
 * before we begin moving the data in 4-byte chunks.
	/* byte copy data until we get to a 4-byte boundary */
		len --;
	/* copy data in 4-byte chunks */
		len -= 4;
		len --;
	/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &tmp); */
	/* Sangoma ISA card -> sdla_bus_write_1(hw, offset, tmp); */
	/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &tmp); */
	/* Sangoma ISA card -> sdla_bus_write_1(hw, offset, tmp); */
/****** Hardware-Specific Functions *****************************************/
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		if (pci_slot_ar[i] == hwcard->u_pci.slot_no){
			DEBUG_EVENT( "%s: Critical Error !!!\n",hw->devname);
					hw->devname);
		pci_slot_ar[i] = hwcard->u_pci.slot_no;
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	len = hwcpu->dpmsize;
	for(; len && (value == 0xFF); --len){ 
	int i, err = -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type){
		return -EINVAL;
		hwcpu->dpmbase = (sdla_mem_handle_t)phys_to_virt(opt[i]);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		hwcard->u_isa.regs[i] = 0;
	switch (hwcard->type) {
	return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type){
			hwcard->u_isa.regs[2] = tmp;
		else return -EINVAL;
			tmp = (hwcard->u_isa.regs[0] & 0x8F) | ((addr >> 9) & 0x70);
			hwcard->u_isa.regs[0] = tmp;
		else return -EINVAL;
				return -EIO;
			hwcard->u_isa.regs[2] = tmp;
		else return -EINVAL;
			hwcard->u_isa.regs[2] = tmp;
		else return -EINVAL;
		return -EINVAL;
	hwcard->u_isa.vector = (sdla_mem_handle_t)(addr & 0xFFFFE000L);
        for (i = 0, w_ptr = hw->dpmbase; i < len_w; ++i, ++w_ptr)
	for (i = 0, w_ptr = hw->dpmbase; i < len_w; ++i, ++w_ptr)
        for (i = 0, w_ptr = hw->dpmbase; i < len_w; ++i, ++w_ptr)
        for (i = 0, w_ptr = hw->dpmbase; i < len_w; ++i, ++w_ptr)
        for (i = 0, w_ptr = hw->dpmbase; i < len_w; ++i, ++w_ptr)
 * Test adapter on-board memory.
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	for (memsize = 0, winsize = hwcpu->dpmsize;
	hwcpu->memory = memsize;
 * Set up adapter dual-port memory window. 
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
		return -EINVAL;
	/* Initialize adapter and test on-board memory segment by segment.
	if (sdla_memtest(hw) < hwcpu->dpmsize) {/* less than window size */
		return -EIO;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (!sdla_get_option_index(s502_port_options, hwcard->u_isa.ioport))
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		return -ENODEV;
	hwcard->u_isa.regs[0] = 0x08;
	hwcard->u_isa.regs[1] = 0xFF;
	i = sdla_get_option_index(s502a_dpmbase_options, virt_to_phys((void*)hwcpu->dpmbase));
		return -EINVAL;
	tmp = s502a_hmcr[i - 1];
	switch (hwcpu->dpmsize) {
		return -EINVAL;
	/* Setup dual-port memory window (this also enables memory access) */
	hwcard->u_isa.regs[1] = tmp;
	hwcard->u_isa.regs[0] = 0x08;
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	card = hwcpu->hwcard;
	if (!sdla_get_option_index(s502_port_options, card->u_isa.ioport))
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		return -ENODEV;
	i = sdla_get_option_index(s508_dpmbase_options, virt_to_phys((void*)hwcpu->dpmbase));
		return -EINVAL;
	tmp = s502e_hmcr[i - 1];
	switch (hwcpu->dpmsize) {
		return -EINVAL;
	/* Setup dual-port memory window */
	hwcard->u_isa.regs[1] = tmp;
	hwcard->u_isa.regs[0] = 0x02;
	return (tmp & 0x02) ? 0 : -EIO;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (!sdla_get_option_index(s503_port_options, hwcard->u_isa.ioport))
 * ---------------------------------------------------------------------------
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		return -ENODEV;
	i = sdla_get_option_index(s508_dpmbase_options, virt_to_phys((void*)hwcpu->dpmbase));
		return -EINVAL;
	tmp = s502e_hmcr[i - 1];
	switch (hwcpu->dpmsize) {
		return -EINVAL;
	/* Setup dual-port memory window */
	hwcard->u_isa.regs[1] = tmp;
	hwcard->u_isa.regs[0] = 0x02;	/* update mirror */
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (!sdla_get_option_index(s508_port_options, hwcard->u_isa.ioport))
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		return -ENODEV;
	i = sdla_get_option_index(s507_dpmbase_options, virt_to_phys((void*)hwcpu->dpmbase));
		return -EINVAL;
	tmp = s507_hmcr[i - 1];
	switch (hwcpu->dpmsize) {
		return -EINVAL;
	hwcard->u_isa.regs[0] = 0x01;
		return -EIO;
	/* Setup dual-port memory window */
	hwcard->u_isa.regs[1] = tmp;
	tmp = hwcard->u_isa.regs[0] | 0x04;
	if (hwcpu->irq) {
		i = sdla_get_option_index(s508_irq_options, hwcpu->irq);
		if (i) tmp |= s507_irqmask[i - 1];
	hwcard->u_isa.regs[0] = tmp;		/* update mirror */
	return (tmp & 0x08) ? 0 : -EIO;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		return -ENODEV;
	i = sdla_get_option_index(s508_dpmbase_options, virt_to_phys((void*)hwcpu->dpmbase));
		return -EINVAL;
	tmp = s508_hmcr[i - 1];
	hwcard->u_isa.regs[1] = tmp;
	hwcard->u_isa.regs[0] = 0x04;		/* update mirror */
	return (tmp & 0x04) ? 0 : -EIO;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	hwcpu->status |= SDLA_MEM_MAPPED;
	hwcpu->status |= SDLA_IO_MAPPED;
	if (!sdla_get_option_index(s508_port_options, hwcard->u_isa.ioport)){
		return -EINVAL;
		return -EINVAL;
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		   (hwcpu->cpu_no == SDLA_CPU_A) ? PCI_MEM_BASE0_DWORD : 
			    	PCI_MEM_BASE1_DWORD, (u32*)&hwcpu->mem_base_addr);
	if (!hwcpu->mem_base_addr){
		if(hwcpu->cpu_no == SDLA_CPU_B){
					hw->devname);
					hw->devname);
		return -EINVAL;
				hw->devname, (unsigned long)hwcpu->mem_base_addr);
			(hwcpu->cpu_no == SDLA_CPU_A) ? PCI_MAP0_DWORD : PCI_MAP1_DWORD, &ut_u32);
			(hwcpu->cpu_no == SDLA_CPU_A) ? PCI_MAP0_DWORD : PCI_MAP1_DWORD,
	/* the INTPIN must not be 0 - if it is, then the S514 adapter is not */
			       hw->devname);
	sdla_pci_read_config_byte(hw, PCI_INT_LINE_BYTE, (u8*)&hwcpu->irq);
        if(hwcpu->irq == PCI_IRQ_NOT_ALLOCATED) {
			hw->devname);
                return -EINVAL;
	hwcpu->irq = hwcard->u_pci.pci_dev->irq;
	ut_u32 |= (hwcpu->cpu_no == SDLA_CPU_A) ?
			hw->devname);
		return -EINVAL;
	hwcpu->irq = hwcard->u_pci.pci_dev->irq;
		hw->devname, hwcpu->irq);
	hwcpu->status |= SDLA_PCI_ENABLE;
	sdla_bus_space_map(hw, 0x0, MAX_SIZEOF_S514_MEMORY, &hwcpu->dpmbase);
	if (!hwcpu->dpmbase){ 
					hw->devname);
		return -EINVAL;
	sdla_bus_space_map(hw, S514_CTRL_REG_BYTE, 16, &hwcard->u_isa.vector);
	if (!hwcard->u_isa.vector){ 
		sdla_bus_space_unmap(hw, hwcpu->dpmbase, MAX_SIZEOF_S514_MEMORY);
					hw->devname);
		hwcpu->dpmbase=0;
		return -EINVAL;
	hwcpu->status |= SDLA_MEM_MAPPED;
	hwcard->u_isa.ioh = hwcard->u_isa.vector;
	hwcpu->status |= SDLA_IO_MAPPED;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	sdla_pci_read_config_dword(hw, PCI_IO_BASE_DWORD, (u32*)&hw->mem_base_addr);
	if(!hw->mem_base_addr) {
					hw->devname);
		return -EINVAL;
				hw->devname, (unsigned long)hwcpu->mem_base_addr);
	sdla_pci_read_config_byte(hw, PCI_INT_LINE_BYTE, (u8*)&hwcpu->irq);
        if(hwcpu->irq == PCI_IRQ_NOT_ALLOCATED) {
			hw->devname);
                return -EINVAL;
	hwcpu->irq = hwcard->u_pci.pci_dev->irq;
				hw->devname, hwcpu->irq);
			hw->devname);
		return -EINVAL;
	hw->status |= SDLA_PCI_ENABLE;
	hw->status |= SDLA_MEM_MAPPED;
	if (sdla_request_mem_region(hw, hw->mem_base_addr, 
				hw->devname);
		return -EINVAL;
	hw->status |= SDLA_MEM_RESERVED;
	hw->memory=GSI_PCI_MEMORY_SIZE;
	sdla_bus_space_map(hw, 0x0, GSI_PCI_MEMORY_SIZE, &hw->dpmbase);
        if(!hw->dpmbase) {
			hw->devname);
                return -EINVAL;
	int		err=-EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	hwcpu->status |= SDLA_PCI_ENABLE;
	switch (hwcard->type){ 
		hwcpu->memory = GSI_PCI_MEMORY_SIZE;
		hwcpu->cpu_no = SDLA_CPU_A;
		switch(hwcard->adptr_type){
			if (hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
				hwcpu->memory = AFT_PCI_MEM_SIZE; 
				hwcpu->memory = AFT2_PCI_MEM_SIZE; 
			hwcpu->memory = AFT4_PCI_MEM_SIZE; 
			hwcpu->memory = AFT8_PCI_MEM_SIZE; 
			hwcpu->memory = AFT2_PCI_MEM_SIZE; 
			hwcpu->memory = AFT_PCI_MEM_SIZE; 
			__FUNCTION__,__LINE__,hwcard->type);
		return -EINVAL;
				(hwcpu->cpu_no == SDLA_CPU_A) ? 
				&hwcpu->mem_base_addr);
	if (!hwcpu->mem_base_addr){
		if(hwcpu->cpu_no == SDLA_CPU_B){
				hw->devname);
				hw->devname);
		err = -EINVAL;
			hw->devname);
		return -EINVAL;
	hwcpu->status |= SDLA_PCI_ENABLE;
	if (!(hwcpu->status & SDLA_MEM_RESERVED)){
		err = pci_request_region(hwcard->u_pci.pci_dev, (hwcpu->cpu_no == SDLA_CPU_A)?0:1 ,reserve_name);
				hwcpu->mem_base_addr, 
				hwcpu->memory,
				hw->devname,(hwcpu->cpu_no == SDLA_CPU_A)?0:1);
			err = -EINVAL;
		hwcpu->status |= SDLA_MEM_RESERVED;
	if((err = pci_set_dma_mask(hwcard->u_pci.pci_dev, DMA_32BIT_MASK))) {
				hw->devname);
		err = -EINVAL;
				(hwcpu->cpu_no == SDLA_CPU_A) ? 
				&hwcpu->mem_base_addr);
	if (!hwcpu->mem_base_addr){
		if(hwcpu->cpu_no == SDLA_CPU_B){
				hw->devname);
				hw->devname);
		err = -EINVAL;
	if (!(hwcpu->status & SDLA_MEM_MAPPED)){
		sdla_bus_space_map(hw, 0x0, hwcpu->memory, &hwcpu->dpmbase);
		if (!hwcpu->dpmbase){
				hw->devname);
			err = -EINVAL;
		hwcpu->status |= SDLA_MEM_MAPPED;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type){ 
		if (hwcpu->status & SDLA_MEM_MAPPED){
					hwcpu->dpmbase, 
					hwcpu->memory);
			hwcpu->status &= ~SDLA_MEM_MAPPED;
		if (hwcpu->status & SDLA_MEM_RESERVED){
			pci_release_region(hwcard->u_pci.pci_dev,(hwcpu->cpu_no == SDLA_CPU_A)?0:1);
					hwcpu->mem_base_addr,
					hwcpu->memory);
			hwcpu->status &= ~SDLA_MEM_RESERVED;
		if (hwcpu->status & SDLA_PCI_ENABLE){
			hwcpu->status &= ~SDLA_PCI_ENABLE;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
				hw->devname, (unsigned long)hwcpu->mem_base_addr);
	hwcpu->irq = hwcard->u_pci.pci_dev->irq;
	sdla_pci_read_config_byte(hw, PCI_INT_LINE_BYTE, (u8*)&hwcpu->irq);
        if(hwcpu->irq == PCI_IRQ_NOT_ALLOCATED) {
			hw->devname);
                return -EINVAL;
				hw->devname, hwcpu->irq);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	if (conf->S514_CPU_no[0] == 'B'){
	switch(conf->card_type){
		if (hwcpu->cpu_no == cpu_no &&
		    conf->card_type == WANOPT_AFT &&
		    hwcpu->hwcard->cfg_type == WANOPT_AFT101) {
			   and old config file for A101/2-SH */
			conf->config_id = WANCONFIG_AFT_TE1;
			conf->card_type = WANOPT_AFT104;
			conf->fe_cfg.line_no=1;
		if (hwcpu->cpu_no == cpu_no &&
		    conf->card_type == WANOPT_AFT &&
		    hwcpu->hwcard->cfg_type == WANOPT_AFT102) {
			   and old config file for A101/2-SH */
			conf->config_id = WANCONFIG_AFT_TE1;
			conf->card_type = WANOPT_AFT104;
				conf->fe_cfg.line_no=1;
				conf->fe_cfg.line_no=2;		
		if (conf->config_id == WANCONFIG_AFT_TE1){
			if (hwcpu->cpu_no == cpu_no &&
			    hw->line_no == conf->fe_cfg.line_no-1 &&
       	          (hwcpu->hwcard->cfg_type == WANOPT_AFT101 ||
			    hwcpu->hwcard->cfg_type == WANOPT_AFT102 ||
			    hwcpu->hwcard->cfg_type == WANOPT_AFT104 ||
			    hwcpu->hwcard->cfg_type == WANOPT_AFT108)) {
			if (hwcpu->cpu_no == cpu_no &&
			    hwcpu->hwcard->cfg_type == conf->card_type){
		if (hwcpu->hwcard->cfg_type == WANOPT_USB_ANALOG){
	if (conf && conf->S514_CPU_no[0] == 'B'){
	}else if (conf && conf->S514_CPU_no[0] == 'A'){
		WAN_ASSERT_RC(hw->hwcpu == NULL, NULL);
		hwcpu = hw->hwcpu;
			if (hw->used < hw->max_port_no){
		if (conf->auto_hw_detect){
		switch(conf->card_type){
				if (hwcpu->hwcard->u_isa.ioport == conf->ioport){ 
				if ((hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no) && 
			    	    (hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no) &&
				    (hw->cfg_type == conf->card_type)){
				if ((hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no) && 
			    	    (hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no) &&
				    (hwcpu->hwcard->cfg_type == conf->card_type) &&
				    (hw->line_no == conf->fe_cfg.line_no-1)){
				if (IS_56K_MEDIA(&conf->fe_cfg) && 
				    hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no && 
			    	    hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no &&
				    hwcpu->hwcard->cfg_type == WANOPT_AFT_56K) {
					conf->card_type = WANOPT_AFT_56K;
					conf->config_id = WANCONFIG_AFT_56K;
					conf->fe_cfg.line_no=1;
				}else if ((hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no) && 
					  (hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no) &&
					  (hwcpu->cpu_no == cpu_no) &&
    					  /*(hw->line_no == conf->comm_port) &&*/
					  (hwcpu->hwcard->cfg_type == conf->card_type)){
				if (conf->card_type == WANOPT_AFT &&
				    hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no && 
			    	    hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no &&
				    hwcpu->hwcard->cfg_type == WANOPT_AFT101) {
					   and old config file for A101/2-SH */
					conf->config_id = WANCONFIG_AFT_TE1;
					conf->card_type = WANOPT_AFT104;
					conf->fe_cfg.line_no=1;
				if (conf->card_type == WANOPT_AFT &&
				    hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no && 
			    	    hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no &&
				    hwcpu->hwcard->cfg_type == WANOPT_AFT102) {
					   and old config file for A101/2-SH */
					conf->config_id = WANCONFIG_AFT_TE1;
					conf->card_type = WANOPT_AFT104;
						conf->fe_cfg.line_no=1;
						conf->fe_cfg.line_no=2;		
				if (conf->card_type == WANOPT_S51X &&
				    IS_56K_MEDIA(&conf->fe_cfg) && 
				    hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no && 
				    hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no &&
				    hwcpu->hwcard->cfg_type == WANOPT_AFT_56K) {
					conf->card_type = WANOPT_AFT_56K;
					conf->config_id = WANCONFIG_AFT_56K;
					conf->fe_cfg.line_no=1;
				if ((hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no) && 
			    	    (hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no) &&
			    	    (hwcpu->cpu_no == cpu_no) &&
				    (hwcpu->hwcard->cfg_type == conf->card_type)){
				if ((hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no) && 
			    	    (hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no) &&
				    (hw->line_no == conf->fe_cfg.line_no-1) &&
				    (hw->cfg_type == conf->card_type)){
				if ((hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no) && 
			    	    (hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no) &&
				    (hw->line_no == conf->fe_cfg.line_no-1)){
//OLD				if (hwcpu->hwcard->u_usb.devnum == conf->usb_devnum){
				if (strcmp(WP_USB_BUSID(hwcpu->hwcard), conf->usb_busid) == 0) {
						devname, conf->card_type);
		switch(hwcpu->hwcard->adptr_type){
			conf->comm_port = 0;
			conf->fe_cfg.line_no = 0;
			if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > MAX_BRI_LINES){
						devname, conf->fe_cfg.line_no, MAX_BRI_LINES);
			conf->fe_cfg.line_no--;
			conf->comm_port = 0;
			if (conf->card_type == WANOPT_AFT_ISDN) {
				if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > A700_MAX_BRI_LINES){
							devname, conf->fe_cfg.line_no, A700_MAX_BRI_LINES);
				conf->fe_cfg.line_no--;
				conf->comm_port = 0;
			} else if(conf->card_type == WANOPT_AFT_ANALOG) {
				conf->fe_cfg.line_no = 4;
				conf->comm_port = 1;
				DEBUG_EVENT("%s: Invalid configuration option for AFT-A700 card\n",
			if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
				conf->comm_port = 0;
				conf->fe_cfg.line_no = 0;
			if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > 2){
						devname, conf->fe_cfg.line_no);
			conf->fe_cfg.line_no--;
			conf->comm_port = 0;
			if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > 4){
						devname, conf->fe_cfg.line_no);
			conf->fe_cfg.line_no--;
			conf->comm_port = 0;
			if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > 8){
						devname, conf->fe_cfg.line_no);
			conf->fe_cfg.line_no--;
			conf->comm_port = 0;
			if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > 2){
						devname, conf->fe_cfg.line_no);
			conf->fe_cfg.line_no--;
			conf->comm_port = 0;
			if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > 4){
						devname, conf->fe_cfg.line_no);
			conf->fe_cfg.line_no--;
			conf->comm_port = 0;
			conf->fe_cfg.line_no = 0;
			conf->comm_port = 0;
		if (hw->hwport[conf->comm_port].used == 0){
		switch(conf->card_type){
                	        devname, conf->ioport, COMPORT_DECODE(conf->comm_port));
			switch(hwcpu->hwcard->adptr_type){
				if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
						SDLA_DECODE_CARDTYPE(conf->card_type),
						conf->pci_bus_no, 
						conf->PCI_slot_no,
						conf->S514_CPU_no[0]);				
						SDLA_DECODE_CARDTYPE(conf->card_type),
						conf->pci_bus_no, 
						conf->PCI_slot_no,
						conf->S514_CPU_no[0],
						conf->fe_cfg.line_no);				
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->pci_bus_no, 
					conf->PCI_slot_no,
					conf->S514_CPU_no[0],
					conf->fe_cfg.line_no);
						SDLA_DECODE_CARDTYPE(conf->card_type),
						conf->pci_bus_no, 
						conf->PCI_slot_no, conf->comm_port);
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->pci_bus_no, 
					conf->PCI_slot_no,
					conf->S514_CPU_no[0]);
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->usb_busid);
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->usb_devnum);
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->pci_bus_no, 
					conf->PCI_slot_no,
					conf->S514_CPU_no[0]);
		switch(conf->card_type){
                	        devname, conf->ioport, COMPORT_DECODE(conf->comm_port));
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->pci_bus_no, 
					conf->PCI_slot_no, 
					conf->S514_CPU_no[0],
					COMPORT_DECODE(conf->comm_port));
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->pci_bus_no, 
					conf->PCI_slot_no); 
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->pci_bus_no, 
					conf->PCI_slot_no,
					conf->S514_CPU_no[0],
					conf->fe_cfg.line_no);
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->usb_busid);
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->usb_devnum);
					SDLA_DECODE_CARDTYPE(conf->card_type));
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type){ 
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch(hwcard->adptr_type){
	return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (hwcard->adptr_type == S5145_ADPTR_1_CPU_56K){
	return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		if (hwcard->adptr_type != S5144_ADPTR_1_CPU_T1E1 &&
		    hwcard->adptr_type != S5147_ADPTR_2_CPU_T1E1 &&
		    hwcard->adptr_type != S5148_ADPTR_1_CPU_T1E1){
				hw->devname,
				hwcard->adptr_name);
			return -EIO;
		hwcard->adptr_type = S5144_ADPTR_1_CPU_T1E1;
		if (hwcard->adptr_type != S5145_ADPTR_1_CPU_56K){
				hw->devname,
				hwcard->adptr_name);
			return -EIO;
		if (hwcard->adptr_type == S5145_ADPTR_1_CPU_56K ||
		    hwcard->adptr_type == S5144_ADPTR_1_CPU_T1E1 ||
		    hwcard->adptr_type == S5147_ADPTR_2_CPU_T1E1 ||
		    hwcard->adptr_type == S5148_ADPTR_1_CPU_T1E1){
				hw->devname,
				hwcard->adptr_name);
			return -EIO;
	WAN_ASSERT_RC(hw1->hwcpu == NULL, 0);
	WAN_ASSERT_RC(hw2->hwcpu == NULL, 0);
	hwcpu1 = hw1->hwcpu;
	hwcpu2 = hw2->hwcpu;
	if (hwcpu1->hwcard == hwcpu2->hwcard){
	if (hw1->hwcpu == hw2->hwcpu){
 * sdla_set_intrhand() - Change interrupt handler for ISA devices. 
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	adapter = device_get_softc(hwcard->u_pci.pci_dev);
			hwcard->u_pci.pci_dev,
			adapter->irq_res, 
			isr_func, arg, &hwcpu->irqh[line_no]);
			hwcard->u_pci.pci_dev,
			adapter->irq_res, 
			isr_func, arg, &hwcpu->irqh[line_no]);
				device_get_name(hwcard->u_pci.pci_dev), line_no,
	adapter = (sdladev_t*)hwcpu->sdla_dev;
	WAN_ASSERT(adapter->sc == NULL);
			adapter->dev,
			adapter->sc->irq_res, 
			&hwcpu->irqh[line_no]);
			adapter->dev,
			adapter->sc->irq_res, 
			&hwcpu->irqh[line_no]);
					device_get_name(adapter->dev), line_no,
	if (adapter->intr_arg[line_no].ready){
  		adapter->intr_arg[line_no].isr  = isr_func;
       		adapter->intr_arg[line_no].arg  = arg;
		return -EINVAL;
 * restore_intrhand() - Restore interrupt handler for ISA/PCI devices.
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard= hwcpu->hwcard;	
	adapter = device_get_softc(hwcard->u_pci.pci_dev);
			hwcard->u_pci.pci_dev,adapter->irq_res,hwcpu->irqh[line_no]);
				device_get_name(hwcard->u_pci.pci_dev), line_no,
		return -EINVAL;
	hwcpu->irqh[line_no] = NULL;
	adapter = (sdladev_t*)hwcpu->sdla_dev;
	WAN_ASSERT(adapter->sc == NULL);
	error = bus_teardown_intr(adapter->dev, adapter->sc->irq_res, hwcpu->irqh[line_no]);
					device_get_name(adapter->dev), line_no,
		return -EINVAL;
    	adapter->intr_arg[line_no].isr  = NULL;
    	adapter->intr_arg[line_no].arg  = NULL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		*(u16*)value = (u16)hwcard->hw_type;
		*(u16*)value = (u16)hwcard->type;
		*(sdla_mem_handle_t*)value = hwcpu->dpmbase;
		*(u32*)value = ((unsigned long)hwcpu->dpmbase + hwcpu->dpmsize - 1);
		*(u16*)value = (u16)hwcpu->dpmsize;
		*(u32*)value = hwcpu->memory;
		*(u16*)value = (u16)hwcpu->irq;
		*(u16*)value = (u16)hwcard->u_isa.ioport;
		*(u16*)value = (u16)hwcard->u_isa.io_range;
		*(u16*)value = (u16)hwcard->adptr_type;
		*(u16*)value = (u16)hwcpu->cpu_no;
		*(u16*)value = (u16)hwcard->u_pci.slot_no;
		*(u16*)value = (u16)hwcard->u_pci.bus_no;
		if (hwcard->u_pci.pci_dev){
			*(bus_dma_tag_t*)value = hwcard->u_pci.pci_dev->pa_dmat;
		*(u8*)value = hwcard->pci_extra_ver;
		*(u32*)value = hwcpu->mem_base_addr;
		*(u8*)value = hwcard->core_rev;
		*(u8*)value = hwcard->core_id;
		*(u32*)value = hwcpu->used;
		*(u8*)value = hwcard->adptr_subtype;
		*(u16*)value = hwcard->hwec_chan_no;
		*(u16*)value = (u16)hw->max_chans_num;
		*(u32*)value = hw->chans_map;   //hwcpu->port_map;
		*(u16*)value = (u16)hw->used;
		*(u16*)value = (u16)hw->hwcpu->reg_line[hw->line_no];
		*(u32*)value = (u32)hw->hwcpu->reg_line_map;
		*(u32*)value = hwcard->recovery_clock_flag;
		*(u32*)value = hwcpu->lines_info[hw->cfg_type].usage;
	WAN_ASSERT(hw->hwcpu == NULL);
	*cnt = hw->hwcpu->lines_info[hw->adptr_type].total_line_no;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		hwcard->recovery_clock_flag = *(u32*)value;
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	*phwcard = hwcpu->hwcard;
	if (hw->hwport[port].hwprobe){
		*hwinfo = hw->hwport[port].hwprobe->hw_info;
 * Calculate 16-bit CRC using CCITT polynomial.
	for (; len; --len, ++buf) {
	WAN_ASSERT2(hw->hwcpu == NULL, 0);
	hwcpu = hw->hwcpu;
	WAN_ASSERT2(hwcpu->hwcard == NULL, 0);
	hwcard = hwcpu->hwcard;
	if (!(hwcpu->status & SDLA_IO_MAPPED)) return 0;
	*value = readb ((u8*)hwcard->u_isa.vector + offset);
	*value = bus_space_read_1(hwcpu->hwcard->memt, hwcard->u_isa.vector, offset);
	*value = wp_readb((hwcard->u_isa.vector + offset));
	*value = READ_REGISTER_UCHAR((PUCHAR)((PUCHAR)hwcard->u_isa.vector + offset));
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	if (!(hwcpu->status & SDLA_IO_MAPPED)) return 0;
	writeb ((u8*)hwcard->u_isa.vector+offset, value);
	bus_space_write_1(hwcpu->hwcard->memt, hwcard->u_isa.vector, offset, value);
	wp_writeb(value, hwcard->u_isa.vector + offset);
	WRITE_REGISTER_UCHAR((PUCHAR)((PUCHAR)hwcard->u_isa.vector + offset), value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	if (!(hwcpu->status & SDLA_MEM_MAPPED)) return 0;
	writeb(((u8*)hwcpu->dpmbase + offset), value);
	bus_space_write_1(hwcpu->hwcard->memt, hwcpu->dpmbase, offset, value);
	wp_writeb(value, hwcpu->dpmbase + offset);
	WRITE_REGISTER_UCHAR((PUCHAR)((PUCHAR)hwcpu->dpmbase + offset), value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	if (!(hwcpu->status & SDLA_MEM_MAPPED)) return 0;
	writew(((u8*)hwcpu->dpmbase + offset), value);
	bus_space_write_2(hwcpu->hwcard->memt, hwcpu->dpmbase, offset, value);
	wp_writew(value,hwcpu->dpmbase+offset);
	WRITE_REGISTER_USHORT((PUSHORT)((PUCHAR)hwcpu->dpmbase + offset), value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	if (!(hwcpu->status & SDLA_MEM_MAPPED)) return 0;
	*value = readb(((u8*)hwcpu->dpmbase + offset));
	*value = bus_space_read_1(hwcpu->hwcard->memt, hwcpu->dpmbase, offset); 
	*value = wp_readb((hwcpu->dpmbase + offset));
	*value = READ_REGISTER_UCHAR((PUCHAR)((PUCHAR)hwcpu->dpmbase + offset));
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	if (!(hwcpu->status & SDLA_MEM_MAPPED)) return 0;
	*value = readw(((u8*)hwcpu->dpmbase + offset));
	*value = bus_space_read_2(hwcpu->hwcard->memt, hwcpu->dpmbase, offset); 
	*value = readw(((unsigned char*)hwcpu->dpmbase+offset));
	*value = READ_REGISTER_USHORT((PUSHORT)((PUCHAR)hwcpu->dpmbase + offset));
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	*value = pci_read_config(hwcard->u_pci.pci_dev, reg, 4);
	*value = ci_cfgread(hwcard->u_pci.pci_dev, reg, 4);
	*value = pci_conf_read(hwcard->u_pci.pci_dev->pa_pc, hwcard->u_pci.pci_dev->pa_tag, reg);
	pci_read_config_dword(hwcard->u_pci.pci_dev, reg, value);
	pci_read_config_dword(hwcard->u_pci.pci_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	*value = pci_read_config(hwcard->u_pci.pci_dev, reg, 2);
	*value = pci_cfgread(hwcard->u_pci.pci_dev, reg, 2);
	tmp = pci_conf_read(hwcard->u_pci.pci_dev->pa_pc, hwcard->u_pci.pci_dev->pa_tag, reg);
	pci_read_config_word(hwcard->u_pci.pci_dev, reg, value);
	pci_read_config_word(hwcard->u_pci.pci_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	*value = pci_read_config(hwcard->u_pci.pci_dev, reg, 1);
	*value = pci_cfgread(hwcard->u_pci.pci_dev, reg, 1);
	tmp = pci_conf_read(hwcard->u_pci.pci_dev->pa_pc, hwcard->u_pci.pci_dev->pa_tag, reg);
	pci_read_config_byte(hwcard->u_pci.pci_dev, reg, value);
	pci_read_config_byte(hwcard->u_pci.pci_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	pci_write_config(hwcard->u_pci.pci_dev, reg, value, 4);
	pci_conf_write(hwcard->u_pci.pci_dev, reg, 4);
	pci_conf_write(hwcard->u_pci.pci_dev->pa_pc, hwcard->u_pci.pci_dev->pa_tag, reg, value); 
	pci_write_config_dword(hwcard->u_pci.pci_dev, reg, value);
	pci_write_config_dword(hwcard->u_pci.pci_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	pci_write_config(hwcard->u_pci.pci_dev, reg, value, 2);
	pci_conf_write(hwcard->u_pci.pci_dev, reg, value, 2);
	pci_conf_write(hwcard->u_pci.pci_dev->pa_pc, hwcard->u_pci.pci_dev->pa_tag, reg, value); 
	pci_write_config_word(hwcard->u_pci.pci_dev, reg, value);
	pci_write_config_word(hwcard->u_pci.pci_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	card = hwcpu->hwcard;
	pci_write_config(card->u_pci.pci_dev, reg, value, 1);
	pci_conf_write(card->u_pci.pci_dev, reg, value, 1);
	pci_conf_write(card->u_pci.pci_dev->pa_pc, card->u_pci.pci_dev->pa_tag, reg, value); 
	pci_write_config_byte(card->u_pci.pci_dev, reg, value);
	pci_write_config_byte(card->u_pci.pci_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	*value = pci_read_config(hwcard->u_pci.pci_bridge_dev, reg, 4);
	*value = ci_cfgread(hwcard->u_pci.pci_bridge_dev, reg, 4);
	*value = pci_conf_read(hwcard->u_pci.pci_bridge_dev->pa_pc, hwcard->u_pci.pci_bridge_dev->pa_tag, reg);
	pci_read_config_dword(hwcard->u_pci.pci_bridge_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	card = hwcpu->hwcard;
	*value = pci_read_config(card->u_pci.pci_bridge_dev, reg, 2);
	*value = ci_cfgread(card->u_pci.pci_bridge_dev, reg, 2);
	*value = pci_conf_read(card->u_pci.pci_bridge_dev->pa_pc, card->u_pci.pci_bridge_dev->pa_tag, reg);
	pci_read_config_word(card->u_pci.pci_bridge_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	*value = pci_read_config(hwcard->u_pci.pci_bridge_dev, reg, 1);
	*value = ci_cfgread(hwcard->u_pci.pci_bridge_dev, reg, 1);
	tmp = pci_conf_read(hwcard->u_pci.pci_bridge_dev->pa_pc, hwcard->u_pci.pci_bridge_dev->pa_tag, reg);
	pci_read_config_byte(hwcard->u_pci.pci_bridge_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	pci_write_config(hwcard->u_pci.pci_bridge_dev, reg, value, 4);
	pci_conf_write(hwcard->u_pci.pci_bridge_dev, reg, 4);
	pci_conf_write(hwcard->u_pci.pci_bridge_dev->pa_pc, hwcard->u_pci.pci_bridge_dev->pa_tag, reg, value); 
	pci_write_config_dword(hwcard->u_pci.pci_bridge_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	pci_write_config(hwcard->u_pci.pci_bridge_dev, reg, value, 1);
	pci_conf_write(hwcard->u_pci.pci_bridge_dev, reg, 1);
	pci_conf_write(hwcard->u_pci.pci_bridge_dev->pa_pc, hwcard->u_pci.pci_bridge_dev->pa_tag, reg, value); 
	pci_write_config_byte(hwcard->u_pci.pci_bridge_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	*value = inb (hwcard->u_isa.ioport + offset);
	*value = bus_space_read_1(hwcard->u_isa.iot, hwcard->u_isa.ioh, offset);
	*value = inb(hwcard->u_isa.ioport + offset);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	hwcard->u_isa.regs[offset] = value;
	outb (hwcard->u_isa.ioport + offset, value);
	bus_space_write_1(hwcard->u_isa.iot, hwcard->u_isa.ioh, offset, value);
	outb(value, hwcard->u_isa.ioport + offset);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	//wan_spin_lock(&hwcard->pcard_lock);
	wan_spin_lock(&hw->hwcpu->lines_info[hw->cfg_type].pcard_lock);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	//wan_spin_unlock(&hwcard->pcard_lock);
	wan_spin_unlock(&hw->hwcpu->lines_info[hw->cfg_type].pcard_lock);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	return wan_spin_trylock(&hwcard->pcard_ec_lock);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	wan_spin_lock(&hwcard->pcard_ec_lock);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	wan_spin_unlock(&hwcard->pcard_ec_lock);
	paddr	= seg->ds_addr;
	plen	= seg->ds_len;	
	if (paddr & (dma_descr->alignment-1)){
               	dma_descr->dma_offset = 
				dma_descr->alignment - 
				(paddr & (dma_descr->alignment-1));
				(unsigned long)paddr,dma_descr->dma_offset);
				dma_descr->dmat,
				dma_descr->dmam,
				(char*)dma_descr->dma_virt+dma_descr->dma_offset,
	dma_descr->dma_addr	= paddr;
	dma_descr->dma_len	= plen;
	wan_set_bit(SDLA_DMA_FLAG_READY, &dma_descr->flag);
				dma_descr->dma_addr,
				dma_descr->dma_len,
 * dma_alignment - value should be multiple 2,4
			&dma_descr->dmat);
					hw->devname,
		return -EINVAL;
		dma_descr_next->dmat		= dma_descr->dmat;
		dma_descr_next->alignment	= dma_alignment;
		dma_descr_next->max_len		= dma_max_len;
		wan_set_bit(SDLA_DMA_FLAG_INIT, &dma_descr_next->flag);
	if (!wan_test_bit(SDLA_DMA_FLAG_INIT, &dma_descr->flag)){
					hw->devname,
		return -EINVAL;
	err = bus_dma_tag_destroy(dma_descr->dmat);
					hw->devname, err);
		return -EINVAL;
		dma_descr_next->dmat		= 0;
		dma_descr_next->alignment	= 0;
		dma_descr_next->max_len		= 0;
		wan_clear_bit(SDLA_DMA_FLAG_INIT, &dma_descr_next->flag);
	err = bus_dmamap_create(dma_descr->dmat,0,&dma_descr->dmam);
					hw->devname,err);
		return -EINVAL;
	err = bus_dmamap_destroy(dma_descr->dmat,dma_descr->dmam);
					hw->devname,err);
		return -EINVAL;
	if (!wan_test_bit(SDLA_DMA_FLAG_INIT, &dma_descr->flag)){
					hw->devname, __FUNCTION__,__LINE__);
		return -EINVAL;
	err = bus_dmamem_alloc(	dma_descr->dmat,
				&dma_descr->dma_virt,
				&dma_descr->dmam);
	if (err || dma_descr->dma_virt == NULL){
					hw->devname, err);
		return -ENOMEM;
	err = bus_dmamap_load(	dma_descr->dmat,
				dma_descr->dmam,
				dma_descr->dma_virt,
				dma_descr->max_len,
				hw->devname, dma_descr->max_len, err);
				dma_descr->dmat,
				dma_descr->dma_virt,
				dma_descr->dmam);
		return -EINVAL;
	wan_set_bit(SDLA_DMA_FLAG_ALLOC, &dma_descr->flag);
	dma_descr->dma_virt = pci_alloc_consistent(	
					dma_descr->max_len,
					(dma_addr_t*)&dma_descr->dma_addr);
	if (dma_descr->dma_virt == NULL){
					hw->devname, err);
		return -ENOMEM;
	if (dma_descr->dma_addr & dma_descr->alignment){
		dma_descr->dma_offset = 
				dma_descr->alignment - 
				(dma_descr->dma_addr & dma_descr->alignment) +
		(u8*)dma_descr->dma_virt += dma_descr->dma_offset;
		dma_descr->dma_addr += dma_descr->dma_offset;
		dma_descr->dma_offset = 0;
	wan_set_bit(SDLA_DMA_FLAG_ALLOC, &dma_descr->flag);
	wan_set_bit(SDLA_DMA_FLAG_READY, &dma_descr->flag);
	if (!wan_test_bit(SDLA_DMA_FLAG_ALLOC, &dma_descr->flag)){
					hw->devname, __FUNCTION__,__LINE__);
	wan_clear_bit(SDLA_DMA_FLAG_READY, &dma_descr->flag);
	bus_dmamap_unload(dma_descr->dmat,dma_descr->dmam);
	bus_dmamem_free(dma_descr->dmat,dma_descr->dma_virt,dma_descr->dmam);
	if (dma_descr->dma_offset){
		(u8*)dma_descr->dma_virt-= dma_descr->dma_offset;
		dma_descr->dma_addr	-= dma_descr->dma_offset;
				dma_descr->max_len, 
				dma_descrdma_descr->dma_virt,
				dma_descr->dma_addr);
	wan_clear_bit(SDLA_DMA_FLAG_ALLOC, &dma_descr->flag);
	dma_descr->dma_virt = NULL;
	dma_descr->dma_addr = 0;
	err = bus_dmamap_load(	dma_descr->dmat,
				dma_descr->dmam,
				dma_descr->dma_virt,
				hw->devname, len, err);
		return -EINVAL;
	bus_dmamap_unload(dma_descr->dmat, dma_descr->dmam);
	WAN_ASSERT_VOID(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT_VOID(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	if (!wan_test_bit(SDLA_DMA_FLAG_READY, &dma_descr->flag)){
					hw->devname, __FUNCTION__,__LINE__);
		bcopy(buf, dma_descr->dma_virt, buflen);
	dma_descr->dma_offset	= 0;
	dma_descr->dma_addr = 
		cpu_to_le32(pci_map_single(hwcard->u_pci.pci_dev,buf,map_len,dir));
	if (dma_descr->dma_addr & (dma_descr->alignment-1)){
		dma_descr->dma_offset = 
			dma_descr->alignment - 
			(dma_descr->dma_addr & (dma_descr->alignment-1));
		dma_descr->dma_virt = buf + dma_descr->dma_offset;
		dma_descr->dma_addr += dma_descr->dma_offset;
		dma_descr->dma_virt	= buf;
		dma_descr->dma_offset	= 0;
	dma_descr->dma_addr = virt_to_phys(buf);
	if (dma_descr->dma_addr & (dma_descr->alignment-1)){
		dma_descr->dma_offset = 
			dma_descr->alignment - 
			(dma_descr->dma_addr & (dma_descr->alignment-1));
		dma_descr->dma_virt = buf + dma_descr->dma_offset;
		dma_descr->dma_addr = virt_to_phys(dma_descrt->dma_virt));
		dma_descr->dma_virt	= buf; 
		dma_descr->dma_offset	=0; 
	dma_descr->dma_len = buflen;
	dma_descr->dma_map_len	= map_len;
	WAN_ASSERT_VOID(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT_VOID(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	if (!wan_test_bit(SDLA_DMA_FLAG_READY, &dma_descr->flag)){
					hw->devname, __FUNCTION__,__LINE__);
	if (dma_descr->skb && dir == SDLA_DMA_POSTREAD){
		** data = wan_skb_put(dma_descr->skb, dma_descr->dma_len);*/
		data = wan_skb_tail(dma_descr->skb);
		bcopy(dma_descr->dma_virt, data, dma_descr->dma_len);
	if (dma_descr->dma_addr){
		dma_descr->dma_addr -= dma_descr->dma_offset;
		pci_unmap_single(	hwcard->u_pci.pci_dev, 
					dma_descr->dma_addr, 
					dma_descr->dma_map_len, 
	dma_descr->dma_addr	= 0;
	dma_descr->dma_addr	= 0;
	dma_descr->dma_len	= 0;
	dma_descr->dma_map_len	= 0;
	if (!wan_test_bit(SDLA_DMA_FLAG_READY, &dma_descr->flag)){
					hw->devname, __FUNCTION__,__LINE__);
		bus_dmamap_sync(dma_descr->dmat, dma_descr->dmam, dir);	
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	return cpu_to_le32(pci_map_single(hwcard->u_pci.pci_dev, buf, len, ctrl));
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	pci_unmap_single(hwcard->u_pci.pci_dev, buf, len, ctrl);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	return wan_test_and_set_bit(value, &hwcpu->lines_info[hw->cfg_type].fe_rw_flag);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	//return wan_test_bit(value, &hwcard->fe_rw_flag);
	return wan_test_bit(value, &hwcpu->lines_info[hw->cfg_type].fe_rw_flag);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	//wan_clear_bit(value, &hwcard->fe_rw_flag);
	wan_clear_bit(value, &hwcpu->lines_info[hw->cfg_type].fe_rw_flag);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	wan_set_bit(value, &hwcpu->lines_info[hw->cfg_type].fe_rw_flag);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
		switch(hwcpu->hwcard->adptr_type){
						hw->devname);
			return -EINVAL;
	}else if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
		switch(hwcpu->hwcard->core_id){
			switch(hwcpu->hwcard->adptr_type){
							hw->devname);
				return -EINVAL;
			switch(hwcpu->hwcard->adptr_type){
							hw->devname);
				return -EINVAL;
			switch(hwcpu->hwcard->adptr_type){
						hw->devname);
				return -EINVAL;		
						hw->devname);
		return -EINVAL;	
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
		switch(hwcard->adptr_type){
						hw->devname, __LINE__);
			return -EINVAL;
	}else if (hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
		switch(hwcard->core_id){
			switch(hwcard->adptr_type){
							hw->devname, __LINE__);
				return -EINVAL;
			switch(hwcard->adptr_type){
							hw->devname);
				return -EINVAL;
			switch(hwcard->adptr_type){
						hw->devname, __LINE__);
				return -EINVAL;		
						hw->devname, __LINE__);
		return -EINVAL;	
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		if (hwcard->u_pci.pci_bridge_dev == NULL) return 0;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	if (hw->hwcpu->hwcard->hwec_chan_no == 0) return -EINVAL;
	return hw->hwcpu->hwcard->hwec_ind;
	hwcard->type = SDLA_USB;
	hwcard->cfg_type = WANOPT_USB_ANALOG;	/* temporary */
	switch(hwcard->adptr_type){
		DEBUG_EVENT("%s: %s USB-FXO module found (rev.%X)!\n",
				hwcard->adptr_name,
				hwcard->core_rev);
			sdladrv_callback.add_device(hw->devname, hw);
				hwcard->adptr_type,
				 udev->devnum, udev->dev.bus_id);
	hwcard = sdla_card_register(SDLA_USB_CARD, udev->devnum, 0, 0, udev->dev.bus_id); 
	hwcard->adptr_type	= adptr_type;
	hwcard->u_usb.usb_dev	= udev;
	hwcard->u_usb.usb_intf	= intf;
		return -EINVAL;
					udev->devnum, udev->dev.bus_id);
	hwcard = sdla_card_search(SDLA_USB_CARD, udev->devnum, 0, 0, udev->dev.bus_id);
		return -EINVAL;
	hwcpu = sdla_hwcpu_search(SDLA_USB_CARD, udev->devnum, 0, 0, 0, udev->dev.bus_id);
		return -EINVAL;
		return -EINVAL;
			sdladrv_callback.delete_device(hw->devname);
			DEBUG_EVENT("sdlausb: Sangoma USB devices doesn't support hot-plug functionality!\n");
	if (sdla_hwdev_common_unregister(hwcpu) == -EBUSY){
		return -EINVAL;
	if (sdla_hwcpu_unregister(hwcpu) == -EBUSY){
		return -EINVAL;
	if (sdla_card_unregister(hwcard) == -EBUSY){
		return -EINVAL;
	sdla_adapter_cnt.usb_adapters--;
	DEBUG_EVENT("sdlausb: USB-FXO module on %d detached (BusId %s)\n", 
					udev->devnum, udev->dev.bus_id);
	int cnum=0, err=-1, sec_port=0;
		WAN_ASSERT_RC(hw->hwcpu == NULL, -1);
		hwcpu = hw->hwcpu;
			if (hwcpu->hwcard->cfg_type == WANOPT_S51X) {
		hwinfo->card_model = hwcpu->hwcard->adptr_type;
		hwinfo->firmware_version = hwcpu->hwcard->core_rev;
		hwinfo->pci_bus_number = hwcpu->hwcard->u_pci.bus_no;
		hwinfo->pci_slot_number = hwcpu->hwcard->u_pci.slot_no;
		hwinfo->max_hw_ec_chans = hwcpu->hwcard->hwec_chan_no;
		hwinfo->port_number = hw->line_no+1;
			hwinfo->port_number++;
						AFT_PCITYPE_DECODE(hwcpu->hwcard),
						AFT_PCIBRIDGE_DECODE(hwcpu->hwcard),
						hwcpu->hwcard->cpld_rev);
						AFT_PCITYPE_DECODE(hwcpu->hwcard),
						AFT_PCIBRIDGE_DECODE(hwcpu->hwcard),
						hwcpu->hwcard->cpld_rev);
				return -EINVAL;
				return -EINVAL;
				return -EINVAL;
			sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "%s|BUS_IF=%s|BRDG=%s|C=%02d",str_dump, 
								AFT_PCITYPE_DECODE(hwcpu->hwcard),
								AFT_PCIBRIDGE_DECODE(hwcpu->hwcard),		
								hw->hwcpu->hwcard->cpld_rev);
			memcpy(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_verbose[0],
			hw->adptr_type	  = AFT_ADPTR_ISDN;
			hw->chans_map	  = 0x03;	/* 2 BRI bchans */
			hw->max_chans_num = 2;
			hwcpu->lines_info[AFT_ADPTR_ISDN].total_line_no++;
		hwcpu->lines_info[AFT_ADPTR_ISDN].line_map	= line_map;
		return -EINVAL;
		return -EINVAL;
		return -EINVAL;
					AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
			sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|FE=%s","FXS");
					AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
			sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|FE=%s","FXO");
			sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|FE=%s","EMPTY");
		hw->max_chans_num++;
		memcpy(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_verbose[off], str, strlen(str));
	hw->adptr_type	  = A200_ADPTR_ANALOG;
	hw->chans_map	  = chans_map;
	hw->max_chans_num = max_analog_lines;
	hwcpu->lines_info[A200_ADPTR_ANALOG].total_line_no = 1;
./sdladrv_src.c
* Copyright:	(c) 1995-2001 Sangoma Technologies Inc.
 *  o initialize protocol-specific fields of the adapter data space.
			card->devname);
			card->devname);
	if (conf->config_id != WANCONFIG_BSCSTRM) {
				  card->devname, conf->config_id);
		return -EINVAL;
	card->wandev.comm_port = conf->comm_port;
	/* Initialize protocol-specific fields */
	if(card->type != SDLA_S514){
		/* Alex Apr 8 2004 Sangoma ISA card -> card->mbox_off  = 0; */
		card->mbox_off = BASE_ADDR_SEND_MB;
		if (card->hw_iface.mapmem){
			err = card->hw_iface.mapmem(card->hw, BASE_ADDR_SEND_MB);
			err = -EINVAL;
		card->mbox_off = BASE_ADDR_SEND_MB;
	mbox=&card->wan_mbox;
	while((jiffies-timeout) < (HZ)){
		card->wandev.state = WAN_DISCONNECTED;
		return -EIO;
		card->devname, mbox->wan_data); 
	card->isr			= &wp_bscstrm_isr;
	card->poll			= NULL;
	card->exec			= NULL;
	card->wandev.update		= &update;
 	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= &del_if;
	card->wandev.udp_port   	= conf->udp_port;
	card->disable_comm		= NULL;
	card->wandev.new_if_cnt = 0;
	card->wandev.ttl = conf->ttl;
	card->wandev.electrical_interface = conf->electrical_interface; 
	card->wandev.clocking = conf->clocking;
	card->wandev.mtu = 1000;
	if (card->wandev.clocking == WANOPT_EXTERNAL){
		card->wandev.bscstrm_cfg.baud_rate = 0;
		card->wandev.bscstrm_cfg.baud_rate = conf->bps;
	memcpy(&card->wandev.bscstrm_cfg, &conf->u.bscstrm, sizeof(wan_bscstrm_conf_t));
	cfg.baud_rate 			= card->wandev.bscstrm_cfg.baud_rate;
   	cfg.adapter_frequency		= card->wandev.bscstrm_cfg.adapter_frequency; 
   	cfg.max_data_length		= card->wandev.bscstrm_cfg.max_data_length;	
   	cfg.EBCDIC_encoding		= card->wandev.bscstrm_cfg.EBCDIC_encoding;	
   	cfg.Rx_block_type		= card->wandev.bscstrm_cfg.Rx_block_type;	
   	cfg.no_consec_PADs_EOB		= card->wandev.bscstrm_cfg.no_consec_PADs_EOB;
   	cfg.no_add_lead_Tx_SYN_chars	= card->wandev.bscstrm_cfg.no_add_lead_Tx_SYN_chars;
   	cfg.no_bits_per_char		= card->wandev.bscstrm_cfg.no_bits_per_char;
   	cfg.parity			= card->wandev.bscstrm_cfg.parity;
   	cfg.misc_config_options		= card->wandev.bscstrm_cfg.misc_config_options;
   	cfg.statistics_options		= card->wandev.bscstrm_cfg.statistics_options;
   	cfg.modem_config_options	= card->wandev.bscstrm_cfg.modem_config_options;
	printk(KERN_INFO "%s: Bisync Streaming Config: \n",card->devname);
			card->devname,card->wandev.comm_port==0?"PRI":"SEC");
			card->devname,card->wandev.bscstrm_cfg.baud_rate);
			card->devname,card->wandev.bscstrm_cfg.adapter_frequency);
			card->devname,card->wandev.bscstrm_cfg.max_data_length);
			card->devname,card->wandev.bscstrm_cfg.EBCDIC_encoding);
			card->devname,card->wandev.bscstrm_cfg.Rx_block_type);
			card->devname,card->wandev.bscstrm_cfg.no_consec_PADs_EOB);
			card->devname,card->wandev.bscstrm_cfg.no_add_lead_Tx_SYN_chars);
			card->devname,card->wandev.bscstrm_cfg.no_bits_per_char);
			card->devname,card->wandev.bscstrm_cfg.parity);
			card->devname,card->wandev.bscstrm_cfg.misc_config_options);
			card->devname,card->wandev.bscstrm_cfg.statistics_options);
			card->devname,card->wandev.bscstrm_cfg.modem_config_options);
	printk(KERN_INFO "%s: Configuring Bisync Streaming!\n",card->devname);
				card->devname);
		return -EINVAL;
	card->wandev.state = WAN_DISCONNECTED;
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical))
                return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
	if((bscstrm_priv_area=dev->priv) == NULL)
		return -ENODEV;
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
			card->devname, conf->name);
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
	if (card->wandev.new_if_cnt){
		return -EEXIST;
		return -ENOMEM;
	bscstrm_priv_area->card = card; 
	bscstrm_priv_area->common.sk = NULL;
	bscstrm_priv_area->common.state = WAN_DISCONNECTED;
	bscstrm_priv_area->common.dev = dev;
	if(card->wandev.new_if_cnt > 0) {
		return -EEXIST;
	if (strcmp(conf->usedby, "API") == 0) {
			wandev->name);
					wandev->name);
		return -EINVAL;
	wan_reg_api(bscstrm_priv_area, dev, card->devname);
	WAN_TASKLET_INIT((&bscstrm_priv_area->common.bh_task),0,bscstrm_bh,(unsigned long)bscstrm_priv_area);
	card->rxmb_off = card->mbox_off + 0x1000;
	dev->init = &if_init;
	dev->priv = bscstrm_priv_area;
	card->wandev.new_if_cnt++;
	bscstrm_private_area_t*	chan = dev->priv;
	sdla_t*			card = chan->card;
	WAN_TASKLET_KILL(&chan->common.bh_task);
	wan_unreg_api(chan, card->devname);
	bscstrm_private_area_t* bscstrm_priv_area = dev->priv;
	sdla_t* card = bscstrm_priv_area->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->do_ioctl		= &if_ioctl;
	dev->tx_timeout		= NULL;
	dev->watchdog_timeo	= TX_TIMEOUT;
	/* Initialize media-specific parameters */
	dev->flags		|= IFF_POINTOPOINT;
	dev->flags		|= IFF_NOARP;
	if (bscstrm_priv_area->true_if_encoding){
		dev->type	= ARPHRD_HDLC; /* This breaks the tcpdump */
		dev->type	= ARPHRD_PPP;
	dev->mtu		= card->wandev.mtu;
	dev->mtu += sizeof(api_tx_hdr_t);
	dev->hard_header_len	= BSTRM_HDR_LEN;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start); //ALEX_TODAY wandev->maddr;
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end); //ALEX_TODAY wandev->maddr + wandev->msize - 1;
        dev->tx_queue_len = 100;
	bscstrm_private_area_t* bscstrm_priv_area = dev->priv;
	sdla_t* card = bscstrm_priv_area->card;
		return -EBUSY;
	bscstrm_priv_area->router_start_time = tv.tv_sec;
				card->devname);
		return -EIO;
	printk(KERN_INFO "%s: Enabling bscstrm rx isr\n",card->devname);
				card->devname);
		return -EINVAL;
	printk(KERN_INFO "%s: Enabling bscstrm communication\n",card->devname);
	bscstrm_private_area_t* bscstrm_priv_area = dev->priv;
	sdla_t* card = bscstrm_priv_area->card;
	dev->start=0;
	card->wandev.state = WAN_DISCONNECTED;
	bscstrm_private_area_t *chan = dev->priv;
	sdla_t *card = chan->card;
	wan_mbox_t *mbox = &card->wan_mbox;
	api_tx_element_t *api_tx_el = (api_tx_element_t *)&skb->data[0];
	int len = skb->len-sizeof(api_tx_hdr_t);
				card->devname,skb->len,sizeof(api_tx_hdr_t));
	if (chan->common.state != WAN_CONNECTED){
		++card->wandev.stats.tx_carrier_errors;
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	if (card->next){
		wan_spin_lock(&card->next->wandev.lock);
	mbox->wan_command=BSC_WRITE;
	mbox->wan_data_len=len;
	mbox->wan_bscstrm_port=card->wandev.comm_port;
	mbox->wan_bscstrm_misc_bits=api_tx_el->api_tx_hdr.misc_tx_rx_bits;
	memcpy(mbox->wan_data,api_tx_el->data,len);
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	if (card->next){
		wan_spin_unlock(&card->next->wandev.lock);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
					card->devname,err);
	++card->wandev.stats.tx_packets;
	card->wandev.stats.tx_bytes=len;
	if (!dev || !(dev->flags & IFF_UP)){
		return -ENODEV;
	if (!(chan = dev->priv)){
		return -ENODEV;
	if (!(card = chan->card)){
		return -ENODEV;
	mbox=&card->wan_mbox;
			err= -EINVAL;
		wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
		err=wan_bind_api_to_svc(chan,ifr->ifr_data);
		wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
			err= -EINVAL;
		wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
		err=wan_unbind_api_from_svc(chan, ifr->ifr_data);
		wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
		err = chan->common.state;
		user_mbox= (wan_mbox_t*)ifr->ifr_data;
			err=-EINVAL;
			return -EOPNOTSUPP;
		if (copy_from_user(&mbox->wan_command,&user_mbox->wan_command,sizeof(wan_cmd_t))){
			return -EFAULT;
		if (mbox->wan_data_len){
			if (copy_from_user(mbox->wan_data,user_mbox->wan_data,mbox->wan_data_len)){
				return -EFAULT;
		wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
		wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
			return -EINVAL;
		if (copy_to_user(&user_mbox->wan_command,&mbox->wan_command,sizeof(wan_cmd_t))){
			return -EFAULT;
		if (mbox->wan_data_len){
			if (copy_to_user(user_mbox->wan_data,mbox->wan_data,mbox->wan_data_len)){
				return -EFAULT;
	wan_mbox_t		*mbox = &card->wan_mbox;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if ((bscstrm_priv_area = dev->priv) == NULL){
	card->hw_iface.peek(card->hw, card->rxmb_off, mbox, sizeof(wan_cmd_t));
	if (mbox->wan_data_len){
		card->hw_iface.peek(card->hw, 
				    card->rxmb_off+offsetof(wan_mbox_t, wan_data), 
				    mbox->wan_data, mbox->wan_data_len);
			card->devname,
			mbox->wan_opp_flag,mbox->wan_bscstrm_port,
			bscstrm_priv_area->common.sk);
	set_bit(0,&card->wandev.critical);
	if (!bscstrm_priv_area->common.sk){
		++card->wandev.stats.rx_dropped;
	if (mbox->wan_opp_flag && mbox->wan_bscstrm_port == card->wandev.comm_port){
				mbox->wan_data_len,++gcount);
		skb = dev_alloc_skb(mbox->wan_data_len+sizeof(api_rx_hdr_t)+5);
					card->devname);
			mbox->wan_opp_flag=0;
			card->hw_iface.poke(card->hw, card->rxmb_off, mbox, sizeof(wan_cmd_t)); 
			card->hw_iface.poke(card->hw,0xFFF0,&reset_byte,sizeof(reset_byte));
			++card->wandev.stats.rx_dropped;
		buf=(api_rx_element_t*)skb_put(skb,mbox->wan_data_len);
		memcpy(buf,mbox->wan_data,mbox->wan_data_len);
		skb->protocol = htons(PVC_PROT);
		skb->dev      = dev;
		skb->pkt_type = WAN_PACKET_DATA;
			++card->wandev.stats.rx_dropped;
			mbox->wan_opp_flag=0;
			card->hw_iface.poke(card->hw, card->rxmb_off, mbox, sizeof(wan_cmd_t)); 
			card->hw_iface.poke(card->hw,0xFFF0,&reset_byte,sizeof(reset_byte));
			++card->wandev.stats.rx_packets;
			card->wandev.stats.rx_bytes += mbox->wan_data_len;
		mbox->wan_opp_flag=0;
		card->hw_iface.poke(card->hw, card->rxmb_off, mbox, sizeof(wan_cmd_t)); 
		card->hw_iface.poke(card->hw,0xFFF0,&reset_byte,sizeof(reset_byte));
	if (mbox->wan_opp_flag && mbox->wan_bscstrm_port == card->wandev.comm_port){
		mbox->wan_opp_flag=0;
		card->hw_iface.poke(card->hw, card->rxmb_off, mbox, sizeof(wan_cmd_t));
		card->hw_iface.poke(card->hw,0xFFF0,&reset_byte,sizeof(reset_byte));
	clear_bit(0,&card->wandev.critical);
 * Get ethernet-style interface statistics.
	if ((bscstrm_priv_area=dev->priv) == NULL)
	my_card = bscstrm_priv_area->card;
	return &my_card->wandev.stats; 
	wan_mbox_t*	mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = DISABLE_COMMUNICATIONS;
	mb->wan_bscstrm_port=card->wandev.comm_port;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t*	mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = ENABLE_COMMUNICATIONS;
	mb->wan_bscstrm_port=card->wandev.comm_port;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t*	mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_CODE_VERSION;
	mb->wan_bscstrm_port=card->wandev.comm_port;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t*	mb = &card->wan_mbox;
        mb->wan_data_len = sizeof(CONFIGURATION_STRUCT);
        mb->wan_command = SET_CONFIGURATION;
	mb->wan_bscstrm_port=card->wandev.comm_port;
	memcpy(mb->wan_data,cfg,sizeof(CONFIGURATION_STRUCT));
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t*	mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_CONFIGURATION;
	mb->wan_bscstrm_port=card->wandev.comm_port;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t*	mb = &card->wan_mbox;
        mb->wan_data_len = 4;
        mb->wan_command = SET_INTERRUPT_TRIGGERS;
	mb->wan_bscstrm_port=card->wandev.comm_port;
	mb->wan_data[0]=0x01;
	mb->wan_data[1]=0x00;
	mb->wan_data[2]=0x00;
	mb->wan_data[3]=card->wandev.irq;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_command;
			card->devname, cmd);
			card->devname, cmd, err);
        if (card->wandev.state != state)
                                card->devname);
                                card->devname);
                                card->devname);
                card->wandev.state  = state;
		dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
			bscstrm_priv_area->common.state = state;
./sdla_bscstrm.c
* 		WANPIPE(tm) AFT CORE Hardware Support - Utilities
* Copyright:	(c) 2003-2008 Sangoma Technologies Inc.
	if (card->adptr_subtype == AFT_SUBTYPE_SHARK){
		card->u.aft.security_id=0x01;
	card->hw_iface.hw_lock(card->hw,&smp_flags);
	wan_spin_lock_irq(&card->wandev.lock,&flags);
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
	card->u.aft.security_id=adptr_security;
				card->devname);
				card->devname);
				card->devname);		
		return -EINVAL;
	card->u.aft.security_cnt=0;
        if (card->u.aft.firm_id == AFT_PMC_FE_CORE_ID) {
		card->hw_iface.bus_read_4(card->hw,AFT_CHIP_CFG_REG, &reg);
					card->devname);
				return -EINVAL;
					card->devname);
				return -EINVAL;
	if (len > chan->dma_mru){
				chan->if_name,len,chan->dma_mru);
		return -ENOMEM;
	if (!chan->tx_realign_buf){
		chan->tx_realign_buf=wan_malloc(chan->dma_mru);
		if (!chan->tx_realign_buf){
						chan->if_name);
			return -ENOMEM;
						chan->if_name,chan->dma_mru);
	memcpy(chan->tx_realign_buf,data,len);
				chan->if_name,wan_skb_tailroom(skb),len);
		return -ENOMEM;
		return -EINVAL;
	memcpy(data,chan->tx_realign_buf,len);
	chan->opstats.Data_frames_Tx_realign_count++;
	u32 wdt_ctrl_reg=AFT_WDT_1TO4_CTRL_REG+card->wandev.comm_port;
	if (card->wandev.comm_port > 3) {
		wdt_ctrl_reg=AFT_WDT_4TO8_CTRL_REG+(card->wandev.comm_port%4);	
	card->hw_iface.bus_read_1(card->hw,AFT_PORT_REG(card,wdt_ctrl_reg), &reg);		
	card->hw_iface.bus_write_1(card->hw,AFT_PORT_REG(card,wdt_ctrl_reg), reg);
	u32 wdt_ctrl_reg=AFT_WDT_1TO4_CTRL_REG+card->wandev.comm_port;
	if (card->wandev.comm_port > 3) {
		wdt_ctrl_reg=AFT_WDT_4TO8_CTRL_REG+(card->wandev.comm_port%4);	
	card->hw_iface.bus_read_1(card->hw, AFT_PORT_REG(card,wdt_ctrl_reg), &reg);		
	card->hw_iface.bus_write_1(card->hw, AFT_PORT_REG(card,wdt_ctrl_reg), reg);
	card->hw_iface.bus_read_4(card->hw,
		wan_set_bit(chan->logic_ch_num,&reg);
		wan_clear_bit(chan->logic_ch_num,&reg);
	card->hw_iface.bus_write_4(card->hw,
	card->hw_iface.bus_read_4(card->hw,
		wan_set_bit(chan->logic_ch_num,&reg);
		wan_clear_bit(chan->logic_ch_num,&reg);
	card->hw_iface.bus_write_4(card->hw,
	card->hw_iface.bus_read_4(card->hw,
		wan_set_bit(chan->logic_ch_num,&reg);
		wan_clear_bit(chan->logic_ch_num,&reg);
	card->hw_iface.bus_write_4(card->hw,
	card->hw_iface.bus_read_4(card->hw,
		wan_set_bit(chan->logic_ch_num,&reg);
		wan_clear_bit(chan->logic_ch_num,&reg);
	card->hw_iface.bus_write_4(card->hw,
	if (chan->hdlc_eng){
	dma_ram_reg+=(chan->logic_ch_num*4);
	card->hw_iface.bus_read_4(card->hw, dma_ram_reg, &reg);
	card->hw_iface.bus_write_4(card->hw, dma_ram_reg, reg);
	wan_skb_queue_tail(&chan->wp_rx_free_list,skb);
	if (chan->tx_idle_skb == skb) {
	if (chan->common.usedby == XMTP2_API) {
	} else if (chan->channelized_cfg && !chan->hdlc_eng){
		if (chan->channelized_cfg && !chan->hdlc_eng){
      				skb=__dev_alloc_skb(chan->dma_mru,GFP_DMA|GFP_ATOMIC);  	
                         	skb=__dev_alloc_skb(chan->dma_mru,GFP_DMA|GFP_KERNEL);
				skb=wan_skb_alloc(chan->dma_mru);
				skb=wan_skb_kalloc(chan->dma_mru);
                        	skb=wan_skb_alloc(chan->dma_mru); 
			        skb=wan_skb_kalloc(chan->dma_mru); 	
					chan->if_name,__FUNCTION__);
			return -ENOMEM;
		wan_skb_queue_tail(&chan->wp_rx_free_list,skb);
	return aft_hwdev[card->wandev.card_type].aft_read_cpld(card,cpld_off);
	return 	aft_hwdev[card->wandev.card_type].aft_write_cpld(card,off,data);
				card->devname, off, value);
				card->devname, off, value);
	if(api_cmd->len == 1){
		if (api_cmd->offset <= 0x3C){
			card->hw_iface.pci_read_config_byte(
					card->hw,
					api_cmd->offset,
					(u8*)&api_cmd->data[0]); 
			card->hw_iface.bus_read_1(
					card->hw,
				       	api_cmd->offset,
			       		(u8*)&api_cmd->data[0]);
	}else if (api_cmd->len == 2){
		if (api_cmd->offset <= 0x3C){
			card->hw_iface.pci_read_config_word(
					card->hw,
					api_cmd->offset,
					(u16*)&api_cmd->data[0]); 
			card->hw_iface.bus_read_2(
					card->hw,
				       	api_cmd->offset,
			       		(u16*)&api_cmd->data[0]);
	}else if (api_cmd->len == 4){
		if (api_cmd->offset <= 0x3C){
			card->hw_iface.pci_read_config_dword(card->hw,
					api_cmd->offset,
					(u32*)&api_cmd->data[0]); 
			WAN_ASSERT(card->hw_iface.bus_read_4 == NULL);
			card->hw_iface.bus_read_4(
					card->hw,
				       	api_cmd->offset,
			       		(u32*)&api_cmd->data[0]);
		card->hw_iface.peek(card->hw,
					api_cmd->offset,
					&api_cmd->data[0],
					api_cmd->len);
				card->devname,
				api_cmd->bar,
				api_cmd->offset,
				*(u32*)&api_cmd->data[0],
				api_cmd->len);
	card->hw_iface.hw_lock(card->hw,&smp_flags);
	api_cmd->data[0] = (u8)card->fe.read_fe_reg(card, (int)api_cmd->offset);
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
			card->devname,api_cmd->bar,api_cmd->offset,api_cmd->len, api_cmd->data[0]);
	if (api_cmd->len == 1){
		card->hw_iface.bus_write_1(
				card->hw,
				api_cmd->offset,
				*(u8*)&api_cmd->data[0]);
				card->devname,api_cmd->offset,
				*(u8*)&api_cmd->data[0]);
	}else if (api_cmd->len == 2){
		card->hw_iface.bus_write_2(
				card->hw,
				api_cmd->offset,
				*(u16*)&api_cmd->data[0]);
				card->devname,api_cmd->offset,
				*(unsigned short*)&api_cmd->data[0]);
	}else if (api_cmd->len == 4){
		card->hw_iface.bus_write_4(
				card->hw,
				api_cmd->offset,
				*(unsigned int*)&api_cmd->data[0]);
			card->devname,api_cmd->offset,
			*(u32*)&api_cmd->data[0]);
		card->hw_iface.poke(
				card->hw,
				api_cmd->offset,
				(u8*)&api_cmd->data[0],
				api_cmd->len);
			(unsigned char*)&api_cmd->data[0], api_cmd->len);
			card->devname,
			api_cmd->bar,
			api_cmd->offset,
			api_cmd->len,
			api_cmd->data[0]);
	card->hw_iface.hw_lock(card->hw,&smp_flags);
	card->fe.write_fe_reg (card, (int)api_cmd->offset, (int)api_cmd->data[0]);
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
			(card->wandev.S514_cpu_no[0] == SDLA_CPU_A) ? 0x10 : 0x14,
			card->u.aft.bar,card->wandev.irq);
	card->hw_iface.pci_write_config_dword(card->hw, 
			(card->wandev.S514_cpu_no[0] == SDLA_CPU_A) ? 0x10 : 0x14,
			card->u.aft.bar);
	card->hw_iface.pci_write_config_dword(card->hw, 0x3C, card->wandev.irq);
	card->hw_iface.pci_write_config_dword(card->hw, 0x0C, 0x0000ff00);
	if (api_cmd->offset){
		if (api_cmd->len){
			aft_write_ec (card, api_cmd->offset, api_cmd->data[0]);
			api_cmd->data[0] = aft_read_ec (card, api_cmd->offset);
			api_cmd->len = 1;
		OctDrvIoctl(card, api_cmd->cmd, api_cmd->data);
	int 		err = -EINVAL;
	if (!ifr || !ifr->ifr_data){
		return -EFAULT;
		return -EFAULT;
	if (WAN_COPY_FROM_USER(api_cmd,ifr->ifr_data,sizeof(wan_cmd_api_t))){
		return -EFAULT;
	switch(api_cmd->cmd){
	if (WAN_COPY_TO_USER(ifr->ifr_data,api_cmd,sizeof(wan_cmd_api_t))){
		return -EFAULT;
	card_ptr->hw_iface.getcfg(card_ptr->hw, SDLA_HWCPU_USEDCNT, &used_cnt);
		if (card->sdla_tdmv_dummy) {
				card->devname,zt_chunksize);
		return -1;		
	card_list=__sdla_get_ptr_isr_array(card_ptr->hw);
		if (card == NULL || wan_test_bit(CARD_DOWN,&card->wandev.critical)) {
		if (card->sdla_tdmv_dummy) {
				card->devname,zt_chunksize);
		if (wan_test_bit(AFT_TDM_GLOBAL_ISR,&card->u.aft.chip_cfg_status)) {
			*mtu = card->u.aft.tdmv_mtu;	
	return -1;
	if (!chan || wan_test_bit(0,&chan->interface_down)) {
		return -ENODEV;
	if (!chan->hdlc_eng) {
		return -EINVAL;
		return -EINVAL;
	if (chan->common.usedby == API){
	}else if (chan->common.usedby == STACK){
	if (new_mtu > chan->dma_mru) {
		return -EINVAL;
	dev->mtu = new_mtu;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (chan->common.state != WAN_CONNECTED) {
		                        card->devname);
	skb = wan_skb_alloc(wan_udp_pkt->wan_udp_data_len+100);
	switch (chan->common.usedby) {
		if (card->u.aft.tdmv_dchan) {
		                        card->devname);
			card->devname);
	buf = wan_skb_put(skb, wan_udp_pkt->wan_udp_data_len);
	memcpy(buf, wan_udp_pkt->wan_udp_data, wan_udp_pkt->wan_udp_data_len);
	skb->next = skb->prev = NULL;
        skb->dev = dev;
        skb->protocol = htons(ETH_P_IP);
				card->devname);
 * "wanpipemon" utility is a user-space program that
	wan_udp_pkt = (wan_udp_pkt_t *)chan->udp_pkt_data;
	if (wan_atomic_read(&chan->udp_pkt_len) == 0){
		return -ENODEV;
	trace_info=&chan->trace_info;
	wan_udp_pkt = (wan_udp_pkt_t *)chan->udp_pkt_data;
		wan_udp_pkt->wan_udp_opp_flag = 0;
		switch(wan_udp_pkt->wan_udp_command) {
 			if_cfg = (wan_if_cfg_t*)&wan_udp_pkt->wan_udp_data[0];
                        if_cfg->usedby = chan->common.usedby;
                        if_cfg->media=card->wandev.fe_iface.get_fe_media(&card->fe);
                        if_cfg->active_ch=chan->time_slot_map;
                        if_cfg->chunk_sz=chan->mru/chan->num_of_time_slots;
                        if_cfg->interface_number=chan->logic_ch_num;
                        if (chan->hdlc_eng) {
                                if_cfg->hw_coding=WAN_TDMV_HDLC;
                                if_cfg->hw_coding=card->fe.fe_cfg.tdmv_law;
                                        if_cfg->hw_coding=WAN_TDMV_MULAW;
                                        if_cfg->hw_coding=WAN_TDMV_ALAW;
                        memcpy(&if_cfg->fe_cfg, &card->fe.fe_cfg, sizeof(sdla_fe_cfg_t));
                        wan_udp_pkt->wan_udp_return_code = 0;
                        wan_udp_pkt->wan_udp_data_len=sizeof(wan_if_cfg_t);
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data[0]=card->u.aft.firm_ver;
			wan_udp_pkt->wan_udp_data_len=1;
			wan_udp_pkt->wan_udp_return_code = 0;
			if (card->wandev.state == WAN_CONNECTED){
				wan_udp_pkt->wan_udp_data[0]=1;
				wan_udp_pkt->wan_udp_data[0]=0;
			wan_udp_pkt->wan_udp_data_len=1;
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data[0]=0;
				if (wan_test_bit(AFT_SERIAL_LCFG_DCD_BIT,&card->u.aft.serial_status)) {
					wan_udp_pkt->wan_udp_data[0]|=0x08;
				if (wan_test_bit(AFT_SERIAL_LCFG_CTS_BIT,&card->u.aft.serial_status)) {
					wan_udp_pkt->wan_udp_data[0]|=0x20;
				if (card->wandev.state == WAN_CONNECTED){
					wan_udp_pkt->wan_udp_data[0]=0x28;
					wan_udp_pkt->wan_udp_data[0]=0;
			wan_udp_pkt->wan_udp_data_len=1;
			wan_udp_pkt->wan_udp_return_code = 
			wan_udp_pkt->wan_udp_return_code = 0;
			memcpy(wan_udp_pkt->wan_udp_data,&chan->opstats,sizeof(aft_op_stats_t));
			wan_udp_pkt->wan_udp_data_len=sizeof(aft_op_stats_t);
			wan_udp_pkt->wan_udp_return_code = 0;
			memset(&chan->opstats,0,sizeof(aft_op_stats_t));
			wan_udp_pkt->wan_udp_data_len=0;
			wan_udp_pkt->wan_udp_return_code = 0;
			memcpy(wan_udp_pkt->wan_udp_data,&chan->errstats,sizeof(aft_comm_err_stats_t));
			wan_udp_pkt->wan_udp_data_len=sizeof(aft_comm_err_stats_t);
			wan_udp_pkt->wan_udp_return_code = 0;
			memset(&chan->errstats,0,sizeof(aft_comm_err_stats_t));
			wan_udp_pkt->wan_udp_data_len=0;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			wan_udp_pkt->wan_udp_data_len = 0;
			if (!wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
				if (wan_udp_pkt->wan_udp_data[0] == 0){
					wan_clear_bit(1,&trace_info->tracing_enabled);
						card->devname);
				}else if (wan_udp_pkt->wan_udp_data[0] == 1){
					wan_clear_bit(2,&trace_info->tracing_enabled);
					wan_set_bit(1,&trace_info->tracing_enabled);
							card->devname);
					wan_clear_bit(1,&trace_info->tracing_enabled);
					wan_set_bit(2,&trace_info->tracing_enabled);
							card->devname);
				wan_set_bit (0,&trace_info->tracing_enabled);
						card->devname);
				wan_udp_pkt->wan_udp_return_code = 2;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			if(wan_test_bit(0,&trace_info->tracing_enabled)) {
				wan_clear_bit(0,&trace_info->tracing_enabled);
				wan_clear_bit(1,&trace_info->tracing_enabled);
				wan_clear_bit(2,&trace_info->tracing_enabled);
							card->devname);
				wan_udp_pkt->wan_udp_return_code = 1;
			if(wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
						card->devname);
				wan_udp_pkt->wan_udp_return_code = 1;
			wan_udp_pkt->wan_udp_atm_num_frames = 0;	
			wan_udp_pkt->wan_udp_atm_ismoredata = 0;
			while (wan_skb_queue_len(&trace_info->trace_queue)){
				WAN_IFQ_POLL(&trace_info->trace_queue, skb);
								card->devname);
				if ((WAN_MAX_DATA_SIZE - buffer_length) < skb->m_pkthdr.len){
					wan_udp_pkt->wan_udp_atm_ismoredata = 0x01;
					   skb->m_pkthdr.len, 
					   &wan_udp_pkt->wan_udp_data[buffer_length]);
				buffer_length += skb->m_pkthdr.len;
				WAN_IFQ_DEQUEUE(&trace_info->trace_queue, skb);
				wan_udp_pkt->wan_udp_atm_num_frames++;
			while ((skb=skb_dequeue(&trace_info->trace_queue)) != NULL){
				if((MAX_TRACE_BUFFER - buffer_length) < wan_skb_len(skb)){
					wan_udp_pkt->wan_udp_atm_ismoredata = 0x01;
						wan_skb_queue_head(&trace_info->trace_queue, skb);
						memcpy(&wan_udp_pkt->wan_udp_atm_data[buffer_length], 
						wan_udp_pkt->wan_udp_atm_num_frames++;
				memcpy(&wan_udp_pkt->wan_udp_atm_data[buffer_length], 
				wan_udp_pkt->wan_udp_atm_num_frames++;
			wan_udp_pkt->wan_udp_data_len = buffer_length;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			wan_getcurrenttime(&chan->router_up_time, NULL);
			chan->router_up_time -= chan->router_start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
					chan->router_up_time;	
			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_aft_num_frames = card->wandev.config_id;
		    wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    wan_udp_pkt->wan_udp_data_len = 1;
		    wan_udp_pkt->wan_udp_data[0] = WAN_PLATFORM_ID;
		    wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    wan_udp_pkt->wan_udp_data_len = 1;
			wan_udp_pkt->wan_udp_data_len = 0;
			wan_udp_pkt->wan_udp_return_code = 0xCD;
			*(u32 *)&wan_udp_pkt->wan_udp_aft_num_frames =
							(u32)card->wandev.fe_ec_map;
			wan_udp_pkt->wan_udp_data_len = sizeof(u32);
			wan_udp_pkt->wan_udp_return_code = 0;
			if ((wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE) ||
			    ((wan_udp_pkt->wan_udp_command & 0xF0) == WAN_FE_UDP_CMD_START)){
				card->hw_iface.hw_lock(card->hw,&smp_flags);
				wan_spin_lock_irq(&card->wandev.lock,&smp_flags1);
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				wan_spin_unlock_irq(&card->wandev.lock,&smp_flags1);
				card->hw_iface.hw_unlock(card->hw,&smp_flags);
			wan_udp_pkt->wan_udp_data_len = 0;
			wan_udp_pkt->wan_udp_return_code = 0xCD;
				card->devname,wan_udp_pkt->wan_udp_command);
	wan_udp_pkt->wan_ip_ttl= card->wandev.ttl;
	wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
        if (IS_TE1_CARD(card) && card->hw) {
	       card->hw_iface.hw_lock(card->hw,&smp_flags);
	       if (card->wandev.fe_iface.read_alarm) {
               		card->wandev.fe_iface.read_alarm(&card->fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE); 
	       if (card->wandev.fe_iface.read_pmon) {
			wan_spin_lock_irq(&card->wandev.lock,&flags);
	         	card->wandev.fe_iface.read_pmon(&card->fe, 0);
			wan_spin_unlock_irq(&card->wandev.lock,&flags);
	       card->hw_iface.hw_unlock(card->hw,&smp_flags);
        	tdmv_hwec_option=conf->hwec.enable;
               	card->wandev.ec_enable(card, 0, fe_chan);
				chan->if_name,
		err = card->wandev.ec_enable(card, 1, fe_chan);
					chan->if_name,fe_chan);
	if (!card->wandev.ec_enable) {
	if (chan->tdm_span_voice_api) {
		u32 map=chan->time_slot_map;
	} else if (chan->common.usedby == TDM_VOICE_API ||
	           chan->common.usedby == TDM_VOICE){
				fe_chan = chan->first_time_slot+1;
				fe_chan = chan->first_time_slot;
			fe_chan = chan->first_time_slot+1;
		    fe_chan = chan->first_time_slot+1; 
	card->hw_iface.bus_read_4(card->hw,AFT_LINE_CFG_REG,&reg);
	card->hw_iface.bus_write_4(card->hw,AFT_LINE_CFG_REG,reg);
	if (card_ptr->wandev.fe_iface.clock_ctrl == NULL){
							card_ptr->devname);
	card_list=__sdla_get_ptr_isr_array(card_ptr->hw);
		if (card == NULL || wan_test_bit(CARD_DOWN,&card->wandev.critical)) {
		DEBUG_TEST("%s: Device Type TE=%i NT=%i!\n",card->devname,
			if (aft_is_bri_te_card(card) && wan_test_bit(CARD_MASTER_CLOCK,&card->wandev.critical)) {		
				if (card->wandev.state != WAN_CONNECTED) {
					if (card->wandev.fe_iface.clock_ctrl){
							card->devname);
						card->wandev.fe_iface.clock_ctrl(&card->fe, 0);
							card->devname);
					wan_clear_bit(CARD_MASTER_CLOCK,&card->wandev.critical);
							card->devname);
		if (card == NULL || wan_test_bit(CARD_DOWN,&card->wandev.critical)) {
			if (aft_is_bri_te_card(card) && !wan_test_bit(CARD_MASTER_CLOCK,&card->wandev.critical)) {	
				if (card->wandev.state == WAN_CONNECTED) {
					if (card->wandev.fe_iface.clock_ctrl){
							card->devname);
						card->wandev.fe_iface.clock_ctrl(&card->fe, 1);
						wan_set_bit(CARD_MASTER_CLOCK,&card->wandev.critical);
	WAN_NETIF_WAKE_QUEUE(chan->common.dev);
	if (chan->common.usedby == API){
	} else if (chan->common.usedby == STACK){
	} else if (chan->common.usedby == TDM_VOICE_DCHAN){
		if (is_tdm_api(chan,&chan->wp_tdm_api_dev)){
			wanpipe_tdm_api_kick(&chan->wp_tdm_api_dev);
	} else if (chan->common.usedby == ANNEXG) {
		if (chan->annexg_dev){
				lapb_protocol.lapb_mark_bh(chan->annexg_dev);
        if (card->tdmv_conf.dchan) {
		if (IS_E1_CARD(card) && !(WAN_FE_FRAME(&card->fe) == WAN_FR_UNFRAMED)) {
			card->tdmv_conf.dchan = card->tdmv_conf.dchan << 1;
			wan_clear_bit(0,&card->tdmv_conf.dchan);
	for (i=card->u.aft.num_of_time_slots-1;i>=0;i--){
			if (wan_test_bit(i,&card->tdmv_conf.dchan)){
				card->u.aft.tdmv_dchan=i;
	if (card->tdmv_conf.dchan && !dchan_found){
	       	for (i=card->u.aft.num_of_time_slots-1;i>=0;i--){
                       	if (wan_test_bit(i,&card->tdmv_conf.dchan)){
	       			card->u.aft.tdmv_dchan=i;
	       			wan_set_bit(i,&card->u.aft.tdmv_dchan_cfg_on_master);
	       			card->devname,card->tdmv_conf.dchan);
	       		return -EINVAL;       
	card->hw_iface.bus_read_4(card->hw,
	card->hw_iface.bus_read_4(card->hw,
	card->hw_iface.bus_read_4(card->hw,
	card->hw_iface.bus_write_4(card->hw,
	card->u.aft.lcfg_reg=reg;
		card->hw_iface.bus_read_4(card->hw,
		card->hw_iface.bus_read_4(card->hw,
	card->hw_iface.bus_read_4(card->hw,
	card->hw_iface.bus_write_4(card->hw,
	card->u.aft.lcfg_reg=reg;
        for (i=0; i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.tdm_logic_ch_map)){
		chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
					card->devname,i);
		if (chan->channelized_cfg && !chan->hdlc_eng && chan->cfg.tdmv_master_if){
			u32 dma_descr=(chan->logic_ch_num<<4) + 
			card->hw_iface.bus_read_4(card->hw,dma_descr,&lo_reg); 
			if (card->wandev.ec_enable){
		        		card->u.aft.tdm_rx_dma_toggle = lo_reg-1; 
                         		card->u.aft.tdm_rx_dma_toggle = 3;
				card->u.aft.tdm_rx_dma_toggle=lo_reg+1;
				if (card->u.aft.tdm_rx_dma_toggle > 3) {
                        		card->u.aft.tdm_rx_dma_toggle=0; 	
		        	card->u.aft.tdm_tx_dma_toggle = lo_reg+1; 
                         	card->u.aft.tdm_tx_dma_toggle = 0;
			card->rsync_timeout=0;
					   card->devname,
					   card->u.aft.tdm_rx_dma_toggle,
					   card->u.aft.tdm_tx_dma_toggle);
	if (wan_test_and_set_bit(0,&chan->ss7_force_rx)){
		DEBUG_TEST("%s: FORCE BUSY RX\n",card->devname);
	dma_ram_desc=chan->logic_ch_num*4+AFT_PORT_REG(card,AFT_DMA_CHAIN_RAM_BASE_REG);
	card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
	card->hw_iface.bus_write_4(card->hw,dma_ram_desc,reg);
	DEBUG_TEST("%s: FORCE RX\n",card->devname);
	wan_clear_bit(0,&chan->ss7_force_rx);
	sdla_t *card=chan->card;
	dma_ram_desc=chan->logic_ch_num*4 + AFT_PORT_REG(card,AFT_DMA_CHAIN_RAM_BASE_REG);
	card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
			chan->if_name, 
			chan->tx_chain_indx,
			chan->tx_pending_chain_indx,
	if (chan->single_dma_chain){
		dma_chain = &chan->tx_dma_chain_table[i];
		dma_descr=(chan->logic_ch_num<<4) + 
			  (dma_chain->index*AFT_DMA_INDEX_OFFSET) + 
		card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
		dma_descr=(chan->logic_ch_num<<4) + 
			  (dma_chain->index*AFT_DMA_INDEX_OFFSET) + 
		card->hw_iface.bus_read_4(card->hw,dma_descr,&lo_reg);
				chan->if_name,
				dma_chain->index,
				dma_chain->init,
	for (i=0; i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
		chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
		if (!wan_test_bit(0,&chan->up)){
		dma_ram_desc=chan->logic_ch_num*4 + AFT_PORT_REG(card,AFT_DMA_CHAIN_RAM_BASE_REG);
		card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
				card->devname,i,reg);
	sdla_t *card=chan->card;
	dma_ram_desc=chan->logic_ch_num*4 + AFT_PORT_REG(card,AFT_DMA_CHAIN_RAM_BASE_REG);
	card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
			chan->if_name, 
			chan->rx_chain_indx,
			chan->rx_pending_chain_indx,
	if (chan->single_dma_chain){
		dma_chain = &chan->rx_dma_chain_table[i];
		dma_descr=(chan->logic_ch_num<<4) +(dma_chain->index*AFT_DMA_INDEX_OFFSET) + 
		card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
		dma_descr=(chan->logic_ch_num<<4) +(dma_chain->index*AFT_DMA_INDEX_OFFSET) + 
		card->hw_iface.bus_read_4(card->hw,dma_descr,&lo_reg);     
				chan->if_name,
				dma_chain->index,
				dma_chain->init,dma_descr,reg,lo_reg,(lo_reg&0x1FF)/128);
	int start=chan->dma_index;
	dma_history_t *dma_hist = &chan->dma_history[start];
		if (dma_hist->loc == 0){
				chan->if_name,
				dma_hist->loc,
				dma_hist->end,
				dma_hist->cur,
				dma_hist->begin,
				dma_hist->status?"Error":"Ok");
		dma_hist = &chan->dma_history[start];
	dma_history_t *dma_hist = &chan->dma_history[chan->dma_index];
	dma_hist->loc=loc;
	dma_hist->end=end;
	dma_hist->cur=cur;
	dma_hist->begin=begin;
	dma_hist->status=0;
					chan->if_name,begin,cur,end);
			dma_hist->status=1;
					chan->if_name,begin,cur,end);
			dma_hist->status=1;
	if (++chan->dma_index >= MAX_DMA_HIST_SIZE){
		chan->dma_index=0;
	if (!card->u.aft.tdmv_api_rx){
		card->u.aft.tdmv_api_rx=wan_skb_alloc(card->u.aft.tdmv_mtu);
		if (!card->u.aft.tdmv_api_rx){
			WAN_NETIF_STATS_INC_RX_ERRORS(&chan->common);	//++chan->if_stats.rx_errors;
	if (wan_skb_len(card->u.aft.tdmv_api_rx) > (card->u.aft.tdmv_mtu-chan->mru)){
		WAN_NETIF_STATS_INC_RX_ERRORS(&chan->common);	//++chan->if_stats.rx_errors;
	buf=wan_skb_put(card->u.aft.tdmv_api_rx, chan->mru);
	memcpy(buf,rxdata,chan->mru);
	WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common);	//++chan->if_stats.rx_dropped;
	if (!card->u.aft.tdmv_api_tx){
		card->u.aft.tdmv_api_tx=wan_skb_dequeue(&card->u.aft.tdmv_api_tx_list);
		if (!card->u.aft.tdmv_api_tx){
			WAN_NETIF_STATS_INC_TX_CARRIER_ERRORS(&chan->common);	//++chan->if_stats.tx_carrier_errors;
			memset(txdata,chan->idle_flag,chan->mtu);
	if (wan_skb_len(card->u.aft.tdmv_api_tx) < chan->mtu){
		memset(txdata,chan->idle_flag,chan->mtu);
		WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);	//++chan->if_stats.tx_errors;
	buf=wan_skb_data(card->u.aft.tdmv_api_tx);
	memcpy(txdata,buf,chan->mtu);
	wan_skb_pull(card->u.aft.tdmv_api_tx,chan->mtu);
	WAN_NETIF_STATS_INC_TX_DROPPED(&chan->common);	//++chan->if_stats.tx_dropped;
	chan=(private_area_t*)wan_netif_priv(chan->common.dev);
	if (!card->u.aft.tdmv_api_rx){
	if (wan_skb_len(card->u.aft.tdmv_api_rx) != card->u.aft.tdmv_mtu){
		wan_skb_free(card->u.aft.tdmv_api_rx);
		card->u.aft.tdmv_api_rx=NULL;
	if (wan_skb_headroom(card->u.aft.tdmv_api_rx) >= sizeof(api_rx_hdr_t)){
			(api_rx_hdr_t*)skb_push(card->u.aft.tdmv_api_rx,
		wan_skb_free(card->u.aft.tdmv_api_rx);
		card->u.aft.tdmv_api_rx=NULL;
	card->u.aft.tdmv_api_rx->protocol = htons(PVC_PROT);
	card->u.aft.tdmv_api_rx->mac.raw  = card->u.aft.tdmv_api_rx->data;
	card->u.aft.tdmv_api_rx->dev      = chan->common.dev;
	card->u.aft.tdmv_api_rx->pkt_type = WAN_PACKET_DATA;	
	if (wan_api_rx(chan,card->u.aft.tdmv_api_rx) != 0){
		wan_skb_free(card->u.aft.tdmv_api_rx);
	card->u.aft.tdmv_api_rx=NULL;
	if (card->u.aft.tdmv_api_tx){
		if (wan_skb_len(card->u.aft.tdmv_api_tx) != 0){
		wan_skb_free(card->u.aft.tdmv_api_tx);
		card->u.aft.tdmv_api_tx=NULL;
		if (WAN_NETIF_QUEUE_STOPPED(chan->common.dev)){
			WAN_NETIF_WAKE_QUEUE(chan->common.dev);
./aft_core_utils.c
		dev->init = &wan_iface_eth_init;
		hdlc->attach 	= wan_iface_hdlc_attach;
		hdlc->xmit 	= wan_iface_send;
		err = -EINVAL;
		dev->init = NULL;
		*(dev->name) = 0;
		return -EINVAL;
		dev->init = &wan_iface_init;
		hdlc->attach 	= wan_iface_hdlc_attach;
		hdlc->xmit 	= wan_iface_send;
		err = -EINVAL;
		dev->init = NULL;
		*(dev->name) = 0;
		return -EINVAL;
		if (dev->priv){
			dev->priv=NULL;
//	dev->priv = NULL;	/* We need 'priv', hdlc doesn't */
	dev->get_stats		= &wan_iface_get_stats;
	dev->do_ioctl		= &wan_iface_ioctl;
	dev->open		= &wan_iface_open;
	dev->stop		= &wan_iface_close;
	dev->hard_start_xmit	= &wan_iface_send;
	dev->get_stats		= &wan_iface_get_stats;
	dev->tx_timeout		= &wan_iface_tx_timeout;
	dev->change_mtu		= &wan_iface_change_mtu;
	dev->watchdog_timeo	= HZ*2;
	dev->hard_header_len	= 32;
	dev->set_config		= NULL;
	/* Initialize media-specific parameters */
	dev->flags		|= IFF_POINTOPOINT;
	dev->flags		|= IFF_NOARP;
	if (!dev->mtu) {
		dev->mtu		= 1500;
	dev->tx_queue_len	= 100;
	dev->type		= ARPHRD_PPP;
	dev->addr_len		= 0;
	*(u8*)dev->dev_addr	= 0; 
	dev->trans_start	= SYSTEM_TICKS;
			dev->name,
			dev->priv);
//	dev->priv = NULL;	/* We need 'priv', hdlc doesn't */
	dev->get_stats		= &wan_iface_get_stats;
	dev->do_ioctl		= &wan_iface_ioctl;
	dev->open		= &wan_iface_open;
	dev->stop		= &wan_iface_close;
	dev->hard_start_xmit	= &wan_iface_send;
	dev->get_stats		= &wan_iface_get_stats;
	dev->tx_timeout		= &wan_iface_tx_timeout;
	dev->watchdog_timeo	= HZ*2;
	dev->hard_header_len	= 32;
	dev->set_config		= NULL;
	if (!dev->mtu) {
		dev->mtu		= 1500;
	dev->tx_queue_len	= 100;
	dev->trans_start	= SYSTEM_TICKS;
	memcpy(dev->dev_addr, "\xFE\xFC\x00\x00\x00\x00", 6);
	*(int *)(dev->dev_addr + 2) += hw_addr;
	dev->hard_header_len 	= 32;
	dev->tx_queue_len	= 100;
			dev->name,
			dev->priv);
	 * from hdlc_open function call (Linux-2.6 overwrite private pointer. */
	DEBUG_TEST("%s: OPEN \n",dev->name);
	if (common->iface.open){
		err = common->iface.open(dev);
	return -EINVAL;
	if (common->iface.close){
		err = common->iface.close(dev);
	return -EINVAL;
	if (common->iface.send){
		return common->iface.send(skb, dev);
	int 			err = -EOPNOTSUPP;
		if (common->iface.ioctl){
			err = common->iface.ioctl(dev, ifr, cmd);
		err = -EINVAL;
/* Get ethernet-style interface statistics.
	if (common && common->iface.get_stats){
		return common->iface.get_stats(dev);
	 * kick start the device by making dev->tbusy = 0.  We expect
	if (common->iface.tx_timeout){
		common->iface.tx_timeout(dev);
	 * kick start the device by making dev->tbusy = 0.  We expect
	if (common->iface.change_mtu){
		return common->iface.change_mtu(dev,new_mtu);
	if (!common->is_netdev){
		skb->protocol = htons(ETH_P_HDLC);
		skb->dev = dev;
		return -EINVAL;
	ifsettings = (struct if_settings*)ifr->ifr_data;
	switch (ifsettings->type) {	
		common->protocol = 
			(ifsettings->type == IF_PROTO_PPP) ? WANCONFIG_PPP :
			(ifsettings->type == IF_PROTO_CISCO) ? WANCONFIG_CHDLC :
		if (common->protocol == WANCONFIG_PPP){
			((wanpipe_common_t*)dev->priv)->prot_ptr = 
					(netdevice_t*)&hdlc->state.ppp.pppdev;
			hdlc->state.ppp.syncppp_ptr = (struct ppp_device*)
					((wanpipe_common_t*)dev->priv)->prot_ptr;
		err = -EINVAL;
	err = -EINVAL;
./wanpipe_linux_iface.c
 * 	Contact: Sangoma Technologies Inc. 905-474-1990, info@sangoma.com
		fe->write_cpld(fe->card, (reg), (val))
		fe->write_fe_cpld(fe->card, (reg), (val))
	fe->write_fe_reg(						\
		((sdla_t*)fe->card)->hw,(int)(reg),(int)(val));
	fe->read_fe_reg(						\
		((sdla_t*)fe->card)->hw,(int)(reg));
	sdla_t *card=fe->card;
	DEBUG_TEST("%s: NENAD %s LOOP\n",fe->name,
	if (card->adptr_subtype == AFT_SUBTYPE_NORMAL){
	}else if (card->adptr_subtype == AFT_SUBTYPE_SHARK){
	return fe->fe_cfg.media;
* Description	: Get current FE line state - is it Connected or Disconnected
* Arguments	: fe - pointer to Front End structure.	
*		  status - pointer to location where the FE line state will
*		  notused - ignored 
	*status = fe->fe_status;
	if (IS_DS3(&fe->fe_cfg)){
		if (IS_DS3_ALARM(fe->fe_alarm)){
			if (fe->fe_status != FE_DISCONNECTED){
						fe->name);
				fe->fe_status = FE_DISCONNECTED;
			if (fe->fe_status != FE_CONNECTED){
						fe->name);
				fe->fe_status = FE_CONNECTED;
	}else if (IS_E3(&fe->fe_cfg)){
		if (IS_E3_ALARM(fe->fe_alarm)){
			if (fe->fe_status != FE_DISCONNECTED){
				fe->fe_param.te3.e3_connect_delay=0;
				if (fe->fe_param.te3.e3_lb_ctrl == 1) {
					fe->fe_param.te3.e3_lb_ctrl = 2;
					fe->fe_param.te3.e3_lb_ctrl=0;
						fe->name,fe->fe_param.te3.e3_lb_ctrl);
				fe->fe_status = FE_DISCONNECTED;
			if (fe->fe_status != FE_CONNECTED){
				fe->fe_param.te3.e3_connect_delay++;
				if (fe->fe_param.te3.e3_connect_delay >= 5) {
					fe->fe_param.te3.e3_connect_delay=0;
					if (fe->fe_param.te3.e3_lb_ctrl == 0) {
						fe->fe_param.te3.e3_lb_ctrl=1;
							fe->name,fe->fe_param.te3.e3_lb_ctrl);
					fe->fe_status = FE_CONNECTED;
		return -EINVAL;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
				fe->name);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
						fe->name);
						fe->name);
			fe->fe_alarm |= WAN_TE3_BIT_LOS_ALARM;
						fe->name);
			fe->fe_alarm &= ~WAN_TE3_BIT_LOS_ALARM;
				fe->name,
				fe->name,
						fe->name);
			fe->fe_alarm |= WAN_TE3_BIT_OOF_ALARM;
						fe->name);
			fe->fe_alarm &= ~WAN_TE3_BIT_OOF_ALARM;
					fe->name);
			fe->fe_alarm |= WAN_TE3_BIT_YEL_ALARM;
					fe->name);
			fe->fe_alarm &= ~WAN_TE3_BIT_YEL_ALARM;
		DEBUG_TE3("%s: AIC bit-field status %s!\n",
				fe->name,
		DEBUG_TE3("%s: P-Bit error interrupt!\n",
					fe->name);
				fe->name);
				fe->name);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
			fe->name, __FUNCTION__);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
						fe->name);
			fe->fe_alarm |= WAN_TE3_BIT_OOF_ALARM;
						fe->name);
			fe->fe_alarm &= ~WAN_TE3_BIT_OOF_ALARM;
						fe->name);
			fe->fe_alarm |= WAN_TE3_BIT_LOF_ALARM;
						fe->name);
			fe->fe_alarm &= ~WAN_TE3_BIT_LOF_ALARM;
						fe->name);
			fe->fe_alarm |= WAN_TE3_BIT_LOS_ALARM;
						fe->name);
			fe->fe_alarm &= ~WAN_TE3_BIT_LOS_ALARM;
						fe->name);
			fe->fe_alarm |= WAN_TE3_BIT_AIS_ALARM;
						fe->name);
			fe->fe_alarm &= ~WAN_TE3_BIT_AIS_ALARM;
					fe->name);
			fe->fe_alarm |= WAN_TE3_BIT_YEL_ALARM;
					fe->name);
			fe->fe_alarm &= ~WAN_TE3_BIT_YEL_ALARM;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	return -EINVAL;
	sdla_fe_cfg_t	*fe_cfg = &fe->fe_cfg;
	switch(fe_cfg->media){
	sdla_fe_cfg_t	*fe_cfg = &fe->fe_cfg;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	if (fe_cfg->media == WAN_MEDIA_DS3){
			fe->name,
				fe->name,
		DEBUG_EVENT("%s:    AIS Alarm is ON\n", fe->name);
		DEBUG_EVENT("%s:    LOS Alarm is ON\n", fe->name);
		DEBUG_EVENT("%s:    OOF Alarm is ON\n", fe->name);
		DEBUG_EVENT("%s:    YEL Alarm is ON\n", fe->name);
		DEBUG_EVENT("%s:    LOF Alarm OFF!\n", fe->name);
		fe->fe_alarm = alarms;
			fe->name, __FUNCTION__);
	return -EINVAL;
	sdla_te3_pmon_t	*pmon = (sdla_te3_pmon_t*)&fe->fe_stats.u.te3_pmon;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	pmon->pmon_lcv += ((value_msb << 8) | value_lsb);
	pmon->pmon_framing += ((value_msb << 8) | value_lsb); 
	pmon->pmon_parity += ((value_msb << 8) | value_lsb); 
	pmon->pmon_febe += ((value_msb << 8) | value_lsb); 
	pmon->pmon_cpbit += ((value_msb << 8) | value_lsb); 
	sdla_te3_pmon_t	*pmon = (sdla_te3_pmon_t*)&fe->fe_stats.u.te3_pmon;
	pmon->pmon_lcv		= 0;
	pmon->pmon_framing	= 0; 
	pmon->pmon_parity	= 0; 
	pmon->pmon_febe		= 0; 
	pmon->pmon_cpbit  	= 0; 
	WAN_ASSERT(fe->write_cpld == NULL);
			fe->name,
		fe->te3_param.cpld_status &= ~BIT_CPLD_STATUS_LLB;
		fe->te3_param.cpld_status &= ~BIT_CPLD_STATUS_RLB;
			fe->te3_param.cpld_status |= BIT_CPLD_STATUS_LLB;
			fe->te3_param.cpld_status &= ~BIT_CPLD_STATUS_RLB;
			fe->te3_param.cpld_status &= ~BIT_CPLD_STATUS_LLB;
			fe->te3_param.cpld_status |= BIT_CPLD_STATUS_RLB;
			fe->te3_param.cpld_status |= BIT_CPLD_STATUS_LLB;
			fe->te3_param.cpld_status |= BIT_CPLD_STATUS_RLB;
					fe->name);
	WRITE_CPLD(REG_CPLD_STATUS, fe->te3_param.cpld_status);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
			fe->name,
					fe->name);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	if ((fe->te3_param.cpld_status & BIT_CPLD_STATUS_LLB) && 
	    (fe->te3_param.cpld_status & BIT_CPLD_STATUS_RLB)){
	}else if (fe->te3_param.cpld_status & BIT_CPLD_STATUS_LLB){
	}else if (fe->te3_param.cpld_status & BIT_CPLD_STATUS_RLB){
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	sdla_t			*card = (sdla_t*)fe->card;
	if (lb->cmd == WAN_FE_LBMODE_CMD_SET){
		if (card->adptr_subtype == AFT_SUBTYPE_NORMAL){
			err = sdla_te3_old_set_lb_modes(fe, lb->type, lb->mode); 
		}else if (card->adptr_subtype == AFT_SUBTYPE_SHARK){
			err = sdla_te3_set_lb_modes(fe, lb->type, lb->mode); 
	}else if (lb->cmd == WAN_FE_LBMODE_CMD_SET){
		if (card->adptr_subtype == AFT_SUBTYPE_NORMAL){
			lb->type_map = sdla_te3_old_get_lb(fe);
		}else if (card->adptr_subtype == AFT_SUBTYPE_SHARK){
			lb->type_map= sdla_te3_get_lb(fe);
		return -EINVAL;
	switch(udp_cmd->wan_cmd_command){
		fe_media->media	= fe->fe_cfg.media;
		udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
		udp_cmd->wan_cmd_data_len = sizeof(wan_femedia_t); 
		    	udp_cmd->wan_cmd_return_code	= WAN_UDP_FAILED_CMD;
	    		udp_cmd->wan_cmd_data_len	= 0x00;
	    	udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
	    	udp_cmd->wan_cmd_data_len = sizeof(sdla_fe_lbmode_t);
		if (udp_cmd->wan_cmd_fe_force){
			DEBUG_EVENT("%s: Force to read Front-End alarms\n",
						fe->name);
			fe->fe_stats.alarms = 
	        memcpy(&data[0], &fe->fe_stats, sizeof(sdla_fe_stats_t));
	        udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
	    	udp_cmd->wan_cmd_data_len = sizeof(sdla_fe_stats_t); 
	        udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
	    		&fe->fe_cfg,
	    	udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
    	    	udp_cmd->wan_cmd_data_len = sizeof(sdla_te_cfg_t);
		switch(fe_debug->type){
			if (fe_debug->fe_debug_reg.read){
				fe_debug->fe_debug_reg.value = 
						READ_REG(fe_debug->fe_debug_reg.reg);
				WRITE_REG(fe_debug->fe_debug_reg.reg, fe_debug->fe_debug_reg.value);
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
    	    	udp_cmd->wan_cmd_data_len = 0;
		udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
	    	udp_cmd->wan_cmd_data_len = 0;
	sdla_fe_cfg_t	*fe_cfg = &fe->fe_cfg;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
					fe->name, FE_MEDIA_DECODE(fe), IS_DS3(fe_cfg));
		return -EINVAL;
 * Returns:	WAN_TRUE - TE3 configred successfully, otherwise WAN_FALSE.
	sdla_fe_cfg_t	*fe_cfg = &fe->fe_cfg;
	WAN_ASSERT(fe->write_cpld == NULL);
	if (fe_cfg->media == WAN_MEDIA_E3){
	if (liu->rx_equal == WAN_TRUE){
	if (liu->tx_lbo == WAN_TRUE){
		DEBUG_TE3("%s: (T3/E2) Enable Transmit Build-out\n",
		DEBUG_TE3("%s: (T3/E3) Disable Transmit Build-out\n",
	if (liu->taos == WAN_TRUE){
 * Returns:	WAN_TRUE - TE3 configred successfully, otherwise WAN_FALSE.
	sdla_fe_cfg_t	*fe_cfg = &fe->fe_cfg;
	WAN_ASSERT(fe->write_fe_cpld == NULL);
	fe->te3_param.cpld_cntrl = 0x00;
	if (fe_cfg->media == WAN_MEDIA_E3){
		fe->te3_param.cpld_cntrl |= BIT_EXAR_CPLD_CNTRL_E3;
	WRITE_EXAR_CPLD(REG_EXAR_CPLD_CNTRL, fe->te3_param.cpld_cntrl);
	if (liu->rx_equal == WAN_TRUE){
	if (liu->tx_lbo == WAN_TRUE){
		DEBUG_TE3("%s: (T3/E2) Enable Transmit Build-out\n",
		DEBUG_TE3("%s: (T3/E3) Disable Transmit Build-out\n",
	if (liu->taos == WAN_TRUE){
	/* Inialize Front-End interface functions */
	fe_iface->config		= &sdla_te3_config;
	fe_iface->unconfig		= &sdla_te3_unconfig;
	fe_iface->post_init		= &sdla_te3_post_init;
	fe_iface->pre_release		= &sdla_te3_pre_release;
	fe_iface->polling		= &sdla_te3_polling;
	fe_iface->isr			= &sdla_te3_isr;
	fe_iface->process_udp		= &sdla_te3_udp;
	fe_iface->read_alarm		= &sdla_te3_read_alarms;
	fe_iface->read_pmon		= &sdla_te3_read_pmon;
	fe_iface->flush_pmon		= &sdla_te3_flush_pmon;
	fe_iface->set_fe_alarm		= &sdla_te3_set_alarm;
	fe_iface->get_fe_status		= &sdla_te3_get_fe_status;
	fe_iface->get_fe_media		= &sdla_te3_get_fe_media;
	fe_iface->get_fe_media_string	= &sdla_te3_get_fe_media_string;
	fe_iface->update_alarm_info	= &sdla_te3_update_alarm_info;
	fe_iface->update_pmon_info	= &sdla_te3_update_pmon_info;
	sdla_t*		card = (sdla_t*)fe->card;
	sdla_fe_cfg_t	*fe_cfg = &fe->fe_cfg;
	sdla_te3_cfg_t	*te3_cfg = &fe_cfg->cfg.te3_cfg;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERSUBTYPE, &adptr_subtype);
	if (card->adptr_subtype == AFT_SUBTYPE_NORMAL){
		sdla_te3_liu_config(fe, &te3_cfg->liu_cfg, fe->name);
	}else if (card->adptr_subtype == AFT_SUBTYPE_SHARK){
		sdla_te3_shark_liu_config(fe, &te3_cfg->liu_cfg, fe->name);	
				fe->name, card->adptr_subtype);
		return -EINVAL;
	switch(fe_cfg->media){
				fe->name);
				fe->name);
				fe->name,fe_cfg->media);
		return -EINVAL;
		if (fe_cfg->media != WAN_MEDIA_E3){
					fe->name);
			return -EINVAL;
				fe->name);
		if (fe_cfg->media != WAN_MEDIA_E3){
					fe->name);
			return -EINVAL;
				fe->name);
		if (fe_cfg->media != WAN_MEDIA_DS3){
					fe->name);
			return -EINVAL;
		DEBUG_TE3("%s: (T3/E3) Frame type C-bit Parity\n",
				fe->name);
		if (fe_cfg->media != WAN_MEDIA_DS3){
					fe->name);
			return -EINVAL;
				fe->name);
				fe->name,fe_cfg->frame);
		return -EINVAL;
				fe->name);
				fe->name);
				fe->name);
				fe->name,fe_cfg->lcode);
		return -EINVAL;
	if (IS_E3(&fe->fe_cfg)){
	fe->fe_param.te3.e3_lb_ctrl=0;
	fe->fe_param.te3.e3_connect_delay=10;
	/* Initialize Front-End parameters */
	fe->fe_status	= FE_DISCONNECTED;
					fe->name, FE_MEDIA_DECODE(fe));
	if (wan_test_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical) ||
	    wan_test_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical)) {
	err = wan_add_timer(&fe->timer, delay);
	err = wan_add_timer(&fe->timer, delay * HZ / 1000);
		return -EINVAL;
	wan_set_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical);
	sdla_t 		*card = (sdla_t*)fe->card;
	wan_device_t	*wandev = &card->wandev;
	DEBUG_TEST("[TE3] %s: TE3 timer!\n", fe->name);
	if (wan_test_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical)){
		wan_clear_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical);
	if (!wan_test_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical)){
					fe->name);
	wan_clear_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical);
	if (wandev->fe_enable_timer){
		wandev->fe_enable_timer(fe->card);
	wan_set_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical);
		&fe->timer, 
	wan_clear_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical);
	if (IS_E3(&fe->fe_cfg)){
	wan_set_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical);
	if (wan_test_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical)){
		wan_del_timer(&fe->timer);
	wan_clear_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical);
			fe->name);
	if (IS_DS3(&fe->fe_cfg)){
			"AIS", WAN_TE3_AIS_ALARM(fe->fe_alarm), 
			"LOS", WAN_TE3_LOS_ALARM(fe->fe_alarm));
			"OOF", WAN_TE3_OOF_ALARM(fe->fe_alarm), 
			"YEL", WAN_TE3_YEL_ALARM(fe->fe_alarm));
			"AIS", WAN_TE3_AIS_ALARM(fe->fe_alarm), 
			"LOS", WAN_TE3_LOS_ALARM(fe->fe_alarm));
			"OFF", WAN_TE3_OOF_ALARM(fe->fe_alarm), 
			"YEL", WAN_TE3_YEL_ALARM(fe->fe_alarm));
			"LOF", WAN_TE3_LOF_ALARM(fe->fe_alarm), 
	return m->count;
		 (IS_DS3(&fe->fe_cfg)) ? "DS3" : "E3");
		"Line Code Violation", fe->fe_stats.u.te3_pmon.pmon_lcv,
		"Framing Bit/Byte Error", fe->fe_stats.u.te3_pmon.pmon_framing);
	if (IS_DS3(&fe->fe_cfg)){
				"Parity Error", fe->fe_stats.u.te3_pmon.pmon_parity,
				"CP-Bit Error Event", fe->fe_stats.u.te3_pmon.pmon_cpbit);
				"Parity Error", fe->fe_stats.u.te3_pmon.pmon_parity,
				"FEBE Event", fe->fe_stats.u.te3_pmon.pmon_febe);
			"Parity Error", fe->fe_stats.u.te3_pmon.pmon_parity,
			"FEBE Event", fe->fe_stats.u.te3_pmon.pmon_febe);
	return m->count;
./sdla_te3.c
* July 5, 2007	David Rokhvarg	Added support of A500 - ISDN BRI card.
 * ------
# warning "WAN_DEBUG_FE - Debugging Enabled"
# warning "WAN_DEBUG_REG - Debugging Enabled"
			hw->devname, off,value);
			hw->devname, off, value);
**	Front End T1/E1 interface for S-Series cards
					hw->devname, cmd);
					hw->devname, cmd, err);
	char		*data = mb->wan_data;
	((sdla_legacy_fe_t*)data)->register_number = (unsigned short)reg;
	mb->wan_data_len = sizeof(sdla_legacy_fe_t);
       mb->wan_command = 0x90;
	return(((sdla_legacy_fe_t*)data)->register_value);
	char		*data = mb->wan_data;
		((sdla_legacy_fe_t*)data)->register_number = (unsigned short)reg;
		((sdla_legacy_fe_t*)data)->register_value = (unsigned char)value;
		mb->wan_data_len = sizeof(sdla_legacy_fe_t);
		mb->wan_command = 0x91;
	}while(err && --retry);
//	u8	qaccess = card->wandev.state == WAN_CONNECTED ? 1 : 0;
//	u8	qaccess = card->wandev.state == WAN_CONNECTED ? 1 : 0;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (hwcard->core_id == AFT_PMC_FE_CORE_ID){
	}else if (hwcard->core_id == AFT_DS_FE_CORE_ID){
		if ((hwcard->adptr_type == A101_ADPTR_2TE1 || 
		     hwcard->adptr_type == A101_ADPTR_1TE1) && line_no == 1){
	WAN_ASSERT(hw->magic != SDLADRV_MAGIC);
			"%s: %s:%d: Critical Error: Re-entry in FE!\n",
					hw->devname,
		return -EINVAL;
					hw->devname, line_no, off, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (hwcard->core_id == AFT_PMC_FE_CORE_ID){
	}else if (hwcard->core_id == AFT_DS_FE_CORE_ID){
		if ((hwcard->adptr_type == A101_ADPTR_1TE1 || 
		     hwcard->adptr_type == A101_ADPTR_2TE1) && line_no == 1){
	WAN_ASSERT(hw->magic != SDLADRV_MAGIC);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			hw->devname, __FUNCTION__,__LINE__);
					hw->devname, line_no, off, tmp);
	WAN_ASSERT(hw->magic != SDLADRV_MAGIC);
			"%s: %s:%d: Critical Error: Re-entry in FE!\n",
					hw->devname,
		return -EINVAL;
	WAN_ASSERT(hw->magic != SDLADRV_MAGIC);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			hw->devname, __FUNCTION__,__LINE__);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
					hw->devname, mod_no, __FUNCTION__,__LINE__);
					hw->devname, mod_no, type);
					return -EINVAL;
		DEBUG_EVENT("%s: ERROR:SPI Iface not ready\n", hw->devname);
		return -EINVAL;
	WAN_ASSERT(hw->magic != SDLADRV_MAGIC);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			    hw->devname, __FUNCTION__,__LINE__);
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	    		hw->devname, mod_no, __FUNCTION__,__LINE__);
					hw->devname, mod_no, type);
		DEBUG_EVENT("%s: ERROR:SPI Iface not ready\n", hw->devname);
	WAN_ASSERT(hw->magic != SDLADRV_MAGIC);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			    hw->devname, __FUNCTION__,__LINE__);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	if (!wan_test_bit(mod_no, card->fe.fe_param.remora.module_map)){
			card->devname, __FUNCTION__,__LINE__,mod_no);
		return -EINVAL;
				/*FIXME: hw->devname,*/mod_no, reg, (u8)value);
	/* bit 0-7: data byte */
		/* bit 8-15: register number */
		/* bit 16-23: chip select byte */
		/* bit 24-31: ctrl byte */
		/* bit 8-15: register byte */
		/* bit 16-23: chip select byte */
		/* bit 24-31: ctrl byte */
				hw->devname, mod_no, type);
		return -EINVAL;
					hw->devname, mod_no,
		return -EINVAL;
	WAN_ASSERT(hw->magic != SDLADRV_MAGIC);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE (%s:%d)!\n",
			hw->devname, __FUNCTION__,__LINE__, fname, fline);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			hw->devname, __FUNCTION__,__LINE__);
		return -EINVAL;
			hw->devname, reg, value);
	__sdla_a700_analog_write_fe(hw, (mod_no-4), type, chain, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
				/*FIXME: hw->devname, */mod_no, reg);
	/* bit 0-7: data byte */
		/* bit 8-15: register byte */
		/* bit 16-23: chip select byte */
		/* bit 24-31: ctrl byte	*/
		/* bit 8-15: register byte */
		/* bit 16-23: chip select byte */
		/* bit 24-31: ctrl byte */
				hw->devname, mod_no, type);
		return -EINVAL;
					hw->devname, mod_no,
	WAN_ASSERT(hw->magic != SDLADRV_MAGIC);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE (%s:%d)!\n",
			hw->devname, __FUNCTION__,__LINE__,fname,fline);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			hw->devname, __FUNCTION__,__LINE__);
	data = __sdla_a700_analog_read_fe (hw, (mod_no-4), type, chain, reg);
	card = (sdla_t*)((sdla_fe_t*)fe)->card;
	card->hw_iface.bus_write_4(card->hw,
	card->hw_iface.bus_write_4(card->hw,
	card = (sdla_t*)((sdla_fe_t*)fe)->card;
	DEBUG_RM("%s: Resetting SPI\n", fe->name);
	card->hw_iface.bus_write_4(card->hw,
	card->hw_iface.bus_write_4(card->hw,
	card->hw_iface.bus_write_4(card->hw,
	card->hw_iface.bus_write_4(card->hw,
	card = (sdla_t*)((sdla_fe_t*)fe)->card;
	card->hw_iface.bus_write_4(card->hw,
	card->hw_iface.bus_write_4(card->hw,
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	if (!wan_test_bit(mod_no, card->fe.fe_param.remora.module_map)){
			card->devname, __FUNCTION__,__LINE__,mod_no);
		return -EINVAL;
				/*FIXME: hw->devname,*/mod_no, reg, (u8)value);
	/* bit 0-7: data byte */
		/* bit 8-15: register number */
		/* bit 16-23: chip select byte
		/* bit 24-31: ctrl byte
		if (hw->hwcpu->hwcard->core_rev > 3){
		/* bit 8-15: register byte */
		/* bit 16-23: chip select byte
		/* bit 24-31: ctrl byte
		if (hw->hwcpu->hwcard->core_rev > 3){
				hw->devname, mod_no, type);
		return -EINVAL;
	if (hw->hwcpu->hwcard->core_rev > 3){
	DEBUG_EVENT("%s: %s: Module %d - Execute SPI command %08X\n",
					card->fe.name,
					hw->devname, mod_no,
		return -EINVAL;
	WAN_ASSERT(hw->magic != SDLADRV_MAGIC);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE (%s:%d)!\n",
			hw->devname, __FUNCTION__,__LINE__, fname, fline);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			hw->devname, __FUNCTION__,__LINE__);
		return -EINVAL;
			hw->devname, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	if (!wan_test_bit(mod_no, card->fe.fe_param.remora.module_map)){
			card->devname, __FUNCTION__,__LINE__,mod_no);
				/*FIXME: hw->devname, */mod_no, reg);
	/* bit 0-7: data byte */
		/* bit 8-15: register byte */
		/* bit 16-23: chip select byte
		/* bit 24-31: ctrl byte
		if (hw->hwcpu->hwcard->core_rev > 3){
		/* bit 8-15: register byte */
		/* bit 16-23: chip select byte
		/* bit 24-31: ctrl byte
		if (hw->hwcpu->hwcard->core_rev > 3){
				hw->devname, mod_no, type);
		return -EINVAL;
	if (hw->hwcpu->hwcard->core_rev > 3){
	DEBUG_EVENT("%s: %s: Module %d - Execute SPI command %08X\n",
					hw->devname,
					hw->devname, mod_no,
	WAN_ASSERT(hw->magic != SDLADRV_MAGIC);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE (%s:%d)!\n",
			hw->devname, __FUNCTION__,__LINE__,fname,fline);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			hw->devname, __FUNCTION__,__LINE__);
	//		hw->devname, reg, data);
		hw->devname,
		Calculate rm_no - should be between 0 and 3 (including). 
	if(rm_no > MAX_BRI_REMORAS - 1){
			hw->devname, __FUNCTION__, __LINE__, rm_no, mod_no);	
		DEBUG_EVENT("%s:%s(): Line:%d: SPI TIMEOUT!!\n", hw->devname, __FUNCTION__, __LINE__);	
		DEBUG_EVENT("%s:%s(): Line:%d: SPI TIMEOUT!!\n", hw->devname, __FUNCTION__, __LINE__);	
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE (%s:%d)!\n",
			hw->devname, __FUNCTION__,__LINE__, fname, fline);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			hw->devname, __FUNCTION__,__LINE__);
		return -EINVAL;
	DEBUG_REG("%s():%s\n", __FUNCTION__, hw->devname);
		   Calculate rm_no - should be between 0 and 3 (including). */
	if(rm_no > MAX_BRI_REMORAS - 1){
			hw->devname, __FUNCTION__, __LINE__,	rm_no, mod_no);	
		DEBUG_EVENT("%s:%s(): Line:%d: SPI TIMEOUT!!\n", hw->devname, __FUNCTION__, __LINE__);	
		DEBUG_EVENT("%s:%s(): Line:%d: SPI TIMEOUT!!\n", hw->devname, __FUNCTION__, __LINE__);	
		DEBUG_EVENT("%s:%s(): Line:%d: SPI TIMEOUT!!\n", hw->devname, __FUNCTION__, __LINE__);	
		DEBUG_EVENT("%s:%s(): Line:%d: SPI TIMEOUT!!\n", hw->devname, __FUNCTION__, __LINE__);	
		hw->devname,
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE (%s:%d)!\n",
			hw->devname, __FUNCTION__,__LINE__,fname,fline);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			hw->devname, __FUNCTION__,__LINE__);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
			"%s: %s:%d: Critical Error: Re-entry in FE!\n",
					hw->devname,
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			hw->devname, __FUNCTION__,__LINE__);
./sdladrv_fe.c
** wpabs_skb_data() - 
** wpabs_skb_tail() - 
** wpabs_skb_len() - 
** wpabs_skb_len() - 
** wpabs_skb_alloc() - 
** wpabs_skb_free() - 
** wpabs_skb_copyback() - 
** wpabs_skb_pull() - 
** wpabs_skb_push() - 
** wpabs_skb_reserve() - 
** wpabs_skb_put() - 
** wpabs_skb_trim() - Trim from tail
** wpabs_skb_clone() - Clone SKB Buffer
** wpabs_skb_copy() - Copy Skb buffer
** wpabs_skb_tailroom() - Skb tail room
** wpabs_skb_queue_len() - Length of skb queue
** wpabs_skb_queue_tail() - Length of skb queue
** wpabs_skb_init() - Init data pointer
** wpabs_add_timer() - Set timer
	timer->MiniportTimerFunction = (wan_timer_func_t)timer_func;
	timer->MiniportAdapterHandle = (void*)data;
	timer->MiniportTimerContext  = (void*)data;
	return ((wan_dma_descr_t*)dma_descr)->vAddr;
	return ((wan_dma_descr_t*)dma_descr)->physicalAddr.u.LowPart;
	card->hw_iface.peek(card->hw, offset, (void*)&data, 1);
	card->hw_iface.peek(card->hw, offset, (void*)&data, 4);
	card->hw_iface.poke_byte(card->hw, offset, data);
	card->hw_iface.poke(card->hw, offset, (void*)&data, 4);
	wan_read_rw_lock(&rwlock->rwlock);
	wan_read_rw_unlock(&rwlock->rwlock);
	wan_write_rw_lock_irq(&rwlock->rwlock,flags);
	wan_write_rw_unlock_irq(&rwlock->rwlock,flags);
	task->running = 0;
 *-F*************************************************************************/
	if (ifa == NULL || ifa->ifa_addr == NULL){
	if ((ifaddr = in_dev->ifa_list)== NULL ){
		addr = (struct sockaddr_in *)ifa->ifa_addr;
		return addr->sin_addr.s_addr;
		addr = (struct sockaddr_in *)ifa->ifa_addr;
		return htonl(addr->sin_addr.s_addr);
		return ifaddr->ifa_local;
		addr = (struct sockaddr_in *)ifa->ifa_dstaddr;
		return addr->sin_addr.s_addr;
		return ifaddr->ifa_address;
		return ifaddr->ifa_mask;
		return ifaddr->ifa_broadcast;
 *-F*************************************************************************/
 *-F*************************************************************************/
	((wan_trace_t*)trace_ptr)->last_trace_direction = direction;
	return ((wan_trace_t*)trace_ptr)->last_trace_direction;
./wanpipe_abstr.c
*		This module is a library of common hardware-specific functions
* Copyright:	(c) 1995-2003 Sangoma Technologies Inc.
*				Support FreeBSD-7
* Jul 06, 2007	David Rokhvarg	Added detection of A500 - ISDN BRI modules.
 * ------
 * 1. This code is ment to be system-independent (as much as possible).  To
 *    achive this, various macros are used to hide system-specific interfaces.
 *	--------	------
 *	bit to '0' causes low-to-high transition on IRQ line (ghosty
 *	CPU control register (BASE+3) - see the next note.
#define	SDLA_IODELAY	100	/* I/O Rd/Wr delay, 10 works for 486DX2-66 */
#define IS_SUPPORTED_ADAPTER(hw) (hw->type==SDLA_S508 || hw->type==SDLA_S514 || hw->type==SDLA_ADSL)
#define IS_S514(hw)	(hw->type == SDLA_S514)
#define IS_S518(hw)	(hw->type == SDLA_ADSL)
#define IS_S508(hw)	(hw->type == SDLA_S508)
/* Entry Point for Low-Level function */
/* Hardware-specific functions */
	0x10, 0x12, 0x14, 0x16, 0x18, 0x1A, 0x1C,	/* A0000 - AC000 */
	0x20, 0x22, 0x24, 0x26, 0x28, 0x2A, 0x2C,	/* C0000 - CC000 */
	0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,	/* D0000 - DC000 */
	0x30, 0x32, 0x34, 0x36, 0x38, 0x3A, 0x3C,	/* E0000 - EC000 */
	0x10, 0x12, 0x14, 0x16, 0x18, 0x1A, 0x1C, 0x1E,	/* A0000 - AE000 */
	0x20, 0x22, 0x24, 0x26, 0x28, 0x2A, 0x2C, 0x2E,	/* C0000 - CE000 */
	0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E,	/* D0000 - DE000 */
	0x30, 0x32, 0x34, 0x36, 0x38, 0x3A, 0x3C, 0x3E,	/* E0000 - EE000 */
	0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E,	/* A0000 - AE000 */
	0x40, 0x42, 0x44, 0x46, 0x48, 0x4A, 0x4C, 0x4E,	/* B0000 - BE000 */
	0x80, 0x82, 0x84, 0x86, 0x88, 0x8A, 0x8C, 0x8E,	/* C0000 - CE000 */
	0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE,	/* E0000 - EE000 */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,	/* A0000 - AE000 */
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,	/* C0000 - CE000 */
	0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,	/* D0000 - DE000 */
	0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,	/* E0000 - EE000 */
		return -ENOMEM;
	sdla_mem_el->len=len;
	sdla_mem_el->line=line;
	sdla_mem_el->mem=mem;
	strncpy(sdla_mem_el->cmd_func,func_name,sizeof(sdla_mem_el->cmd_func)-1);
	wan_debug_mem+=sdla_mem_el->len;
			sdla_mem_el->cmd_func,sdla_mem_el->line,
			 sdla_mem_el->mem, sdla_mem_el->len,wan_debug_mem);
	int err=-1;
		if (sdla_mem_el->mem == mem) {
		wan_debug_mem-=sdla_mem_el->len;
			sdla_mem_el->mem, sdla_mem_el->len, wan_debug_mem,
			sdla_mem_el->cmd_func,sdla_mem_el->line);
			sdla_mem_el->cmd_func,sdla_mem_el->line,
			sdla_mem_el->mem, sdla_mem_el->len);
		total+=sdla_mem_el->len;
			 wan_debug_mem,total,wan_debug_mem-total);
		if (sdla_hwdev_common_unregister(tmp) == -EBUSY){
			return -EBUSY;
		if (sdla_hwcpu_unregister(tmp) == -EBUSY){
			return -EBUSY;
		if (sdla_card_unregister(tmp) == -EBUSY){
			return -EBUSY;
		if (tmp->internal_used){
					tmp->hw_info);
			return -EBUSY;
	"%-10s : IOPORT=0x%X : PORT=%s"
	"%-10s : SLOT=%d : BUS=%d : IRQ=%d : CPU=%c : PORT=%s"
	"%-10s : SLOT=%d : BUS=%d : IRQ=%d : CPU=%c : PORT=%d : V=%02X"
	"%-10s : SLOT=%d : BUS=%d : IRQ=%d : CPU=%c : PORT=%s : V=%02X"
	"%-10s : SLOT=%d : BUS=%d : IRQ=%d : CPU=%c : PORT=%d : HWEC=%d : V=%02X"
        "%-10s : SLOT=%d : BUS=%d : IRQ=%d : CPU=%c : PORT=%s : HWEC=%d : V=%02X"
	"%-10s : SLOT=%d : BUS=%d : IRQ=%d : PORT=%d : HWEC=%d : V=%02X"
	"%-10s : BUSID=%s : V=%02X"
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
		return -EINVAL;
	memset(hwprobe->hw_info, '\0', 100);
	memset(hwprobe->hw_info_verbose, '\0', 500);
	memset(hwprobe->hw_info_dump, 0, sizeof(hwprobe->hw_info_dump));
	hwcpu = hw->hwcpu;
	if (IS_HWCARD_PCI(hwcpu->hwcard)){
		switch(hwcpu->hwcard->adptr_type){
			if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no+1,			/* line_no */
					hwcpu->hwcard->hwec_chan_no,
					hwcpu->hwcard->core_rev);
				/*sprintf(tmp_hw_probe->hw_info,*/
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no ? "SEC" : "PRI",
					hwcpu->hwcard->core_rev);
			if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no+1,			/* line_no */
					hwcpu->hwcard->hwec_chan_no,
					hwcpu->hwcard->core_rev);
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no+1,
					hwcpu->hwcard->core_rev
			/*sprintf(tmp_hw_probe->hw_info,*/
			SDLA_PROBE_SPRINT(hwprobe->hw_info,
				sizeof(hwprobe->hw_info),
				hwcpu->hwcard->adptr_name,
				hwcpu->hwcard->u_pci.slot_no, 
				hwcpu->hwcard->u_pci.bus_no, 
				hwcpu->irq,
				SDLA_GET_CPU(hwcpu->cpu_no),
				hw->line_no ? "SEC" : "PRI",
				hwcpu->hwcard->hwec_chan_no,
				hwcpu->hwcard->core_rev);
			if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no+1,
					hwcpu->hwcard->core_rev);		/* line_no */
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
			sprintf(&hwprobe->hw_info_dump[strlen(hwprobe->hw_info_dump)], "|BUS_IF=%s|C=%02d",
							AFT_PCITYPE_DECODE(hwcpu->hwcard),hwcpu->hwcard->cpld_rev);
			sprintf(hwprobe->hw_info_verbose, "\n+01:C%02d",
							hwcpu->hwcard->cpld_rev);
			if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no+1,
					hwcpu->hwcard->core_rev);		/* line_no */
				SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
			SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					hw->line_no+1,			/* Physical line number */
					hwcpu->hwcard->hwec_chan_no,
					hwcpu->hwcard->core_rev);
			snprintf(hwprobe->hw_info, 
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					hw->line_no+1,			/* Physical line number */
					hwcpu->hwcard->hwec_chan_no,
					hwcpu->hwcard->core_rev);
			SDLA_PROBE_SPRINT(hwprobe->hw_info,
					sizeof(hwprobe->hw_info),
					hwcpu->hwcard->adptr_name,
					hwcpu->hwcard->u_pci.slot_no, 
					hwcpu->hwcard->u_pci.bus_no, 
					hwcpu->irq, 
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hw->line_no+1,
					hwcpu->hwcard->core_rev);		/* line_no */
			/*sprintf(tmp_hw_probe->hw_info,*/
			SDLA_PROBE_SPRINT(hwprobe->hw_info,
				sizeof(hwprobe->hw_info),
				hwcpu->hwcard->adptr_name,
				hwcpu->hwcard->u_pci.slot_no, 
				hwcpu->hwcard->u_pci.bus_no, 
				hwcpu->irq, 
				SDLA_GET_CPU(hwcpu->cpu_no), 
	}else if (hwcpu->hwcard->hw_type == SDLA_USB_CARD){
		snprintf(hwprobe->hw_info, sizeof(hwprobe->hw_info),
				WP_USB_BUSID(hwcpu->hwcard), 
				hwcpu->hwcard->core_rev);
		/*sprintf(tmp_hw_probe->hw_info, */
		SDLA_PROBE_SPRINT(hwprobe->hw_info, sizeof(hwprobe->hw_info),
				"S508-ISA",
				hwcpu->hwcard->u_isa.ioport, 
	hw->hwport[hw->max_port_no++].hwprobe	= hwprobe;
	hwprobe->internal_used++;
	sprintf(hwcard->adptr_name, "%s%s%s",
			SDLA_ADPTR_NAME(hwcard->adptr_type),
			AFT_SUBTYPE(hwcard->adptr_subtype),
			AFT_SECURITY(hwcard->adptr_security));
		hw->adptr_type	= hwcpu->hwcard->adptr_type;
	hwcpu->lines_info[hw->adptr_type].total_line_no = max_line_no; 
		if (tmp_hw->hwcpu == hwcpu){
				return -EBUSY;
		if (hwcpu->hwcard->type == SDLA_S514){
		}else if (hwcpu->hwcard->type == SDLA_AFT){
			if (hwcpu->hwcard->cfg_type == WANOPT_AFT){
			}else if (hwcpu->hwcard->cfg_type == WANOPT_AFT101){
			}else if (hwcpu->hwcard->cfg_type == WANOPT_AFT102){
			}else if (hwcpu->hwcard->cfg_type == WANOPT_AFT104){
				if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
					if (hwcpu->hwcard->core_rev >= 0x28) {
			}else if (hwcpu->hwcard->cfg_type == WANOPT_AFT108){
		hw->adptr_type = hwcpu->hwcard->adptr_type;
		hw->max_chans_num	= 32;
		hw->chans_map		= 0xFFFFFFFF;
		sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|FE=%s|BUS_IF=%s|BRDG=%s",id_dump_str,AFT_PCITYPE_DECODE(hwcpu->hwcard),AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
		sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_verbose[0], "\n+%02d:%s: %s: %s",
				AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
	hwcpu->lines_info[hw->adptr_type].total_line_no = max_line_no; 
		switch(hwcpu->hwcard->adptr_type){
			sprintf(id_str, "AFT-A142 2 Port V.35/X.21");
			sprintf(id_str, "AFT-A144 4 Port V.35/X.21");
			sprintf(id_str, "AFT-A142 2 Port RS232");
			sprintf(id_str, "AFT-A144 4 Port RS232");
		hw->adptr_type	= hwcpu->hwcard->adptr_type;
		hw->chans_map	= 0x01;
		hw->max_chans_num	= 1;
		sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|FE=%s|BUS_IF=%s|BDRG=%s",id_dump_str,AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
		sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_verbose[0], "\n+%02d:%s: %s: %s",
				AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
	hwcpu->lines_info[hw->adptr_type].total_line_no = max_line_no;
		bits: 47-32 => reg 0x1098
		bits: 31-0  => reg 0x109C
		DEBUG_EVENT("%s: Failed to register FXO/FXS modules\n", hw->devname);
		DEBUG_EVENT("%s: No FXO/FXS modules detected\n", hw->devname);
	sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|BUS_IF=%s|BRDG=%s",AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
	/* Serial number not used in production yet - do not remove this */
	memcpy(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_verbose[off],
		DEBUG_EVENT("%s: Failed to register FXO/FXS modules\n", hw->devname);
		DEBUG_EVENT("%s: No FXO/FXS modules detected\n", hw->devname);
	sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|BUS_IF=%s|BRDG=%s",AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
	switch(hw->hwcpu->hwcard->adptr_type) {
				DEBUG_EVENT("Critical error: Not a valid BRI adapter type (0x%X)\n", hw->hwcpu->hwcard->adptr_type);
			DEBUG_EVENT("%s: Failed to register BRI modules\n", hw->devname);
			DEBUG_EVENT("%s: Failed to register FXO/FXS modules\n", hw->devname);
		DEBUG_EVENT("%s: Error: Failed to detect any Modules!\n",hw->devname);
	*lines_no = (hwcpu->lines_info[AFT_ADPTR_ISDN].total_line_no + hwcpu->lines_info[A200_ADPTR_ANALOG].total_line_no);
  		bit 0 == 1	- module 3 active (exist)
		bit 1		- type of module 1 (0 - FXS, 1 - FXO)
	/* For production test - Assume test module is there */
	hw->hwcpu->hwcard->cpld_rev=1;
							hw->devname);
							hw->devname);
							hw->devname);
 * Arguments	: pfe - pointer to Front End structure.	
		bit 0 == 1	- module 1 active (exist)
		bit 1		- type of module 1 (0 - NT, 1 - TE)
		bit 2 == 1	- module 2 active (exist)
		bit 3		- type of module 1 (0 - NT, 1 - TE)
  		bit 4 == 1	- module 3 active (exist)
		bit 5		- type of module 1 (0 - NT, 1 - TE)
		bit 6,7		- has to be zeros for active remora. if non-zero, remora does not exist.
	switch(hw->hwcpu->hwcard->adptr_type) {
				DEBUG_EVENT("%s: Remora number %d: Found 512khz Recovery clock remora.\n", hw->devname, rm_no);
				hw->hwcpu->hwcard->cpld_rev=1;
					DEBUG_TEST("%s: Remora number %d does not exist.\n", hw->devname, rm_no);
			hw->hwcpu->hwcard->cpld_rev=1;
							hw->devname);
			DEBUG_EVENT("Critical error: Not a valid BRI adapter type (0x%X)\n", hw->hwcpu->hwcard->adptr_type);
				DEBUG_TEST("module Number on REMORA (0-2): %d\n", ind / 2);
				/* 0-11, all (even and odd) numbers */
				DEBUG_TEST("mod_no_index on CARD (should be 0-11): %d\n", mod_no_index);
				/* 0-23, only even numbers */
				DEBUG_TEST("mod_no_index (line number) on CARD (should be 0-23): %d\n", mod_no_index);
							hw->devname, mod_no_index, mod_no_index, MAX_BRI_LINES);
							hw->devname, mod_no_index);
							hw->devname, mod_no_index);
							hw->devname, mod_no_index);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
			hwcard->u_pci.pci_bridge_dev = NULL;
			hwcard->u_pci.pci_bridge_bus = 0; 
			hwcard->u_pci.pci_bridge_slot = 0;
				hwcard->u_pci.pci_bridge_dev = NULL;
				hwcard->u_pci.pci_bridge_bus = 0; 
				hwcard->u_pci.pci_bridge_slot = 0;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (hwcard->type != SDLA_AFT){
		return -EINVAL;
	if (hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
		switch(hwcard->adptr_type){
				hwcard->adptr_security = AFT_SECURITY_UNCHAN;
				hwcard->adptr_security = AFT_SECURITY_CHAN;
				"%s: AFT-A101-2 Critical error: Unknown Security ID (0x%02X)!\n",
				hwcard->adptr_security = AFT_SECURITY_UNCHAN;
				hwcard->adptr_security = AFT_SECURITY_CHAN;
				hwcard->adptr_security = AFT_SECURITY_CHAN;
				"%s: AFT-A104 Critical error: Unknown Security ID (%02X)!\n",
	}else if (hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
		switch(hwcard->core_id){
			switch(hwcard->adptr_type){
				hwcard->hwec_chan_no = A104_ECCHAN(AFT_SH_SECURITY(status));
				/* By default, AFT-A300 is unchannelized! */
				hwcard->adptr_security = AFT_SECURITY_UNCHAN;
			switch(hwcard->adptr_type){
				hwcard->hwec_chan_no = A108_ECCHAN(AFT_SH_SECURITY(status));
			switch(hwcard->adptr_type){
				hwcard->hwec_chan_no = AFT_RM_ECCHAN(AFT_SH_SECURITY(status));
				if (hwcard->hwec_chan_no){
				hwcard->hwec_chan_no = A600_ECCHAN((reg >> 4) & 0x3); 
				if (hwcard->hwec_chan_no) {					
				hwcard->hwec_chan_no = A500_ECCHAN(AFT_SH_SECURITY(status));
				DEBUG_BRI("hwcard->hwec_chan_no: %d\n", hwcard->hwec_chan_no);
				if (hwcard->hwec_chan_no){
				hwcard->hwec_chan_no = 0;
				/* AFT-SERIAL: Add code here */
		if (hwcard->u_pci.pci_bridge_dev){
	switch(hwcard->adptr_type){
			hw->hwcpu->hwcard->cpld_rev = (status>>AFT_A300_VER_SHIFT)&AFT_A300_VER_MASK;
			hwcard->hwec_chan_no = 0;
	if (hwcard->hwec_chan_no && !hwcard->hwec_ind){
		hwcard->hwec_ind = get_card_serial_number(hw);
		hwcard->hwec_ind = ++sdla_hwec_no;
	hwcard->cfg_type = WANOPT_S51X;
	hwcard->type = SDLA_S514;
	switch(hwcard->adptr_type){
			return -EINVAL;
			hwcard->adptr_name,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			return -EINVAL;
			hwcard->adptr_name,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			return -EINVAL;
				hwcard->adptr_name,
				hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			sdla_adapter_cnt.s514x_adapters--;
			return -EINVAL;
			return -EINVAL;
			hwcard->adptr_name,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			return -EINVAL;
				hwcard->adptr_name, 
				hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			sdla_adapter_cnt.s514x_adapters--;
			return -EINVAL;
		hwcard->adptr_type = S5144_ADPTR_1_CPU_T1E1;
			return -EINVAL;
		"%s: S514-8-PCI T1/E1 card found, cpu(s) 1, bus #%d, slot #%d, irq #%d\n",
			wan_drvname, hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			return -EINVAL;
		"%s: S514-1-PCI V35/RS232/FT1 card found, cpu(s) 1, bus #%d, slot #%d, irq #%d\n",
	        	wan_drvname, hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
	hwcard->cfg_type = WANOPT_ADSL;
	hwcard->type = SDLA_ADSL;
	switch(hwcard->adptr_type){
			hwcard->adptr_name,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
                       	wan_drvname, hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
	hwcard->type = SDLA_AFT;
	switch(hwcard->adptr_type){
		hwcard->cfg_type = WANOPT_AFT;
		if (hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
			hwcard->cfg_type = WANOPT_AFT;
		}else if (hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
			hwcard->cfg_type = WANOPT_AFT101;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		if (hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
			hwcard->cfg_type = WANOPT_AFT;
			if (hwcard->u_pci.pci_dev->resource[1].flags){
					hwcard->adptr_name, 
					AFT_CORE_ID_DECODE(hwcard->core_id),
					hwcard->core_rev,
					hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
				sdla_adapter_cnt.aft101_adapters--;
		}else if (hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
			hwcard->cfg_type = WANOPT_AFT102;
				hwcard->adptr_name,
				AFT_CORE_ID_DECODE(hwcard->core_id),
				hwcard->core_rev,
				hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT104;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT108;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT300;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT_ANALOG;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT_ISDN;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT_ISDN;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT_56K;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		if (hwcard->adptr_type == AFT_ADPTR_2SERIAL_V35X21 || 
		    hwcard->adptr_type == AFT_ADPTR_2SERIAL_RS232){
		hwcard->cfg_type = WANOPT_AFT_SERIAL;
			hwcard->adptr_name,
			AFT_CORE_ID_DECODE(hwcard->core_id),
			hwcard->core_rev, lines_no,
			hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
		hwcard->cfg_type = WANOPT_AFT_ANALOG;
					hwcard->adptr_name,
					AFT_CORE_ID_DECODE(hwcard->core_id),
					hwcard->core_rev,
					hwcard->u_pci.bus_no, hwcard->u_pci.slot_no, irq);
			hwcard->adptr_type,
			hwcard->u_pci.bus_no,
			hwcard->u_pci.slot_no,
	WAN_ASSERT(hwcard->u_pci.pci_dev == NULL);
	if (hwcard->u_pci.pci_dev->bus == NULL) return 0;
	bus = hwcard->u_pci.pci_dev->bus;
	if (bus->self == NULL) return 0;
	pcibridge_dev = bus->self;
	if (pcibridge_dev->vendor == PLX_VENDOR_ID && 
	    (pcibridge_dev->device == PLX_DEVICE_ID ||
	     pcibridge_dev->device == PLX2_DEVICE_ID)){
		hwcard->u_pci.pci_bridge_dev = pcibridge_dev;
		hwcard->u_pci.pci_bridge_bus = hwcard->u_pci.bus_no; 
		hwcard->u_pci.pci_bridge_slot = hwcard->u_pci.slot_no;
		DEBUG_TEST("%s: PCI-Express card (PLX PCI Bridge, bus:%d, slot:%d)\n",
			wan_drvname, hwcard->bus_no, hwcard->slot_no);
	}else if (pcibridge_dev->vendor == TUNDRA_VENDOR_ID && 
	          pcibridge_dev->device == TUNDRA_DEVICE_ID){
		hwcard->u_pci.pci_bridge_dev = pcibridge_dev;
		hwcard->u_pci.pci_bridge_bus = hwcard->u_pci.bus_no; 
		hwcard->u_pci.pci_bridge_slot = hwcard->u_pci.slot_no;
		DEBUG_TEST("%s: PCI-Express card (TUNDRA PCI Bridge, bus:%d, slot:%d)\n",
			wan_drvname, hwcard->bus_no, hwcard->slot_no);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
	hwcard->adptr_type	= pci_subsystem_id & 0xFF;
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
	hwcard->adptr_type	= pci_subsystem_id & 0xFF;
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
	hwcard->adptr_type	= pci_subsystem_id & 0xFF;
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard->u_pci.pci_dev == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
		/* Old A-series cards, keep original sequence */
		hwcard->adptr_type	= A101_ADPTR_1TE1;
		hwcard->adptr_type	= A101_ADPTR_2TE1;
		hwcard->adptr_type	= A104_ADPTR_4TE1;
		hwcard->adptr_type	= A101_ADPTR_1TE1;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A101_ADPTR_2TE1;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A104_ADPTR_4TE1;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A108_ADPTR_8TE1;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A300_ADPTR_U_1TE3;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A305_ADPTR_C_1TE3;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A200_ADPTR_ANALOG;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= A400_ADPTR_ANALOG;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_FLEXBRI;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_ISDN;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_56K;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_2SERIAL_V35X21;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_4SERIAL_V35X21;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_2SERIAL_RS232;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_4SERIAL_RS232;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->adptr_type	= AFT_ADPTR_A600;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	hwcard->core_id	= AFT_CORE_ID(pci_subsystem_id);
	hwcard->core_rev= AFT_CORE_REV(pci_subsystem_id);
	if (hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
		switch(hwcard->core_id){
					wan_drvname, hwcard->core_id);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
		hwcard->adptr_type	= A101_ADPTR_1TE1;
		hwcard->adptr_type	= A101_ADPTR_2TE1;
		hwcard->adptr_type	= A300_ADPTR_U_1TE3;
	hwcard->core_id	= AFT_CORE_ID(pci_subsystem_id);
	hwcard->core_rev= AFT_CORE_REV(pci_subsystem_id);
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
		hwcard->adptr_type	= A101_ADPTR_1TE1;
		hwcard->adptr_type	= A101_ADPTR_2TE1;
		hwcard->adptr_type	= A104_ADPTR_4TE1;
		hwcard->adptr_type	= A104_ADPTR_4TE1;
		hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
	hwcard->core_id = AFT_CORE_ID(pci_subsystem_id);
	hwcard->core_rev= AFT_CORE_REV(pci_subsystem_id);
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
		hwcard->adptr_type	= A101_ADPTR_1TE1;
		hwcard->adptr_type	= A101_ADPTR_2TE1;
		hwcard->adptr_type	= A300_ADPTR_U_1TE3;
	hwcard->core_id	= AFT_CORE_ID(pci_subsystem_id);
	hwcard->core_rev= AFT_CORE_REV(pci_subsystem_id);
	hwcard->u_pci.pci_dev	= tmp_hwcard->u_pci.pci_dev;
	WAN_ASSERT_RC(hw->hwcpu == NULL,0);
	WAN_ASSERT_RC(hw->hwcpu->hwcard == NULL,0);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
		tmp_hwcard->u_pci.pci_dev = pci_dev;
					((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
					pci_dev->bus->number,
					pci_dev->irq);
		tmp_hwcard->u_pci.pci_dev = pci_dev;
				 	((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
				 	pci_dev->bus->number,
					pci_dev->irq);
		tmp_hwcard->u_pci.pci_dev = pci_dev;	
				 	((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
				 	pci_dev->bus->number,
					pci_dev->irq);
		tmp_hwcard->u_pci.pci_dev = pci_dev;	
					pci_dev->bus->number,
					((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
					pci_dev->irq);
		tmp_hwcard->u_pci.pci_dev = pci_dev;	
					pci_dev->bus->number,
					((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
					pci_dev->irq);
		tmp_hwcard->u_pci.pci_dev = pci_dev;	
					pci_dev->bus->number,
					((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
					pci_dev->irq);
		tmp_hwcard->u_pci.pci_dev = pci_dev;
					pci_dev->bus->number,
					((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
					pci_dev->irq);
		bus = pci_bus_b(pci_dev->bus->children.next);
					bus->self->vendor,
					bus->self->device,
					bus->self->subsystem_vendor,
					bus->self->subsystem_device,
       				 	((bus->self->devfn >> 3) & PCI_DEV_SLOT_MASK),
					bus->number);
		bus = pci_bus_b(pci_dev->bus->children.prev);
					bus->self->vendor,
					bus->self->device,
					bus->self->subsystem_vendor,
					bus->self->subsystem_device,
       				 	((bus->self->devfn >> 3) & PCI_DEV_SLOT_MASK),
					bus->number);
		tmp = pci_dev_b(pci_dev->bus->devices.next);
					tmp->vendor,
					tmp->device,
					tmp->subsystem_vendor,
					tmp->subsystem_device,
       				 	((tmp->devfn >> 3) & PCI_DEV_SLOT_MASK),
					tmp->bus->number);
		tmp = pci_dev_b(pci_dev->bus->devices.prev);
					tmp->vendor,
					tmp->device,
					tmp->subsystem_vendor,
					tmp->subsystem_device,
       				 	((tmp->devfn >> 3) & PCI_DEV_SLOT_MASK),
					tmp->bus->number);
					 pci_dev->bus->number,
					 ((pci_dev->devfn >> 3) & PCI_DEV_SLOT_MASK),
		//hwcard->adptr_type	= pci_subsystem_id & 0xFF;	
		//hwcard->adptr_type	= A104_ADPTR_X_4TE1;
		//hwcard->adptr_subtype	= AFT_SUBTYPE_SHARK;
		hwcard->u_pci.pci_dev		= pci_dev;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	tmp_hwcard = hwcpu->hwcard;
		if (dinfo->cfg.vendor == V3_VENDOR_ID && dinfo->cfg.device == V3_DEVICE_ID){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
					pci_get_slot(dinfo->cfg.dev), 
					pci_get_bus(dinfo->cfg.dev),
					dinfo->cfg.intline);
		if (dinfo->cfg.vendor == PCI_VENDOR_ID_GSI && dinfo->cfg.device == PCI_DEVICE_ID_GSI_ADSL){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
						pci_get_slot(dinfo->cfg.dev), 
						pci_get_bus(dinfo->cfg.dev),
						dinfo->cfg.intline);
		if (dinfo->cfg.vendor == PCI_VENDOR_ID_GSI && dinfo->cfg.device == PCI_DEVICE_ID_GSI_ADSL_V2){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
						pci_get_slot(dinfo->cfg.dev), 
						pci_get_bus(dinfo->cfg.dev),
						dinfo->cfg.intline);
		if (dinfo->cfg.vendor == SANGOMA_PCI_VENDOR){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
						pci_get_bus(dinfo->cfg.dev),
						pci_get_slot(dinfo->cfg.dev), 
						dinfo->cfg.intline);
		if (dinfo->cfg.vendor == SANGOMA_PCI_VENDOR && dinfo->cfg.device == SANGOMA_PCI_DEVICE){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
						pci_get_bus(dinfo->cfg.dev),
						pci_get_slot(dinfo->cfg.dev), 
						dinfo->cfg.intline);
		if (dinfo->cfg.vendor == SANGOMA_PCI_VENDOR && dinfo->cfg.device == SANGOMA_PCI_4_DEVICE){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
						pci_get_bus(dinfo->cfg.dev),
						pci_get_slot(dinfo->cfg.dev), 
						dinfo->cfg.intline);
		if (dinfo->cfg.vendor == SANGOMA_PCI_VENDOR_OLD && dinfo->cfg.device == SANGOMA_PCI_DEVICE){
			tmp_hwcard->u_pci.pci_dev = dinfo->cfg.dev;
						pci_get_bus(dinfo->cfg.dev),
						pci_get_slot(dinfo->cfg.dev), 
						dinfo->cfg.intline);
	tmp_hwcpu->hwcard = tmp_hwcard;
	tmp_hw->hwcpu = tmp_hwcpu;
	tmp_hw->magic = SDLADRV_MAGIC;
		tmp_hwcard->hw_type = SDLA_ISA_CARD;
		tmp_hwcard->u_isa.ioport = opt[i];
			DEBUG_EVENT("%s: S508-ISA card found, port 0x%x\n",
				wan_drvname, tmp_hwcard->u_isa.ioport);
					SDLA_ISA_CARD, 0, 0, tmp_hwcard->u_isa.ioport, NULL);
			hwcard->adptr_type	= 0x00;
			hwcard->cfg_type 	= WANOPT_S50X;
		tmp_hwcard->u_isa.ioport = 0x00;
	tmp_hwcard->hw_type = SDLA_PCI_CARD;
	tmp_hwcard->u_pci.bus_no = 0;
	tmp_hwcard->u_pci.slot_no = 0;
		if (dev->type == SDLA_S508){
			DEBUG_EVENT( "%s: S508-ISA card found, port 0x%x\n",
			hwcard->adptr_type	= 0x00;
			hwcard->cfg_type 	= WANOPT_S50X;
	    		hwcpu->irq    	= sdladev_irq(dev);
	    		hwcpu->dpmbase 	= sdladev_maddr(dev);
			hwcard->u_isa.ioh	= dev->u.isa.ioh;
    			hwcard->u_isa.iot    	= dev->sc->ia.ia_iot;
	    		hwcard->u_isa.memt   	= dev->sc->ia.ia_memt;
	tmp_hw->hwcpu = tmp_hwcpu;
	tmp_hw->magic = SDLADRV_MAGIC;
	tmp_hwcpu->hwcard = tmp_hwcard;	
	tmp_hwcard->hw_type = SDLA_PCI_CARD;
	tmp_hwcard->u_pci.bus_no = 0;
	tmp_hwcard->u_pci.slot_no = 0;
	/* Probe PCI/PCI-Exp cards */
		pci_dev = dev->sc->dev;
    		pci_dev = dev->u.pci.pci_dev;
	    	pci_dev = &dev->sc->pa;
		hwcard->adptr_type	= dev->adapter_type;
		hwcard->adptr_subtype	= dev->adapter_subtype;
		hwcard->u_pci.pci_dev	= pci_dev;
	    	hwcard->memt		= pci_dev->pa_memt;
		switch(dev->vendor_id){
			if (dev->subvendor_id == SANGOMA_SUBSYS_VENDOR){
			}else if (dev->device_id == SANGOMA_PCI_DEVICE){
				hwcard->core_id	= AFT_CORE_ID(dev->subsystem_id);
				hwcard->core_rev= AFT_CORE_REV(dev->subsystem_id);
					wan_drvname, dev->device_id);
			hwcard->core_id	= AFT_CORE_ID(dev->subsystem_id);
			hwcard->core_rev= AFT_CORE_REV(dev->subsystem_id);
					wan_drvname, dev->vendor_id);
				hwcard->u_pci.bus_no,
				hwcard->u_pci.slot_no); 
				hwcard->u_isa.ioport);
	new_hwcard->hw_type	= hw_type;
	switch(new_hwcard->hw_type){
		new_hwcard->u_isa.ioport 	= ioport;
		new_hwcard->u_pci.bus_no  	= bus_no;
		new_hwcard->u_pci.slot_no	= slot_no;
//		new_hwcard->u_usb.devnum  	= bus_no;
	wan_spin_lock_init(&new_hwcard->pcard_lock,"wan_hwcard_lock");
	wan_spin_lock_init(&new_hwcard->pcard_ec_lock,"wan_hwcard_ec_lock");
	if (hwcard->internal_used){
				hwcard->internal_used);
		return -EBUSY;
		if (tmp->hw_type != hw_type){
		switch(tmp->hw_type){
			if (tmp->u_pci.bus_no == bus_no && 
			    tmp->u_pci.slot_no == slot_no){
			if (tmp->u_isa.ioport == ioport){
//			if (tmp->u_usb.devnum == bus_no){
	WAN_ASSERT(hwcpu->hwcard == NULL);
	if (IS_HWCARD_PCI(hwcpu->hwcard)){
				hwcpu->hwcard->u_pci.slot_no,
				hwcpu->hwcard->u_pci.bus_no, 
				SDLA_GET_CPU(hwcpu->cpu_no));
	}else if (IS_HWCARD_USB(hwcpu->hwcard)){
				__FUNCTION__, WP_USB_BUSID(hwcpu->hwcard));
				hwcpu->hwcard->u_isa.ioport);
		hwcpu = sdla_hwcpu_search(	(u8)hwcard->hw_type,
						hwcard->u_isa.ioport,
		hwcpu = sdla_hwcpu_search(	(u8)hwcard->hw_type, 
						hwcard->u_pci.bus_no,
						hwcard->u_pci.slot_no,
		hwcpu = sdla_hwcpu_search(	(u8)hwcard->hw_type, 
	hwcpu->cpu_no	= cpu_no;
	hwcpu->irq	= irq;
	hwcpu->hwcard	= hwcard;
	hwcpu->sdla_dev	= dev;	/* Internal kernel BSD structure */
	hwcpu->magic	= SDLADRV_MAGIC;
	hwcard->internal_used++;
	if (hwcpu->internal_used){
					hwcpu->internal_used);
		return -EBUSY;
	hwcpu->hwcard->internal_used--;			/* Decrement card usage */
	hwcpu->hwcard = NULL;
		WAN_ASSERT_RC(tmp->hwcard == NULL, NULL);
		if (tmp->hwcard->hw_type != hw_type){
			if (tmp->hwcard->u_pci.bus_no == bus_no && 
			    tmp->hwcard->u_pci.slot_no == slot_no && 
			    tmp->cpu_no == cpu_no){ 
			if (tmp->hwcard->u_isa.ioport == ioport){
//			if (tmp->hwcard->u_usb.devnum == bus_no){
			if (strcmp(WP_USB_BUSID(tmp->hwcard), bus_id) == 0){
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	if (IS_HWCARD_PCI(hw->hwcpu->hwcard)){
				hw->hwcpu->hwcard->u_pci.bus_no, 
				hw->hwcpu->hwcard->u_pci.slot_no,
				SDLA_GET_CPU(hw->hwcpu->cpu_no),
				hw->line_no);
	}else if (IS_HWCARD_USB(hw->hwcpu->hwcard)){
				__FUNCTION__, WP_USB_BUSID(hw->hwcpu->hwcard));
				hw->hwcpu->hwcard->u_isa.ioport,
				hw->line_no);
					hwcpu->hwcard->u_pci.bus_no,
					hwcpu->hwcard->u_pci.slot_no,
					hwcpu->cpu_no,
	new_hw->devname	= SDLA_HWPROBE_NAME;
	new_hw->hwcpu	= hwcpu;
	new_hw->magic	= SDLADRV_MAGIC;
	new_hw->line_no	= dev_no;
	new_hw->cfg_type = hwcpu->hwcard->cfg_type;
	if (hwcpu->hwcard->adptr_type == AFT_ADPTR_FLEXBRI) {
			new_hw->cfg_type = WANOPT_AFT_ANALOG;
			new_hw->cfg_type = WANOPT_AFT_ISDN;
	hwcpu->internal_used++;
	hwcpu->max_lines_num++;
	hwcpu->hwdev[dev_no] = new_hw;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	if (hw->internal_used){
					hw->internal_used);
		return -EBUSY;
	for(port = 0; port < hw->max_port_no; port++){
		if (hw->hwport[port].hwprobe){
			hwprobe = hw->hwport[port].hwprobe;
			hwprobe->internal_used--;
			if (hwprobe->internal_used == 0){
			hw->hwport[port].hwprobe = NULL;
	hw->hwcpu->hwdev[hw->line_no] = NULL;
	hw->hwcpu->internal_used--;	/* Decrement card usage */
	hw->hwcpu = NULL;
		WAN_ASSERT_RC(tmp_hw->hwcpu == NULL, NULL);
		if (tmp_hw->hwcpu != hwcpu || tmp_hw->line_no != line_no){
	hw = hw_iface->hw;
	if (hw == NULL || hw->used >= hw->max_port_no){
	WAN_ASSERT_RC(hw->hwcpu == NULL, NULL);
	WAN_ASSERT_RC(hw->hwcpu->hwcard == NULL, NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	hw_iface->setup		= sdla_setup;
	hw_iface->hw_down	= sdla_down;
	hw_iface->load		= sdla_load;
	hw_iface->intack	= sdla_intack;
	hw_iface->read_int_stat	= sdla_read_int_stat;
	hw_iface->mapmem	= sdla_mapmem;
	hw_iface->check_mismatch= sdla_check_mismatch;
	hw_iface->peek		= sdla_peek;
	hw_iface->poke		= sdla_poke;
	hw_iface->poke_byte	= sdla_poke_byte;
	hw_iface->getcfg	= sdla_getcfg;
	hw_iface->get_totalines	= sdla_get_totalines;
	hw_iface->setcfg	= sdla_setcfg;
	hw_iface->isa_read_1	= sdla_isa_read_1;
	hw_iface->isa_write_1	= sdla_isa_write_1;
	hw_iface->io_read_1	= sdla_io_read_1;
	hw_iface->io_write_1	= sdla_io_write_1;
	hw_iface->bus_read_1	= sdla_bus_read_1;
	hw_iface->bus_read_2	= sdla_bus_read_2;
	hw_iface->bus_read_4	= sdla_bus_read_4;
	hw_iface->bus_write_1	= sdla_bus_write_1;
	hw_iface->bus_write_2	= sdla_bus_write_2;
	hw_iface->bus_write_4	= sdla_bus_write_4;
	hw_iface->set_intrhand	= sdla_set_intrhand;
	hw_iface->restore_intrhand= sdla_restore_intrhand;
	hw_iface->is_te1	= sdla_is_te1;
	hw_iface->is_56k	= sdla_is_56k;
	hw_iface->get_hwcard	= sdla_get_hwcard;
	hw_iface->get_hwprobe	= sdla_get_hwprobe;
	hw_iface->hw_lock	= sdla_hw_lock;
	hw_iface->hw_unlock	= sdla_hw_unlock;
	hw_iface->hw_ec_trylock	= sdla_hw_ec_trylock;
	hw_iface->hw_ec_lock	= sdla_hw_ec_lock;
	hw_iface->hw_ec_unlock	= sdla_hw_ec_unlock;
	hw_iface->pci_map_dma	= sdla_pci_map_dma;
	hw_iface->pci_unmap_dma = sdla_pci_unmap_dma;
	hw_iface->hw_same	= sdla_is_same_hwcard;
	hw_iface->hwcpu_same	= sdla_is_same_hwcpu;
	hw_iface->fe_test_and_set_bit = sdla_hw_fe_test_and_set_bit;
	hw_iface->fe_set_bit = sdla_hw_fe_set_bit;
	hw_iface->fe_test_bit = sdla_hw_fe_test_bit;
	hw_iface->fe_clear_bit =  sdla_hw_fe_clear_bit;
	switch(hwcard->cfg_type){
		hwcard->type		= SDLA_S508;
		hw_iface->cmd		= sdla_cmd;
		hw_iface->set_bit	= sdla_set_bit;
		hw_iface->clear_bit	= sdla_clear_bit;
					SDLA_DECODE_CARDTYPE(hwcard->cfg_type),
					hwcard->u_isa.ioport,
					hwcpu->irq);
		hwcard->type			= SDLA_S514;
		hw_iface->load			= sdla_load;	/* For Edukit */
		hw_iface->hw_halt		= sdla_halt;	/* For Edukit */
		hw_iface->start			= sdla_start;	/* For Edukit */
		hw_iface->cmd			= sdla_cmd;
		hw_iface->set_bit		= sdla_set_bit;
		hw_iface->clear_bit		= sdla_clear_bit;
		hw_iface->pci_read_config_byte 	= sdla_pci_read_config_byte;
		hw_iface->pci_read_config_word 	= sdla_pci_read_config_word;
		hw_iface->pci_read_config_dword = sdla_pci_read_config_dword;
		hw_iface->pci_write_config_byte = sdla_pci_write_config_byte;
		hw_iface->pci_write_config_word = sdla_pci_write_config_word;
		hw_iface->pci_write_config_dword = sdla_pci_write_config_dword;
		hw_iface->fe_read = sdla_legacy_read_fe;
		hw_iface->fe_write = sdla_legacy_write_fe;
				SDLA_DECODE_CARDTYPE(hwcard->cfg_type),
				SDLA_GET_CPU(hwcpu->cpu_no), 
				hwcard->u_pci.bus_no, 
				hwcard->u_pci.slot_no);
		hwcard->type			= SDLA_ADSL;
		hw_iface->pci_read_config_byte 	= sdla_pci_read_config_byte;
		hw_iface->pci_read_config_word 	= sdla_pci_read_config_word;
		hw_iface->pci_read_config_dword = sdla_pci_read_config_dword;
		hw_iface->pci_write_config_byte = sdla_pci_write_config_byte;
		hw_iface->pci_write_config_word = sdla_pci_write_config_word;
		hw_iface->pci_write_config_dword = sdla_pci_write_config_dword;
					SDLA_DECODE_CARDTYPE(hwcard->cfg_type),
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hwcard->u_pci.bus_no, 
					hwcard->u_pci.slot_no);
		hwcard->type			= SDLA_AFT;
		hw_iface->set_bit		= sdla_set_bit;
		hw_iface->clear_bit		= sdla_clear_bit;
		hw_iface->pci_read_config_byte 	= sdla_pci_read_config_byte;
		hw_iface->pci_read_config_word 	= sdla_pci_read_config_word;
		hw_iface->pci_read_config_dword = sdla_pci_read_config_dword;
		hw_iface->pci_write_config_byte = sdla_pci_write_config_byte;
		hw_iface->pci_write_config_word = sdla_pci_write_config_word;
		hw_iface->pci_write_config_dword = sdla_pci_write_config_dword;
		hw_iface->pci_bridge_read_config_dword	= sdla_pci_bridge_read_config_dword;
		hw_iface->pci_bridge_read_config_byte	= sdla_pci_bridge_read_config_byte;
		hw_iface->pci_bridge_write_config_dword = sdla_pci_bridge_write_config_dword;
		hw_iface->pci_bridge_write_config_byte = sdla_pci_bridge_write_config_byte;
		hw_iface->read_cpld		= sdla_hw_read_cpld;
		hw_iface->write_cpld		= sdla_hw_write_cpld;
		hw_iface->busdma_descr_alloc	= sdla_busdma_descr_alloc;
		hw_iface->busdma_descr_free	= sdla_busdma_descr_free;
		hw_iface->busdma_tag_create	= sdla_busdma_tag_create;
		hw_iface->busdma_tag_destroy	= sdla_busdma_tag_destroy;
		hw_iface->busdma_create		= sdla_busdma_create;
		hw_iface->busdma_destroy	= sdla_busdma_destroy;
		hw_iface->busdma_alloc		= sdla_busdma_alloc;
		hw_iface->busdma_free		= sdla_busdma_free;
		hw_iface->busdma_load		= sdla_busdma_load;
		hw_iface->busdma_unload		= sdla_busdma_unload;
		hw_iface->busdma_map		= sdla_busdma_map;
		hw_iface->busdma_unmap		= sdla_busdma_unmap;
		hw_iface->busdma_sync		= sdla_busdma_sync;
		hw_iface->pci_map_dma		= sdla_pci_map_dma;
		hw_iface->pci_unmap_dma 	= sdla_pci_unmap_dma;
		hw_iface->get_hwec_index	= sdla_get_hwec_index;
		switch(hwcard->adptr_type){
			if (hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
				hw_iface->fe_read = sdla_te1_read_fe;
				hw_iface->fe_write = sdla_te1_write_fe;
				hw_iface->fe_read = sdla_shark_te1_read_fe;
				hw_iface->__fe_read = __sdla_shark_te1_read_fe; 
				hw_iface->fe_write = sdla_shark_te1_write_fe;
			hw_iface->fe_read = sdla_shark_te1_read_fe;
			hw_iface->__fe_read = __sdla_shark_te1_read_fe; 
			hw_iface->fe_write = sdla_shark_te1_write_fe;
			hw_iface->fe_read = sdla_shark_56k_read_fe;
			hw_iface->__fe_read = __sdla_shark_56k_read_fe;
			hw_iface->fe_write = sdla_shark_56k_write_fe;
			hw_iface->fe_read = sdla_shark_rm_read_fe;
			hw_iface->__fe_read = __sdla_shark_rm_read_fe;
			hw_iface->fe_write = sdla_shark_rm_write_fe;
			hw_iface->reset_fe = sdla_a200_reset_fe;
			hw_iface->fe_read = sdla_te3_read_fe;
			hw_iface->fe_write = sdla_te3_write_fe;
			hw_iface->fe_read = sdla_shark_bri_read_fe;
			hw_iface->fe_write = sdla_shark_bri_write_fe;
			if (hw->cfg_type == WANOPT_AFT_ISDN) {
				hw_iface->fe_read = sdla_shark_bri_read_fe;
				hw_iface->fe_write = sdla_shark_bri_write_fe;
				hw_iface->fe_read = sdla_a700_analog_read_fe;
				hw_iface->fe_write = sdla_a700_analog_write_fe;
				hw_iface->__fe_read = __sdla_a700_analog_read_fe;
				hw_iface->reset_fe = sdla_a700_reset_fe;
			hw_iface->fe_read = sdla_shark_serial_read_fe;
			hw_iface->fe_write = sdla_shark_serial_write_fe;
			hw_iface->fe_read = sdla_a600_read_fe;
			hw_iface->__fe_read = __sdla_a600_read_fe;
			hw_iface->fe_write = sdla_a600_write_fe;
			hw_iface->reset_fe = sdla_a600_reset_fe;
		switch(hwcard->adptr_type){
					SDLA_DECODE_CARDTYPE(hwcard->cfg_type),
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hwcard->u_pci.bus_no,
					hwcard->u_pci.slot_no, 
					hw->line_no);		//(conf) ? conf->comm_port : hw->used);
					SDLA_DECODE_CARDTYPE(hwcard->cfg_type),
					SDLA_GET_CPU(hwcpu->cpu_no), 
					hwcard->u_pci.bus_no, 
					hwcard->u_pci.slot_no);
					SDLA_DECODE_CARDTYPE(hwcard->cfg_type),
					hw->used);
		hwcard->type			= SDLA_USB;
		hw_iface->fe_read		= sdla_usb_fxo_read;
		hw_iface->fe_write		= sdla_usb_fxo_write;
		hw_iface->usb_cpu_read		= sdla_usb_cpu_read;
		hw_iface->usb_cpu_write		= sdla_usb_cpu_write;
		hw_iface->usb_write_poll	= sdla_usb_write_poll;
		hw_iface->usb_read_poll		= sdla_usb_read_poll;
		hw_iface->usb_rxevent_enable	= sdla_usb_rxevent_enable;
		hw_iface->usb_rxevent		= sdla_usb_rxevent;
		hw_iface->usb_rxtx_data_init	= sdla_usb_rxtx_data_init;
		hw_iface->usb_rxdata_enable	= sdla_usb_rxdata_enable;
		hw_iface->usb_rxdata		= sdla_usb_rxdata;
		hw_iface->usb_txdata		= sdla_usb_txdata;
		hw_iface->usb_txdata_ready	= sdla_usb_txdata_ready;
		hw_iface->usb_err_stats		= sdla_usb_err_stats;
		hw_iface->usb_flush_err_stats	= sdla_usb_flush_err_stats;
		hw_iface->set_intrhand		= sdla_usb_set_intrhand;
		hw_iface->restore_intrhand	= sdla_usb_restore_intrhand;
					hwcard->cfg_type);
	if (!hw->used){
		hw->devname = devname;
	hw->hwport[(conf)?conf->comm_port:hw->used].used++;
	hw->hwport[(conf)?conf->comm_port:hw->used].devname = devname;
	hw->used++;
	hw->hwcpu->used++;
	hw->hwcpu->lines_info[hw->cfg_type].usage++;
	wan_spin_lock_init(&hw->hwcpu->lines_info[hw->cfg_type].pcard_lock, "wan_pcard_lock");
	/* ISDN-BRI logial used cnt */
	if (hwcard->adptr_type == AFT_ADPTR_ISDN ||
		hwcard->adptr_type == AFT_ADPTR_FLEXBRI){
			port = hw->line_no / 2;
			hw->hwcpu->reg_line[port]++;
			hw->hwcpu->reg_line[port+1]++;
			hw->hwcpu->reg_line[0]++;
	wan_set_bit(hw->line_no,&hw->hwcpu->reg_line_map);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	/* ISDN-BRI logial used cnt */
	if (hwcpu->hwcard->adptr_type == AFT_ADPTR_ISDN ||
		hwcpu->hwcard->adptr_type == AFT_ADPTR_FLEXBRI) {
		port = hw->line_no / 2;
		hw->hwcpu->reg_line[port]--;
		hw->hwcpu->reg_line[port+1]--;
		hw->hwcpu->reg_line[0]--;
	for(port = 0; port < hw->max_port_no; port++){
		if (hw->hwport[port].devname == devname){
			hw->hwport[port].devname = NULL;
			hw->hwport[port].used --;
	if (hwcpu->hwcard->adptr_type == AFT_ADPTR_FLEXBRI) {
		if (hw->cfg_type == WANOPT_AFT_ANALOG) {
			hw->hwport[1].used--;
	wan_clear_bit(hw->line_no, &hw->hwcpu->reg_line_map);
	hw->used--;
	hw->hwcpu->used--;
	hw->hwcpu->lines_info[hw->cfg_type].usage--;	
	if (!hw->used){
		hw->devname = SDLA_HWPROBE_NAME;
	if (conf->card_type != WANOPT_S50X){
	if (conf->card_type==WANOPT_S50X){
			SDLA_DECODE_CARDTYPE(conf->card_type),
			conf->ioport,
			conf->irq);
	}else if (conf->auto_hw_detect){
		if (conf->card_type == WANOPT_USB_ANALOG){
					SDLA_DECODE_CARDTYPE(conf->card_type));
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->S514_CPU_no[0]);
	}else if (conf->card_type == WANOPT_USB_ANALOG){
				SDLA_DECODE_CARDTYPE(conf->card_type),
				conf->usb_busid);
				SDLA_DECODE_CARDTYPE(conf->card_type),
				conf->usb_devnum);
				SDLA_DECODE_CARDTYPE(conf->card_type),
				conf->S514_CPU_no[0],
				conf->pci_bus_no,
				conf->PCI_slot_no); 
	switch(conf->card_type){
		if (conf->auto_hw_detect && sdla_adapter_cnt.s514x_adapters > 1){
				return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.s518_adapters > 1){
				return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft101_adapters > 1){
 			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-101/102 cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft104_adapters > 1){
			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-104 cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft108_adapters > 1){
			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-108 cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft200_adapters > 1){
 			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-ANALOG cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft200_adapters > 1){
 			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-ISDN BRI cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft300_adapters > 1){
			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-300 cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft_56k_adapters > 1){
 			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-56K cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft_serial_adapters > 1){
 			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-SERIAL cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.aft_a600_adapters > 1){
			DEBUG_EVENT( "%s: HW Auto PCI failed: Multiple AFT-A600 cards found! \n"
			return -EINVAL;
		if (conf->auto_hw_detect && sdla_adapter_cnt.usb_adapters > 1){
			return -EINVAL;
				devname,conf->card_type);
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch(hwcard->type){
		hw->port = conf->ioport;
		hwcpu->irq = (conf && conf->irq == 9) ? 2 : conf->irq;
		if(conf && conf->maddr){
			hwcpu->dpmbase = (sdla_mem_handle_t)phys_to_virt(conf->maddr);
		if (conf && !conf->S514_CPU_no[0]){
					hw->devname);
			return -EINVAL;
		if (conf->S514_CPU_no[0] == 'A'){
			hw->cpu_no = SDLA_CPU_A;
		}else if (conf->S514_CPU_no[0] == 'B'){
			hw->cpu_no = SDLA_CPU_B;
		hw->slot_no = conf->PCI_slot_no;
		hw->bus_no  = conf->pci_bus_no;
		hw->auto_hw_detect = conf->auto_hw_detect;
		if (hw->auto_hw_detect == WANOPT_YES){
					hw->devname, 
					SDLA_GET_CPU(hw->cpu_no));
					hw->devname, 
					SDLA_GET_CPU(hw->cpu_no),
					hwcard->slot_no);
		hw->dpmbase = (sdla_mem_handle_t)conf->maddr;
		hw->cpu_no = SDLA_CPU_A;
		hw->slot_no = conf->PCI_slot_no;
		hw->auto_hw_detect = conf->auto_hw_detect;
		hw->bus_no  = conf->pci_bus_no;
		if (hw->auto_hw_detect == WANOPT_YES){
					hw->devname);
					hw->devname, 
					hwcard->slot_no,
					hwcard->bus_no);
		hw->dpmbase = (sdla_mem_handle_t)conf->maddr;
		hwcpu->fwid = SFID_ADSL; 
		switch(hwcard->adptr_type){
			if (hwcpu->used > 1){
				if (conf) conf->irq = hwcpu->irq;
		hwcpu->fwid = SFID_AFT; 
			return -EINVAL;
				hw->devname, hwcard->type);
		return -EINVAL;
	hwcpu->dpmsize		= SDLA_WINDOWSIZE;
		hwcard->u_isa.pclk	= (conf) ? conf->hw_opt[1] : 0;
		return -ENODEV;
	switch(hwcard->type){
                		hw->devname, hwcard->type, hwcard->u_isa.ioport);
                hwcpu->dpmsize = SDLA_WINDOWSIZE;
		switch(hwcard->type){
                        hwcard->u_isa.io_range    = S502A_IORANGE;
                        hwcard->u_isa.io_range    = S502E_IORANGE;
                        hwcard->u_isa.io_range    = S503_IORANGE;
                        hwcard->u_isa.io_range    = S507_IORANGE;
                        hwcard->u_isa.io_range    = S508_IORANGE;
                        	hw->devname, hwcard->type);
                     	return -EINVAL;
                if (!sdla_get_option_index(irq_opt, hwcpu->irq)) {
                        	hw->devname, hwcpu->irq);
                      return -EINVAL;
                if (hwcard->u_isa.pclk == 0)
                        hwcard->u_isa.pclk = pclk_opt[1];  /* use default */
                else if (!sdla_get_option_index(pclk_opt, hwcard->u_isa.pclk)) {
				hw->devname, hwcard->u_isa.pclk);
                        return -EINVAL;
			hw->devname, hwcard->u_isa.pclk);
                /* Setup adapter dual-port memory window and test memory */
                if (hwcpu->dpmbase == 0) {
							hw->devname);
			virt_to_phys((void*)hwcpu->dpmbase))) {
						hw->devname, 
						(unsigned long)virt_to_phys((void*)hwcpu->dpmbase));
                        return -EINVAL;
						hw->devname, 
						(unsigned long)virt_to_phys((void*)hwcpu->dpmbase));
                        return -EINVAL;
		DEBUG_EVENT("%s: dual-port memory window is set at 0x%lX.\n",
				hw->devname, (unsigned long)virt_to_phys((void*)hwcpu->dpmbase));
		if (virt_to_phys((void*)hwcpu->dpmbase) >= 0xE0000){
			DEBUG_EVENT("\n(WARNING) %s: !!!!!!!!  WARNING !!!!!!!!\n",hw->devname);
						hw->devname, 
						(unsigned long)virt_to_phys((void*)hwcpu->dpmbase));
			DEBUG_EVENT("(WARNING) %s: !!!!!!!!  WARNING !!!!!!!!\n\n",hw->devname);
		if (conf) conf->irq = hwcpu->irq;
		if (conf && conf->config_id == WANCONFIG_DEBUG){
			hwcpu->memory = MAX_SIZEOF_S514_MEMORY;
		hwcpu->memory = sdla_test_memregion(hw, MAX_SIZEOF_S514_MEMORY);
		if(hwcpu->memory < (256 * 1024)) {
					hw->devname, hwcpu->memory);
			return -EINVAL;
		if (conf) conf->irq = hwcpu->irq;
		if (conf) conf->irq = hwcpu->irq;
				hw->devname, hwcard->type);
		return -EINVAL;
	DEBUG_EVENT("%s: found %luK bytes of on-board memory\n",
		hw->devname, hwcpu->memory / 1024);
		err = sdla_load(hw, conf->data, conf->data_size);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->u_isa.pclk) {
	switch (hwcard->type) {
 * Prepare boot-time firmware configuration data.
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	if (!sfminfo->datasize) return 0;	/* nothing to do */
	if (sdla_mapmem(hw, sfminfo->dataoffs) != 0)
		return -EIO;
	if (hwcard->type == SDLA_S514){
		offset = sfminfo->dataoffs;
		offset = sfminfo->dataoffs - (unsigned long)hwcard->u_isa.vector;
	sdla_bus_set_region_1(hw, 0x00, 0x00, sfminfo->datasize);
	switch (sfminfo->codeid) {
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (!hwcard->u_isa.ioport && (hwcard->type != SDLA_S514)) return -EFAULT;
 	switch (hwcard->type) {
		return -EINVAL;
	switch (hwcard->type) {
		hwcard->u_isa.regs[0] = 0x10;
		hwcard->u_isa.regs[3] = 0x01;
			hwcard->u_isa.regs[0] = 0;
		else return -EIO;
		tmp = hwcard->u_isa.regs[0] | 0x09;	/* set bits 0 and 3 */
		hwcard->u_isa.regs[0] = tmp;		/* update mirror */
			return -EIO;
		tmp = hwcard->u_isa.regs[0] | 0x02;
		hwcard->u_isa.regs[0] = tmp;		/* update mirror */
			return -EIO;
		tmp = hwcard->u_isa.regs[0] | 0x02;
		hwcard->u_isa.regs[0] = tmp;	/* update mirror */
			return -EIO;
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (strcmp(sfm->signature, SFM_SIGNATURE)) {
			hw->devname);
		return -EINVAL;
	if (sfm->version != SFM_VERSION) {
			hw->devname, sfm->version, SFM_VERSION);
		return -EINVAL;
	if ((len - offsetof(sfm_t, image) != sfm->info.codesize) ||
		(sdla_checksum((void*)&sfm->info,
		sizeof(sfm_info_t) + sfm->info.codesize) != sfm->checksum)) {
		DEBUG_EVENT("%s: firmware corrupted!\n", hw->devname);
		return -EINVAL;
	DEBUG_EVENT("%s: loading %s (ID=%u)...\n", hw->devname,
		(sfm->descr[0] != '\0') ? sfm->descr : "unknown firmware",
		sfm->info.codeid);
	if (hwcard->type == SDLA_S514){
			hw->devname, SDLA_GET_CPU(hwcpu->cpu_no));
	     (i < SFM_MAX_SDLA) && (sfm->info.adapter[i] != hwcard->type);
			hw->devname, hwcard->type);
		return -EINVAL;
	/* Make sure there is enough on-board memory */
	if (hwcpu->memory < sfm->info.memsize){
		DEBUG_EVENT("%s: firmware needs %u bytes of on-board memory!\n",
			hw->devname, sfm->info.memsize);
		return -EINVAL;
	if (sdla_poke(hw, sfm->info.codeoffs, sfm->image, sfm->info.codesize)) {
			hw->devname);
		return -EIO;
	if (sdla_peek(hw, sfm->info.codeoffs, test, 100)){
				hw->devname);
		return -EIO;
	if (strncmp(sfm->image, test, 100) != 0){
			hw->devname);
		return -EIO;
	/* Prepare boot-time configuration data and kick-off CPU */
	sdla_bootcfg(hw, &sfm->info);
	if (sfm->info.codeid != SFID_BSCMP514 && sfm->info.codeid != SFID_POS){
		if (sdla_start(hw, sfm->info.startoffs)) {
				hw->devname);
			return -EIO;
        if (sdla_mapmem(hw, sfm->info.winoffs) || sdla_inten(hw)) {
			hw->devname);
		return -EIO;
	hwcpu->fwid = sfm->info.codeid;		/* set firmware ID */
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
        if(!hwcard->u_isa.ioport && (hwcard->type != SDLA_S514))
                return -EFAULT;
	switch (hwcard->type) {
		hwcard->u_isa.regs[0] = 0x08;
		hwcard->u_isa.regs[1] = 0xFF;
			hwcard->u_isa.regs[i] = 0
		hwcard->u_isa.regs[0] = 0;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type) {
		if (!hwcard->u_isa.ioport){
			return -EFAULT;
		hwcard->u_isa.regs[0] = 0x08;
		hwcard->u_isa.regs[1] = 0xFF;
	 	if (!hwcard->u_isa.ioport){
                        return -EFAULT;
			hwcard->u_isa.regs[i] = 0
	 	if (!hwcard->u_isa.ioport){
                        return -EFAULT;
		hwcard->u_isa.regs[0] = 0;
        	CPU_no = hwcpu->cpu_no;
	        int_config &= (hwcpu->cpu_no == SDLA_CPU_A) ? ~PCI_DISABLE_IRQ_CPU_A : ~PCI_DISABLE_IRQ_CPU_B;
		if (hwcpu->cpu_no == SDLA_CPU_A){
		if (hwcpu->status & SDLA_MEM_MAPPED){
			sdla_bus_space_unmap(hw, hwcpu->dpmbase, MAX_SIZEOF_S514_MEMORY);
			hwcpu->status &= ~SDLA_MEM_MAPPED;
		if (hwcpu->status & SDLA_IO_MAPPED){
			sdla_bus_space_unmap(hw, hwcard->u_isa.vector, 16);
			hwcpu->status &= ~SDLA_IO_MAPPED;
		if (hw->status & SDLA_MEM_RESERVED){
			sdla_release_mem_region(hw, hw->mem_base_addr, GSI_PCI_MEMORY_SIZE);
			hw->status &= ~SDLA_MEM_RESERVED;
		if (hw->status & SDLA_MEM_MAPPED){
			sdla_bus_space_unmap(hw, hw->dpmbase, GSI_PCI_MEMORY_SIZE);
			hw->status &= ~SDLA_MEM_MAPPED;
		switch(hwcard->adptr_type){
			if (hwcpu->used > 1){
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type) {
			hwcard->u_isa.regs[0] = 0x06;
		else return -EIO;
		tmp = hwcard->u_isa.regs[0] | 0x04;
		hwcard->u_isa.regs[0] = tmp;		/* update mirror */
			return -EIO;
		tmp = hwcard->u_isa.regs[0] | 0x10;
		hwcard->u_isa.regs[0] = tmp;		/* update mirror */
			return -EIO;
		return -EINVAL;
	WAN_ASSERT(hw->hwcard == NULL);
	card = hw->hwcard;
	switch (card->type){
			sdla_isa_write_1(hw, 0x00, hw->regs[0] & ~0x04);
			hw->regs[0] &= ~0x04;
		else return -EIO;
		tmp = hw->regs[0] & ~0x04;
		hw->regs[0] = tmp;			/* update mirror */
			return -EIO;
		tmp = hw->regs[0] & ~0x10;
		hw->regs[0] = tmp;			/* update mirror */
			return -EIO;
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch(hwcard->type){
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type){
			tmp = hwcard->u_isa.regs[0] & ~0x04;
			hwcard->u_isa.regs[0] = tmp;
		else return -EIO;
			tmp = hwcard->u_isa.regs[0] & ~0x08;
			hwcard->u_isa.regs[0] = tmp;
		return -EINVAL;
	WAN_ASSERT(hw->hwcard == NULL);
	card = hw->hwcard;
	switch (card->type) {
			hw->regs[0] = 0x10;
		else return -EIO;
		else return -EIO;
		else return -EIO;
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	len += mbox->wan_data_len;
				hw->devname,mbox->wan_command);
	/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &value); */
				hw->devname);
	mbox->wan_opp_flag = 0x00;
					hw->devname, mbox->wan_command);
	if (mbox->wan_data_len < (sizeof(wan_mbox_t) - sizeof(wan_cmd_t))){
			  mbox->wan_data, mbox->wan_data_len);
				hw->devname,mbox->wan_data_len);
				hw->devname,mbox->wan_command);
	return mbox->wan_return_code;	
 * o Busy-wait until flag is reset.
	/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &value); */
						hw->devname);
	/* Sangoma ISA card -> sdla_bus_write_1(hw, offset, 0x01); */
	/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &value); */
				(unsigned long)(SYSTEM_TICKS-tstop+EXEC_TIMEOUT),
		/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &value); */
 * Care should be taken when crossing dual-port memory window boundary.
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (addr + len > hwcpu->memory)	/* verify arguments */
		return -EINVAL;
	switch(hwcard->type){
		unsigned long oldvec = (unsigned long)hwcard->u_isa.vector;
		unsigned winsize = hwcpu->dpmsize;
			curvec = addr - curpos;   /* current window vector */
			curlen = (len > (winsize - curpos)) ?
						(winsize - curpos) : len;
			len        -= curlen;
			__FUNCTION__,hwcard->type);
		err = -EINVAL;
 * Read data from adapter's memory to a data buffer in 4-byte chunks.
 * Note that we ensure that the SDLA memory address is on a 4-byte boundary
 * before we begin moving the data in 4-byte chunks.
	/* byte copy data until we get to a 4-byte boundary */
		len --;
	/* copy data in 4-byte chunks */
		len -= 4;
		len --;
 * Care should be taken when crossing dual-port memory window boundary.
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (addr + len > hwcpu->memory){	/* verify arguments */
		return -EINVAL;
	switch (hwcard->type){
		unsigned long oldvec = (unsigned long)hwcard->u_isa.vector;
		unsigned winsize = hwcpu->dpmsize;
			curvec = addr - curpos;     /* current window vector */
			curlen = (len > (winsize - curpos)) ?
				(winsize - curpos) : len;
			len        -= curlen;
			__FUNCTION__,hwcard->type);
		err = -EINVAL;
 * Write from a data buffer to adapter's memory in 4-byte chunks.
 * Note that we ensure that the SDLA memory address is on a 4-byte boundary
 * before we begin moving the data in 4-byte chunks.
	/* byte copy data until we get to a 4-byte boundary */
		len --;
	/* copy data in 4-byte chunks */
		len -= 4;
		len --;
	/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &tmp); */
	/* Sangoma ISA card -> sdla_bus_write_1(hw, offset, tmp); */
	/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &tmp); */
	/* Sangoma ISA card -> sdla_bus_write_1(hw, offset, tmp); */
/****** Hardware-Specific Functions *****************************************/
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		if (pci_slot_ar[i] == hwcard->u_pci.slot_no){
			DEBUG_EVENT( "%s: Critical Error !!!\n",hw->devname);
					hw->devname);
		pci_slot_ar[i] = hwcard->u_pci.slot_no;
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	len = hwcpu->dpmsize;
	for(; len && (value == 0xFF); --len){ 
	int i, err = -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type){
		return -EINVAL;
		hwcpu->dpmbase = (sdla_mem_handle_t)phys_to_virt(opt[i]);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		hwcard->u_isa.regs[i] = 0;
	switch (hwcard->type) {
	return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type){
			hwcard->u_isa.regs[2] = tmp;
		else return -EINVAL;
			tmp = (hwcard->u_isa.regs[0] & 0x8F) | ((addr >> 9) & 0x70);
			hwcard->u_isa.regs[0] = tmp;
		else return -EINVAL;
				return -EIO;
			hwcard->u_isa.regs[2] = tmp;
		else return -EINVAL;
			hwcard->u_isa.regs[2] = tmp;
		else return -EINVAL;
		return -EINVAL;
	hwcard->u_isa.vector = (sdla_mem_handle_t)(addr & 0xFFFFE000L);
        for (i = 0, w_ptr = hw->dpmbase; i < len_w; ++i, ++w_ptr)
	for (i = 0, w_ptr = hw->dpmbase; i < len_w; ++i, ++w_ptr)
        for (i = 0, w_ptr = hw->dpmbase; i < len_w; ++i, ++w_ptr)
        for (i = 0, w_ptr = hw->dpmbase; i < len_w; ++i, ++w_ptr)
        for (i = 0, w_ptr = hw->dpmbase; i < len_w; ++i, ++w_ptr)
 * Test adapter on-board memory.
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	for (memsize = 0, winsize = hwcpu->dpmsize;
	hwcpu->memory = memsize;
 * Set up adapter dual-port memory window. 
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
		return -EINVAL;
	/* Initialize adapter and test on-board memory segment by segment.
	if (sdla_memtest(hw) < hwcpu->dpmsize) {/* less than window size */
		return -EIO;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (!sdla_get_option_index(s502_port_options, hwcard->u_isa.ioport))
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		return -ENODEV;
	hwcard->u_isa.regs[0] = 0x08;
	hwcard->u_isa.regs[1] = 0xFF;
	i = sdla_get_option_index(s502a_dpmbase_options, virt_to_phys((void*)hwcpu->dpmbase));
		return -EINVAL;
	tmp = s502a_hmcr[i - 1];
	switch (hwcpu->dpmsize) {
		return -EINVAL;
	/* Setup dual-port memory window (this also enables memory access) */
	hwcard->u_isa.regs[1] = tmp;
	hwcard->u_isa.regs[0] = 0x08;
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	card = hwcpu->hwcard;
	if (!sdla_get_option_index(s502_port_options, card->u_isa.ioport))
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		return -ENODEV;
	i = sdla_get_option_index(s508_dpmbase_options, virt_to_phys((void*)hwcpu->dpmbase));
		return -EINVAL;
	tmp = s502e_hmcr[i - 1];
	switch (hwcpu->dpmsize) {
		return -EINVAL;
	/* Setup dual-port memory window */
	hwcard->u_isa.regs[1] = tmp;
	hwcard->u_isa.regs[0] = 0x02;
	return (tmp & 0x02) ? 0 : -EIO;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (!sdla_get_option_index(s503_port_options, hwcard->u_isa.ioport))
 * ---------------------------------------------------------------------------
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		return -ENODEV;
	i = sdla_get_option_index(s508_dpmbase_options, virt_to_phys((void*)hwcpu->dpmbase));
		return -EINVAL;
	tmp = s502e_hmcr[i - 1];
	switch (hwcpu->dpmsize) {
		return -EINVAL;
	/* Setup dual-port memory window */
	hwcard->u_isa.regs[1] = tmp;
	hwcard->u_isa.regs[0] = 0x02;	/* update mirror */
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (!sdla_get_option_index(s508_port_options, hwcard->u_isa.ioport))
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		return -ENODEV;
	i = sdla_get_option_index(s507_dpmbase_options, virt_to_phys((void*)hwcpu->dpmbase));
		return -EINVAL;
	tmp = s507_hmcr[i - 1];
	switch (hwcpu->dpmsize) {
		return -EINVAL;
	hwcard->u_isa.regs[0] = 0x01;
		return -EIO;
	/* Setup dual-port memory window */
	hwcard->u_isa.regs[1] = tmp;
	tmp = hwcard->u_isa.regs[0] | 0x04;
	if (hwcpu->irq) {
		i = sdla_get_option_index(s508_irq_options, hwcpu->irq);
		if (i) tmp |= s507_irqmask[i - 1];
	hwcard->u_isa.regs[0] = tmp;		/* update mirror */
	return (tmp & 0x08) ? 0 : -EIO;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		return -ENODEV;
	i = sdla_get_option_index(s508_dpmbase_options, virt_to_phys((void*)hwcpu->dpmbase));
		return -EINVAL;
	tmp = s508_hmcr[i - 1];
	hwcard->u_isa.regs[1] = tmp;
	hwcard->u_isa.regs[0] = 0x04;		/* update mirror */
	return (tmp & 0x04) ? 0 : -EIO;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	hwcpu->status |= SDLA_MEM_MAPPED;
	hwcpu->status |= SDLA_IO_MAPPED;
	if (!sdla_get_option_index(s508_port_options, hwcard->u_isa.ioport)){
		return -EINVAL;
		return -EINVAL;
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		   (hwcpu->cpu_no == SDLA_CPU_A) ? PCI_MEM_BASE0_DWORD : 
			    	PCI_MEM_BASE1_DWORD, (u32*)&hwcpu->mem_base_addr);
	if (!hwcpu->mem_base_addr){
		if(hwcpu->cpu_no == SDLA_CPU_B){
					hw->devname);
					hw->devname);
		return -EINVAL;
				hw->devname, (unsigned long)hwcpu->mem_base_addr);
			(hwcpu->cpu_no == SDLA_CPU_A) ? PCI_MAP0_DWORD : PCI_MAP1_DWORD, &ut_u32);
			(hwcpu->cpu_no == SDLA_CPU_A) ? PCI_MAP0_DWORD : PCI_MAP1_DWORD,
	/* the INTPIN must not be 0 - if it is, then the S514 adapter is not */
			       hw->devname);
	sdla_pci_read_config_byte(hw, PCI_INT_LINE_BYTE, (u8*)&hwcpu->irq);
        if(hwcpu->irq == PCI_IRQ_NOT_ALLOCATED) {
			hw->devname);
                return -EINVAL;
	hwcpu->irq = hwcard->u_pci.pci_dev->irq;
	ut_u32 |= (hwcpu->cpu_no == SDLA_CPU_A) ?
			hw->devname);
		return -EINVAL;
	hwcpu->irq = hwcard->u_pci.pci_dev->irq;
		hw->devname, hwcpu->irq);
	hwcpu->status |= SDLA_PCI_ENABLE;
	sdla_bus_space_map(hw, 0x0, MAX_SIZEOF_S514_MEMORY, &hwcpu->dpmbase);
	if (!hwcpu->dpmbase){ 
					hw->devname);
		return -EINVAL;
	sdla_bus_space_map(hw, S514_CTRL_REG_BYTE, 16, &hwcard->u_isa.vector);
	if (!hwcard->u_isa.vector){ 
		sdla_bus_space_unmap(hw, hwcpu->dpmbase, MAX_SIZEOF_S514_MEMORY);
					hw->devname);
		hwcpu->dpmbase=0;
		return -EINVAL;
	hwcpu->status |= SDLA_MEM_MAPPED;
	hwcard->u_isa.ioh = hwcard->u_isa.vector;
	hwcpu->status |= SDLA_IO_MAPPED;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	sdla_pci_read_config_dword(hw, PCI_IO_BASE_DWORD, (u32*)&hw->mem_base_addr);
	if(!hw->mem_base_addr) {
					hw->devname);
		return -EINVAL;
				hw->devname, (unsigned long)hwcpu->mem_base_addr);
	sdla_pci_read_config_byte(hw, PCI_INT_LINE_BYTE, (u8*)&hwcpu->irq);
        if(hwcpu->irq == PCI_IRQ_NOT_ALLOCATED) {
			hw->devname);
                return -EINVAL;
	hwcpu->irq = hwcard->u_pci.pci_dev->irq;
				hw->devname, hwcpu->irq);
			hw->devname);
		return -EINVAL;
	hw->status |= SDLA_PCI_ENABLE;
	hw->status |= SDLA_MEM_MAPPED;
	if (sdla_request_mem_region(hw, hw->mem_base_addr, 
				hw->devname);
		return -EINVAL;
	hw->status |= SDLA_MEM_RESERVED;
	hw->memory=GSI_PCI_MEMORY_SIZE;
	sdla_bus_space_map(hw, 0x0, GSI_PCI_MEMORY_SIZE, &hw->dpmbase);
        if(!hw->dpmbase) {
			hw->devname);
                return -EINVAL;
	int		err=-EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	hwcpu->status |= SDLA_PCI_ENABLE;
	switch (hwcard->type){ 
		hwcpu->memory = GSI_PCI_MEMORY_SIZE;
		hwcpu->cpu_no = SDLA_CPU_A;
		switch(hwcard->adptr_type){
			if (hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
				hwcpu->memory = AFT_PCI_MEM_SIZE; 
				hwcpu->memory = AFT2_PCI_MEM_SIZE; 
			hwcpu->memory = AFT4_PCI_MEM_SIZE; 
			hwcpu->memory = AFT8_PCI_MEM_SIZE; 
			hwcpu->memory = AFT2_PCI_MEM_SIZE; 
			hwcpu->memory = AFT_PCI_MEM_SIZE; 
			__FUNCTION__,__LINE__,hwcard->type);
		return -EINVAL;
				(hwcpu->cpu_no == SDLA_CPU_A) ? 
				&hwcpu->mem_base_addr);
	if (!hwcpu->mem_base_addr){
		if(hwcpu->cpu_no == SDLA_CPU_B){
				hw->devname);
				hw->devname);
		err = -EINVAL;
			hw->devname);
		return -EINVAL;
	hwcpu->status |= SDLA_PCI_ENABLE;
	if (!(hwcpu->status & SDLA_MEM_RESERVED)){
		err = pci_request_region(hwcard->u_pci.pci_dev, (hwcpu->cpu_no == SDLA_CPU_A)?0:1 ,reserve_name);
				hwcpu->mem_base_addr, 
				hwcpu->memory,
				hw->devname,(hwcpu->cpu_no == SDLA_CPU_A)?0:1);
			err = -EINVAL;
		hwcpu->status |= SDLA_MEM_RESERVED;
	if((err = pci_set_dma_mask(hwcard->u_pci.pci_dev, DMA_32BIT_MASK))) {
				hw->devname);
		err = -EINVAL;
				(hwcpu->cpu_no == SDLA_CPU_A) ? 
				&hwcpu->mem_base_addr);
	if (!hwcpu->mem_base_addr){
		if(hwcpu->cpu_no == SDLA_CPU_B){
				hw->devname);
				hw->devname);
		err = -EINVAL;
	if (!(hwcpu->status & SDLA_MEM_MAPPED)){
		sdla_bus_space_map(hw, 0x0, hwcpu->memory, &hwcpu->dpmbase);
		if (!hwcpu->dpmbase){
				hw->devname);
			err = -EINVAL;
		hwcpu->status |= SDLA_MEM_MAPPED;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type){ 
		if (hwcpu->status & SDLA_MEM_MAPPED){
					hwcpu->dpmbase, 
					hwcpu->memory);
			hwcpu->status &= ~SDLA_MEM_MAPPED;
		if (hwcpu->status & SDLA_MEM_RESERVED){
			pci_release_region(hwcard->u_pci.pci_dev,(hwcpu->cpu_no == SDLA_CPU_A)?0:1);
					hwcpu->mem_base_addr,
					hwcpu->memory);
			hwcpu->status &= ~SDLA_MEM_RESERVED;
		if (hwcpu->status & SDLA_PCI_ENABLE){
			hwcpu->status &= ~SDLA_PCI_ENABLE;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
				hw->devname, (unsigned long)hwcpu->mem_base_addr);
	hwcpu->irq = hwcard->u_pci.pci_dev->irq;
	sdla_pci_read_config_byte(hw, PCI_INT_LINE_BYTE, (u8*)&hwcpu->irq);
        if(hwcpu->irq == PCI_IRQ_NOT_ALLOCATED) {
			hw->devname);
                return -EINVAL;
				hw->devname, hwcpu->irq);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	if (conf->S514_CPU_no[0] == 'B'){
	switch(conf->card_type){
		if (hwcpu->cpu_no == cpu_no &&
		    conf->card_type == WANOPT_AFT &&
		    hwcpu->hwcard->cfg_type == WANOPT_AFT101) {
			   and old config file for A101/2-SH */
			conf->config_id = WANCONFIG_AFT_TE1;
			conf->card_type = WANOPT_AFT104;
			conf->fe_cfg.line_no=1;
		if (hwcpu->cpu_no == cpu_no &&
		    conf->card_type == WANOPT_AFT &&
		    hwcpu->hwcard->cfg_type == WANOPT_AFT102) {
			   and old config file for A101/2-SH */
			conf->config_id = WANCONFIG_AFT_TE1;
			conf->card_type = WANOPT_AFT104;
				conf->fe_cfg.line_no=1;
				conf->fe_cfg.line_no=2;		
		if (conf->config_id == WANCONFIG_AFT_TE1){
			if (hwcpu->cpu_no == cpu_no &&
			    hw->line_no == conf->fe_cfg.line_no-1 &&
       	          (hwcpu->hwcard->cfg_type == WANOPT_AFT101 ||
			    hwcpu->hwcard->cfg_type == WANOPT_AFT102 ||
			    hwcpu->hwcard->cfg_type == WANOPT_AFT104 ||
			    hwcpu->hwcard->cfg_type == WANOPT_AFT108)) {
			if (hwcpu->cpu_no == cpu_no &&
			    hwcpu->hwcard->cfg_type == conf->card_type){
		if (hwcpu->hwcard->cfg_type == WANOPT_USB_ANALOG){
	if (conf && conf->S514_CPU_no[0] == 'B'){
	}else if (conf && conf->S514_CPU_no[0] == 'A'){
		WAN_ASSERT_RC(hw->hwcpu == NULL, NULL);
		hwcpu = hw->hwcpu;
			if (hw->used < hw->max_port_no){
		if (conf->auto_hw_detect){
		switch(conf->card_type){
				if (hwcpu->hwcard->u_isa.ioport == conf->ioport){ 
				if ((hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no) && 
			    	    (hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no) &&
				    (hw->cfg_type == conf->card_type)){
				if ((hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no) && 
			    	    (hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no) &&
				    (hwcpu->hwcard->cfg_type == conf->card_type) &&
				    (hw->line_no == conf->fe_cfg.line_no-1)){
				if (IS_56K_MEDIA(&conf->fe_cfg) && 
				    hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no && 
			    	    hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no &&
				    hwcpu->hwcard->cfg_type == WANOPT_AFT_56K) {
					conf->card_type = WANOPT_AFT_56K;
					conf->config_id = WANCONFIG_AFT_56K;
					conf->fe_cfg.line_no=1;
				}else if ((hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no) && 
					  (hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no) &&
					  (hwcpu->cpu_no == cpu_no) &&
    					  /*(hw->line_no == conf->comm_port) &&*/
					  (hwcpu->hwcard->cfg_type == conf->card_type)){
				if (conf->card_type == WANOPT_AFT &&
				    hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no && 
			    	    hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no &&
				    hwcpu->hwcard->cfg_type == WANOPT_AFT101) {
					   and old config file for A101/2-SH */
					conf->config_id = WANCONFIG_AFT_TE1;
					conf->card_type = WANOPT_AFT104;
					conf->fe_cfg.line_no=1;
				if (conf->card_type == WANOPT_AFT &&
				    hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no && 
			    	    hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no &&
				    hwcpu->hwcard->cfg_type == WANOPT_AFT102) {
					   and old config file for A101/2-SH */
					conf->config_id = WANCONFIG_AFT_TE1;
					conf->card_type = WANOPT_AFT104;
						conf->fe_cfg.line_no=1;
						conf->fe_cfg.line_no=2;		
				if (conf->card_type == WANOPT_S51X &&
				    IS_56K_MEDIA(&conf->fe_cfg) && 
				    hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no && 
				    hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no &&
				    hwcpu->hwcard->cfg_type == WANOPT_AFT_56K) {
					conf->card_type = WANOPT_AFT_56K;
					conf->config_id = WANCONFIG_AFT_56K;
					conf->fe_cfg.line_no=1;
				if ((hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no) && 
			    	    (hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no) &&
			    	    (hwcpu->cpu_no == cpu_no) &&
				    (hwcpu->hwcard->cfg_type == conf->card_type)){
				if ((hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no) && 
			    	    (hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no) &&
				    (hw->line_no == conf->fe_cfg.line_no-1) &&
				    (hw->cfg_type == conf->card_type)){
				if ((hwcpu->hwcard->u_pci.slot_no == conf->PCI_slot_no) && 
			    	    (hwcpu->hwcard->u_pci.bus_no == conf->pci_bus_no) &&
				    (hw->line_no == conf->fe_cfg.line_no-1)){
//OLD				if (hwcpu->hwcard->u_usb.devnum == conf->usb_devnum){
				if (strcmp(WP_USB_BUSID(hwcpu->hwcard), conf->usb_busid) == 0) {
						devname, conf->card_type);
		switch(hwcpu->hwcard->adptr_type){
			conf->comm_port = 0;
			conf->fe_cfg.line_no = 0;
			if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > MAX_BRI_LINES){
						devname, conf->fe_cfg.line_no, MAX_BRI_LINES);
			conf->fe_cfg.line_no--;
			conf->comm_port = 0;
			if (conf->card_type == WANOPT_AFT_ISDN) {
				if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > A700_MAX_BRI_LINES){
							devname, conf->fe_cfg.line_no, A700_MAX_BRI_LINES);
				conf->fe_cfg.line_no--;
				conf->comm_port = 0;
			} else if(conf->card_type == WANOPT_AFT_ANALOG) {
				conf->fe_cfg.line_no = 4;
				conf->comm_port = 1;
				DEBUG_EVENT("%s: Invalid configuration option for AFT-A700 card\n",
			if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
				conf->comm_port = 0;
				conf->fe_cfg.line_no = 0;
			if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > 2){
						devname, conf->fe_cfg.line_no);
			conf->fe_cfg.line_no--;
			conf->comm_port = 0;
			if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > 4){
						devname, conf->fe_cfg.line_no);
			conf->fe_cfg.line_no--;
			conf->comm_port = 0;
			if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > 8){
						devname, conf->fe_cfg.line_no);
			conf->fe_cfg.line_no--;
			conf->comm_port = 0;
			if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > 2){
						devname, conf->fe_cfg.line_no);
			conf->fe_cfg.line_no--;
			conf->comm_port = 0;
			if (conf->fe_cfg.line_no < 1 || conf->fe_cfg.line_no > 4){
						devname, conf->fe_cfg.line_no);
			conf->fe_cfg.line_no--;
			conf->comm_port = 0;
			conf->fe_cfg.line_no = 0;
			conf->comm_port = 0;
		if (hw->hwport[conf->comm_port].used == 0){
		switch(conf->card_type){
                	        devname, conf->ioport, COMPORT_DECODE(conf->comm_port));
			switch(hwcpu->hwcard->adptr_type){
				if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
						SDLA_DECODE_CARDTYPE(conf->card_type),
						conf->pci_bus_no, 
						conf->PCI_slot_no,
						conf->S514_CPU_no[0]);				
						SDLA_DECODE_CARDTYPE(conf->card_type),
						conf->pci_bus_no, 
						conf->PCI_slot_no,
						conf->S514_CPU_no[0],
						conf->fe_cfg.line_no);				
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->pci_bus_no, 
					conf->PCI_slot_no,
					conf->S514_CPU_no[0],
					conf->fe_cfg.line_no);
						SDLA_DECODE_CARDTYPE(conf->card_type),
						conf->pci_bus_no, 
						conf->PCI_slot_no, conf->comm_port);
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->pci_bus_no, 
					conf->PCI_slot_no,
					conf->S514_CPU_no[0]);
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->usb_busid);
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->usb_devnum);
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->pci_bus_no, 
					conf->PCI_slot_no,
					conf->S514_CPU_no[0]);
		switch(conf->card_type){
                	        devname, conf->ioport, COMPORT_DECODE(conf->comm_port));
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->pci_bus_no, 
					conf->PCI_slot_no, 
					conf->S514_CPU_no[0],
					COMPORT_DECODE(conf->comm_port));
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->pci_bus_no, 
					conf->PCI_slot_no); 
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->pci_bus_no, 
					conf->PCI_slot_no,
					conf->S514_CPU_no[0],
					conf->fe_cfg.line_no);
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->usb_busid);
					SDLA_DECODE_CARDTYPE(conf->card_type),
					conf->usb_devnum);
					SDLA_DECODE_CARDTYPE(conf->card_type));
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch (hwcard->type){ 
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	switch(hwcard->adptr_type){
	return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (hwcard->adptr_type == S5145_ADPTR_1_CPU_56K){
	return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		if (hwcard->adptr_type != S5144_ADPTR_1_CPU_T1E1 &&
		    hwcard->adptr_type != S5147_ADPTR_2_CPU_T1E1 &&
		    hwcard->adptr_type != S5148_ADPTR_1_CPU_T1E1){
				hw->devname,
				hwcard->adptr_name);
			return -EIO;
		hwcard->adptr_type = S5144_ADPTR_1_CPU_T1E1;
		if (hwcard->adptr_type != S5145_ADPTR_1_CPU_56K){
				hw->devname,
				hwcard->adptr_name);
			return -EIO;
		if (hwcard->adptr_type == S5145_ADPTR_1_CPU_56K ||
		    hwcard->adptr_type == S5144_ADPTR_1_CPU_T1E1 ||
		    hwcard->adptr_type == S5147_ADPTR_2_CPU_T1E1 ||
		    hwcard->adptr_type == S5148_ADPTR_1_CPU_T1E1){
				hw->devname,
				hwcard->adptr_name);
			return -EIO;
	WAN_ASSERT_RC(hw1->hwcpu == NULL, 0);
	WAN_ASSERT_RC(hw2->hwcpu == NULL, 0);
	hwcpu1 = hw1->hwcpu;
	hwcpu2 = hw2->hwcpu;
	if (hwcpu1->hwcard == hwcpu2->hwcard){
	if (hw1->hwcpu == hw2->hwcpu){
 * sdla_set_intrhand() - Change interrupt handler for ISA devices. 
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	adapter = device_get_softc(hwcard->u_pci.pci_dev);
			hwcard->u_pci.pci_dev,
			adapter->irq_res, 
			isr_func, arg, &hwcpu->irqh[line_no]);
			hwcard->u_pci.pci_dev,
			adapter->irq_res, 
			isr_func, arg, &hwcpu->irqh[line_no]);
				device_get_name(hwcard->u_pci.pci_dev), line_no,
	adapter = (sdladev_t*)hwcpu->sdla_dev;
	WAN_ASSERT(adapter->sc == NULL);
			adapter->dev,
			adapter->sc->irq_res, 
			&hwcpu->irqh[line_no]);
			adapter->dev,
			adapter->sc->irq_res, 
			&hwcpu->irqh[line_no]);
					device_get_name(adapter->dev), line_no,
	if (adapter->intr_arg[line_no].ready){
  		adapter->intr_arg[line_no].isr  = isr_func;
       		adapter->intr_arg[line_no].arg  = arg;
		return -EINVAL;
 * restore_intrhand() - Restore interrupt handler for ISA/PCI devices.
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard= hwcpu->hwcard;	
	adapter = device_get_softc(hwcard->u_pci.pci_dev);
			hwcard->u_pci.pci_dev,adapter->irq_res,hwcpu->irqh[line_no]);
				device_get_name(hwcard->u_pci.pci_dev), line_no,
		return -EINVAL;
	hwcpu->irqh[line_no] = NULL;
	adapter = (sdladev_t*)hwcpu->sdla_dev;
	WAN_ASSERT(adapter->sc == NULL);
	error = bus_teardown_intr(adapter->dev, adapter->sc->irq_res, hwcpu->irqh[line_no]);
					device_get_name(adapter->dev), line_no,
		return -EINVAL;
    	adapter->intr_arg[line_no].isr  = NULL;
    	adapter->intr_arg[line_no].arg  = NULL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		*(u16*)value = (u16)hwcard->hw_type;
		*(u16*)value = (u16)hwcard->type;
		*(sdla_mem_handle_t*)value = hwcpu->dpmbase;
		*(u32*)value = ((unsigned long)hwcpu->dpmbase + hwcpu->dpmsize - 1);
		*(u16*)value = (u16)hwcpu->dpmsize;
		*(u32*)value = hwcpu->memory;
		*(u16*)value = (u16)hwcpu->irq;
		*(u16*)value = (u16)hwcard->u_isa.ioport;
		*(u16*)value = (u16)hwcard->u_isa.io_range;
		*(u16*)value = (u16)hwcard->adptr_type;
		*(u16*)value = (u16)hwcpu->cpu_no;
		*(u16*)value = (u16)hwcard->u_pci.slot_no;
		*(u16*)value = (u16)hwcard->u_pci.bus_no;
		if (hwcard->u_pci.pci_dev){
			*(bus_dma_tag_t*)value = hwcard->u_pci.pci_dev->pa_dmat;
		*(u8*)value = hwcard->pci_extra_ver;
		*(u32*)value = hwcpu->mem_base_addr;
		*(u8*)value = hwcard->core_rev;
		*(u8*)value = hwcard->core_id;
		*(u32*)value = hwcpu->used;
		*(u8*)value = hwcard->adptr_subtype;
		*(u16*)value = hwcard->hwec_chan_no;
		*(u16*)value = (u16)hw->max_chans_num;
		*(u32*)value = hw->chans_map;   //hwcpu->port_map;
		*(u16*)value = (u16)hw->used;
		*(u16*)value = (u16)hw->hwcpu->reg_line[hw->line_no];
		*(u32*)value = (u32)hw->hwcpu->reg_line_map;
		*(u32*)value = hwcard->recovery_clock_flag;
		*(u32*)value = hwcpu->lines_info[hw->cfg_type].usage;
	WAN_ASSERT(hw->hwcpu == NULL);
	*cnt = hw->hwcpu->lines_info[hw->adptr_type].total_line_no;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		hwcard->recovery_clock_flag = *(u32*)value;
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	*phwcard = hwcpu->hwcard;
	if (hw->hwport[port].hwprobe){
		*hwinfo = hw->hwport[port].hwprobe->hw_info;
 * Calculate 16-bit CRC using CCITT polynomial.
	for (; len; --len, ++buf) {
	WAN_ASSERT2(hw->hwcpu == NULL, 0);
	hwcpu = hw->hwcpu;
	WAN_ASSERT2(hwcpu->hwcard == NULL, 0);
	hwcard = hwcpu->hwcard;
	if (!(hwcpu->status & SDLA_IO_MAPPED)) return 0;
	*value = readb ((u8*)hwcard->u_isa.vector + offset);
	*value = bus_space_read_1(hwcpu->hwcard->memt, hwcard->u_isa.vector, offset);
	*value = wp_readb((hwcard->u_isa.vector + offset));
	*value = READ_REGISTER_UCHAR((PUCHAR)((PUCHAR)hwcard->u_isa.vector + offset));
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	if (!(hwcpu->status & SDLA_IO_MAPPED)) return 0;
	writeb ((u8*)hwcard->u_isa.vector+offset, value);
	bus_space_write_1(hwcpu->hwcard->memt, hwcard->u_isa.vector, offset, value);
	wp_writeb(value, hwcard->u_isa.vector + offset);
	WRITE_REGISTER_UCHAR((PUCHAR)((PUCHAR)hwcard->u_isa.vector + offset), value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	if (!(hwcpu->status & SDLA_MEM_MAPPED)) return 0;
	writeb(((u8*)hwcpu->dpmbase + offset), value);
	bus_space_write_1(hwcpu->hwcard->memt, hwcpu->dpmbase, offset, value);
	wp_writeb(value, hwcpu->dpmbase + offset);
	WRITE_REGISTER_UCHAR((PUCHAR)((PUCHAR)hwcpu->dpmbase + offset), value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	if (!(hwcpu->status & SDLA_MEM_MAPPED)) return 0;
	writew(((u8*)hwcpu->dpmbase + offset), value);
	bus_space_write_2(hwcpu->hwcard->memt, hwcpu->dpmbase, offset, value);
	wp_writew(value,hwcpu->dpmbase+offset);
	WRITE_REGISTER_USHORT((PUSHORT)((PUCHAR)hwcpu->dpmbase + offset), value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	if (!(hwcpu->status & SDLA_MEM_MAPPED)) return 0;
	*value = readb(((u8*)hwcpu->dpmbase + offset));
	*value = bus_space_read_1(hwcpu->hwcard->memt, hwcpu->dpmbase, offset); 
	*value = wp_readb((hwcpu->dpmbase + offset));
	*value = READ_REGISTER_UCHAR((PUCHAR)((PUCHAR)hwcpu->dpmbase + offset));
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	if (!(hwcpu->status & SDLA_MEM_MAPPED)) return 0;
	*value = readw(((u8*)hwcpu->dpmbase + offset));
	*value = bus_space_read_2(hwcpu->hwcard->memt, hwcpu->dpmbase, offset); 
	*value = readw(((unsigned char*)hwcpu->dpmbase+offset));
	*value = READ_REGISTER_USHORT((PUSHORT)((PUCHAR)hwcpu->dpmbase + offset));
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	*value = pci_read_config(hwcard->u_pci.pci_dev, reg, 4);
	*value = ci_cfgread(hwcard->u_pci.pci_dev, reg, 4);
	*value = pci_conf_read(hwcard->u_pci.pci_dev->pa_pc, hwcard->u_pci.pci_dev->pa_tag, reg);
	pci_read_config_dword(hwcard->u_pci.pci_dev, reg, value);
	pci_read_config_dword(hwcard->u_pci.pci_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	*value = pci_read_config(hwcard->u_pci.pci_dev, reg, 2);
	*value = pci_cfgread(hwcard->u_pci.pci_dev, reg, 2);
	tmp = pci_conf_read(hwcard->u_pci.pci_dev->pa_pc, hwcard->u_pci.pci_dev->pa_tag, reg);
	pci_read_config_word(hwcard->u_pci.pci_dev, reg, value);
	pci_read_config_word(hwcard->u_pci.pci_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	*value = pci_read_config(hwcard->u_pci.pci_dev, reg, 1);
	*value = pci_cfgread(hwcard->u_pci.pci_dev, reg, 1);
	tmp = pci_conf_read(hwcard->u_pci.pci_dev->pa_pc, hwcard->u_pci.pci_dev->pa_tag, reg);
	pci_read_config_byte(hwcard->u_pci.pci_dev, reg, value);
	pci_read_config_byte(hwcard->u_pci.pci_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	pci_write_config(hwcard->u_pci.pci_dev, reg, value, 4);
	pci_conf_write(hwcard->u_pci.pci_dev, reg, 4);
	pci_conf_write(hwcard->u_pci.pci_dev->pa_pc, hwcard->u_pci.pci_dev->pa_tag, reg, value); 
	pci_write_config_dword(hwcard->u_pci.pci_dev, reg, value);
	pci_write_config_dword(hwcard->u_pci.pci_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	pci_write_config(hwcard->u_pci.pci_dev, reg, value, 2);
	pci_conf_write(hwcard->u_pci.pci_dev, reg, value, 2);
	pci_conf_write(hwcard->u_pci.pci_dev->pa_pc, hwcard->u_pci.pci_dev->pa_tag, reg, value); 
	pci_write_config_word(hwcard->u_pci.pci_dev, reg, value);
	pci_write_config_word(hwcard->u_pci.pci_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	card = hwcpu->hwcard;
	pci_write_config(card->u_pci.pci_dev, reg, value, 1);
	pci_conf_write(card->u_pci.pci_dev, reg, value, 1);
	pci_conf_write(card->u_pci.pci_dev->pa_pc, card->u_pci.pci_dev->pa_tag, reg, value); 
	pci_write_config_byte(card->u_pci.pci_dev, reg, value);
	pci_write_config_byte(card->u_pci.pci_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	*value = pci_read_config(hwcard->u_pci.pci_bridge_dev, reg, 4);
	*value = ci_cfgread(hwcard->u_pci.pci_bridge_dev, reg, 4);
	*value = pci_conf_read(hwcard->u_pci.pci_bridge_dev->pa_pc, hwcard->u_pci.pci_bridge_dev->pa_tag, reg);
	pci_read_config_dword(hwcard->u_pci.pci_bridge_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	card = hwcpu->hwcard;
	*value = pci_read_config(card->u_pci.pci_bridge_dev, reg, 2);
	*value = ci_cfgread(card->u_pci.pci_bridge_dev, reg, 2);
	*value = pci_conf_read(card->u_pci.pci_bridge_dev->pa_pc, card->u_pci.pci_bridge_dev->pa_tag, reg);
	pci_read_config_word(card->u_pci.pci_bridge_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	*value = pci_read_config(hwcard->u_pci.pci_bridge_dev, reg, 1);
	*value = ci_cfgread(hwcard->u_pci.pci_bridge_dev, reg, 1);
	tmp = pci_conf_read(hwcard->u_pci.pci_bridge_dev->pa_pc, hwcard->u_pci.pci_bridge_dev->pa_tag, reg);
	pci_read_config_byte(hwcard->u_pci.pci_bridge_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	pci_write_config(hwcard->u_pci.pci_bridge_dev, reg, value, 4);
	pci_conf_write(hwcard->u_pci.pci_bridge_dev, reg, 4);
	pci_conf_write(hwcard->u_pci.pci_bridge_dev->pa_pc, hwcard->u_pci.pci_bridge_dev->pa_tag, reg, value); 
	pci_write_config_dword(hwcard->u_pci.pci_bridge_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	pci_write_config(hwcard->u_pci.pci_bridge_dev, reg, value, 1);
	pci_conf_write(hwcard->u_pci.pci_bridge_dev, reg, 1);
	pci_conf_write(hwcard->u_pci.pci_bridge_dev->pa_pc, hwcard->u_pci.pci_bridge_dev->pa_tag, reg, value); 
	pci_write_config_byte(hwcard->u_pci.pci_bridge_dev, reg, value);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	*value = inb (hwcard->u_isa.ioport + offset);
	*value = bus_space_read_1(hwcard->u_isa.iot, hwcard->u_isa.ioh, offset);
	*value = inb(hwcard->u_isa.ioport + offset);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	hwcard->u_isa.regs[offset] = value;
	outb (hwcard->u_isa.ioport + offset, value);
	bus_space_write_1(hwcard->u_isa.iot, hwcard->u_isa.ioh, offset, value);
	outb(value, hwcard->u_isa.ioport + offset);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	//wan_spin_lock(&hwcard->pcard_lock);
	wan_spin_lock(&hw->hwcpu->lines_info[hw->cfg_type].pcard_lock);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	//wan_spin_unlock(&hwcard->pcard_lock);
	wan_spin_unlock(&hw->hwcpu->lines_info[hw->cfg_type].pcard_lock);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	return wan_spin_trylock(&hwcard->pcard_ec_lock);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	wan_spin_lock(&hwcard->pcard_ec_lock);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	wan_spin_unlock(&hwcard->pcard_ec_lock);
	paddr	= seg->ds_addr;
	plen	= seg->ds_len;	
	if (paddr & (dma_descr->alignment-1)){
               	dma_descr->dma_offset = 
				dma_descr->alignment - 
				(paddr & (dma_descr->alignment-1));
				(unsigned long)paddr,dma_descr->dma_offset);
				dma_descr->dmat,
				dma_descr->dmam,
				(char*)dma_descr->dma_virt+dma_descr->dma_offset,
	dma_descr->dma_addr	= paddr;
	dma_descr->dma_len	= plen;
	wan_set_bit(SDLA_DMA_FLAG_READY, &dma_descr->flag);
				dma_descr->dma_addr,
				dma_descr->dma_len,
 * dma_alignment - value should be multiple 2,4
			&dma_descr->dmat);
					hw->devname,
		return -EINVAL;
		dma_descr_next->dmat		= dma_descr->dmat;
		dma_descr_next->alignment	= dma_alignment;
		dma_descr_next->max_len		= dma_max_len;
		wan_set_bit(SDLA_DMA_FLAG_INIT, &dma_descr_next->flag);
	if (!wan_test_bit(SDLA_DMA_FLAG_INIT, &dma_descr->flag)){
					hw->devname,
		return -EINVAL;
	err = bus_dma_tag_destroy(dma_descr->dmat);
					hw->devname, err);
		return -EINVAL;
		dma_descr_next->dmat		= 0;
		dma_descr_next->alignment	= 0;
		dma_descr_next->max_len		= 0;
		wan_clear_bit(SDLA_DMA_FLAG_INIT, &dma_descr_next->flag);
	err = bus_dmamap_create(dma_descr->dmat,0,&dma_descr->dmam);
					hw->devname,err);
		return -EINVAL;
	err = bus_dmamap_destroy(dma_descr->dmat,dma_descr->dmam);
					hw->devname,err);
		return -EINVAL;
	if (!wan_test_bit(SDLA_DMA_FLAG_INIT, &dma_descr->flag)){
					hw->devname, __FUNCTION__,__LINE__);
		return -EINVAL;
	err = bus_dmamem_alloc(	dma_descr->dmat,
				&dma_descr->dma_virt,
				&dma_descr->dmam);
	if (err || dma_descr->dma_virt == NULL){
					hw->devname, err);
		return -ENOMEM;
	err = bus_dmamap_load(	dma_descr->dmat,
				dma_descr->dmam,
				dma_descr->dma_virt,
				dma_descr->max_len,
				hw->devname, dma_descr->max_len, err);
				dma_descr->dmat,
				dma_descr->dma_virt,
				dma_descr->dmam);
		return -EINVAL;
	wan_set_bit(SDLA_DMA_FLAG_ALLOC, &dma_descr->flag);
	dma_descr->dma_virt = pci_alloc_consistent(	
					dma_descr->max_len,
					(dma_addr_t*)&dma_descr->dma_addr);
	if (dma_descr->dma_virt == NULL){
					hw->devname, err);
		return -ENOMEM;
	if (dma_descr->dma_addr & dma_descr->alignment){
		dma_descr->dma_offset = 
				dma_descr->alignment - 
				(dma_descr->dma_addr & dma_descr->alignment) +
		(u8*)dma_descr->dma_virt += dma_descr->dma_offset;
		dma_descr->dma_addr += dma_descr->dma_offset;
		dma_descr->dma_offset = 0;
	wan_set_bit(SDLA_DMA_FLAG_ALLOC, &dma_descr->flag);
	wan_set_bit(SDLA_DMA_FLAG_READY, &dma_descr->flag);
	if (!wan_test_bit(SDLA_DMA_FLAG_ALLOC, &dma_descr->flag)){
					hw->devname, __FUNCTION__,__LINE__);
	wan_clear_bit(SDLA_DMA_FLAG_READY, &dma_descr->flag);
	bus_dmamap_unload(dma_descr->dmat,dma_descr->dmam);
	bus_dmamem_free(dma_descr->dmat,dma_descr->dma_virt,dma_descr->dmam);
	if (dma_descr->dma_offset){
		(u8*)dma_descr->dma_virt-= dma_descr->dma_offset;
		dma_descr->dma_addr	-= dma_descr->dma_offset;
				dma_descr->max_len, 
				dma_descrdma_descr->dma_virt,
				dma_descr->dma_addr);
	wan_clear_bit(SDLA_DMA_FLAG_ALLOC, &dma_descr->flag);
	dma_descr->dma_virt = NULL;
	dma_descr->dma_addr = 0;
	err = bus_dmamap_load(	dma_descr->dmat,
				dma_descr->dmam,
				dma_descr->dma_virt,
				hw->devname, len, err);
		return -EINVAL;
	bus_dmamap_unload(dma_descr->dmat, dma_descr->dmam);
	WAN_ASSERT_VOID(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT_VOID(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	if (!wan_test_bit(SDLA_DMA_FLAG_READY, &dma_descr->flag)){
					hw->devname, __FUNCTION__,__LINE__);
		bcopy(buf, dma_descr->dma_virt, buflen);
	dma_descr->dma_offset	= 0;
	dma_descr->dma_addr = 
		cpu_to_le32(pci_map_single(hwcard->u_pci.pci_dev,buf,map_len,dir));
	if (dma_descr->dma_addr & (dma_descr->alignment-1)){
		dma_descr->dma_offset = 
			dma_descr->alignment - 
			(dma_descr->dma_addr & (dma_descr->alignment-1));
		dma_descr->dma_virt = buf + dma_descr->dma_offset;
		dma_descr->dma_addr += dma_descr->dma_offset;
		dma_descr->dma_virt	= buf;
		dma_descr->dma_offset	= 0;
	dma_descr->dma_addr = virt_to_phys(buf);
	if (dma_descr->dma_addr & (dma_descr->alignment-1)){
		dma_descr->dma_offset = 
			dma_descr->alignment - 
			(dma_descr->dma_addr & (dma_descr->alignment-1));
		dma_descr->dma_virt = buf + dma_descr->dma_offset;
		dma_descr->dma_addr = virt_to_phys(dma_descrt->dma_virt));
		dma_descr->dma_virt	= buf; 
		dma_descr->dma_offset	=0; 
	dma_descr->dma_len = buflen;
	dma_descr->dma_map_len	= map_len;
	WAN_ASSERT_VOID(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT_VOID(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	if (!wan_test_bit(SDLA_DMA_FLAG_READY, &dma_descr->flag)){
					hw->devname, __FUNCTION__,__LINE__);
	if (dma_descr->skb && dir == SDLA_DMA_POSTREAD){
		** data = wan_skb_put(dma_descr->skb, dma_descr->dma_len);*/
		data = wan_skb_tail(dma_descr->skb);
		bcopy(dma_descr->dma_virt, data, dma_descr->dma_len);
	if (dma_descr->dma_addr){
		dma_descr->dma_addr -= dma_descr->dma_offset;
		pci_unmap_single(	hwcard->u_pci.pci_dev, 
					dma_descr->dma_addr, 
					dma_descr->dma_map_len, 
	dma_descr->dma_addr	= 0;
	dma_descr->dma_addr	= 0;
	dma_descr->dma_len	= 0;
	dma_descr->dma_map_len	= 0;
	if (!wan_test_bit(SDLA_DMA_FLAG_READY, &dma_descr->flag)){
					hw->devname, __FUNCTION__,__LINE__);
		bus_dmamap_sync(dma_descr->dmat, dma_descr->dmam, dir);	
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	return cpu_to_le32(pci_map_single(hwcard->u_pci.pci_dev, buf, len, ctrl));
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	pci_unmap_single(hwcard->u_pci.pci_dev, buf, len, ctrl);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	return wan_test_and_set_bit(value, &hwcpu->lines_info[hw->cfg_type].fe_rw_flag);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	//return wan_test_bit(value, &hwcard->fe_rw_flag);
	return wan_test_bit(value, &hwcpu->lines_info[hw->cfg_type].fe_rw_flag);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	//wan_clear_bit(value, &hwcard->fe_rw_flag);
	wan_clear_bit(value, &hwcpu->lines_info[hw->cfg_type].fe_rw_flag);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	WAN_ASSERT(hwcpu->hwcard == NULL);
	hwcard = hwcpu->hwcard;
	wan_set_bit(value, &hwcpu->lines_info[hw->cfg_type].fe_rw_flag);
	WAN_ASSERT(hw->hwcpu == NULL);
	hwcpu = hw->hwcpu;
	if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
		switch(hwcpu->hwcard->adptr_type){
						hw->devname);
			return -EINVAL;
	}else if (hwcpu->hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
		switch(hwcpu->hwcard->core_id){
			switch(hwcpu->hwcard->adptr_type){
							hw->devname);
				return -EINVAL;
			switch(hwcpu->hwcard->adptr_type){
							hw->devname);
				return -EINVAL;
			switch(hwcpu->hwcard->adptr_type){
						hw->devname);
				return -EINVAL;		
						hw->devname);
		return -EINVAL;	
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
	if (hwcard->adptr_subtype == AFT_SUBTYPE_NORMAL){
		switch(hwcard->adptr_type){
						hw->devname, __LINE__);
			return -EINVAL;
	}else if (hwcard->adptr_subtype == AFT_SUBTYPE_SHARK){
		switch(hwcard->core_id){
			switch(hwcard->adptr_type){
							hw->devname, __LINE__);
				return -EINVAL;
			switch(hwcard->adptr_type){
							hw->devname);
				return -EINVAL;
			switch(hwcard->adptr_type){
						hw->devname, __LINE__);
				return -EINVAL;		
						hw->devname, __LINE__);
		return -EINVAL;	
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcpu = hw->hwcpu;
	hwcard = hwcpu->hwcard;
		if (hwcard->u_pci.pci_bridge_dev == NULL) return 0;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	if (hw->hwcpu->hwcard->hwec_chan_no == 0) return -EINVAL;
	return hw->hwcpu->hwcard->hwec_ind;
	hwcard->type = SDLA_USB;
	hwcard->cfg_type = WANOPT_USB_ANALOG;	/* temporary */
	switch(hwcard->adptr_type){
		DEBUG_EVENT("%s: %s USB-FXO module found (rev.%X)!\n",
				hwcard->adptr_name,
				hwcard->core_rev);
			sdladrv_callback.add_device(hw->devname, hw);
				hwcard->adptr_type,
				 udev->devnum, udev->dev.bus_id);
	hwcard = sdla_card_register(SDLA_USB_CARD, udev->devnum, 0, 0, udev->dev.bus_id); 
	hwcard->adptr_type	= adptr_type;
	hwcard->u_usb.usb_dev	= udev;
	hwcard->u_usb.usb_intf	= intf;
		return -EINVAL;
					udev->devnum, udev->dev.bus_id);
	hwcard = sdla_card_search(SDLA_USB_CARD, udev->devnum, 0, 0, udev->dev.bus_id);
		return -EINVAL;
	hwcpu = sdla_hwcpu_search(SDLA_USB_CARD, udev->devnum, 0, 0, 0, udev->dev.bus_id);
		return -EINVAL;
		return -EINVAL;
			sdladrv_callback.delete_device(hw->devname);
			DEBUG_EVENT("sdlausb: Sangoma USB devices doesn't support hot-plug functionality!\n");
	if (sdla_hwdev_common_unregister(hwcpu) == -EBUSY){
		return -EINVAL;
	if (sdla_hwcpu_unregister(hwcpu) == -EBUSY){
		return -EINVAL;
	if (sdla_card_unregister(hwcard) == -EBUSY){
		return -EINVAL;
	sdla_adapter_cnt.usb_adapters--;
	DEBUG_EVENT("sdlausb: USB-FXO module on %d detached (BusId %s)\n", 
					udev->devnum, udev->dev.bus_id);
	int cnum=0, err=-1, sec_port=0;
		WAN_ASSERT_RC(hw->hwcpu == NULL, -1);
		hwcpu = hw->hwcpu;
			if (hwcpu->hwcard->cfg_type == WANOPT_S51X) {
		hwinfo->card_model = hwcpu->hwcard->adptr_type;
		hwinfo->firmware_version = hwcpu->hwcard->core_rev;
		hwinfo->pci_bus_number = hwcpu->hwcard->u_pci.bus_no;
		hwinfo->pci_slot_number = hwcpu->hwcard->u_pci.slot_no;
		hwinfo->max_hw_ec_chans = hwcpu->hwcard->hwec_chan_no;
		hwinfo->port_number = hw->line_no+1;
			hwinfo->port_number++;
						AFT_PCITYPE_DECODE(hwcpu->hwcard),
						AFT_PCIBRIDGE_DECODE(hwcpu->hwcard),
						hwcpu->hwcard->cpld_rev);
						AFT_PCITYPE_DECODE(hwcpu->hwcard),
						AFT_PCIBRIDGE_DECODE(hwcpu->hwcard),
						hwcpu->hwcard->cpld_rev);
				return -EINVAL;
				return -EINVAL;
				return -EINVAL;
			sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "%s|BUS_IF=%s|BRDG=%s|C=%02d",str_dump, 
								AFT_PCITYPE_DECODE(hwcpu->hwcard),
								AFT_PCIBRIDGE_DECODE(hwcpu->hwcard),		
								hw->hwcpu->hwcard->cpld_rev);
			memcpy(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_verbose[0],
			hw->adptr_type	  = AFT_ADPTR_ISDN;
			hw->chans_map	  = 0x03;	/* 2 BRI bchans */
			hw->max_chans_num = 2;
			hwcpu->lines_info[AFT_ADPTR_ISDN].total_line_no++;
		hwcpu->lines_info[AFT_ADPTR_ISDN].line_map	= line_map;
		return -EINVAL;
		return -EINVAL;
		return -EINVAL;
					AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
			sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|FE=%s","FXS");
					AFT_PCITYPE_DECODE(hwcpu->hwcard), AFT_PCIBRIDGE_DECODE(hwcpu->hwcard));
			sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|FE=%s","FXO");
			sprintf(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump[strlen(hw->hwport[hw->max_port_no-1].hwprobe->hw_info_dump)], "|FE=%s","EMPTY");
		hw->max_chans_num++;
		memcpy(&hw->hwport[hw->max_port_no-1].hwprobe->hw_info_verbose[off], str, strlen(str));
	hw->adptr_type	  = A200_ADPTR_ANALOG;
	hw->chans_map	  = chans_map;
	hw->max_chans_num = max_analog_lines;
	hwcpu->lines_info[A200_ADPTR_ANALOG].total_line_no = 1;
./sdladrv.c
	int err=-EINVAL;
		return -ENOMEM;
	cdev->dev_ptr=&wandev;
	memcpy(&cdev->ops,&wandev_fops,sizeof(wanpipe_cdev_ops_t));
	if (wan_test_and_set_bit(0,&wdev->used)) {
		return -EBUSY;
	wan_clear_bit(0,&wdev->used);
	int err=-EINVAL;
	int err=-EINVAL;
		err=-ENOMEM;
	if (!usr_port_mgmnt->port_no) {
	sprintf(card_name,"wanpipe%d",usr_port_mgmnt->port_no);
		err=-ENODEV;
	switch (usr_port_mgmnt->command_code) {
			err=-ENODEV;
	int err=-EINVAL;
		return -EFAULT;
		err = -ENOMEM;
	if (!usr_port_cfg->port_no) {
	sprintf(card_name,"wanpipe%d",usr_port_cfg->port_no);
		err=-ENODEV;
	switch (usr_port_cfg->command_code) {
		if (!wandev->port_cfg) {
			err = -ENODEV;
						 wandev->port_cfg,
		if (!wandev->port_cfg) {
			wandev->port_cfg = wan_kmalloc(sizeof(wanpipe_port_cfg_t));
			if (!wandev->port_cfg) {
				err = -ENOMEM;
		err=WAN_COPY_FROM_USER(wandev->port_cfg,
	hardware_info_t *hw_info = (hardware_info_t*)usr_port_mgmnt->data;
	sdla_t *card=(sdla_t*)wandev->priv;
				__FUNCTION__,wandev->name);
		return -EINVAL;
	return sdla_get_hwinfo(hw_info,usr_port_mgmnt->port_no);
	int err=-EINVAL;
	wanpipe_port_cfg_t *port_cfg=wandev->port_cfg;
	if (!wandev->port_cfg) {
		return -EINVAL;
	err=wan_device_setup(wandev, &port_cfg->wandev_conf, 0);
	for (i = 0; i < port_cfg->num_of_ifs; i++) {
		err=wan_device_new_if (wandev, &port_cfg->if_cfg[i], 0);
	err=-ENODEV;
	for (i = 0; i < port_cfg->num_of_ifs; i++) {
		netdevice_t *dev = wan_dev_get_by_name(port_cfg->if_cfg[i].name);
			err=dev_change_flags(dev,(dev->flags|IFF_UP));
			err=-ENODEV;
./wandev.c
# include "zapcompat.h" /* Map of Zaptel -> DAHDI definitions */
# define WP_USB_TDMV_FUNC_DEBUG  DEBUG_EVENT("[USB-TDMV] %s:%d\n",__FUNCTION__,__LINE__)
#define IS_TDMV_RUNNING(wr)	wan_test_bit(WP_TDMV_RUNNING, &(wr)->flags)
#define IS_TDMV_UP(wr)		wan_test_bit(WP_TDMV_UP, &(wr)->flags)
	wp_usb_tdmv_remora_t	*wr = chan->pvt;
	WAN_ASSERT(wr->card == NULL);
	card	= wr->card;
	fe	= &card->fe;
		if (fe->rm_param.mod[chan->chanpos - 1].type != MOD_TYPE_FXS) {
			return -EINVAL;
		if (err) return -EFAULT;
		wr->mod[chan->chanpos - 1].fxs.ohttimer = x << 3;
		if (fe->fe_cfg.cfg.remora.reversepolarity){
			fe->rm_param.mod[chan->chanpos - 1].u.fxs.idletxhookstate  = 0x6;
			fe->rm_param.mod[chan->chanpos - 1].u.fxs.idletxhookstate  = 0x2;
		if (wr->mod[chan->chanpos - 1].fxs.lasttxhook == 0x1) {
			if (fe->fe_cfg.cfg.remora.reversepolarity){
				wr->mod[chan->chanpos - 1].fxs.lasttxhook = 0x6;
				wr->mod[chan->chanpos - 1].fxs.lasttxhook = 0x2;
			wr->mod[chan->chanpos-1].fxs.lasttxhook_update = 1;
			WRITE_USB_RM_REG(chan->chanpos - 1, 64, wr->mod[chan->chanpos - 1].fxs.lasttxhook);
		if (err) return -EFAULT;
		if (fe->rm_param.mod[chan->chanpos - 1].type != MOD_TYPE_FXS) {
			return -EINVAL;
		if ((wr->mod[chan->chanpos - 1].fxs.lasttxhook == 0x04) ||
		    (wr->mod[chan->chanpos - 1 ].fxs.lasttxhook == 0x00)){
			return -EINVAL;
		if ((x && !fe->fe_cfg.cfg.remora.reversepolarity) || (!x && fe->fe_cfg.cfg.remora.reversepolarity)){
			wr->mod[chan->chanpos - 1].fxs.lasttxhook |= 0x04;
			wr->mod[chan->chanpos - 1].fxs.lasttxhook &= ~0x04;
		wr->mod[chan->chanpos-1].fxs.lasttxhook_update = 1;
		WRITE_USB_RM_REG(chan->chanpos - 1, 64, wr->mod[chan->chanpos - 1].fxs.lasttxhook);
		if (fe->rm_param.mod[chan->chanpos - 1].type == MOD_TYPE_FXO) {
					&wr->mod[chan->chanpos-1].fxo.echoregs,
			if (err) return -EFAULT;
			wr->mod[chan->chanpos-1].fxo.echotune = 1;
					wr->devname, chan->chanpos-1);
			WRITE_USB_RM_REG(chan->chanpos - 1, 30, echoregs.acim);
			WRITE_USB_RM_REG(chan->chanpos - 1, 45, echoregs.coef1);
			WRITE_USB_RM_REG(chan->chanpos - 1, 46, echoregs.coef2);
			WRITE_USB_RM_REG(chan->chanpos - 1, 47, echoregs.coef3);
			WRITE_USB_RM_REG(chan->chanpos - 1, 48, echoregs.coef4);
			WRITE_USB_RM_REG(chan->chanpos - 1, 49, echoregs.coef5);
			WRITE_USB_RM_REG(chan->chanpos - 1, 50, echoregs.coef6);
			WRITE_USB_RM_REG(chan->chanpos - 1, 51, echoregs.coef7);
			WRITE_USB_RM_REG(chan->chanpos - 1, 52, echoregs.coef8);
					wr->devname, chan->chanpos-1);
			return -EINVAL;
			return -EFAULT;
		if (wr->dtmfsupport != WANOPT_YES || card->wandev.ec_dev == NULL){
			return -ENOSYS;
			wr->devname,
			(x & ZT_TONEDETECT_ON) ? "ON" : "OFF", chan->chanpos - 1,
			wr->dtmfmask |= (1 << (chan->chanpos - 1));
			wr->dtmfmask &= ~(1 << (chan->chanpos - 1));
			wr->dtmfmutemask |= (1 << (chan->chanpos - 1));
			wr->dtmfmutemask &= ~(1 << (chan->chanpos - 1));
						wr->devname);
			return -EFAULT;
		event_ctrl->type = WAN_EVENT_EC_CHAN_MODIFY;
		event_ctrl->channel = chan->chanpos-1;
		event_ctrl->mode = (x & ZT_TONEDETECT_MUTE) ? WAN_EVENT_ENABLE : WAN_EVENT_DISABLE;
		if (wanpipe_ec_event_ctrl(card->wandev.ec_dev, card, event_ctrl)){
		err = -EINVAL;
		return -ENOTTY;
	wp_usb_tdmv_remora_t	*wr = chan->pvt;
	WAN_ASSERT(wr->card == NULL);
	card	= wr->card;
	fe	= &card->fe;
	if (fe->rm_param.mod[chan->chanpos - 1].type == MOD_TYPE_FXO) {
			DEBUG_TDMV("%s: Module %d: goes off-hook (txsig %d)\n", 
					wr->devname, chan->chanpos, txsig);
			wr->mod[chan->chanpos - 1].fxo.offhook = 1;
			wr->reg0shadow[chan->chanpos-1] = 0x09;
			wr->reg0shadow_update[chan->chanpos-1] = 1;
			WRITE_USB_RM_REG(chan->chanpos - 1, 5, 0x9);
			DEBUG_TDMV("%s: Module %d: goes on-hook (txsig %d)\n", 
					wr->devname, chan->chanpos, txsig);
			wr->mod[chan->chanpos - 1].fxo.offhook = 0;
			wr->reg0shadow[chan->chanpos-1] = 0x08;
			wr->reg0shadow_update[chan->chanpos-1] = 1;
			WRITE_USB_RM_REG(chan->chanpos - 1, 5, 0x8);
					wr->devname, txsig, chan->chanpos);
	}else if (fe->rm_param.mod[chan->chanpos - 1].type == MOD_TYPE_FXS) {
			DEBUG_TDMV("%s: Module %d: goes on-hook (txsig %d).\n",
					wr->devname, chan->chanpos, txsig);
			switch(chan->sig) {
				wr->mod[chan->chanpos-1].fxs.lasttxhook =
					fe->rm_param.mod[chan->chanpos-1].u.fxs.idletxhookstate;
				wr->mod[chan->chanpos-1].fxs.lasttxhook = 3;
			DEBUG_TDMV("%s: Module %d: goes off-hook (txsig %d).\n",
					wr->devname, chan->chanpos, txsig);
			switch(chan->sig) {
				wr->mod[chan->chanpos-1].fxs.lasttxhook = 5;
				wr->mod[chan->chanpos-1].fxs.lasttxhook =
					fe->rm_param.mod[chan->chanpos-1].u.fxs.idletxhookstate;
					wr->devname, chan->chanpos, txsig);
			wr->mod[chan->chanpos-1].fxs.lasttxhook = 4;
			wr->mod[chan->chanpos-1].fxs.lasttxhook = 0;
					wr->devname, txsig);
		wr->mod[chan->chanpos-1].fxs.lasttxhook_update = 1;
		WRITE_USB_RM_REG(chan->chanpos - 1, 64, wr->mod[chan->chanpos-1].fxs.lasttxhook);
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wr = chan->pvt;
	wr->usecount++;
	wan_set_bit(WP_TDMV_RUNNING, &wr->flags);
				wr->devname,
				wr->usecount,
				chan->channo,
				chan->chanpos);
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wr	= chan->pvt;
	card	= wr->card;
	fe	= &card->fe;
	wr->usecount--;
	wan_clear_bit(WP_TDMV_RUNNING, &wr->flags);
	if (fe->rm_param.mod[chan->chanpos - 1].type == MOD_TYPE_FXS) {
		if (fe->fe_cfg.cfg.remora.reversepolarity)
			fe->rm_param.mod[chan->chanpos - 1].u.fxs.idletxhookstate = 5;
			fe->rm_param.mod[chan->chanpos - 1].u.fxs.idletxhookstate = 1;
	wctdm_restart_dma(span->pvt);
** wp_remora_zap_hwec() - 
	int			fe_chan = chan->chanpos;
	int			err = -ENODEV;
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wr = chan->pvt;
	WAN_ASSERT2(wr->card == NULL, -ENODEV);
	card = wr->card;
	if (card->wandev.ec_enable){
		if (card->hwec_conf.persist_disable) {
			err = card->wandev.ec_enable(card, enable, fe_chan);
				wr->devname,
	WAN_ASSERT1(wr->card == NULL);
	card	= wr->card;
	fe	= &card->fe;
	res = wr->reg2shadow[mod_no];
		"%s: Module %d: Ouch, part reset, quickly restoring reality (%02X) -- Comment out\n",
				wr->devname, mod_no, res);
	res = wr->reg1shadow[mod_no];
	if (!res && (res != wr->mod[mod_no].fxs.lasttxhook)) {
		res = wr->reg2shadow[mod_no];
					wr->devname, mod_no+1);
			if (wr->mod[mod_no].fxs.palarms++ < MAX_ALARMS) {
					wr->devname, mod_no + 1);
				if (wr->mod[mod_no].fxs.lasttxhook == 4)
					wr->mod[mod_no].fxs.lasttxhook = 1;
				WRITE_USB_RM_REG(mod_no, 64, wr->mod[mod_no].fxs.lasttxhook);
				if (wr->mod[mod_no].fxs.palarms == MAX_ALARMS)
						wr->devname, mod_no + 1);
	WAN_ASSERT1(wr->card == NULL);
	card	= wr->card;
	fe	= &card->fe;
	res = wr->reg2shadow[mod_no];
					wr->devname, mod_no+1);
	WAN_ASSERT1(wr->card == NULL);
	card	= wr->card;
	fe	= &card->fe;
	b = wr->reg0shadow[mod_no];
		/* Not good -- don't look at anything else */
				wr->devname, mod_no + 1, (unsigned char)b); 
	if (wr->mod[mod_no].fxo.offhook) {
			DEBUG_TDMV("%s: Module %d: Correct Reg:5 <- 0x09 (%02X:offhook=%d:%d)!\n",
					wr->devname, mod_no + 1,
					(unsigned char)b, wr->mod[mod_no].fxo.offhook,
			if (!wr->reg0shadow_update[mod_no]){
				wr->reg0shadow[mod_no] = 0x09;
				wr->reg0shadow_update[mod_no] = 1;
			DEBUG_TDMV("%s: Module %d: Correct Reg:5 <- 0x08 (%02X:offhook=%d:%d)!\n",
					wr->devname, mod_no + 1,
					(unsigned char)b, wr->mod[mod_no].fxo.offhook,
			if (!wr->reg0shadow_update[mod_no]){
				wr->reg0shadow[mod_no] = 0x08;
				wr->reg0shadow_update[mod_no] = 1;
	if (!wr->mod[mod_no].fxo.offhook) {
		res = wr->reg0shadow[mod_no];
		if ((res & 0x60) && wr->mod[mod_no].fxo.battery) {
			wr->mod[mod_no].fxo.ringdebounce += (ZT_CHUNKSIZE * 16);
			if (wr->mod[mod_no].fxo.ringdebounce >= ZT_CHUNKSIZE * 64) {
				if (!wr->mod[mod_no].fxo.wasringing) {
					wr->mod[mod_no].fxo.wasringing = 1;
					zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_RING);
							wr->devname,
							wr->span.spanno, res);
				wr->mod[mod_no].fxo.ringdebounce = ZT_CHUNKSIZE * 64;
			wr->mod[mod_no].fxo.ringdebounce -= ZT_CHUNKSIZE * 4;
			if (wr->mod[mod_no].fxo.ringdebounce <= 0) {
				if (wr->mod[mod_no].fxo.wasringing) {
					wr->mod[mod_no].fxo.wasringing = 0;
					zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_OFFHOOK);
					DEBUG_TDMV("%s: Module %d: NO RING on span %d (off-hook) (%X)!\n",
							wr->devname,
							wr->span.spanno, res);
				wr->mod[mod_no].fxo.ringdebounce = 0;
	b = wr->reg1shadow[mod_no];
					wr->devname, mod_no + 1, 
			       		b, wr->mod[mod_no].fxo.battdebounce);
		fe->rm_param.mod[mod_no].u.fxo.statusdebounce ++;
		if (fe->rm_param.mod[mod_no].u.fxo.statusdebounce >= FXO_LINK_DEBOUNCE){
			if (fe->rm_param.mod[mod_no].u.fxo.status != FE_DISCONNECTED){
								wr->devname,
				fe->rm_param.mod[mod_no].u.fxo.status = FE_DISCONNECTED;
			fe->rm_param.mod[mod_no].u.fxo.statusdebounce = FXO_LINK_DEBOUNCE;
		fe->rm_param.mod[mod_no].u.fxo.statusdebounce--;
		if (fe->rm_param.mod[mod_no].u.fxo.statusdebounce <= 0) {
			if (fe->rm_param.mod[mod_no].u.fxo.status != FE_CONNECTED){
								wr->devname,
				fe->rm_param.mod[mod_no].u.fxo.status = FE_CONNECTED;
			fe->rm_param.mod[mod_no].u.fxo.statusdebounce = 0;
	if (abs(b) < wr->battthresh) {
		wr->mod[mod_no].fxo.nobatttimer++;
		if (wr->mod[mod_no].fxo.battery)
				wr->devname, mod_no+1,
				b, wr->mod[mod_no].fxo.battdebounce);
		if (wr->mod[mod_no].fxo.battery && !wr->mod[mod_no].fxo.battdebounce) {
						wr->devname,
						wr->span.spanno, (unsigned char)b);
			wr->mod[mod_no].fxo.battery =  0;
			if ((!wr->mod[mod_no].fxo.ohdebounce) &&
		            wr->mod[mod_no].fxo.offhook) {
				zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_ONHOOK);
							wr->devname,
							wr->span.spanno);
				wr->mod[mod_no].fxo.onhook++;
							wr->devname,
							wr->span.spanno, (unsigned char)b);
			zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_ONHOOK);
			wr->mod[mod_no].fxo.battdebounce = wr->battdebounce;
		} else if (!wr->mod[mod_no].fxo.battery)
			wr->mod[mod_no].fxo.battdebounce = wr->battdebounce;
	} else if (abs(b) > wr->battthresh) {
		if (!wr->mod[mod_no].fxo.battery && !wr->mod[mod_no].fxo.battdebounce) {
						wr->devname,
						wr->span.spanno,
						(b < 0) ? "-" : "+", (unsigned char)b);
			if (wr->mod[mod_no].fxo.onhook) {
				wr->mod[mod_no].fxo.onhook = 0;
				zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_OFFHOOK);
							wr->devname,
							wr->span.spanno);
			zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_OFFHOOK);
							wr->devname,
							wr->span.spanno, (unsigned char)b);
			wr->mod[mod_no].fxo.battery = 1;
			wr->mod[mod_no].fxo.nobatttimer = 0;
			wr->mod[mod_no].fxo.battdebounce = wr->battdebounce;
		} else if (wr->mod[mod_no].fxo.battery)
			wr->mod[mod_no].fxo.battdebounce = wr->battdebounce;
		if (wr->mod[mod_no].fxo.lastpol >= 0) {
				wr->mod[mod_no].fxo.lastpol = -1;
				wr->mod[mod_no].fxo.polaritydebounce = POLARITY_DEBOUNCE;
		if (wr->mod[mod_no].fxo.lastpol <= 0) {
				wr->mod[mod_no].fxo.lastpol = 1;
				wr->mod[mod_no].fxo.polaritydebounce = POLARITY_DEBOUNCE;
		wr->mod[mod_no].fxo.battdebounce = wr->battdebounce;
	if (wr->mod[mod_no].fxo.battdebounce)
		wr->mod[mod_no].fxo.battdebounce--;
	if (wr->mod[mod_no].fxo.polaritydebounce) {
	        wr->mod[mod_no].fxo.polaritydebounce--;
		if (wr->mod[mod_no].fxo.polaritydebounce < 1) {
			if (wr->mod[mod_no].fxo.lastpol != wr->mod[mod_no].fxo.polarity) {
				"%s: Module %d: Polarity reversed %d -> %d (%u)\n",
						wr->devname,
						wr->mod[mod_no].fxo.polarity, 
						wr->mod[mod_no].fxo.lastpol,
				if (wr->mod[mod_no].fxo.polarity){
					zt_qevent_lock(&wr->chans[mod_no],
				wr->mod[mod_no].fxo.polarity =
						wr->mod[mod_no].fxo.lastpol;
	WAN_ASSERT1(wr->card == NULL);
	card	= wr->card;
	fe	= &card->fe;
	res = wr->reg0shadow[mod_no];
	if (hook != wr->mod[mod_no].fxs.lastrxhook) {
		wr->mod[mod_no].fxs.debounce = 4 * (4 * 8);
				wr->devname, mod_no + 1, hook,
				wr->mod[mod_no].fxs.debounce);
		if (wr->mod[mod_no].fxs.debounce > 0) {
			wr->mod[mod_no].fxs.debounce-= 16 * ZT_CHUNKSIZE;
					wr->devname, mod_no + 1,
					hook, wr->mod[mod_no].fxs.debounce);
			if (!wr->mod[mod_no].fxs.debounce) {
							wr->devname,
				wr->mod[mod_no].fxs.debouncehook = hook;
			if (!wr->mod[mod_no].fxs.oldrxhook && wr->mod[mod_no].fxs.debouncehook) {
							wr->devname, mod_no + 1);
				zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_OFFHOOK);
				wr->mod[mod_no].fxs.oldrxhook = 1;
			} else if (wr->mod[mod_no].fxs.oldrxhook && !wr->mod[mod_no].fxs.debouncehook) {
							wr->devname, mod_no + 1);
				zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_ONHOOK);
				wr->mod[mod_no].fxs.oldrxhook = 0;
	wr->mod[mod_no].fxs.lastrxhook = hook;
	sdla_t			*card = fe->card;
	wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr	= wan_tdmv->sc;
	if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS) {
	} else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO) {
	sdla_t			*card = fe->card;
	wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr	= wan_tdmv->sc;
		zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_OFFHOOK);
		zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_ONHOOK);
	wr->mod[mod_no].fxs.lastrxhook = off_hook;
** wp_usb_tdmv_remora_init() - 
	iface->check_mtu	= wp_usb_tdmv_remora_check_mtu;
	iface->create		= wp_usb_tdmv_remora_create;
	iface->remove		= wp_usb_tdmv_remora_remove;
	iface->reg		= wp_usb_tdmv_remora_reg;
	iface->unreg		= wp_usb_tdmv_remora_unreg;
	iface->software_init	= wp_usb_tdmv_remora_software_init;
	iface->state		= wp_usb_tdmv_remora_state;
	iface->running		= wp_usb_tdmv_remora_running;
	iface->is_rbsbits	= wp_usb_tdmv_remora_is_rbsbits;
	iface->rx_tx_span	= wp_usb_tdmv_remora_rx_tx_span;
	iface->rx_chan		= wp_usb_tdmv_remora_rx_chan;
	iface->ec_span		= wp_usb_tdmv_remora_ec_span;  
	iface->update_regs	= wp_usb_tdmv_remora_update_regs;
	wp_usb_tdmv_remora_t	*wr = wan_tdmv->sc;
	WAN_ASSERT(wr->card == NULL);
	card = wr->card;
	fe = &card->fe;
	if (wan_test_bit(WP_TDMV_REGISTER, &wr->flags)){
					wr->devname, wr->span.spanno);
	sprintf(wr->span.name, "WRTDM/%d", wr->num);
	sprintf(wr->span.desc, "wrtdm Board %d", wr->num + 1);
	switch(fe->fe_cfg.tdmv_law){
					wr->devname);
		wr->span.deflaw = ZT_LAW_ALAW;
		wr->span.deflaw = ZT_LAW_MULAW;
	wr->dtmfsupport = card->u.aft.tdmv_hw_dtmf;
	wr->battthresh	= DEFAULT_BATT_THRESH;
	wr->battdebounce= DEFAULT_BATT_DEBOUNCE;
	if (fe->fe_cfg.cfg.remora.battthresh && 
	    fe->fe_cfg.cfg.remora.battthresh != DEFAULT_BATT_THRESH){
		wr->battthresh = fe->fe_cfg.cfg.remora.battthresh;
		DEBUG_EVENT("%s: A200/A400 Remora Battery Threshhold changed %d -> %d\n", 
					wr->devname, DEFAULT_BATT_THRESH, wr->battthresh);
	if (fe->fe_cfg.cfg.remora.battdebounce && 
            fe->fe_cfg.cfg.remora.battdebounce != DEFAULT_BATT_DEBOUNCE){
		wr->battdebounce = fe->fe_cfg.cfg.remora.battdebounce;
		DEBUG_EVENT("%s: A200/A400 Remora Battery Debounce changed %d -> %d\n", 
					wr->devname, DEFAULT_BATT_DEBOUNCE, wr->battdebounce);
		if (wan_test_bit(x, &fe->rm_param.module_map)){
			sprintf(wr->chans[x].name, "WRTDM/%d/%d", wr->num, x);
					wr->devname, 
					wr->chans[x].name,
					WP_REMORA_DECODE_TYPE(fe->rm_param.mod[x].type));
			if (fe->rm_param.mod[x].type == MOD_TYPE_FXO){
				wr->chans[x].sigcap =	ZT_SIG_FXSKS |
			}else if (fe->rm_param.mod[x].type == MOD_TYPE_FXS){
				wr->chans[x].sigcap =	ZT_SIG_FXOKS |
			wr->chans[x].chanpos = x+1;
			wr->chans[x].pvt = wr;
			sprintf(wr->chans[x].name, "WRTDM/%d/%d", wr->num, x);
					wr->devname, 
			wr->chans[x].sigcap = ZT_SIG_CLEAR;
			wr->chans[x].chanpos = x+1;
			wr->chans[x].pvt = wr;
	wr->span.pvt = wr;
	wr->span.chans		= wr->chans;
	wr->span.channels	= num/*wr->max_timeslots*/;
	wr->span.hooksig	= wp_remora_zap_hooksig;
	wr->span.open		= wp_remora_zap_open;
	wr->span.close		= wp_remora_zap_close;
	wr->span.flags		= ZT_FLAG_RBS;
	wr->span.ioctl		= wp_remora_zap_ioctl;
	wr->span.watchdog	= wp_remora_zap_watchdog;
	if (wr->hwec == WANOPT_YES && card->wandev.ec_dev){
		wr->span.echocan = wp_remora_zap_hwec;
	init_waitqueue_head(&wr->span.maintq);
	if (zt_register(&wr->span, 0)) {
				wr->devname);
		return -EINVAL;
	if (wr->span.spanno != wr->spanno +1){
						wr->spanno + 1);
						wr->devname,wr->span.spanno);
		wr->spanno = wr->span.spanno-1;
					wr->devname, wr->span.spanno);
	wp_usb_tdmv_remora_check_mtu(card, wr->reg_module_map, &wr->max_rxtx_len);
	wan_set_bit(WP_TDMV_REGISTER, &wr->flags);
	if (wr->dtmfsupport == WANOPT_YES){
		DEBUG_EVENT("%s: Enable HW DTMF detection!\n", wr->devname);
		card->wandev.event_callback.dtmf = wp_usb_tdmv_remora_dtmf;
	if (fe->fe_cfg.cfg.remora.fxs_pulsedialing == WANOPT_YES){
					wr->devname);
** wp_usb_tdmv_release() - 
	if (wan_test_bit(WP_TDMV_REGISTER, &wr->flags)){
				wr->devname);
		wan_clear_bit(WP_TDMV_REGISTER, &wr->flags);
		zt_unregister(&wr->span);
		wan_clear_bit(WP_TDMV_REGISTER, &wr->flags);
** wp_usb_tdmv_remora_check_mtu() - 
	max_channels = WAN_FE_MAX_CHANNELS(&card->fe);
** wp_usb_tdmv_remora_create() - 
	WAN_ASSERT(tdmv_conf->span_no == 0);
					card->devname);
		return -EINVAL;
		if (tmp->spanno == tdmv_conf->span_no){
					card->devname);
					card->devname, tdmv_conf->span_no);
			return -EINVAL;
	memset(&card->wan_tdmv, 0x0, sizeof(wan_tdmv_t));
	card->wan_tdmv.max_timeslots			= card->fe.rm_param.max_fe_channels;
	card->wan_tdmv.spanno				= tdmv_conf->span_no;
	card->wandev.fe_notify_iface.hook_state		= wp_usb_tdmv_remora_hook;
	card->wandev.fe_notify_iface.check_hook_state	= wp_usb_tdmv_remora_check_hook;
		return -ENOMEM;
	card->wan_tdmv.sc	= wr;
	wr->spanno		= tdmv_conf->span_no-1;
	wr->num			= wp_remora_no++;
	wr->card		= card;
	wr->devname		= card->devname;
	wr->max_timeslots	= card->fe.rm_param.max_fe_channels;
	wr->max_rxtx_len	= 0;
	wan_spin_lock_irq_init(&wr->lockirq, "wan_rmtdmv_lock");
	wan_spin_lock_irq_init(&wr->tx_rx_lockirq, "wan_rmtdmv_txrx_lock");
		WAN_LIST_INSERT_AFTER(tmp, &card->wan_tdmv, next);
		WAN_LIST_INSERT_HEAD(&wan_tdmv_head, &card->wan_tdmv, next);
** wp_usb_tdmv_reg() - 
** Returns: 	0-31	- Return TDM Voice channel number.
**		-EINVAL - otherwise
	sdla_fe_t		*fe = &card->fe;
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = wan_tdmv->sc;
	if (wan_test_bit(WP_TDMV_REGISTER, &wr->flags)){
				card->devname);
		return -EINVAL;
	for(i = 0; i < wr->max_timeslots; i++){
		    wan_test_bit(i, &fe->rm_param.module_map)){
			if (tdmv_conf->tdmv_echo_off){
				wan_set_bit(i, &wr->echo_off_map);
	if (i == wr->max_timeslots){
					card->devname,
		return -EINVAL;
			card->devname,
			WP_REMORA_DECODE_TYPE(fe->rm_param.mod[channo].type),
	wan_set_bit(channo, &wr->reg_module_map);
	if (tdmv_conf->tdmv_echo_off){
				wr->devname);
	memset(wr->chans[channo].sreadchunk, WAN_TDMV_IDLE_FLAG, ZT_CHUNKSIZE);
	memset(wr->chans[channo].swritechunk, WAN_TDMV_IDLE_FLAG, ZT_CHUNKSIZE);
	wr->chans[channo].readchunk = wr->chans[channo].sreadchunk;
	wr->chans[channo].writechunk = wr->chans[channo].swritechunk;
	wr->channelized = WAN_TRUE;
	wr->hwec = ec_enable;
	wp_usb_tdmv_remora_check_mtu(card, active_ch, &wr->max_rxtx_len);
** wp_usb_tdmv_unreg() - 
	sdla_fe_t		*fe = &card->fe;
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = wan_tdmv->sc;
	for(channo = 0; channo < wr->max_timeslots; channo++){
		if (wan_test_bit(channo, &wr->reg_module_map)){
				card->devname,
				WP_REMORA_DECODE_TYPE(fe->rm_param.mod[channo].type),
			wan_clear_bit(channo, &wr->reg_module_map);
			wan_clear_bit(channo, &wr->echo_off_map);
			memset(wr->chans[channo].sreadchunk, 
			memset(wr->chans[channo].swritechunk, 
			wr->chans[channo].readchunk = 
					wr->chans[channo].sreadchunk;
			wr->chans[channo].writechunk = 
					wr->chans[channo].swritechunk;
** wp_usb_tdmv_remove() - 
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	if (!card->wan_tdmv.sc){
	wr = wan_tdmv->sc;
	if (wr && wr->reg_module_map){
				card->devname,
				wr->reg_module_map);
		return -EINVAL;
	if (wr && wr->usecount){
				card->devname);
		return -EINVAL;
		wan_clear_bit(WP_TDMV_RUNNING, &wr->flags);
		wan_clear_bit(WP_TDMV_UP, &wr->flags);
		wan_tdmv->sc = NULL;
		wan_tdmv->sc = NULL;
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = (wp_usb_tdmv_remora_t*)wan_tdmv->sc;
					wr->devname);
		wan_set_bit(WP_TDMV_UP, &wr->flags);
					wr->devname);
		wan_clear_bit(WP_TDMV_UP, &wr->flags);
** wp_usb_tdmv_running() - 
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	wr = wan_tdmv->sc;
	if (wr && wr->usecount){
				card->devname);
		return -EINVAL;
** wp_usb_tdmv_remora_is_rbsbits() - 
** wp_usb_tdmv_rx_chan() - 
	wp_usb_tdmv_remora_t	*wr = wan_tdmv->sc;
	WAN_ASSERT2(wr == NULL, -EINVAL);
	WAN_ASSERT2(channo < 0, -EINVAL);
	WAN_ASSERT2(channo > 31, -EINVAL);
		return -EINVAL;
	card = wr->card;
	pwr_rxtx = &wan_tdmv->chan_pwr[channo];
	wr->chans[channo].readchunk = rxbuf;	
	wr->chans[channo].writechunk = txbuf;	
	wp_usb_tdmv_echo_check(wan_tdmv, &wr->chans[channo], channo);
	if ((!card->wandev.ec_enable || card->wandev.ec_enable_map == 0) && 
	     !wan_test_bit(channo, &wr->echo_off_map)) {
		if(pwr_rxtx->current_state != ECHO_ABSENT){
		if (wan_test_bit(AFT_TDM_SW_RING_BUF,&card->u.aft.chip_cfg_status)) {
				&wr->chans[channo], 
				wr->chans[channo].readchunk, 
				wr->chans[channo].writechunk);
				&wr->chans[channo], 
				wr->chans[channo].readchunk, 
				wr->ec_chunk1[channo]);
				wr->ec_chunk1[channo],
				wr->chans[channo].writechunk,
				&wr->chans[channo], 
				wr->chans[channo].readchunk, 
				wr->ec_chunk1[channo]);
				wr->ec_chunk1[channo],
				wr->ec_chunk2[channo],
				wr->ec_chunk2[channo],
				wr->chans[channo].writechunk,
		} /*if(pwr_rxtx->current_state != ECHO_ABSENT) */
	} /* if (!wan_test_bit(channo, &wr->echo_off_map)) */
	sdla_fe_t		*fe = &card->fe;
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = wan_tdmv->sc;
	if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS) {
		wr->reg0shadow[mod_no] = regs[0];	// 68
		wr->reg1shadow[mod_no] = regs[1];	// 64
		wr->reg2shadow[mod_no] = regs[2];	// 8
	}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO) {
		if (!wr->reg0shadow_update[mod_no]) wr->reg0shadow[mod_no] = regs[0];	//5
		wr->reg1shadow[mod_no] = regs[1];	//29
		wr->reg2shadow[mod_no] = regs[2];	//34
	sdla_fe_t		*fe = &card->fe;
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = wan_tdmv->sc;
	wr->intcount++;
	for (x = 0; x < wr->max_timeslots; x++) {
		if (!wan_test_bit(x, &wr->reg_module_map)){
		if (fe->rm_param.mod[x].type == MOD_TYPE_FXS){
			if (wr->mod[x].fxs.lasttxhook_update){
				WRITE_USB_RM_REG(x, 64, wr->mod[x].fxs.lasttxhook);
				wr->mod[x].fxs.lasttxhook_update = 0;
			if (wr->mod[x].fxs.lasttxhook == 0x4) {
				wr->mod[x].fxs.ohttimer = OHT_TIMER << 3;
				if (fe->fe_cfg.cfg.remora.reversepolarity){
					fe->rm_param.mod[x].u.fxs.idletxhookstate = 0x6;
					fe->rm_param.mod[x].u.fxs.idletxhookstate = 0x2; 
				if (wr->mod[x].fxs.ohttimer) {
					wr->mod[x].fxs.ohttimer-= ZT_CHUNKSIZE;
					if (!wr->mod[x].fxs.ohttimer) {
						if (fe->fe_cfg.cfg.remora.reversepolarity){
							fe->rm_param.mod[x].u.fxs.idletxhookstate = 0x5;
							fe->rm_param.mod[x].u.fxs.idletxhookstate = 0x1;
						if ((wr->mod[x].fxs.lasttxhook == 0x2) || (wr->mod[x].fxs.lasttxhook == 0x6)) {
							if (fe->fe_cfg.cfg.remora.reversepolarity){ 
								wr->mod[x].fxs.lasttxhook = 0x5;
								wr->mod[x].fxs.lasttxhook = 0x1;
							WRITE_USB_RM_REG(x, 64, wr->mod[x].fxs.lasttxhook);
		} else if (fe->rm_param.mod[x].type == MOD_TYPE_FXO) {
			if (wr->mod[x].fxo.echotune){
							fe->name, x);
				WRITE_USB_RM_REG(x, 30, wr->mod[x].fxo.echoregs.acim);
				WRITE_USB_RM_REG(x, 45, wr->mod[x].fxo.echoregs.coef1);
				WRITE_USB_RM_REG(x, 46, wr->mod[x].fxo.echoregs.coef2);
				WRITE_USB_RM_REG(x, 47, wr->mod[x].fxo.echoregs.coef3);
				WRITE_USB_RM_REG(x, 48, wr->mod[x].fxo.echoregs.coef4);
				WRITE_USB_RM_REG(x, 49, wr->mod[x].fxo.echoregs.coef5);
				WRITE_USB_RM_REG(x, 50, wr->mod[x].fxo.echoregs.coef6);
				WRITE_USB_RM_REG(x, 51, wr->mod[x].fxo.echoregs.coef7);
				WRITE_USB_RM_REG(x, 52, wr->mod[x].fxo.echoregs.coef8);
						fe->name, x+1);
				wr->mod[x].fxo.echotune = 0;
			if (wr->reg0shadow_update[x]){
						wr->devname, x+1,
						(unsigned char)wr->reg0shadow[x], 
				WRITE_USB_RM_REG(x, 5, wr->reg0shadow[x]);
				wr->reg0shadow_update[x] = 0;
		if (fe->fe_cfg.cfg.remora.fxs_pulsedialing == WANOPT_YES){
	x = wr->intcount % MAX_USB_REMORA_MODULES;
	if (wan_test_bit(x, &wr->reg_module_map)) {
		if (fe->fe_cfg.cfg.remora.fxs_pulsedialing != WANOPT_YES){
		if (!(wr->intcount & 0xf0)){
			if (fe->rm_param.mod[x].type == MOD_TYPE_FXS) {
			}else if (fe->rm_param.mod[x].type == MOD_TYPE_FXO) {
	if (!(wr->intcount % 10000)) {
		for (x = 0; x < wr->max_timeslots; x++) 
			if (wan_test_bit(x, &wr->reg_module_map) &&
			    (fe->rm_param.mod[x].type == MOD_TYPE_FXS)) {
				if (wr->mod[x].fxs.palarms){
					wr->mod[x].fxs.palarms--;
	zt_receive(&wr->span);
	zt_transmit(&wr->span);
        wan_tdmv_t      *wan_tdmv = &card->wan_tdmv;
        WAN_ASSERT(wan_tdmv->sc == NULL);
        wr = wan_tdmv->sc;
	zt_ec_span(&wr->span);
        wan_tdmv_t      *wan_tdmv = &card->wan_tdmv;
        WAN_ASSERT1(wan_tdmv->sc == NULL);
        wr = wan_tdmv->sc;
	if (event->type == WAN_EVENT_EC_DTMF){
			card->devname,
			event->channel,
			event->digit,
			(event->dtmf_port == WAN_EC_CHANNEL_PORT_ROUT)?"ROUT":"SOUT",
			(event->dtmf_type == WAN_EC_TONE_PRESENT)?"PRESENT":"STOP");
	}else if (event->type == WAN_EVENT_RM_DTMF){
			card->devname,
			event->channel,
			event->digit);	
	if (!(wr->dtmfmask & (1 << (event->channel-1)))){
					card->devname,
					event->channel);
	if (event->dtmf_type == WAN_EC_TONE_PRESENT){
		wr->dtmfactive |= (1 << event->channel);
				&wr->span.chans[event->channel-1],
				(ZT_EVENT_DTMFDOWN | event->digit));
		wr->dtmfactive &= ~(1 << event->channel);
				&wr->span.chans[event->channel-1],
				(ZT_EVENT_DTMFUP | event->digit));
./sdla_usb_remora_tdmv.c
* wanpipe_multppp.c Multi-Port PPP driver module.
* Copyright:	(c) 1995-2001 Sangoma Technologies Inc.
* 				was running. The dev->do_ioctl call
 *  o initialize protocol-specific fields of the adapter data space.
	if (conf->config_id != WANCONFIG_MPPP) {
				  card->devname, conf->config_id);
		return -EINVAL;
	if ((conf->comm_port == WANOPT_PRI) || (conf->comm_port == WANOPT_SEC)){
		if (card->next){
			if (conf->comm_port != card->next->u.c.comm_port){
				card->u.c.comm_port = conf->comm_port;
				DEBUG_EVENT("%s: ERROR - %s port used!\n",
        		        	card->wandev.name, PORT(conf->comm_port));
				return -EINVAL;
			card->u.c.comm_port = conf->comm_port;
		DEBUG_EVENT("%s: ERROR - Invalid Port Selected!\n",
                			card->wandev.name);
		return -EINVAL;
	/* Initialize protocol-specific fields */
	if (card->u.c.comm_port == WANOPT_PRI){
		card->mbox_off = PRI_BASE_ADDR_MB_STRUCT;
		card->mbox_off = SEC_BASE_ADDR_MB_STRUCT;
	mb = &card->wan_mbox;
	mb1 = &card->wan_mbox;
	if (!card->configured){
			card->hw_iface.peek(card->hw,
				card->mbox_off+offsetof(wan_mbox_t, wan_return_code),
			if ((SYSTEM_TICKS - timeout) > 1*HZ) break;
				card->devname);
			return -EIO;
				card->devname);
	err = (card->hw_iface.check_mismatch) ?
			card->hw_iface.check_mismatch(card->hw,conf->fe_cfg.media) : -EINVAL;
	if (IS_TE1_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_te_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg	= card->hw_iface.fe_write;
		card->fe.read_fe_reg		= card->hw_iface.fe_read;
		card->wandev.fe_enable_timer = chdlc_enable_timer;
		card->wandev.te_link_state = handle_front_end_state;
		conf->electrical_interface =
		if (card->u.c.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
	}else if (IS_56K_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_56k_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg	= card->hw_iface.fe_write;
		card->fe.read_fe_reg		= card->hw_iface.fe_read;
		card->fe.fe_status = FE_CONNECTED;
	card->wandev.ignore_front_end_status = conf->ignore_front_end_status;
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
		return -EIO;
			 "%s: for Multi-Port protocol.\n",
			card->devname,u.str,card->devname);
		return -EIO;
	card->isr			= &wsppp_isr;
	card->poll			= NULL;
	card->exec			= NULL;
	card->wandev.update		= &update;
 	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= &del_if;
	card->wandev.udp_port   	= conf->udp_port;
	card->wandev.bind_annexg	= &bind_annexg;
	card->wandev.un_bind_annexg	= &un_bind_annexg;
	card->wandev.get_map		= &get_map;
	card->wandev.get_active_inactive= &get_active_inactive;
	card->wandev.new_if_cnt = 0;
	card->wandev.get_config_info 	= &chdlc_get_config_info;
	card->wandev.get_status_info 	= &chdlc_get_status_info;
	card->wandev.set_dev_config    	= &chdlc_set_dev_config;
	card->wandev.set_if_info     	= &chdlc_set_if_info;
	card->u.c.update_call_count = 0;
	card->wandev.ttl = conf->ttl;
	card->wandev.electrical_interface = conf->electrical_interface;
	if ((card->u.c.comm_port == WANOPT_SEC && conf->electrical_interface == WANOPT_V35)&&
	    card->type != SDLA_S514){
		DEBUG_EVENT("%s: ERROR - V35 Interface not supported on S508 %s port \n",
			card->devname, PORT(card->u.c.comm_port));
		return -EIO;
	card->wandev.clocking = conf->clocking;
	port_num = card->u.c.comm_port;
	if(card->wandev.clocking) {
		if((port_num == WANOPT_PRI) || card->u.c.receive_only) {
				(card->type == SDLA_S514) ?
                               (card->type == SDLA_S514) ?
		if(conf->bps > max_permitted_baud) {
			conf->bps = max_permitted_baud;
				card->wandev.name);
				card->wandev.name, max_permitted_baud);
		}else if (conf->bps == 0){
			conf->bps = max_permitted_baud;
					card->devname);
				card->wandev.name, max_permitted_baud);
		card->wandev.bps = conf->bps;
        	card->wandev.bps = 0;
	if (conf->u.chdlc.fast_isr == WANOPT_YES){
				card->devname);
		card->u.c.protocol_options|=INSTALL_FAST_INT_HANDLERS;
	if((port_num == WANOPT_PRI) || card->u.c.receive_only) {
		card->wandev.mtu =
			(conf->mtu >= MIN_LGTH_CHDLC_DATA_CFG) ?
			wp_min(conf->mtu, PRI_MAX_NO_DATA_BYTES_IN_FRAME) :
		card->wandev.mtu =
			(conf->mtu >= MIN_LGTH_CHDLC_DATA_CFG) ?
			wp_min(conf->mtu, SEC_MAX_NO_DATA_BYTES_IN_FRAME) :
	card->wandev.mtu += PPP_HEADER_LEN;
         * Use this pointer to calculate the value of card->u.c.flags !
		wan_clear_bit(1, (void*)&card->wandev.critical);
		return -EIO;
       	card->flags_off = cfg.ptr_shared_mem_info_struct;
    	card->intr_type_off = card->flags_off +
	card->intr_perm_off = card->flags_off +
	card->fe_status_off = card->flags_off +
	card->wandev.state = WAN_DUALPORT;
	card->u.c.state = WAN_DISCONNECTED;
	if (!card->wandev.piggyback){
			return -EIO;
		card->configured = 1;
				card->devname);
		return -EIO;
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
		return -ENODEV;
       	if(chan->update_comms_stats){
		return -EAGAIN;
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	chan->update_comms_stats=0;
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
	if(++card->wandev.new_if_cnt > 1) {
				card->devname);
		--card->wandev.new_if_cnt;
		return -EEXIST;
		--card->wandev.new_if_cnt;
		return -ENOMEM;
	chan->card = card;
	strncpy(card->u.c.if_name, conf->name,WAN_IFNAME_SZ);
	strncpy(chan->if_name,conf->name,WAN_IFNAME_SZ);
	if (!conf->max_trace_queue){
		conf->max_trace_queue=MAX_TRACE_QUEUE;
	wan_trace_info_init(&chan->trace_info,conf->max_trace_queue);
	WAN_TASKLET_INIT((&chan->tasklet),
	WAN_IFQ_INIT((&chan->rx_queue),0);
	chan->route_status = NO_ROUTE;
	chan->route_removed = 0;
	card->u.c.async_mode = conf->async_mode;
		wandev->name);
	chan->common.prot_ptr=NULL;
	if(conf->async_mode) {
			wandev->name);
		if(card->u.c.comm_port == WANOPT_PRI) {
					wandev->name);
			err=-EINVAL;
		if (strcmp(conf->usedby, "API") == 0){
						wandev->name);
			chan->common.usedby = API;
			wan_reg_api(chan, dev, card->devname);
				chan->if_name, conf->usedby);
			err=-EINVAL;
		if(!card->wandev.clocking) {
				wandev->name);
			err=-EINVAL;
		if((card->wandev.bps < MIN_ASY_BAUD_RATE) ||
			(card->wandev.bps > MAX_ASY_BAUD_RATE)) {
				wandev->name);
			err=-EINVAL;
		card->u.c.api_options = 0;
                if (conf->asy_data_trans == WANOPT_YES) {
                        card->u.c.api_options |= ASY_RX_DATA_TRANSPARENT;
		card->u.c.protocol_options = 0;
		if (conf->rts_hs_for_receive == WANOPT_YES) {
			card->u.c.protocol_options |= ASY_RTS_HS_FOR_RX;
                if (conf->xon_xoff_hs_for_receive == WANOPT_YES) {
                        card->u.c.protocol_options |= ASY_XON_XOFF_HS_FOR_RX;
                if (conf->xon_xoff_hs_for_transmit == WANOPT_YES) {
                        card->u.c.protocol_options |= ASY_XON_XOFF_HS_FOR_TX;
                if (conf->dcd_hs_for_transmit == WANOPT_YES) {
                        card->u.c.protocol_options |= ASY_DCD_HS_FOR_TX;
                if (conf->cts_hs_for_transmit == WANOPT_YES) {
                        card->u.c.protocol_options |= ASY_CTS_HS_FOR_TX;
		card->u.c.tx_bits_per_char = conf->tx_bits_per_char;
                card->u.c.rx_bits_per_char = conf->rx_bits_per_char;
                card->u.c.stop_bits = conf->stop_bits;
		card->u.c.parity = conf->parity;
		card->u.c.break_timer = conf->break_timer;
		card->u.c.inter_char_timer = conf->inter_char_timer;
		card->u.c.rx_complete_length = conf->rx_complete_length;
		card->u.c.xon_char = conf->xon_char;
		if( strcmp(conf->usedby, "WANPIPE") == 0) {
				wandev->name,chan->if_name);
			chan->common.usedby=WANPIPE;
				err = -ENOMEM;
			chan->common.prot_ptr=(void*)pppdev;
			pppdev->dev=dev;
			if(conf->pap == WANOPT_YES){
				pppdev->sppp.myauth.proto = PPP_PAP;
			}else if(conf->chap == WANOPT_YES){
				pppdev->sppp.myauth.proto = PPP_CHAP;
				pppdev->sppp.myauth.proto = 0;
			if(pppdev->sppp.myauth.proto){
				memcpy(pppdev->sppp.myauth.name, conf->userid, AUTHNAMELEN);
				memcpy(pppdev->sppp.myauth.secret, conf->passwd, AUTHNAMELEN);
			pppdev->sppp.gateway = conf->gateway;
			if (conf->if_down){
				pppdev->sppp.dynamic_ip = 1;
			sprintf(pppdev->sppp.hwdevname,"%s",card->devname);
			sp = &pppdev->sppp;
			if (conf->protocol == WANCONFIG_CHDLC){
						card->devname);
				sp->pp_flags |= PP_CISCO;
				conf->ignore_dcd = WANOPT_YES;
				conf->ignore_cts = WANOPT_YES;
						card->devname);
				sp->pp_flags &= ~PP_CISCO;
				dev->type	= ARPHRD_PPP;
		if (strcmp(conf->usedby, "ANNEXG") == 0) {
				wandev->name,chan->if_name);
			chan->common.usedby=ANNEXG;
			if (strlen(conf->label)){
				strncpy(chan->label,conf->label,WAN_IF_LABEL_SZ);
		if (strcmp(conf->usedby, "STACK") == 0) {
			chan->common.usedby = STACK;
					card->devname,chan->if_name);
		}else if (strcmp(conf->usedby, "API") == 0) {
			chan->common.usedby = API;
			wan_reg_api(chan, dev, card->devname);
					card->devname,chan->if_name);
				wandev->name,chan->if_name);
			err=-EINVAL;
	if (conf->single_tx_buf) {
		DEBUG_EVENT("%s: Enabling Single Tx Buffer \n",chan->if_name);
		card->u.c.protocol_options|=SINGLE_TX_BUFFER;
	chan->mc = conf->mc;
	if (conf->ignore_dcd == WANOPT_YES || conf->ignore_cts == WANOPT_YES){
		DEBUG_EVENT("%s: Ignore modem changes DCD/CTS\n",card->devname);
		chan->ignore_modem=1;
				card->devname);
	chan->dev=dev;
	dev->init = &if_init;
	chan->common.iface.open      = &if_open;
        chan->common.iface.close     = &if_close;
        chan->common.iface.output    = &if_send;
        chan->common.iface.ioctl     = &if_do_ioctl;
        chan->common.iface.tx_timeout= &if_tx_timeout;
			wan_iface.attach(dev, NULL, chan->common.is_netdev);
				card->devname, wan_netif_name(dev));
		err = -EINVAL;
	wan_netif_set_mtu(dev, card->wandev.mtu);
					   &chan->dent,
					   card->u.c.if_name,
			card->devname, card->u.c.if_name);
		err = -ENOMEM;
	--card->wandev.new_if_cnt;
	if (chan->common.usedby == API){
		wan_unreg_api(chan, card->devname);
		chan->common.prot_ptr=NULL;
	sdla_t		*card = chan->card;
	if (chan->common.usedby == ANNEXG && chan->annexg_dev){
		DEBUG_EVENT("%s: Unregistering Lapb Protocol\n",wandev->name);
			wan_spin_lock_irq(&wandev->lock, &smp_flags);
			chan->annexg_dev = NULL;
			wan_spin_unlock_irq(&wandev->lock, &smp_flags);
		wan_spin_lock_irq(&wandev->lock, &smp_flags);
		tmp_dev=chan->annexg_dev;
		chan->annexg_dev=NULL;
		wan_spin_unlock_irq(&wandev->lock, &smp_flags);
			wan_spin_lock_irq(&wandev->lock, &smp_flags);
			chan->annexg_dev=tmp_dev;
			wan_spin_unlock_irq(&wandev->lock, &smp_flags);
	wanrouter_proc_delete_interface(wandev, card->u.c.if_name);
	wan_spin_lock_irq(&wandev->lock,&smp_flags);
	if (chan->common.prot_ptr){
				wandev->name,wan_netif_name(dev));
	dev->do_ioctl = NULL;
	if (chan->common.prot_ptr){
		wan_free(chan->common.prot_ptr);
		chan->common.prot_ptr= NULL;
	if (card->u.c.comm_enabled){
	wan_spin_unlock_irq(&wandev->lock,&smp_flags);
		wan_iface.detach(dev, chan->common.is_netdev);
	if (chan->common.usedby == API){
		wan_unreg_api(chan, card->devname);
	/* TE1 - Unconfiging, only on shutdown */
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
	sdla_t* card = chan->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= TX_TIMEOUT;
	if (!chan->common.prot_ptr){
		dev->flags     |= IFF_POINTOPOINT;
		dev->flags     |= IFF_NOARP;
		dev->type	= ARPHRD_PPP;
		dev->mtu		= card->wandev.mtu;
		dev->hard_header_len	= 0;
	dev->do_ioctl 		= &if_do_ioctl;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start); //ALEX_TODAY wandev->maddr;
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end); //ALEX_TODAY wandev->maddr + wandev->msize - 1;
        dev->tx_queue_len = 100;
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++card->wandev.stats.collisions;
	chan->tick_counter = SYSTEM_TICKS;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
				card->devname,wan_netif_name(dev));
	dev->trans_start = SYSTEM_TICKS;
	if (chan->common.usedby == STACK){
	sdla_t* card = chan->card;
		return -EBUSY;
	if (chan->common.prot_ptr){
			return -EIO;
	wan_getcurrenttime(&chan->router_start_time, NULL);
	if (chan->common.state == WAN_CONNECTED){
	card->u.c.timer_int_enabled |= TMR_INT_ENABLED_CONFIG;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	sdla_t* card = chan->card;
	WAN_TASKLET_KILL((&chan->tasklet));
	if (chan->common.prot_ptr){
	dev->start=0;
 * o set tbusy flag (marks start of the transmission) to block a timer-based
 *		non-0	packet may be re-transmitted (tbusy must be set)
	sdla_t *card = chan->card;
		 * tx-done interrupt.
			card->devname, wan_netif_name(dev));
	if (dev->tbusy){
		 * kick start the device by making dev->tbusy = 0.  We expect
                ++card->wandev.stats.collisions;
		if((SYSTEM_TICKS - chan->tick_counter) < (5 * HZ)) {
   	if (chan->common.usedby != ANNEXG &&
	    chan->common.usedby != STACK
	    ntohs(skb->protocol) != htons(PVC_PROT)
				card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
      	if(card->type != SDLA_S514){
    	if (wan_test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)){
					card->wandev.name,card->wandev.critical);
                ++card->wandev.stats.tx_dropped;
	if (card->u.c.state != WAN_CONNECTED){
		++card->wandev.stats.tx_carrier_errors;
	if (chan->common.usedby == API){
		if (card->u.c.receive_only ||
			++card->wandev.stats.tx_dropped;
		if(card->type == SDLA_S514){
			wan_spin_lock_irq(&card->wandev.lock,&smp_flags1);
			wan_spin_unlock_irq(&card->wandev.lock,&smp_flags1);
		++card->wandev.stats.tx_packets;
       		card->wandev.stats.tx_bytes += wan_skb_len(skb);
		dev->trans_start = SYSTEM_TICKS;
		wan_capture_trace_packet(card, &chan->trace_info, skb, TRC_OUTGOING_FRM);
		chan->tick_counter = SYSTEM_TICKS;
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
	wan_clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
	if(card->type != SDLA_S514){
 * Get ethernet-style interface statistics.
         * dev->priv pointer. This function, gets
	my_card = chan->card;
	return &my_card->wandev.stats;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CHDLC_CODE_VERSION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		len = mb->wan_data_len;
		memcpy(str, mb->wan_data, len);
/*-----------------------------------------------------------------------------
	wan_mbox_t *mb = &card->wan_mbox;
	mb->wan_data_len = data_length;
	memcpy(mb->wan_data, data, data_length);
	mb->wan_command = SET_CHDLC_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
 * Set interrupt mode -- HDLC Version.
	wan_mbox_t* mb = &card->wan_mbox;
		 (CHDLC_INT_TRIGGERS_STRUCT *)mb->wan_data;
	DEBUG_TEST("%s: Setting interrupt mode %02X\n", card->devname, mode);
	int_data->CHDLC_interrupt_triggers 	= mode;
	int_data->IRQ				= card->wandev.irq;	//ALEX_TODAY card->hw.irq;
	int_data->interrupt_timer               = 1;
	mb->wan_data_len = sizeof(CHDLC_INT_TRIGGERS_STRUCT);
	mb->wan_command = SET_CHDLC_INTERRUPT_TRIGGERS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = ENABLE_CHDLC_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->u.c.comm_enabled=1;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = DISABLE_CHDLC_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_COMMS_ERROR_STATS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t*	mbox = &card->wan_mbox;
	mbox->wan_data_len = 0;
	mbox->wan_command = READ_CHDLC_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
				card->devname);
		//bcopy(mbox->wan_data, cfg, sizeof(CHDLC_CONFIGURATION_STRUCT));
		memcpy(cfg, mbox->wan_data, sizeof(CHDLC_CONFIGURATION_STRUCT));
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_CHDLC_OPERATIONAL_STATS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
		card->wandev.fe_iface.read_alarm(&card->fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE);
		card->wandev.fe_iface.read_pmon(&card->fe, 0);
		card->wandev.fe_iface.read_alarm(&card->fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE);
	err_stats = (COMMS_ERROR_STATS_STRUCT *)mb->wan_data;
	card->wandev.stats.rx_over_errors =
			err_stats->Rx_overrun_err_count;
	card->wandev.stats.rx_crc_errors =
			err_stats->CRC_err_count;
	card->wandev.stats.rx_frame_errors =
			err_stats->Rx_abort_count;
	card->wandev.stats.rx_fifo_errors =
			err_stats->Rx_dis_pri_bfrs_full_count;
	card->wandev.stats.rx_missed_errors =
			card->wandev.stats.rx_fifo_errors;
	card->wandev.stats.tx_aborted_errors =
			err_stats->sec_Tx_abort_count;
	op_stats = (CHDLC_OPERATIONAL_STATS_STRUCT *)mb->wan_data;
	card->wandev.stats.rx_length_errors =
		(op_stats->Rx_Data_discard_short_count +
		op_stats->Rx_Data_discard_long_count);
 *	Return:	0 - o.k.
 *		1 - no transmit buffers available
	card->hw_iface.peek(card->hw, card->u.c.txbuf_off, &txbuf, sizeof(txbuf));
	card->hw_iface.poke(card->hw, txbuf.ptr_data_bfr, data, len);
	card->hw_iface.poke(card->hw, card->u.c.txbuf_off, &txbuf, sizeof(txbuf));
	card->hw_iface.poke_byte(card->hw,
				 card->u.c.txbuf_off+offsetof(CHDLC_DATA_TX_STATUS_EL_STRUCT, opp_flag),
	card->u.c.txbuf_off += sizeof(txbuf);
	if (card->u.c.txbuf_off > card->u.c.txbuf_last_off)
		card->u.c.txbuf_off = card->u.c.txbuf_base_off;
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_command;
			card->devname, cmd);
				card->devname);
			card->devname, cmd, err);
	if (!card->hw){
	wan_set_bit(0,&card->in_isr);
	card->spurious = 0;
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if(wan_test_bit(PERI_CRIT, (void*)&card->wandev.critical)) {
		card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	if(card->type != SDLA_S514) {
		if(wan_test_bit(0, (void*)&card->wandev.critical)) {
				card->devname, card->wandev.critical);
			card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
			if (chan->common.usedby == STACK){
			if (chan->common.usedby == API){
			if (chan->common.usedby == API){
			if (chan->common.usedby == ANNEXG &&
				  chan->annexg_dev){
					lapb_protocol.lapb_mark_bh(chan->annexg_dev);
			++card->timer_int_enabled;
				card->hw_iface.peek(card->hw,
					            card->fe_status_off,
				card->hw_iface.poke(card->hw,
					            card->fe_status_off,
			if (card->next){
				wan_set_bit(0,&card->spurious);
				card->devname,
	card->in_isr = 0;
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	card->hw_iface.peek(card->hw, card->u.c.rxmb_off, &rxbuf, sizeof(rxbuf));
			card->devname, (unsigned)card->u.c.rxmb_off, rxbuf.opp_flag);
				card->devname);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (!dev->start){
	tmp_prev_error=chan->prev_error;
	chan->prev_error=rxbuf.error_flag;
	if (chan->common.usedby == ANNEXG){
					card->devname,rxbuf.frame_length);
	if (chan->common.usedby == STACK){
					card->devname,rxbuf.frame_length);
		++card->wandev.stats.rx_dropped;
	if (chan->common.usedby == API){
		len = rxbuf.frame_length - CRC_LENGTH;
						card->devname);
		++card->wandev.stats.rx_dropped;
	if ((addr + len) > card->u.c.rx_top_off + 1) {
		unsigned tmp = card->u.c.rx_top_off - addr + 1;
		card->hw_iface.peek(card->hw, addr, buf, tmp);
		addr = card->u.c.rx_base_off;
		len -= tmp;
	card->hw_iface.peek(card->hw, addr, buf, len);
	wan_capture_trace_packet(card, &chan->trace_info, skb, TRC_INCOMING_FRM);
		card->wandev.stats.rx_packets ++;
		card->wandev.stats.rx_bytes += wan_skb_len(skb);
		skb->protocol = htons(ETH_P_IP);
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	}else if (chan->common.usedby == ANNEXG){
		if (chan->annexg_dev){
			skb->protocol = htons(ETH_P_X25);
			skb->dev = chan->annexg_dev;
			if (wan_skb_queue_len(&chan->rx_queue) > MAX_RX_QUEUE){
							card->devname);
				++card->wandev.stats.rx_dropped;
			wan_skb_queue_tail(&chan->rx_queue,skb);
			WAN_TASKLET_SCHEDULE((&chan->tasklet));
			++card->wandev.stats.rx_errors;
	}else if (chan->common.usedby == STACK){
		wan_skb_set_dev(skb, chan->annexg_dev);	//FIXME: Nenad please check this line!!!!
		if (wan_skb_queue_len(&chan->rx_queue) > MAX_RX_QUEUE){
						card->devname);
			++card->wandev.stats.rx_dropped;
		wan_skb_queue_tail(&chan->rx_queue,skb);
		WAN_TASKLET_SCHEDULE((&chan->tasklet));
		if (wan_skb_queue_len(&chan->rx_queue) > MAX_RX_QUEUE){
						card->devname);
			++card->wandev.stats.rx_dropped;
		wan_skb_queue_tail(&chan->rx_queue,skb);
		WAN_TASKLET_SCHEDULE((&chan->tasklet));
	card->hw_iface.poke(card->hw, card->u.c.rxmb_off, &rxbuf, sizeof(rxbuf));
	card->u.c.rxmb_off += sizeof(rxbuf);
	if (card->u.c.rxmb_off > card->u.c.rxbuf_last_off){
		card->u.c.rxmb_off = card->u.c.rxbuf_base_off;
 *    2) Reading board-level statistics for updating the proc file system.
        dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (card->u.c.timer_int_enabled & TMR_INT_ENABLED_TE) {
		card->wandev.fe_iface.polling(&card->fe);
		card->u.c.timer_int_enabled &= ~TMR_INT_ENABLED_TE;
	if (card->u.c.timer_int_enabled & TMR_INT_ENABLED_CONFIG) {
		card->u.c.timer_int_enabled &= ~TMR_INT_ENABLED_CONFIG;
       	if(card->u.c.timer_int_enabled & TMR_INT_ENABLED_UDP) {
		card->u.c.timer_int_enabled &= ~TMR_INT_ENABLED_UDP;
        if(!card->u.c.timer_int_enabled) {
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
/*-----------------------------------------------------------------------------
------------------------------------------------------------------------------*/
 	wan_mbox_t *mb = &card->wan_mbox;
	if(card->wandev.clocking)
		cfg.baud_rate = card->wandev.bps;
	cfg.line_config_options = (card->wandev.electrical_interface == WANOPT_RS232) ?
	cfg.asy_API_options 		= card->u.c.api_options;
	cfg.asy_protocol_options	= card->u.c.protocol_options;
	cfg.Tx_bits_per_char		= card->u.c.tx_bits_per_char;
	cfg.Rx_bits_per_char		= card->u.c.rx_bits_per_char;
	cfg.stop_bits			= card->u.c.stop_bits;
	cfg.parity			= card->u.c.parity;
	cfg.break_timer			= card->u.c.break_timer;
	cfg.asy_Rx_inter_char_timer	= card->u.c.inter_char_timer;
	cfg.asy_Rx_complete_length	= card->u.c.rx_complete_length;
	cfg.XON_char			= card->u.c.xon_char;
	cfg.XOFF_char			= card->u.c.xoff_char;
	mb->wan_data_len = sizeof(ASY_CONFIGURATION_STRUCT);
	memcpy(mb->wan_data, &cfg, mb->wan_data_len);
	mb->wan_command = SET_ASY_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
				card->devname);
	wan_mbox_t		*mb = &card->wan_mbox;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -EINVAL;
	mb->wan_data_len = 0;
	mb->wan_command = ENABLE_ASY_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->u.c.comm_enabled = 1;
/*------------------------------------------------------------------------------
	- set_chdlc_config() used to set configuration options on the board
------------------------------------------------------------------------------*/
	if(card->wandev.clocking)
		cfg.baud_rate = card->wandev.bps;
	cfg.line_config_options = (card->wandev.electrical_interface == WANOPT_RS232) ?
	cfg.CHDLC_protocol_options	= card->u.c.protocol_options | HDLC_STREAMING_MODE;
	cfg.max_CHDLC_data_field_length	= card->wandev.mtu+CRC_LENGTH;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_GLOBAL_EXCEPTION_CONDITION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		switch(mb->wan_return_code) {
				card->hw_iface.peek(card->hw,
						    card->fe_status_off,
				card->fe.fe_param.k56_param.RR8_reg_56k =
				card->fe.fe_param.k56_param.RRA_reg_56k =
				card->fe.fe_param.k56_param.RRC_reg_56k =
				card->wandev.fe_iface.read_alarm(&card->fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE);
				card->wandev.fe_iface.isr(&card->fe);
			if ((mb->wan_data[0] & (DCD_HIGH | CTS_HIGH)) == (DCD_HIGH | CTS_HIGH)){
				card->fe.fe_status = FE_CONNECTED;
				card->fe.fe_status = FE_DISCONNECTED;
				card->devname);
			switch(mb->wan_data[0] & (DCD_HIGH | CTS_HIGH)) {
					DEBUG_EVENT("%s: DCD high, CTS low\n",card->devname);
                                        DEBUG_EVENT("%s: DCD low, CTS high\n",card->devname);
                                        DEBUG_EVENT("%s: DCD high, CTS high\n",card->devname);
                                        DEBUG_EVENT("%s: DCD low, CTS low\n",card->devname);
				card->devname);
				card->devname);
				card->devname, mb->wan_return_code);
	if (card->wandev.ignore_front_end_status == WANOPT_YES){
	if (card->fe.fe_status == FE_CONNECTED){
		if (card->u.c.state == WAN_CONNECTED){
			dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
			card->wandev.state = WAN_DISCONNECTED;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CHDLC_EXCEPTION_CONDITION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			card->u.c.state = WAN_CONNECTED;
					card->devname);
				if (card->fe.fe_status != FE_CONNECTED) {
					card->wandev.state = WAN_DISCONNECTED;
				if (card->wandev.ignore_front_end_status == WANOPT_YES ||
				card->fe.fe_status == FE_CONNECTED){
			DEBUG_EVENT("%s: Exception condition: Link In-active!\n",
					card->devname);
			card->u.c.state = WAN_DISCONNECTED;
						card->devname);
						card->devname);
					card->devname,err);
	if(!wan_atomic_read(&chan->udp_pkt_len) &&
		wan_atomic_set(&chan->udp_pkt_len, wan_skb_len(skb));
		chan->udp_pkt_src = udp_pkt_src;
       		memcpy(chan->udp_pkt_data, wan_skb_data(skb)+4, wan_skb_len(skb)-4);
		card->u.c.timer_int_enabled = TMR_INT_ENABLED_UDP;
 *	if_do_ioctl - Ioctl handler for fr
	int err=-EINVAL;
		return -ENODEV;
	card=chan->card;
				err= -EINVAL;
			wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
			err=wan_bind_api_to_svc(chan,ifr->ifr_data);
			wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
				err= -EINVAL;
			wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
			err=wan_unbind_api_from_svc(chan,ifr->ifr_data);
			wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
			err = chan->common.state;
					return -ENOMEM;
				if (WAN_COPY_FROM_USER(usr_mbox,ifr->ifr_data,sizeof(wan_mbox_t))){
					return -EFAULT;
				wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
				wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
				if (WAN_COPY_TO_USER(ifr->ifr_data,usr_mbox,sizeof(wan_mbox_t))){
					return -EFAULT;
			if (wan_atomic_read(&chan->udp_pkt_len) != 0){
				return -EBUSY;
			wan_atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
			if (wan_test_bit(0,&card->in_isr)){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EBUSY;
			wan_udp_pkt=(wan_udp_pkt_t*)chan->udp_pkt_data;
			if (WAN_COPY_FROM_USER(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			if (wan_udp_pkt->wan_udp_command == DIGITAL_LOOPTEST) {
				wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
				wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
			if (wan_atomic_read(&chan->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						card->devname,wan_atomic_read(&chan->udp_pkt_len));
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EINVAL;
			if (WAN_COPY_TO_USER(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			wan_atomic_set(&chan->udp_pkt_len,0);
			if (chan->common.prot_ptr){
			return -EINVAL;
	wan_mbox_t *mb = &card->wan_mbox;
	wan_udp_pkt = (wan_udp_pkt_t *) chan->udp_pkt_data;
		if(chan->udp_pkt_src == UDP_PKT_FRM_NETWORK){
			switch(wan_udp_pkt->wan_udp_command) {
		wan_udp_pkt->wan_udp_data_len = 0;
		wan_udp_pkt->wan_udp_return_code = 0xCD;
			card->devname,wan_udp_pkt->wan_udp_command);
		wan_udp_hdr_t* udp_hdr = &wan_udp_pkt->wan_udp_hdr;
		wan_trace_t *trace_info = &chan->trace_info;
		wan_udp_pkt->wan_udp_opp_flag = 0;
		switch(wan_udp_pkt->wan_udp_command) {
			wan_udp_pkt->wan_udp_return_code =
			udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
			udp_hdr->wan_udphdr_data_len = 0;
			if (!wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
							card->devname);
				wan_set_bit (0,&trace_info->tracing_enabled);
						card->devname);
				udp_hdr->wan_udphdr_return_code = 2;
			udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
			if(wan_test_bit(0,&trace_info->tracing_enabled)) {
				wan_clear_bit(0,&trace_info->tracing_enabled);
							card->devname);
				udp_hdr->wan_udphdr_return_code = 1;
			if(wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
						card->devname);
				udp_hdr->wan_udphdr_return_code = 1;
			udp_hdr->wan_udphdr_chdlc_num_frames = 0;
			udp_hdr->wan_udphdr_chdlc_ismoredata = 0;
			while (wan_skb_queue_len(&trace_info->trace_queue)){
				WAN_IFQ_POLL(&trace_info->trace_queue, skb);
								card->devname);
				if ((WAN_MAX_DATA_SIZE - buffer_length) < skb->m_pkthdr.len){
					udp_hdr->wan_udphdr_chdlc_ismoredata = 0x01;
					   skb->m_pkthdr.len,
					   &udp_hdr->wan_udphdr_data[buffer_length]);
				buffer_length += skb->m_pkthdr.len;
				WAN_IFQ_DEQUEUE(&trace_info->trace_queue, skb);
				udp_hdr->wan_udphdr_chdlc_num_frames++;
			while ((skb=skb_dequeue(&trace_info->trace_queue)) != NULL){
				if((MAX_TRACE_BUFFER - buffer_length) < wan_skb_len(skb)){
					udp_hdr->wan_udphdr_chdlc_ismoredata = 0x01;
						wan_skb_queue_head(&trace_info->trace_queue, skb);
						memcpy(&udp_hdr->wan_udphdr_chdlc_data[buffer_length],
						udp_hdr->wan_udphdr_chdlc_num_frames++;
				memcpy(&udp_hdr->wan_udphdr_chdlc_data[buffer_length],
				udp_hdr->wan_udphdr_chdlc_num_frames++;
			udp_hdr->wan_udphdr_data_len = buffer_length;
			udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
			card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
			((unsigned char *)wan_udp_pkt->wan_udp_data )[0] =
			((unsigned char *)wan_udp_pkt->wan_udp_data )[1] =
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
			wan_udp_pkt->wan_udp_data_len = 2;
			mb->wan_data_len = 2;
			wan_getcurrenttime(&chan->router_up_time, NULL);
			chan->router_up_time -= chan->router_start_time;
			*(u_int32_t *)&wan_udp_pkt->wan_udp_data =
					chan->router_up_time;
			mb->wan_data_len = sizeof(u_int32_t);
			wan_udp_pkt->wan_udp_data_len = sizeof(u_int32_t);
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
	        	if ((wan_udp_pkt->wan_udp_data[0] & ENABLE_READ_FT1_STATUS) ||
				(wan_udp_pkt->wan_udp_data[0] & ENABLE_READ_FT1_OP_STATS)) {
					wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
					mb->wan_data_len = 1;
	      		if( wan_udp_pkt->wan_udp_data[0] == 0) {
	      	   	     	if( --rCount != 0) {
		  			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
					mb->wan_data_len = 1;
				card->wandev.fe_iface.process_udp(
						&card->fe,
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				card->wandev.fe_iface.process_udp(
						&card->fe,
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				if (wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE){
		    			wan_udp_pkt->wan_udp_data_len = sizeof(wan_femedia_t);
					wan_udp_pkt->wan_udp_return_code = CMD_OK;
					wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
		   	wan_udp_pkt->wan_udp_chdlc_num_frames = WANCONFIG_CHDLC;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_LINUX_PLATFORM;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
			wan_udp_pkt->wan_udp_data_len = 0;
			wan_udp_pkt->wan_udp_return_code = 0xCD;
			mb->wan_command = wan_udp_pkt->wan_udp_command;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
			if (mb->wan_data_len) {
				memcpy(&mb->wan_data, (unsigned char *) wan_udp_pkt->
							wan_udp_data, mb->wan_data_len);
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	         	memcpy(&wan_udp_pkt->wan_udp_hdr.wan_cmd, mb, sizeof(wan_cmd_t));
			if (mb->wan_data_len) {
	         		memcpy(&wan_udp_pkt->wan_udp_data, &mb->wan_data,
								mb->wan_data_len);
	wan_udp_pkt->wan_ip_ttl= card->wandev.ttl;
		wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	len = wan_reply_udp(card,chan->udp_pkt_data, mb->wan_data_len);
     	if(chan->udp_pkt_src == UDP_PKT_FRM_NETWORK){
	   	if (!wan_test_bit(SEND_CRIT,&card->wandev.critical)) {
			if(!chdlc_send(card, chan->udp_pkt_data, len)) {
				++ card->wandev.stats.tx_packets;
				card->wandev.stats.tx_bytes += len;
  	    		memcpy(buf, chan->udp_pkt_data, len);
					card->devname);
	wan_atomic_set(&chan->udp_pkt_len,0);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CHDLC_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			((CHDLC_CONFIGURATION_STRUCT *)mb->wan_data)->
			((CHDLC_CONFIGURATION_STRUCT *)mb->wan_data)->
	card->hw_iface.peek(card->hw, tx_config_off, &tx_config, sizeof(tx_config));
	card->u.c.txbuf_base_off =
	card->u.c.txbuf_last_off =
			card->u.c.txbuf_base_off +
			(tx_config.number_Tx_status_elements - 1) *
	card->hw_iface.peek(card->hw, rx_config_off, &rx_config, sizeof(rx_config));
	card->u.c.rxbuf_base_off =
	card->u.c.rxbuf_last_off =
			card->u.c.rxbuf_base_off +
			(rx_config.number_Rx_status_elements - 1) *
       	card->u.c.txbuf_off =
       	card->u.c.rxmb_off =
        card->u.c.rx_base_off = rx_config.base_addr_Rx_buffer;
        card->u.c.rx_top_off  = rx_config.end_addr_Rx_buffer;
	wan_mbox_t* mb = &card->wan_mbox;
	card->timer_int_enabled = 0;
			mb->wan_data_len  = 0;
			mb->wan_command = READ_CHDLC_CODE_VERSION;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	if(err || (card->timer_int_enabled < MAX_NEW_INTR_TEST_COUNTER)) {
				card->devname, card->timer_int_enabled);
				card->devname);
		return  -EIO;
				card->devname, card->timer_int_enabled);
				  wan_udp_pkt->wan_udp_signature,
				  wan_udp_pkt->wan_udp_dport,
				  ntohs(card->wandev.udp_port),
				  wan_udp_pkt->wan_ip_p,
				  wan_udp_pkt->wan_udp_request_reply,
				  skb->data[36], skb->data[37]);
	if ((wan_udp_pkt->wan_udp_dport == ntohs(card->wandev.udp_port)) &&
	   (wan_udp_pkt->wan_ip_p == UDPMGMT_UDP_PROTOCOL) &&
	   (wan_udp_pkt->wan_udp_request_reply == UDPMGMT_REQUEST)) {
		if (!strncmp(wan_udp_pkt->wan_udp_signature,UDPMGMT_SIGNATURE,8)){
		if (!strncmp(wan_udp_pkt->wan_udp_signature,GLOBAL_UDP_SIGNATURE,8)){
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
        if (card->wandev.state != state)
                                card->devname);
			if (chan->common.usedby == ANNEXG &&
			    chan->annexg_dev){
					lapb_protocol.lapb_link_up(chan->annexg_dev);
			if (chan->common.usedby == STACK){
                                card->devname);
                                card->devname);
			if (chan->common.usedby == ANNEXG &&
			    chan->annexg_dev){
					lapb_protocol.lapb_link_down(chan->annexg_dev);
			if (chan->common.usedby == STACK){
                card->wandev.state = state;
		chan->common.state = state;
	wan_spin_lock_irq(&card->wandev.lock, smp_flags);
        if (card->next){
        	wan_spin_lock(&card->next->wandev.lock);
	if (card->next){
		wan_spin_unlock(&card->next->wandev.lock);
	wan_spin_unlock_irq(&card->wandev.lock, smp_flags);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (card->u.c.comm_enabled){
	if (card->u.c.async_mode){
				card->devname);
			return -EINVAL;
					card->devname);
			return -EINVAL;
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
		int	err = -EINVAL;
			card->devname,
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
					card->devname,
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
		int	err = -EINVAL;
			card->devname);
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
				card->devname);
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
				card->devname);
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off,
	if (card->u.c.async_mode){
					card->devname);
			card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
			card->u.c.comm_enabled=0;
					card->devname);
			card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
			card->u.c.comm_enabled=0;
	card->u.c.state = WAN_CONNECTING;
		card->wandev.fe_iface.read_alarm(&card->fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE);
	card->hw_iface.set_bit(card->hw, card->intr_perm_off,
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0);
	if (!chan->common.prot_ptr){
	if (chan->ignore_modem)
		new_skb->protocol = htons(ETH_P_WAN_PPP);
		new_skb->dev = dev;
		wan_skb_queue_tail(&chan->rx_queue,new_skb);
		WAN_TASKLET_SCHEDULE((&chan->tasklet));
#define PROC_CFG_FRM	"%-15s| %-12s|\n"
#define PROC_STAT_FRM	"%-15s| %-12s| %-14s|\n"
		return m->count;
	card = chan->card;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		PROC_CFG_FRM, card->u.c.if_name, card->devname);
	return m->count;
		return m->count;
	card = chan->card;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		card->u.c.if_name, card->devname, STATE_DECODE(chan->common.state));
	return m->count;
#define PROC_DEV_FR_S_FRM	"%-20s| %-14s|\n"
#define PROC_DEV_FR_D_FRM	"%-20s| %-14d|\n"
	card = (sdla_t*)wandev->priv;
			wandev->name, buffer);
#define PROC_IF_FR_S_FRM	"%-30s\t%-14s\n"
#define PROC_IF_FR_D_FRM	"%-30s\t%-14d\n"
#define PROC_IF_FR_L_FRM	"%-30s\t%-14ld\n"
	if (chan->card == NULL)
	card = chan->card;
			card->u.c.if_name, buffer);
	wan_mbox_t* mb = &card->wan_mbox;
	ADAPTER_CONFIGURATION_STRUCT* cfg = (ADAPTER_CONFIGURATION_STRUCT*)mb->wan_data;
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &cfg->adapter_type);
	cfg->adapter_config = 0x00;
	cfg->operating_frequency = 00;
	mb->wan_data_len = sizeof(ADAPTER_CONFIGURATION_STRUCT);
	mb->wan_command = SET_ADAPTER_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card->u.c.timer_int_enabled |= TMR_INT_ENABLED_TE;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	sdla_t *card = chan->card;
	if (wan_test_bit(PERI_CRIT, (void*)&card->wandev.critical)){
				card->devname);
		WAN_TASKLET_END((&chan->tasklet));
	if (!WAN_NETIF_UP(chan->dev)){
				card->devname);
		WAN_TASKLET_END((&chan->tasklet));
	while ((skb=wan_skb_dequeue(&chan->rx_queue))){
		if (chan->common.usedby == WANPIPE){
			card->wandev.stats.rx_packets ++;
			card->wandev.stats.rx_bytes += wan_skb_len(skb);
			wp_sppp_input(skb->dev,skb);
		if (chan->common.usedby == API){
						chan->if_name,
				++card->wandev.stats.rx_dropped;
			wan_skb_set_dev(skb, chan->common.dev);
			skb->pkt_type = WAN_PACKET_DATA;
				card->wandev.stats.rx_packets++;
				card->wandev.stats.rx_bytes += len;
				++card->wandev.stats.rx_dropped;
		}else if (chan->common.usedby == STACK){
				++card->wandev.stats.rx_dropped;
				card->wandev.stats.rx_packets++;
				card->wandev.stats.rx_bytes += len;
			if (chan->annexg_dev){
					lapb_protocol.lapb_rx(chan->annexg_dev,skb);
					card->wandev.stats.rx_packets++;
					card->wandev.stats.rx_bytes += len;
					++card->wandev.stats.rx_dropped;
				++card->wandev.stats.rx_dropped;
			++card->wandev.stats.rx_dropped;
	WAN_TASKLET_END((&chan->tasklet));
	sdla_t *card = chan->card;
		return -EINVAL;
	if (chan->common.usedby != ANNEXG)
		return -EPROTONOSUPPORT;
	if (chan->annexg_dev)
		return -EBUSY;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	chan->annexg_dev = annexg_dev;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	sdla_t *card = wandev->priv;
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (!chan->annexg_dev || chan->common.usedby != ANNEXG)
		if (chan->annexg_dev == annexg_dev){
			wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
			chan->annexg_dev = NULL;
			wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	if (chan->common.usedby == ANNEXG && chan->annexg_dev){
			lapb_protocol.lapb_get_active_inactive(chan->annexg_dev,wp_stats);
	if (chan->common.state == WAN_CONNECTED){
		wp_stats->fr_active++;
		wp_stats->fr_inactive++;
	if (!(dev->flags&IFF_UP)){
		return m->count;
	if (chan->common.usedby == ANNEXG && chan->annexg_dev){
			return lapb_protocol.lapb_get_map(chan->annexg_dev,
		chan->label,
		wandev->name,(wandev->state == WAN_CONNECTED) ? '*' : ' ',
		dev->name,(chan->common.state == WAN_CONNECTED) ? '*' : ' ');
	return m->count;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (chan->common.state != WAN_CONNECTED) {
		                        card->devname);
	skb = wan_skb_alloc(wan_udp_pkt->wan_udp_data_len+100);
	switch (chan->common.usedby) {
			card->devname);
	buf = wan_skb_put(skb, wan_udp_pkt->wan_udp_data_len);
	memcpy(buf, wan_udp_pkt->wan_udp_data, wan_udp_pkt->wan_udp_data_len);
	skb->next = skb->prev = NULL;
        skb->dev = dev;
        skb->protocol = htons(ETH_P_IP);
				card->devname);
	wan_mbox_t *mb = &card->wan_mbox;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
./wanpipe_multppp.c
	/* USB-FXO */
		wan_set_bit(WUD_STATUS_DOWN, &sc->status);
	struct wud_desc 	*dinfo = (struct wud_desc *)id->driver_info;
				dinfo->name, dev->devnum);
		return -ENODEV;
				WUD_MOD_DESC, dev->devnum);
				WUD_MOD_NAME, dev->devnum);
				WUD_MOD_NAME, dev->devnum);
	DEBUG_EVENT("%s: WARNING: Pre-reset USB device on %d \n",
				WUD_MOD_NAME, dev->devnum);
	DEBUG_EVENT("%s: WARNING: Post-Reset USB device on %d \n",
				WUD_MOD_NAME, dev->devnum);
	wud_softc_t	*sc = (wud_softc_t*)q->context;
	if (wan_test_bit(WUD_STATUS_DOWN, &sc->status)){
	if (!wan_test_bit(WUD_STATUS_READY, &sc->status)){
					sc->name);
	if (q->actual_length < MAX_WUD_RX_LEN){
					sc->name, 
					q->actual_length,
	rxcount_bytes += q->actual_length;
			sc->name, rxcount, rxcount_bytes,
			(unsigned long)(SYSTEM_TICKS-last_ticks)); 
			sc->name, rxcount, (unsigned long)SYSTEM_TICKS);
	zt_receive(&sc->span);
	zt_transmit(&sc->span);
		"%s: Failed to re-start RX transfer request!\n",
					sc->name);
	wud_softc_t	*sc = (wud_softc_t*)q->context;
		(((epd)->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
		(((epd)->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)
		(((epd)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==	\
	iface_desc = intf->cur_altsetting;
	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
		endpoint = &iface_desc->endpoint[i].desc;
						sc->name, i);
						sc->name, i);
		usb_init_urb(&sc->rx_urb);
				&sc->rx_urb,
				sc->usb_dev,
				usb_rcvbulkpipe (sc->usb_dev,
						   endpoint->bEndpointAddress),
				sc->rx_buf, 
					sc->name,
					endpoint->bEndpointAddress);
		usb_init_urb(&sc->tx_urb);
				&sc->tx_urb,
				sc->usb_dev,
				usb_sndbulkpipe (sc->usb_dev,
						endpoint->bEndpointAddress),
				sc->tx_buf, 
					sc->name,
					endpoint->bEndpointAddress);
	if (wan_test_bit(WUD_STATUS_DOWN, &sc->status)){
		return -EINVAL; 
					sc->name, ret);
		return -EINVAL;
	WAN_ASSERT(sc->usb_dev == NULL);
	length = (((size - 1) | 3) + 1)/4;
					sc->name, (length*sizeof(__le32)));
		return -ENOMEM;
		result = usb_control_msg (sc->usb_dev,
				usb_sndctrlpipe(sc->usb_dev, 0),
		result = usb_control_msg (sc->usb_dev,
				usb_sndctrlpipe(sc->usb_dev, 0),
					sc->name, request, size, result);
		return -EPROTO;
	result = usb_control_msg(sc->usb_dev,
				usb_sndctrlpipe(sc->usb_dev, 0),
 * 'data' is a pointer to a pre-allocated array of integers large
	WAN_ASSERT(sc->usb_dev == NULL);
	length = (((size - 1) | 3) + 1)/4;
					sc->name, (length*sizeof(__le32)));
		return -ENOMEM;
	result = usb_control_msg (	sc->usb_dev,
					usb_rcvctrlpipe (sc->usb_dev, 0),
					sc->name, request, size, result);
		return -EPROTO;
		return -ENODEV;
	sprintf(sc->name, "%s0", WUD_NAME);
	sc->usb_intf	= intf;
	sc->usb_dev	= dev;
				sc->name);
					sc->name);
					sc->name, baud);
					sc->name, bits);
					sc->name);
	usb_set_intfdata(sc->usb_intf, sc);
	wan_set_bit(WUD_STATUS_READY, &sc->status);
					sc->name);
		usb_set_intfdata(sc->usb_intf, NULL);
	if (wud_start_transfer(sc, &sc->rx_urb)) {
					sc->name);
		zt_unregister(&sc->span);
		usb_set_intfdata(sc->usb_intf, NULL);
	wan_clear_bit(WUD_STATUS_READY, &sc->status);
	usb_set_intfdata(sc->usb_intf, NULL);
	return -ENODEV;
		wan_clear_bit(WUD_STATUS_READY, &sc->status);
		zt_unregister(&sc->span);
		usb_unlink_urb(&sc->rx_urb);
		usb_kill_urb(&sc->rx_urb);
		usb_set_intfdata(sc->usb_intf, NULL);
	sprintf(sc->span.name, "WPUSBDUMMY/1");
	snprintf(sc->span.desc, sizeof(sc->span.desc) - 1, "%s (source: " WUD_CLOCK_SRC ") %d", sc->span.name, 1);
	sprintf(sc->chan.name, "WPUSBDUMMY/%d/%d", 1, 0);
	strncpy(sc->span.devicetype, WUD_MOD_DESC, sizeof(sc->span.devicetype) - 1);
	sc->chan.chanpos = 1;
	sc->span.chans = &sc->chan;
	sc->span.channels = 0;		/* no channels on our span */
	sc->span.deflaw = ZT_LAW_MULAW;
	init_waitqueue_head(&sc->span.maintq);
	sc->span.pvt = sc;
	sc->chan.pvt = sc;
	if (zt_register(&sc->span, 0)) {
		return -1;
./wpusbdummy_main.c
* Copyright:	(c) 2003-2005 Sangoma Technologies Inc.
	wan_skb_queue_purge(&tdm_api->wp_rx_list);
	wan_skb_queue_purge(&tdm_api->wp_rx_free_list);
	wan_skb_queue_purge(&tdm_api->wp_tx_free_list);
	wan_skb_queue_purge(&tdm_api->wp_tx_list);
	wan_skb_queue_purge(&tdm_api->wp_event_list);
	if (tdm_api->rx_skb){
		wan_skb_free(tdm_api->rx_skb);
		tdm_api->rx_skb=NULL;
	if (tdm_api->tx_skb){
		wan_skb_free(tdm_api->tx_skb);
		tdm_api->tx_skb=NULL;
	tdm_api->rx_gain=NULL;
	tdm_api->tx_gain=NULL;
	if (tdm_api->tdm_span == 1 && tdm_api->tdm_chan == 1) {
			DEBUG_EVENT("%s: TDMAPI WAKING DEV \n",tdm_api->name);
	if (tdm_api->cdev) {
		wanpipe_cdev_wake(tdm_api->cdev);
		return -1;
		wan_skb_queue_init(&tdm_api->wp_rx_list);
		wan_skb_queue_init(&tdm_api->wp_rx_free_list);
		wan_skb_queue_init(&tdm_api->wp_tx_free_list);
		wan_skb_queue_init(&tdm_api->wp_tx_list);
		wan_skb_queue_init(&tdm_api->wp_event_list);
		wan_set_bit(0,&tdm_api->init);
		wan_spin_lock_init(&tdm_api->lock, "wan_tdmapi_lock");
		cdev->dev_ptr=&tdmapi_ctrl;
		tdm_api->cdev=cdev;
		memcpy(&cdev->ops, &wp_tdmapi_fops, sizeof(wanpipe_cdev_ops_t));
		return -1;
	card = (sdla_t*)tdm_api->card;
	wan_skb_queue_init(&tdm_api->wp_rx_list);
	wan_skb_queue_init(&tdm_api->wp_rx_free_list);
	wan_skb_queue_init(&tdm_api->wp_tx_free_list);
	wan_skb_queue_init(&tdm_api->wp_tx_list);
	wan_skb_queue_init(&tdm_api->wp_event_list);
	tdm_api->cfg.rbs_poll=0;
	if (tdm_api->hdlc_framing) {
			tdm_api->cfg.hw_mtu_mru		=300;
			tdm_api->cfg.usr_mtu_mru	=300;
			tdm_api->cfg.hw_mtu_mru		=1500;
			tdm_api->cfg.usr_mtu_mru	=1500;
		tdm_api->cfg.usr_period		=0;
		tdm_api->cfg.tdm_codec		=WP_NONE;
		tdm_api->cfg.power_level	=0;
		tdm_api->cfg.rx_disable		=0;
		tdm_api->cfg.tx_disable		=0;
		tdm_api->cfg.ec_tap		=0;
		tdm_api->cfg.rbs_rx_bits	=-1;
		tdm_api->cfg.hdlc		=1;
		tdm_api->cfg.tdm_codec		=WP_NONE;
		tdm_api->cfg.power_level	=0;
		tdm_api->cfg.rx_disable		=0;
		tdm_api->cfg.tx_disable		=0;
		tdm_api->cfg.ec_tap			=0;
		tdm_api->cfg.rbs_rx_bits	=-1;
		tdm_api->cfg.hdlc			=0;
		tdm_api->tx_q_len			= WP_TDM_MAX_TX_Q_LEN;
		if (!tdm_api->span_mode) {
			tdm_api->cfg.hw_mtu_mru		=8;
			tdm_api->cfg.usr_period		=10;
			tdm_api->cfg.usr_mtu_mru = tdm_api->cfg.usr_period*tdm_api->cfg.hw_mtu_mru;
		if (tdm_api->cfg.idle_flag == 0) {
        		tdm_api->cfg.idle_flag=0xFF;
	tdm_api->critical=0;
	wan_clear_bit(0,&tdm_api->used);
		wp_tdmapi_global_cnt--;
	wan_spin_lock_init(&tdm_api->lock, "wan_tdmapi_lock");
	sprintf(tmp_name,"wptdm_s%dc%d",tdm_api->tdm_span,tdm_api->tdm_chan);
			card->devname,tmp_name, tdm_api->tx_q_len);
	card->wandev.event_callback.rbsbits		= wp_tdmapi_rbsbits;
	card->wandev.event_callback.alarms		= wp_tdmapi_alarms;
	card->wandev.event_callback.hook		= wp_tdmapi_hook;
	card->wandev.event_callback.ringdetect	= wp_tdmapi_ringdetect;
	card->wandev.event_callback.ringtrip	= wp_tdmapi_ringtrip;
	card->wandev.event_callback.linkstatus		= wp_tdmapi_linkstatus;
	tdm_api->dtmfsupport = WANOPT_YES;
	card->wandev.event_callback.dtmf = wp_tdmapi_dtmf;
	if (tdm_api->cfg.rbs_tx_bits) {
					tdm_api->cfg.rbs_tx_bits);
		tdm_api->write_rbs_bits(tdm_api->chan,
		                        tdm_api->tdm_chan,
					(u8)tdm_api->cfg.rbs_tx_bits);
	cdev->dev_ptr=tdm_api;
	tdm_api->cdev=cdev;
	cdev->span=tdm_api->tdm_span;
	cdev->chan=tdm_api->tdm_chan;
	sprintf(cdev->name,tmp_name,sizeof(cdev->name));
	memcpy(&cdev->ops, &wp_tdmapi_fops, sizeof(wanpipe_cdev_ops_t));
		wp_tdmapi_global_cnt--;
	wan_set_bit(WP_TDM_DOWN,&tdm_api->critical);
	if (wan_test_bit(0,&tdm_api->used)) {
			tdm_api->name,tdm_api->tdm_span,tdm_api->tdm_chan);
		return -EBUSY;
	if (tdm_api->cdev) {
		wanpipe_cdev_free(tdm_api->cdev);
		wan_free(tdm_api->cdev);
		tdm_api->cdev=NULL;
	wp_tdmapi_global_cnt--;
	if (tdm_api == NULL || !wan_test_bit(0,&tdm_api->init)){
		return -ENODEV;
       	tdm_api->state = (u8)state;
       	tdm_api->cfg.fe_alarms = (state == WAN_CONNECTED ? 0 : 1);
	if (tdm_api == NULL || !wan_test_bit(0,&tdm_api->init)){
		return -ENODEV;
	if (is_tdm_api_stopped(tdm_api) || (unsigned)wan_skb_queue_len(&tdm_api->wp_tx_list) > tdm_api->tx_q_len){
		if (wan_test_bit(0,&tdm_api->used)) {
		return -ENODEV;
	if (wan_test_bit(WP_TDM_DOWN,&tdm_api->critical)) {
		return -ENODEV;
	if (wan_test_and_set_bit(0,&tdm_api->used)) {
				tdm_api->name, tdm_api->tdm_span,tdm_api->tdm_span);
		return -EBUSY;
		__FUNCTION__, tdm_api->tdm_span, tdm_api->tdm_chan, tdm_api);
	if (tdm_api == NULL || !wan_test_bit(0,&tdm_api->init) || !wan_test_bit(0,&tdm_api->used)) {
		return -ENODEV;
		return -EINVAL;
	if (wan_test_bit(WP_TDM_DOWN,&tdm_api->critical)) {
		return -ENODEV;
	skb=wan_skb_dequeue(&tdm_api->wp_rx_list);
		return -ENOBUFS;
	if (tdm_api->tdm_span == 1 &&
	    tdm_api->tdm_chan == 1) {
				tdm_api->name, gread_cnt,
				wan_skb_len(skb)-sizeof(wp_tdm_api_rx_hdr_t));
		return -EFAULT;
	if (tdm_api->hdlc_framing ||
	    wan_skb_queue_len(&tdm_api->wp_rx_free_list) > WP_TDM_MAX_RX_FREE_Q_LEN) {
			wan_skb_queue_tail(&tdm_api->wp_rx_free_list,skb);
	if (wan_test_and_set_bit(WP_TDM_HDLC_TX,&tdm_api->critical)){
		return -1;
	while ((skb=wan_skb_dequeue(&tdm_api->wp_tx_list)) != NULL) {
		err=tdm_api->write_hdlc_frame(tdm_api->chan,skb);
			wan_skb_queue_head(&tdm_api->wp_tx_list, skb);
		tdm_api->cfg.stats.tx_packets++;
	wan_clear_bit(WP_TDM_HDLC_TX,&tdm_api->critical);
	if (tdm_api == NULL || !wan_test_bit(0,&tdm_api->init) || !wan_test_bit(0,&tdm_api->used)){
		return -ENODEV;
		return -EINVAL;
	if (wan_test_bit(WP_TDM_DOWN,&tdm_api->critical)) {
		return -ENODEV;
		return -EINVAL;
	if (wan_skb_queue_len(&tdm_api->wp_tx_list) > tdm_api->tx_q_len){
	if (tdm_api->span_mode || tdm_api->hdlc_framing) {
		if (wan_skb_len(skb) > (tdm_api->cfg.usr_mtu_mru + sizeof(wp_tdm_api_tx_hdr_t))) {
			return -EFBIG;
				tdm_api->name,count);
			return -EFBIG;
	if (tdm_api->span_mode || tdm_api->hdlc_framing) {
		wan_skb_queue_tail(&tdm_api->wp_tx_list, skb);
		if (tdm_api->tdm_span == 1 &&
			tdm_api->tdm_chan == 1) {
						tdm_api->name, gwrite_cnt,
						wan_skb_len(skb)-sizeof(wp_tdm_api_tx_hdr_t));
		wan_skb_queue_tail(&tdm_api->wp_tx_list, skb);
	if (tdm_api == NULL || !wan_test_bit(0,&tdm_api->init)){
		return -ENODEV;
	wan_clear_bit(0,&tdm_api->used);
	wan_spin_lock(&tdm_api->lock);
	tdm_api->cfg.rbs_rx_bits=-1;
	tdm_api->cfg.rbs_tx_bits=-1;
	tdm_api->cfg.rbs_poll=0;
	wan_spin_unlock(&tdm_api->lock);
	if (!wan_test_bit(0,&tdm_api->used)) {
	if (wan_skb_queue_len(&tdm_api->wp_event_list) > WP_TDM_MAX_CTRL_EVENT_Q_LEN) {
		wan_skb_queue_tail(&tdm_api->wp_event_list,nskb);
	if (tdm_api->cfg.rbs_poll){
	if (tdm_api == NULL || !wan_test_bit(0,&tdm_api->init) || !wan_test_bit(0,&tdm_api->used)){
		return -ENODEV;
	if (wan_test_bit(WP_TDM_DOWN,&tdm_api->critical)) {
		return -ENODEV;
	if (tdm_api->tdm_span == 1 && tdm_api->tdm_chan == 1) {
				tdm_api->name, gpoll_cnt,
				wan_skb_queue_len(&tdm_api->wp_tx_free_list),
				wan_skb_queue_len(&tdm_api->wp_rx_free_list),
				tdm_api->cfg.stats.tx_carrier_errors,
				tdm_api->cfg.stats.tx_errors,
				tdm_api->cfg.stats.tx_packets);
	if (!wan_test_bit(0,&tdm_api->cfg.tx_disable)){
		if ((tdm_api->span_mode || tdm_api->hdlc_framing) &&
		    wan_skb_queue_len(&tdm_api->wp_tx_list) > tdm_api->tx_q_len &&
		if (wan_skb_queue_len(&tdm_api->wp_tx_list) <= tdm_api->tx_q_len) {
	if (!wan_test_bit(0,&tdm_api->cfg.rx_disable) &&
	    wan_skb_queue_len(&tdm_api->wp_rx_list)) {
	if (tdm_api->cfg.rbs_poll){
	if (wan_skb_queue_len(&tdm_api->wp_event_list)) {
	if (!tdm_api->cfg.rbs_poll) {
	if (SYSTEM_TICKS - tdm_api->rbs_poll_cnt < tdm_api->cfg.rbs_poll) {
	tdm_api->rbs_poll_cnt=SYSTEM_TICKS;
	if (!tdm_api->read_rbs_bits) {
		tdm_api->name,SYSTEM_TICKS,tdm_api->cfg.stats.rx_errors);
		tdm_api->cfg.stats.rx_errors=0;
	tdm_api->read_rbs_bits(	tdm_api->chan,
				tdm_api->tdm_chan,
	if (tdm_api->cfg.rbs_rx_bits == rbs_bits) {
			tdm_api->name, tdm_api->cfg.rbs_rx_bits, rbs_bits);
	tdm_api->cfg.rbs_rx_bits = rbs_bits;
	if (wan_skb_queue_len(&tdm_api->wp_event_list) > WP_TDM_MAX_EVENT_Q_LEN) {
	pevent->wp_tdm_api_event_type	= WP_TDMAPI_EVENT_RBS;
	pevent->wp_tdm_api_event_rbs_bits = (u8)tdm_api->cfg.rbs_rx_bits;
	rx_hdr->event_time_stamp = gettimeofday();
	pevent->channel = tdm_api->tdm_chan;
	wan_skb_queue_tail(&tdm_api->wp_event_list,skb);
			tdm_api->name, tdm_api->state);
	if (!wan_test_bit(0,&tdm_api->used)) {
	pevent->wp_tdm_api_event_type = WP_TDMAPI_EVENT_ALARM;
	pevent->wp_tdm_api_event_alarm = (state == WAN_CONNECTED) ? 0 : 1;
	rx_hdr->event_time_stamp = gettimeofday();
	pevent->span = (u_int8_t)tdm_api->tdm_span;
	pevent->channel = (u_int8_t)tdm_api->tdm_chan;
	if (!wan_test_bit(0,&tdm_api->used) ||
	    wan_skb_queue_len(&tdm_api->wp_event_list) > WP_TDM_MAX_EVENT_Q_LEN) {
	wan_skb_queue_tail(&tdm_api->wp_event_list,skb);
	sdla_t *card = (sdla_t*)tdm_api->card;
	if (!tdm_api->chan && tdm_api != &tdmapi_ctrl){
		return -EFAULT;
		return -EINVAL;
	       return -EFAULT;
	DEBUG_TDMAPI("%s: TDM API CMD: %i\n",tdm_api->name,cmd);
	wan_spin_lock(&tdm_api->lock);
	if (tdm_api->hdlc_framing) {
			DEBUG_EVENT("%s: Invalid TDM API HDLC CMD %i\n", tdm_api->name,cmd);
			err=-EOPNOTSUPP;
			DEBUG_EVENT("%s: Invalid TDM API for CTRL DEVICE %i\n", tdm_api->name,cmd);
			err=-EOPNOTSUPP;
		err=-EOPNOTSUPP;
		usr_tdm_api.hw_mtu_mru = tdm_api->cfg.hw_mtu_mru;
		if (tdm_api->span_mode) {
			err=-EOPNOTSUPP;
			usr_tdm_api.usr_mtu_mru = usr_tdm_api.usr_period*tdm_api->cfg.hw_mtu_mru;
			err = -EINVAL;
					tdm_api->name,usr_tdm_api.usr_period);
		usr_tdm_api.usr_mtu_mru = wanpipe_codec_calc_new_mtu(tdm_api->cfg.tdm_codec,
		tdm_api->cfg.usr_period = usr_tdm_api.usr_period;
		tdm_api->cfg.usr_mtu_mru = usr_tdm_api.usr_mtu_mru;
		usr_tdm_api.usr_period = tdm_api->cfg.usr_period;
		usr_tdm_api.usr_mtu_mru = tdm_api->cfg.usr_mtu_mru;
		if (tdm_api->span_mode) {
			err=-EOPNOTSUPP;
		if (usr_tdm_api.tdm_codec == tdm_api->cfg.tdm_codec){
			err = -EINVAL;
			usr_tdm_api.usr_mtu_mru = tdm_api->cfg.hw_mtu_mru * tdm_api->cfg.usr_period;
			wp_codec_ops = WANPIPE_CODEC_OPS[tdm_api->cfg.hw_tdm_coding][usr_tdm_api.tdm_codec];
			if (!wp_codec_ops || !wp_codec_ops->init){
				err = -EINVAL;
						tdm_api->name,usr_tdm_api.tdm_codec);
								      tdm_api->cfg.usr_mtu_mru);
		tdm_api->cfg.usr_mtu_mru=usr_tdm_api.usr_mtu_mru;
		tdm_api->cfg.tdm_codec = usr_tdm_api.tdm_codec;
		usr_tdm_api.tdm_codec = tdm_api->cfg.tdm_codec;
		tdm_api->cfg.power_level = usr_tdm_api.power_level;
		usr_tdm_api.power_level = tdm_api->cfg.power_level;
		if (tdm_api->cfg.tx_disable){
			wan_clear_bit(0,&tdm_api->cfg.rx_disable);
			wan_set_bit(0,&tdm_api->cfg.rx_disable);
		if (tdm_api->cfg.tx_disable){
			wan_clear_bit(0,&tdm_api->cfg.tx_disable);
			wan_set_bit(0,&tdm_api->cfg.tx_disable);
				tdm_api->cfg.ec_tap = usr_tdm_api.ec_tap;
						tdm_api->name);
				err = -EINVAL;
		usr_tdm_api.ec_tap = tdm_api->cfg.ec_tap;
		if (card && card->wandev.ec_enable) {
			card->hw_iface.hw_lock(card->hw,&smp_flags1);
                	card->wandev.ec_enable(card, 1, tdm_api->tdm_chan);
			card->hw_iface.hw_unlock(card->hw,&smp_flags1);
		if (card && card->wandev.ec_enable) {
			card->hw_iface.hw_lock(card->hw,&smp_flags1);
                	card->wandev.ec_enable(card, 0, tdm_api->tdm_chan);
			card->hw_iface.hw_unlock(card->hw,&smp_flags1);
		if (card && card->wandev.ec_enable && card->u.aft.tdmv_hw_dtmf == WANOPT_YES) {
		memcpy(&usr_tdm_api.stats,&tdm_api->cfg.stats,sizeof(tdm_api->cfg.stats));
		memcpy(&usr_tdm_api.data[0],&tdm_api->cfg,sizeof(wanpipe_tdm_cfg_t)-sizeof(wp_tdm_chan_stats_t));
					tdm_api->name);
		tdm_api->cfg.rbs_poll = usr_tdm_api.rbs_poll;
		if (card && card->wandev.fe_iface.set_fe_sigctrl){
                 	card->wandev.fe_iface.set_fe_sigctrl(
					&card->fe,
		tdm_api->cfg.rbs_poll=0;
		if (card && card->wandev.fe_iface.set_fe_sigctrl){
                 	card->wandev.fe_iface.set_fe_sigctrl(
					&card->fe,
		wan_spin_unlock(&tdm_api->lock);
		err=tdm_api->write_rbs_bits(
						tdm_api->chan,
					    tdm_api->tdm_chan,
			DEBUG_EVENT("%s: WRITE RBS Error (%i)\n",tdm_api->name,err);
		if (card && card->wandev.fe_iface.get_fe_status){
			card->hw_iface.hw_lock(card->hw,&smp_flags1);
                 	card->wandev.fe_iface.get_fe_status(
					&card->fe, &usr_tdm_api.fe_status,tdm_api->tdm_chan);
			card->hw_iface.hw_unlock(card->hw,&smp_flags1);
		if (card && card->wandev.fe_iface.set_fe_status){
			card->hw_iface.hw_lock(card->hw,&smp_flags1);
                 	card->wandev.fe_iface.set_fe_status(
					&card->fe, usr_tdm_api.fe_status);
			card->hw_iface.hw_unlock(card->hw,&smp_flags1);
		skb=wan_skb_dequeue(&tdm_api->wp_event_list);
			err=-ENOBUFS;
		usr_tdm_api.hw_tdm_coding = tdm_api->cfg.hw_tdm_coding;
		if (usr_tdm_api.data_len && utdmapi->data) {
                         	err=-EINVAL;
			wan_spin_unlock(&tdm_api->lock);
                         		err=-ENOMEM;
			memcpy(rx_gains, utdmapi->data, usr_tdm_api.data_len);*/
					       utdmapi->data,
	       			err=-EFAULT;
		       	wan_spin_lock(&tdm_api->lock);
		       	tdm_api->rx_gain = rx_gains;
	       	       	err=-EFAULT;
		usr_tdm_api.fe_alarms = (tdm_api->state == WAN_CONNECTED ? 0 : 1);
		if (usr_tdm_api.data_len && utdmapi->data) {
                         	err=-EINVAL;
			wan_spin_unlock(&tdm_api->lock);
                         		err=-ENOMEM;
			memcpy(tx_gains, utdmapi->data, usr_tdm_api.data_len);*/
					       utdmapi->data,
	       			err=-EFAULT;
		       	wan_spin_lock(&tdm_api->lock);
		       	tdm_api->tx_gain = tx_gains;
				err=-EFAULT;
		tdm_api->rx_gain = NULL;
		tdm_api->tx_gain = NULL;
		if (tdm_api->process_udp) {
			err=tdm_api->process_udp(card, NULL, tdm_api->chan, 1);
		DEBUG_EVENT("%s: Invalid TDM API CMD %i\n", tdm_api->name,cmd);
		err=-EOPNOTSUPP;
	wan_spin_unlock(&tdm_api->lock);
	       return -EFAULT;
	if (tdm_api->event_ctrl == NULL){
				tdm_api->name);
		return -EINVAL;
	tdm_event = &tdm_cmd->event;
	switch(tdm_event->wp_tdm_api_event_type){
			tdm_api->name,
			WP_TDMAPI_EVENT_MODE_DECODE(tdm_event->wp_tdm_api_event_mode),
			tdm_api->active_ch);
		if (tdm_event->wp_tdm_api_event_mode == WP_TDMAPI_EVENT_ENABLE){
		if(tdm_event->channel < 1 || tdm_event->channel > NUM_OF_E1_CHANNELS - 1/* 31 */){
				__FUNCTION__, tdm_api->name, tdm_event->channel);
			tdm_event->channel = 1;/* */
		event_ctrl.channel	= tdm_event->channel;
		event_ctrl.channel	= tdm_api->tdm_chan;
		// A200-Remora DTMF event
		DEBUG_TDMAPI("%s: %s A200-Remora DTMF event!\n",
			tdm_api->name,
			WP_TDMAPI_EVENT_MODE_DECODE(tdm_event->wp_tdm_api_event_mode));
		if (tdm_event->wp_tdm_api_event_mode == WP_TDMAPI_EVENT_ENABLE){
		event_ctrl.mod_no	= tdm_api->tdm_chan;
		DEBUG_TDMAPI("%s: %s A200-Remora Loop Closure event!\n",
			tdm_api->name,
			WP_TDMAPI_EVENT_MODE_DECODE(tdm_event->wp_tdm_api_event_mode));
		if (tdm_event->wp_tdm_api_event_mode == WP_TDMAPI_EVENT_ENABLE){
		event_ctrl.mod_no	= tdm_api->tdm_chan;
			tdm_api->name,
			WP_TDMAPI_EVENT_MODE_DECODE(tdm_event->wp_tdm_api_event_mode),
			tdm_api->tdm_chan);
		if (tdm_event->wp_tdm_api_event_mode == WP_TDMAPI_EVENT_ENABLE){
		event_ctrl.mod_no	= tdm_api->tdm_chan;
			tdm_api->name,
			WP_TDMAPI_EVENT_MODE_DECODE(tdm_event->wp_tdm_api_event_mode),
			tdm_api->tdm_chan);
		if (tdm_event->wp_tdm_api_event_mode == WP_TDMAPI_EVENT_ENABLE){
		event_ctrl.mod_no	= tdm_api->tdm_chan;
			tdm_api->name,
			WP_TDMAPI_EVENT_MODE_DECODE(tdm_event->wp_tdm_api_event_mode),
			tdm_api->tdm_chan);
		if (tdm_event->wp_tdm_api_event_mode == WP_TDMAPI_EVENT_ENABLE){
		event_ctrl.mod_no	= tdm_api->tdm_chan;
			tdm_api->name,
			WP_TDMAPI_EVENT_MODE_DECODE(tdm_event->wp_tdm_api_event_mode),
			tdm_event->wp_tdm_api_event_tone_type,
			tdm_api->tdm_chan);
		if (tdm_event->wp_tdm_api_event_mode == WP_TDMAPI_EVENT_ENABLE){
			switch(tdm_event->wp_tdm_api_event_tone_type){
						tdm_api->name,
						tdm_event->wp_tdm_api_event_tone_type);
				return -EINVAL;
		event_ctrl.mod_no	= tdm_api->tdm_chan;
				tdm_api->name, tdm_api->tdm_chan);
		event_ctrl.mod_no	= tdm_api->tdm_chan;
				tdm_api->name, tdm_api->tdm_chan);
		event_ctrl.mod_no	= tdm_api->tdm_chan;
				tdm_api->name, tdm_api->tdm_chan);
		event_ctrl.mod_no	= tdm_api->tdm_chan;
				tdm_api->name, tdm_api->tdm_chan);
		event_ctrl.mod_no	= tdm_api->tdm_chan;
				tdm_api->name, tdm_api->tdm_chan);
		event_ctrl.mod_no	= tdm_api->tdm_chan;
		event_ctrl.ohttimer	= tdm_event->wp_tdm_api_event_ohttimer;
				tdm_api->name, tdm_api->tdm_chan);
		event_ctrl.mod_no	= tdm_api->tdm_chan;
		event_ctrl.polarity	= tdm_event->wp_tdm_api_event_polarity;
		event_ctrl.channel	= tdm_event->channel;
		if (tdm_event->wp_tdm_api_event_mode == WP_TDMAPI_EVENT_ENABLE){
			tdm_api->name,
				tdm_api->name,
				tdm_event->wp_tdm_api_event_type);
		return -EINVAL;
	switch(tdm_event->wp_tdm_api_event_type){
			sdla_t *card = (sdla_t*)tdm_api->card;
			card->hw_iface.hw_lock(card->hw,&smp_flags1);
			rc = tdm_api->event_ctrl(tdm_api->chan, &event_ctrl);
			card->hw_iface.hw_unlock(card->hw,&smp_flags1);
		return tdm_api->event_ctrl(tdm_api->chan, &event_ctrl);
	if (wan_test_bit(0,&tdm_api->cfg.tx_disable)){
	if (!tdm_api->tx_skb) {
		tdm_api->tx_skb=wan_skb_dequeue(&tdm_api->wp_tx_list);
		if (!tdm_api->tx_skb){
			memset(tx_data,tdm_api->cfg.idle_flag,len);
			tdm_api->cfg.stats.tx_carrier_errors++;
			return -ENOBUFS;
		buf=wan_skb_pull(tdm_api->tx_skb,sizeof(wp_tdm_api_tx_hdr_t));
		memcpy(&tdm_api->tx_hdr, buf, sizeof(wp_tdm_api_tx_hdr_t));
		if (wan_skb_len(tdm_api->tx_skb) % len) {
			wan_skb_free(tdm_api->tx_skb);
			tdm_api->tx_skb=NULL;
			tdm_api->cfg.stats.tx_errors++;
			return -EINVAL;
	tx_hdr=&tdm_api->tx_hdr;
	buf=(u8*)wan_skb_data(tdm_api->tx_skb);
	wan_skb_pull(tdm_api->tx_skb,len);
	if (wan_skb_len(tdm_api->tx_skb) <= 0) {
		wan_skb_push(tdm_api->tx_skb,sizeof(wp_tdm_api_tx_hdr_t));
		wan_skb_init(tdm_api->tx_skb,16);
		wan_skb_trim(tdm_api->tx_skb,0);
		wan_skb_queue_tail(&tdm_api->wp_tx_free_list,tdm_api->tx_skb);
		tdm_api->tx_skb=NULL;
		tdm_api->cfg.stats.tx_packets++;
	int err=-EINVAL;
	if (wan_test_bit(0,&tdm_api->cfg.rx_disable)) {
	if (wan_skb_queue_len(&tdm_api->wp_rx_list) > WP_TDM_MAX_RX_Q_LEN) {
		tdm_api->cfg.stats.rx_fifo_errors++;
	if (!tdm_api->rx_skb) {
		tdm_api->rx_skb=wan_skb_dequeue(&tdm_api->wp_rx_free_list);
		if (!tdm_api->rx_skb) {
			tdm_api->rx_skb=wan_skb_alloc(WP_TDM_API_MAX_LEN);
			if (!tdm_api->rx_skb){
				err=-ENOMEM;
				tdm_api->cfg.stats.rx_errors++;
		data_ptr=wan_skb_put(tdm_api->rx_skb,sizeof(wp_tdm_api_rx_hdr_t));
	if (wan_skb_len(tdm_api->rx_skb)+len >= WP_TDM_API_MAX_LEN) {
		err=-EINVAL;
		tdm_api->cfg.stats.rx_errors++;
	rx_hdr=(wp_tdm_api_rx_hdr_t*)wan_skb_data(tdm_api->rx_skb);
	data_ptr=wan_skb_put(tdm_api->rx_skb,len);
	if (tdm_api->cfg.tdm_codec == WP_NONE) {
		data_ptr=wan_skb_put(tdm_api->rx_skb,len);
		wan_spin_lock_irq(&tdm_api->lock,&smp_flags);
		wp_codec_ops=WANPIPE_CODEC_OPS[tdm_api->cfg.hw_tdm_coding][tdm_api->cfg.tdm_codec];
		if (!wp_codec_ops || !wp_codec_ops->init){
			wan_spin_unlock_irq(&tdm_api->lock,&smp_flags);
			err=-EINVAL;
			tdm_api->cfg.stats.rx_errors++;
		wan_spin_unlock_irq(&tdm_api->lock,&smp_flags);
		data_ptr=(u8*)wan_skb_data(tdm_api->rx_skb);
		len = wp_codec_ops->encode(rx_data,
					   (u16*)&data_ptr[wan_skb_len(tdm_api->rx_skb)],
			tdm_api->cfg.stats.rx_errors++;
		wan_skb_put(tdm_api->rx_skb,len);
	if (wan_skb_len(tdm_api->rx_skb) >=
	   (tdm_api->cfg.usr_period*tdm_api->cfg.hw_mtu_mru + sizeof(wp_tdm_api_rx_hdr_t))) {
		wan_skb_queue_tail(&tdm_api->wp_rx_list,tdm_api->rx_skb);
		tdm_api->rx_skb=NULL;
		tdm_api->cfg.stats.rx_packets++;
	if (tdm_api->rx_skb) {
		wan_skb_free(tdm_api->rx_skb);
	tdm_api->rx_skb=NULL;
	if (!tdm_api->chan || !wan_test_bit(0,&tdm_api->init)){
	if (!wan_test_bit(0,&tdm_api->used)) {
		if (tx_data[0] != tdm_api->cfg.idle_flag) {
			memset(tx_data,tdm_api->cfg.idle_flag,len);
	if (!tdm_api->chan || !wan_test_bit(0,&tdm_api->init)){
		return -1;
	if (!tdm_api->span_mode) {
			DEBUG_EVENT("%s: Internal Error - function called on device in non span mode!\n",
		return -1;
	if (!wan_test_bit(0,&tdm_api->used)) {
		return -1;
	if (wan_skb_queue_len(&tdm_api->wp_rx_list) > 50) {
		return -1;
					tdm_api->name,
		return -1;
	wan_skb_queue_tail(&tdm_api->wp_rx_list,skb);
	if (wan_skb_queue_len(&tdm_api->wp_rx_list) > WP_TDM_MAX_RX_Q_LEN) {
		tdm_api->cfg.stats.rx_fifo_errors++;
		return -EBUSY;
	if (!wan_test_bit(0,&tdm_api->used)) {
		return -ENODEV;
	DEBUG_TDMAPI("%s: TDM API RX HDLC FRAME %i\n",tdm_api->name, wan_skb_len(skb));
	wan_skb_queue_tail(&tdm_api->wp_rx_list,skb);
	tdm_api->cfg.stats.rx_packets++;
	tdm_api = card->wp_tdmapi_hash[fe_chan];
					card->devname);
					card->devname);
	if (event->type == WAN_EVENT_EC_DTMF){
			card->devname,
			event->channel,
			event->digit,
			(event->dtmf_port == WAN_EC_CHANNEL_PORT_ROUT)?"ROUT":"SOUT",
			(event->dtmf_type == WAN_EC_TONE_PRESENT)?"PRESENT":"STOP");
	}else if (event->type == WAN_EVENT_RM_DTMF){
			card->devname,
			event->channel,
			event->digit);
	tdm_api = wp_tdmapi_search(card, event->channel);
	p_tdmapi_event->wp_tdm_api_event_type		= WP_TDMAPI_EVENT_DTMF;
	p_tdmapi_event->wp_tdm_api_event_dtmf_digit	= event->digit;
	p_tdmapi_event->wp_tdm_api_event_dtmf_type	= event->dtmf_type;
	p_tdmapi_event->wp_tdm_api_event_dtmf_port	= event->dtmf_port;
	p_tdmapi_event->channel = event->channel;
	p_tdmapi_event->span = wp_tdmapi_get_span(card);
	rx_hdr->event_time_stamp = gettimeofday();
	if (!wan_test_bit(0,&tdm_api->used) ||
	    wan_skb_queue_len(&tdm_api->wp_event_list) > WP_TDM_MAX_EVENT_Q_LEN) {
	wan_skb_queue_tail(&tdm_api->wp_event_list,skb);
			card->devname,
			event->channel,
			(event->rxhook==WAN_EVENT_RXHOOK_OFF)?"OFF-HOOK":"ON-HOOK");
	tdm_api = wp_tdmapi_search(card, event->channel);
	p_tdmapi_event->wp_tdm_api_event_type 		= WP_TDMAPI_EVENT_RXHOOK;
	p_tdmapi_event->wp_tdm_api_event_channel	= event->channel;
	p_tdmapi_event->wp_tdm_api_event_span		= wp_tdmapi_get_span(card);
	switch(event->rxhook){
		p_tdmapi_event->wp_tdm_api_event_hook_state =
		p_tdmapi_event->wp_tdm_api_event_hook_state =
	rx_hdr->event_time_stamp = gettimeofday();
	if (!wan_test_bit(0,&tdm_api->used) ||
  	    wan_skb_queue_len(&tdm_api->wp_event_list) > WP_TDM_MAX_EVENT_Q_LEN) {
	wan_skb_queue_tail(&tdm_api->wp_event_list,skb);
			card->devname,
			event->channel,
			(event->link_status==WAN_EVENT_LINK_STATUS_DISCONNECTED)?"Disconnected":"connected");
	tdm_api = wp_tdmapi_search(card, event->channel);
	if (wan_skb_queue_len(&tdm_api->wp_event_list) > WP_TDM_MAX_EVENT_Q_LEN) {
	p_tdmapi_event->wp_tdm_api_event_type		= WP_TDMAPI_EVENT_LINK_STATUS;
	p_tdmapi_event->wp_tdm_api_event_channel	= event->channel;
	p_tdmapi_event->wp_tdm_api_event_span		= wp_tdmapi_get_span(card);
	switch(event->link_status){
		p_tdmapi_event->wp_tdm_api_event_link_status =
		p_tdmapi_event->wp_tdm_api_event_link_status =
	rx_hdr->event_time_stamp = gettimeofday();
	wan_skb_queue_tail(&tdm_api->wp_event_list,skb);
off-hook during the ringing state.
			card->devname,
			event->channel,
			WAN_EVENT_RING_TRIP_DECODE(event->ring_mode));
	tdm_api = wp_tdmapi_search(card, event->channel);
	p_tdmapi_event->wp_tdm_api_event_type = WP_TDMAPI_EVENT_RING_TRIP_DETECT;
	p_tdmapi_event->wp_tdm_api_event_channel	= event->channel;
	p_tdmapi_event->wp_tdm_api_event_span = wp_tdmapi_get_span(card);
	if (event->ring_mode == WAN_EVENT_RING_TRIP_STOP){
		p_tdmapi_event->wp_tdm_api_event_ring_state =
	}else if (event->ring_mode == WAN_EVENT_RING_TRIP_PRESENT){
		p_tdmapi_event->wp_tdm_api_event_ring_state =
	rx_hdr->event_time_stamp = gettimeofday();
	if (!wan_test_bit(0,&tdm_api->used) ||
  	    wan_skb_queue_len(&tdm_api->wp_event_list) > WP_TDM_MAX_EVENT_Q_LEN) {
	wan_skb_queue_tail(&tdm_api->wp_event_list,skb);
			card->devname,
			event->channel,
			WAN_EVENT_RING_DECODE(event->ring_mode));
	tdm_api = wp_tdmapi_search(card, event->channel);
	p_tdmapi_event->wp_tdm_api_event_type = WP_TDMAPI_EVENT_RING_DETECT;
	p_tdmapi_event->wp_tdm_api_event_channel	= event->channel;
	p_tdmapi_event->wp_tdm_api_event_span = wp_tdmapi_get_span(card);
	switch(event->ring_mode){
		p_tdmapi_event->wp_tdm_api_event_ring_state =
		p_tdmapi_event->wp_tdm_api_event_ring_state =
	rx_hdr->event_time_stamp = gettimeofday();
	if (!wan_test_bit(0,&tdm_api->used) ||
  	    wan_skb_queue_len(&tdm_api->wp_event_list) > WP_TDM_MAX_EVENT_Q_LEN) {
	wan_skb_queue_tail(&tdm_api->wp_event_list,skb);
	DEBUG_TDMAPI("%s(): original_active_ch: 0x%X\n", __FUNCTION__, tdm_api->original_active_ch);
		if(tdm_api->original_active_ch & (1 << i)){
					__FUNCTION__, i, tdm_api->tdm_span);
			if(card->wp_tdmapi_hash[i] != NULL){
					__FUNCTION__, tdm_api->tdm_span, i);
			card->wp_tdmapi_hash[i] = tdm_api;
	card = (sdla_t*)tdm_api->card;
	DEBUG_TDMAPI("%s(): original_active_ch: 0x%X\n", __FUNCTION__, tdm_api->original_active_ch);
		if(tdm_api->original_active_ch & (1 << i)){
			DEBUG_TDMAPI("%s(): RE-setting channel: %d\n", __FUNCTION__, i);
					__FUNCTION__, i, tdm_api->tdm_span);
			if(card->wp_tdmapi_hash[i] == NULL){
					__FUNCTION__, tdm_api->tdm_span, tdm_api->tdm_chan);
			card->wp_tdmapi_hash[i] = NULL;
//when transmitting: convert from s-linear to MuLaw/ALaw.
	if (tdm_api->hdlc_framing){
	if(tdm_api->cfg.tdm_codec == WP_NONE) {
	wp_codec_ops=WANPIPE_CODEC_OPS[tdm_api->cfg.hw_tdm_coding][tdm_api->cfg.tdm_codec];
	if (!wp_codec_ops || !wp_codec_ops->init){
		DBG_TDMCODEC("%s(): Error: !wp_codec_ops || !wp_codec_ops->init !!!\n", __FUNCTION__);
	len = wp_codec_ops->decode((u16*)original_databuf,
				   tdm_api->tx_gain,
//when receiving: convert from MuLaw/ALaw to s-linear.
	if (tdm_api->hdlc_framing){
	if(tdm_api->cfg.tdm_codec == WP_NONE) {
	wp_codec_ops=WANPIPE_CODEC_OPS[tdm_api->cfg.hw_tdm_coding][tdm_api->cfg.tdm_codec];
	if (!wp_codec_ops || !wp_codec_ops->init){
		DBG_TDMCODEC("%s(): Error: !wp_codec_ops || !wp_codec_ops->init !!!\n", __FUNCTION__);
	len = wp_codec_ops->encode(original_databuf,
				   tdm_api->rx_gain,
	if (tdm_api->hdlc_framing) {
				__FUNCTION__, tdm_api->tdm_span, tdm_api->tdm_chan);
	if(	*destination_buf_datalen >= tdm_api->cfg.usr_period*tdm_api->cfg.hw_mtu_mru){
	return -EINVAL;
	return -EINVAL;
	return -ENODEV;
	return -EINVAL;
 	return -EINVAL;
	return -EINVAL;
./wanpipe_tdm_api.c
* Copyright:	(c) 1995-2003 Sangoma Technologies Inc.
 * wppos_init - Cisco HDLC protocol initialization routine.
 *  o initialize protocol-specific fields of the adapter data space.
	if (conf->config_id != WANCONFIG_POS) {
				  card->devname, conf->config_id);
		return -EINVAL;
	/* Initialize protocol-specific fields */
	card->mbox_off = PRI_BASE_ADDR_MB_STRUCT;
	mb = &card->wan_mbox;
	card->wandev.clocking 			= conf->clocking;
	card->wandev.ignore_front_end_status 	= conf->ignore_front_end_status;
	card->wandev.ttl 			= conf->ttl;
	card->wandev.electrical_interface 			= conf->electrical_interface; 
	card->wandev.comm_port 			= conf->comm_port;
	card->wandev.udp_port   		= conf->udp_port;
	card->wandev.new_if_cnt 		= 0;
	wan_atomic_set(&card->wandev.if_cnt,0);
	err = (card->hw_iface.check_mismatch) ? 
			card->hw_iface.check_mismatch(card->hw,conf->fe_cfg.media) : -EINVAL;
	card->fe.fe_status = FE_CONNECTED;
	card->wandev.mtu = conf->mtu;
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
	DEBUG_EVENT( "%s: Running POS firmware\n",card->devname); 
	card->isr			= NULL;
	card->wandev.update		= &update;
 	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= &del_if;
	card->disable_comm		= &disable_comm;
	card->u.pos.state = WAN_DISCONNECTED;
	card->wandev.state = WAN_DISCONNECTED;
	DEBUG_EVENT( "%s: Pos Firmware Ready!\n",card->devname);
 * update - Update wanpipe device status & statistics
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical))
                return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
	if((priv_area=dev->priv) == NULL)
		return -ENODEV;
       	if(card->update_comms_stats){
		return -EAGAIN;
	return -ENODEV;
 * new_if - Create new logical channel.
 * to dev->priv pointer.  
 * Also the dev->init pointer should also be initialized
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
			card->devname, conf->name);
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
	 * If developing a multi-interface protocol, one should
	if (wan_atomic_read(&card->wandev.if_cnt) > 0){
		return -EEXIST;
		WAN_MEM_ASSERT(card->devname);
		return -ENOMEM;
	strncpy(priv_area->if_name, conf->name, WAN_IFNAME_SZ);
	priv_area->card = card; 
	priv_area->common.usedby = API;
			wandev->name,priv_area->if_name);
	 * 	dev->if_init : function that will be called
	 * 	dev->priv    : private structure allocated above
	dev->init = &if_init;
	dev->priv = priv_area;
	wan_atomic_inc(&card->wandev.if_cnt);
 * del_if - Delete logical channel.
 * NOTE: DO NOT deallocate dev->priv here! It will be
	private_area_t* 	priv_area = dev->priv;
	sdla_t*			card = priv_area->card;
	wan_atomic_dec(&card->wandev.if_cnt);
 * if_init - Initialize Linux network interface.
	private_area_t* priv_area = dev->priv;
	sdla_t* card = priv_area->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_header	= NULL; 
	dev->rebuild_header	= NULL;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->do_ioctl		= if_do_ioctl;
	/* Initialize media-specific parameters */
	dev->flags		|= IFF_POINTOPOINT;
	dev->flags		|= IFF_NOARP;
	dev->type		= ARPHRD_PPP;
	dev->mtu		= card->wandev.mtu;
	dev->hard_header_len	= 0;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start);
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end);
        dev->tx_queue_len = 100;
 * if_open - Open network interface.
	private_area_t* priv_area = dev->priv;
	sdla_t* card = priv_area->card;
		return -EBUSY;
	priv_area->router_start_time = tv.tv_sec;
 * if_close - Close network interface.
	private_area_t* priv_area = dev->priv;
	sdla_t* card = priv_area->card;
	dev->start=0;
 * disable_comm - Main shutdown function
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	if (card->comm_enabled){
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
 * if_send - Send a packet on a network interface.
 * 	Return a non-zero value to tell the stack
 *		non-0	packet may be re-transmitted 
	private_area_t *chan = dev->priv;
	sdla_t *card = chan->card;
	DEBUG_EVENT("%s: if_send() dropping packet!\n",card->devname);
	if ((priv_area=dev->priv) == NULL)
	return &priv_area->if_stats;
 * if_do_ioctl - Ioctl handler for fr
	private_area_t* chan= (private_area_t*)dev->priv;
		return -ENODEV;
	card=chan->card;
	mb = &card->wan_mbox;
	if (test_and_set_bit(0,&card->wandev.critical)){
		return -EBUSY;
			usr_mb=(wan_mbox_t*)ifr->ifr_data;
					card->devname, cmd);
				err=-EINVAL;
				err= -EFAULT;
			usr_mb=(wan_mbox_t*)ifr->ifr_data;
					card->devname, cmd);
				err=-EINVAL;
				printk(KERN_INFO "%s: SDLC Cmd: Failed to copy mb \n",card->devname);
				err = -EFAULT;
			if (mb->wan_pos_data_len > 0){
				if (mb->wan_pos_data_len > 1030){
					err=-EFAULT;
				if (copy_from_user((unsigned char*)&mb->wan_pos_data[0], 
					           (unsigned char*)&usr_mb->wan_pos_data[0],
						   mb->wan_pos_data_len)){
							card->devname, mb->wan_pos_data_len);
					err = -EFAULT;
			//spin_lock_irqsave(&card->wandev.lock,smp_flags);
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			//spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
			if (!err && mb->wan_pos_command == CONFIGURE){
				CONFIGURATION_STRUCT *cfg=(CONFIGURATION_STRUCT *)mb->wan_pos_data;
				dev->mtu = cfg->sdlc_maxdata; 
				err= -EFAULT;
			if (mb->wan_pos_data_len>0) {
				if (mb->wan_pos_data_len > 1030){
					err=-EFAULT;
				if (copy_to_user(&usr_mb->wan_pos_data[0], 
						 &mb->wan_pos_data[0], 
						 mb->wan_pos_data_len)){
					err= -EFAULT;
			err= -EOPNOTSUPP;
	clear_bit(0,&card->wandev.critical);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_pos_data_len = 0;
	mb->wan_pos_port_num = card->wandev.comm_port;;
	mb->wan_pos_command = DISABLE_POS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card->comm_enabled = 0;
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_pos_command;
			return -EBUSY;
			card->devname, cmd, err);
./sdla_pos.c
* Copyright:	(c) 2003-2007 Sangoma Technologies Inc.
	while ((SYSTEM_TICKS-timeout)<(sec*HZ)){
	conf->config_id			= WANCONFIG_AFT;
	conf->u.aft.dma_per_ch	= 10;
	conf->u.aft.mru	= 1500;
	memcpy(conf->usedby, "WANPIPE", 7);
	conf->if_down		= 0;
	conf->ignore_dcd	= WANOPT_NO;
	conf->ignore_cts	= WANOPT_NO;
	conf->hdlc_streaming	= WANOPT_YES;
	conf->mc		= 0;
	conf->gateway		= 0;
	conf->active_ch		= ENABLE_ALL_CHANNELS;
 * wp_xilinx_init - Cisco HDLC protocol initialization routine.
 *  o initialize protocol-specific fields of the adapter data space.
	wan_clear_bit(CARD_DOWN,&card->wandev.critical);
	if (card->wandev.config_id != WANCONFIG_AFT) {
				  card->devname, card->wandev.config_id);
		return -EINVAL;
				card->devname);
		return -EINVAL;
	card->wandev.clocking 			= conf->clocking;
	card->wandev.ignore_front_end_status 	= conf->ignore_front_end_status;
	card->wandev.ttl 			= conf->ttl;
	card->wandev.electrical_interface      	= conf->electrical_interface;
	card->wandev.comm_port 			= conf->comm_port;
	card->wandev.udp_port   		= conf->udp_port;
	card->wandev.new_if_cnt 		= 0;
	wan_atomic_set(&card->wandev.if_cnt,0);
	card->u.aft.chip_security_cnt=0;
	card->hw_iface.getcfg(card->hw, SDLA_COREREV, &card->u.aft.firm_ver);
	if (card->u.aft.firm_ver < AFT_MIN_FRMW_VER){
				  card->devname, card->u.aft.firm_ver,AFT_MIN_FRMW_VER);
				  card->devname);
				  card->devname);
		return -EINVAL;
	memcpy(&card->u.aft.cfg,&conf->u.aft,sizeof(wan_xilinx_conf_t));
	memcpy(&card->tdmv_conf,&conf->tdmv_conf,sizeof(wan_tdmv_conf_t));
	card->u.aft.cfg.dma_per_ch = 10;
	if (conf->u.aft.dma_per_ch){
		card->u.aft.cfg.dma_per_ch=conf->u.aft.dma_per_ch;
		if (card->u.aft.cfg.dma_per_ch > MAX_DMA_PER_CH ||
		    card->u.aft.cfg.dma_per_ch < MIN_DMA_PER_CH){
					card->devname,card->u.aft.cfg.dma_per_ch,
			return -EINVAL;
	if (IS_TE1_MEDIA(&conf->fe_cfg)){
		if (conf->fe_cfg.cfg.te_cfg.active_ch == 0){
			conf->fe_cfg.cfg.te_cfg.active_ch = -1;
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_te_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg	= card->hw_iface.fe_write;
		card->fe.read_fe_reg	= card->hw_iface.fe_read;
		card->wandev.te_report_rbsbits = aft_report_rbsbits;
		card->wandev.fe_enable_timer = enable_timer;
		card->wandev.te_link_state = handle_front_end_state;
		if (card->fe.fe_cfg.cfg.te_cfg.te_clock == WAN_NORMAL_CLK){
			card->fe.fe_cfg.cfg.te_cfg.te_ref_clock = WAN_TE1_REFCLK_OSC;
		conf->electrical_interface =
		if (card->wandev.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
				card->devname,conf->fe_cfg.media);
		return -EINVAL;
       	card->u.aft.tdmv_dchan = 0;
		card->tdmv_conf.dchan = card->tdmv_conf.dchan << 1;
		wan_clear_bit(0,&card->tdmv_conf.dchan);
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
        card->wandev.update             = &update;
        card->wandev.new_if             = &new_if;
        card->wandev.del_if             = &del_if;
     	card->disable_comm              = NULL;
	card->wandev.get_config_info 	= &get_config_info;
	card->wandev.get_status_info 	= &get_status_info;
	card->wandev.get_dev_config_info= &get_dev_config_info;
	card->wandev.get_if_info     	= &get_if_info;
	card->wandev.set_dev_config    	= &set_dev_config;
	card->wandev.set_if_info     	= &set_if_info;
	card->wandev.get_info		= &wan_aft_get_info;
	if(card->wandev.clocking) {
		card->wandev.bps = conf->bps;
        	card->wandev.bps = 0;
        card->wandev.mtu = conf->mtu;
	card->wan_tdmv.sc = NULL;
	card->wandev.mtu=conf->mtu;
	if (card->wandev.mtu > MAX_WP_PRI_MTU ||
	    card->wandev.mtu < MIN_WP_PRI_MTU){
				card->devname,card->wandev.mtu,
		return -EINVAL;
	card->u.aft.cfg.mru=conf->u.aft.mru;
	if (!card->u.aft.cfg.mru){
		card->u.aft.cfg.mru = card->wandev.mtu;
	if (card->u.aft.cfg.mru > MAX_WP_PRI_MTU ||
	    card->u.aft.cfg.mru < MIN_WP_PRI_MTU){
				card->devname,card->u.aft.cfg.mru,
		return -EINVAL;
	card->hw_iface.getcfg(card->hw, SDLA_BASEADDR, &card->u.aft.bar);
	WAN_TASKQ_INIT((&card->u.aft.port_task),0,aft_port_task,card);
        card->isr = &wp_xilinx_isr;
	wan_set_bit(AFT_CHIP_CONFIGURED,&card->u.aft.chip_cfg_status);
	if (wan_test_bit(AFT_FRONT_END_UP,&card->u.aft.chip_cfg_status)){
				card->devname);
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		wan_clear_bit(AFT_FRONT_END_UP,&card->u.aft.chip_cfg_status);
			card->devname,card->devname,card->u.aft.firm_ver);
			card->devname,
			card->wandev.mtu);
			card->devname,
			card->u.aft.cfg.mru);
			card->devname,
			card->u.aft.cfg.rbs?"On":"Off");
			card->devname,
			WAN_TE1_REFCLK(&card->fe) == WAN_TE1_REFCLK_OSC?"Osc":"Line");
 	card->disable_comm              = &disable_comm;
 * update - Update wanpipe device status & statistics
	sdla_t			*card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	if(wan_test_bit(PERI_CRIT, (void*)&card->wandev.critical))
                return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
       	if(card->update_comms_stats){
		return -EAGAIN;
		DEBUG_EVENT("%s: Starting up Interfaces\n",card->devname);
		for (dev=card->wandev.dev;dev;dev=wan_next_dev(dev)){
			chan=dev->priv;
		                wan_skb_queue_len(&chan->wp_tx_pending_list));
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
 	return -EINVAL;
	wanpipe_tdm_api_dev_t *wp_tdm_api_dev = &chan->wp_tdm_api_dev_idx[logic_ch];
	if (chan->common.usedby != TDM_VOICE_API &&
	    chan->common.usedby != TDM_VOICE_DCHAN) {
	if (chan->tdmv_zaptel_cfg) {
	wp_tdm_api_dev->chan = chan;
	wp_tdm_api_dev->card = card;
	wan_spin_lock_init(&wp_tdm_api_dev->lock, "wan_tdmapi_lock");
	strncpy(wp_tdm_api_dev->name,chan->if_name,WAN_IFNAME_SZ);
	if (conf->hdlc_streaming) {
        	wp_tdm_api_dev->hdlc_framing=1;
	wp_tdm_api_dev->event_ctrl	= aft_event_ctrl;
	wp_tdm_api_dev->read_rbs_bits = aft_read_rbs_bits;
	wp_tdm_api_dev->write_rbs_bits = aft_write_rbs_bits;
	wp_tdm_api_dev->write_hdlc_frame = aft_write_hdlc_frame;
	wp_tdm_api_dev->cfg.rx_disable = 0;
	wp_tdm_api_dev->cfg.tx_disable = 0;
		wp_tdm_api_dev->cfg.hw_tdm_coding=WP_MULAW;
		wp_tdm_api_dev->cfg.hw_tdm_coding=WP_ALAW;
	wp_tdm_api_dev->cfg.idle_flag = conf->u.aft.idle_flag;
	wp_tdm_api_dev->cfg.rbs_tx_bits = conf->u.aft.rbs_cas_idle;
    	wp_tdm_api_dev->tdm_span = card->tdmv_conf.span_no;
	wp_tdm_api_dev->tdm_chan = logic_ch+1;
		wp_tdm_api_dev->active_ch = conf->active_ch << 1;
		wp_tdm_api_dev->active_ch = conf->active_ch;
	wan_set_bit(0,&wp_tdm_api_dev->init);
			card->devname);
      	return -EINVAL;
	wanpipe_tdm_api_dev_t *wp_tdm_api_dev = &chan->wp_tdm_api_dev_idx[logic_ch];
	if (wan_test_bit(0,&wp_tdm_api_dev->init)){
		wan_clear_bit(0,&wp_tdm_api_dev->init);
			wan_set_bit(0,&wp_tdm_api_dev->init);
	int err=-EINVAL;
	u32 active_ch=conf->active_ch;
	chan->tdmapi_timeslots=active_ch;
	for (i=0;i<card->u.aft.num_of_time_slots;i++) {
		if (wan_test_bit(i,&chan->tdmapi_timeslots)){
			card->devname);
      	return -EINVAL;
	for (i=0;i<card->u.aft.num_of_time_slots;i++) {
		if (wan_test_bit(i,&chan->tdmapi_timeslots)){
       WAN_NETIF_WAKE_QUEUE(chan->common.dev);
        if (chan->common.usedby == API){
        }else if (chan->common.usedby == STACK){
 * new_if - Create new logical channel.
 * to dev->priv pointer.
 * Also the dev->init pointer should also be initialized
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
			card->devname, wan_netif_name(dev));
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)){
			card->devname);
		return -EINVAL;
		WAN_MEM_ASSERT(card->devname);
		return -ENOMEM;
	chan->first_time_slot=-1;
	strncpy(chan->if_name, wan_netif_name(dev), WAN_IFNAME_SZ);
	memcpy(&chan->cfg,&conf->u.aft,sizeof(chan->cfg));
		chan->channelized_cfg=1;
			for (cptr=wan_netif_priv(dev);cptr->next!=NULL;cptr=cptr->next);
			cptr->next=chan;
			chan->next=NULL;
			chan->next = wan_netif_priv(dev);
		chan->channelized_cfg=0;
	chan->common.card = card;
	chan->true_if_encoding=conf->true_if_encoding;
	WAN_IFQ_INIT(&chan->wp_tx_free_list, 0);
	WAN_IFQ_INIT(&chan->wp_tx_pending_list,0);
	WAN_IFQ_INIT(&chan->wp_tx_complete_list,0);
	WAN_IFQ_INIT(&chan->wp_rx_free_list,0);
	WAN_IFQ_INIT(&chan->wp_rx_complete_list,0);
	wan_trace_info_init(&chan->trace_info,MAX_TRACE_QUEUE);
	WAN_TASKLET_INIT((&chan->common.bh_task), 0, wp_bh, chan);
	chan->common.dev = dev;
	chan->tracing_enabled = 0;
	chan->route_removed = 0;
	chan->mtu = card->wandev.mtu;
	if (conf->u.aft.mtu){
		chan->mtu=conf->u.aft.mtu;
	if (chan->mtu > MAX_WP_PRI_MTU ||
    	    chan->mtu < MIN_WP_PRI_MTU){
			card->devname,chan->if_name,chan->mtu,
		err= -EINVAL;
	chan->mru = card->u.aft.cfg.mru;
	if (conf->u.aft.mru){
		chan->mru = conf->u.aft.mru;
	if (chan->mru > MAX_WP_PRI_MTU ||
    	    chan->mru < MIN_WP_PRI_MTU){
			card->devname,chan->if_name,chan->mru,
		err= -EINVAL;
			card->devname,
			conf->usedby);
	if(strcmp(conf->usedby, "WANPIPE") == 0) {
		chan->common.usedby = WANPIPE;
		if (conf->if_down){
			wan_set_bit(DYN_OPT_ON,&chan->interface_down);
			   card->devname,chan->if_name);
		if (conf->protocol != WANOPT_NO){
			if (conf->ignore_dcd == WANOPT_YES || conf->ignore_cts == WANOPT_YES){
							card->devname);
				chan->ignore_modem=1;
						card->devname);
	}else if( strcmp(conf->usedby, "API") == 0) {
		chan->common.usedby = API;
		wan_reg_api(chan, dev, card->devname);
	}else if (strcmp(conf->usedby, "BRIDGE") == 0) {
		chan->common.usedby = BRIDGE;
	}else if (strcmp(conf->usedby, "BRIDGE_N") == 0) {
		chan->common.usedby = BRIDGE_NODE;
	}else if (strcmp(conf->usedby, "TDM_VOICE_DCHAN") == 0) {
		int dchan=card->u.aft.tdmv_dchan;
		dchan--;
		chan->tdmv_chan=dchan;
		chan->common.usedby = TDM_VOICE_DCHAN;
		conf->hdlc_streaming=1;
		chan->mru=chan->mtu=1500;
		chan->tdmv_zaptel_cfg=1;
		card->u.aft.tdmv_zaptel_cfg=1;
				card->devname);
		err=-EINVAL;
					card->devname,chan->if_name);
					card->devname,chan->if_name);
		err=-EINVAL;
	}else if (strcmp(conf->usedby, "TDM_VOICE") == 0) {
		chan->common.usedby = TDM_VOICE;
		chan->tdmv_zaptel_cfg=1;
		card->u.aft.tdmv_zaptel_cfg=1;
					card->devname,chan->if_name);
					card->devname,chan->if_name);
		err=-EINVAL;
	}else if (strcmp(conf->usedby, "TDM_VOICE_API") == 0) {
		int dchan=card->u.aft.tdmv_dchan;
		dchan--;
		chan->tdmv_chan=dchan;
		chan->common.usedby = TDM_VOICE_API;
		chan->cfg.data_mux=1;
		conf->hdlc_streaming=0;
		chan->tdmv_zaptel_cfg=0;
	}else if (strcmp(conf->usedby, "TDM_VOICE_DCHAN_API") == 0) {
		int dchan=card->u.aft.tdmv_dchan;
		dchan--;
		chan->tdmv_chan=dchan;
		chan->common.usedby = TDM_VOICE_DCHAN;
		conf->hdlc_streaming=1;
		chan->mru=chan->mtu=1500;
		chan->tdmv_zaptel_cfg=0;
	}else if (strcmp(conf->usedby, "STACK") == 0) {
		chan->common.usedby = STACK;
		if (chan->hdlc_eng){
			chan->mtu+=32;
			chan->mru+=32;
				card->devname,chan->if_name, conf->usedby);
		err=-EINVAL;
	chan->time_slot_map=conf->active_ch;
		err=-EINVAL;
			card->devname,
			chan->mru);
			card->devname,
			chan->mtu);
	chan->hdlc_eng = conf->hdlc_streaming;
			card->devname,
			chan->hdlc_eng?"On":"Off (Transparent)");
	if (!chan->hdlc_eng){
		if (!wan_test_bit(0,&card->u.aft.tdmv_sync)){
					card->devname);
			wan_set_bit(0,&card->u.aft.tdmv_sync);
			wan_set_bit(0,&chan->tdmv_sync);
					card->devname);
			wan_clear_bit(0,&chan->tdmv_sync);
		if(conf->protocol == WANCONFIG_LIP_ATM ||
		   conf->protocol == WANCONFIG_LIP_KATM){
			DEBUG_EVENT("%s: Disabling Time Slot Sync for ATM.\n", chan->if_name);
			card->u.aft.tdmv_sync = 0;
			chan->tdmv_sync = 0;
		if (chan->mtu&0x03){
					card->devname,chan->if_name);
			err = -EINVAL;
			card->devname,
			chan->time_slot_map);
        if (chan->common.usedby == TDM_VOICE_DCHAN){
                card->u.aft.tdmv_dchan=chan->logic_ch_num+1;
	chan->dma_mru = xilinx_valid_mtu(chan->mru+100);
	if (!chan->dma_mru){
			card->devname,
			chan->if_name,
			chan->dma_mru,card->u.aft.cfg.mru);
		err= -EINVAL;
	if (!chan->hdlc_eng){
		chan->max_idle_size=chan->mru;
		chan->idle_flag = conf->u.aft.idle_flag;
				card->devname,
				chan->idle_flag);
				card->devname,
				chan->max_idle_size);
				card->devname,
				chan->cfg.data_mux?"On":"Off");
		if (chan->common.usedby == TDM_VOICE){
			chan->idle_flag = WAN_TDMV_IDLE_FLAG;
		chan->tx_idle_skb = wan_skb_alloc(chan->dma_mru);
		if (!chan->tx_idle_skb){
			err=-ENOMEM;
		if(conf->protocol != WANCONFIG_LIP_ATM &&
		   conf->protocol != WANCONFIG_LIP_KATM){
			buf=wan_skb_put(chan->tx_idle_skb,chan->dma_mru);
			memset(buf,chan->idle_flag,chan->dma_mru);
			wan_skb_trim(chan->tx_idle_skb,0);
			wan_skb_put(chan->tx_idle_skb,chan->max_idle_size);
			buf=wan_skb_put(chan->tx_idle_skb,chan->max_idle_size);
			chan->lip_atm = 1;
					wan_skb_len(chan->tx_idle_skb),
					chan->if_name,
					chan->cfg.data_mux)){
				wan_skb_free(chan->tx_idle_skb);
				chan->tx_idle_skb = NULL;
				return -EINVAL;
			wan_skb_reverse(chan->tx_idle_skb);
			card->devname,
			chan->dma_mru);
	if (wan_test_bit(0,&chan->tdmv_sync)){
		if (chan->dma_mru%4){
                        		card->devname,
                        		chan->if_name,
                        		chan->dma_mru,card->u.aft.cfg.mru);
                	err= -EINVAL;
			card->devname,
			card->u.aft.cfg.dma_per_ch);
	err=aft_alloc_rx_dma_buff(card, chan, card->u.aft.cfg.dma_per_ch,0);
	 *      is brought back up, we must know to re-astablish the
			card->devname,
			conf->gateway?"Yes":"No");
	chan->gateway = conf->gateway;
	chan->mc = conf->mc;
	chan->max_tx_bufs = MAX_TX_BUF;
	 * 	dev->if_init : function that will be called
	 * 	dev->priv    : private structure allocated above
					   &chan->dent,
					   chan->if_name,
			card->devname, chan->if_name);
	dev->init = &if_init;
	chan->common.is_netdev = 1;
	chan->common.iface.open      = &wanpipe_xilinx_open;
        chan->common.iface.close     = &wanpipe_xilinx_close;
        chan->common.iface.output    = &wan_aft_output;
        chan->common.iface.ioctl     = &wanpipe_xilinx_ioctl;
        chan->common.iface.tx_timeout= &wanpipe_xilinx_tx_timeout;
		wan_iface.attach(dev, NULL, chan->common.is_netdev);
				card->devname, wan_netif_name(dev));
		err = -EINVAL;
	wan_netif_set_mtu(dev, chan->mtu);
	wan_atomic_inc(&card->wandev.if_cnt);
	chan->common.state = WAN_CONNECTING;
	int err=-EINVAL;
	sdla_t *card=wandev->priv;
			card->devname,
			conf->active_ch,
			conf->active_ch<<1,
			card->tdmv_conf.dchan);
		conf->active_ch = conf->active_ch << 1;
		wan_clear_bit(0,&conf->active_ch);
	if (strcmp(conf->usedby, "TDM_VOICE") == 0 ) {
		if (card->tdmv_conf.span_no){
			err = wp_tdmv_te1_init(&card->tdmv_iface);
						card->devname);
				return -EINVAL;
			WAN_TDMV_CALL(create, (card, &card->tdmv_conf), err);
						card->devname);
					card->devname);
					card->devname);
		return -EINVAL;
	if (strcmp(conf->usedby, "TDM_VOICE") == 0 ||
	    strcmp(conf->usedby, "TDM_VOICE_API") == 0){
                for (i=card->u.aft.num_of_time_slots-1;i>=0;i--){
                       	if (wan_test_bit(i,&card->tdmv_conf.dchan)){
				card->u.aft.tdmv_dchan=i;
                        	card->u.aft.tdmv_dchan++;
			wan_clear_bit(dchan,&conf->active_ch);
			if (card->tdmv_conf.dchan){
				conf->active_ch=0;
				if (strcmp(conf->usedby, "TDM_VOICE") == 0) {
					sprintf(conf->usedby,"TDM_VOICE_DCHAN");
					sprintf(conf->usedby,"TDM_VOICE_DCHAN_API");
				wan_set_bit(dchan,&conf->active_ch);
 * del_if - Delete logical channel.
 * NOTE: DO NOT deallocate dev->priv here! It will be
	sdla_t*			card = (sdla_t*)chan->common.card;
	if (wan_test_bit(0,&chan->tdmv_sync)){
		wan_clear_bit(0,&card->u.aft.tdmv_sync);
		wan_clear_bit(0,&chan->tdmv_sync);
				chan->if_name);
		return -EBUSY;
	WAN_TASKLET_KILL((&chan->common.bh_task));
	if (chan->common.usedby == API){
		wan_unreg_api(chan, card->devname);
		wan_iface.detach(dev, chan->common.is_netdev);
        wan_spin_lock_irq(&card->wandev.lock,&flags);
	while ((skb=wan_skb_dequeue(&chan->wp_rx_free_list)) != NULL){
	while ((skb=wan_skb_dequeue(&chan->wp_rx_complete_list)) != NULL){
	while ((skb=wan_skb_dequeue(&chan->wp_tx_free_list)) != NULL){
	while ((skb=wan_skb_dequeue(&chan->wp_tx_pending_list)) != NULL){
        if (chan->tx_dma_addr && chan->tx_dma_len){
	if (chan->tx_dma_skb){
		wan_skb_free(chan->tx_dma_skb);
		chan->tx_dma_skb=NULL;
	if (chan->tx_idle_skb){
		wan_skb_free(chan->tx_idle_skb);
		chan->tx_idle_skb=NULL;
	if (chan->rx_dma_skb){
		netskb_t *skb=chan->rx_dma_skb;
		chan->rx_dma_skb=NULL;
		card->hw_iface.pci_unmap_dma(card->hw,
			 rx_el->dma_addr,
			 chan->dma_mru,
	if (chan->tx_realign_buf){
		wan_free(chan->tx_realign_buf);
		chan->tx_realign_buf=NULL;
	chan->logic_ch_num=-1;
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	wanrouter_proc_delete_interface(wandev, chan->if_name);
	wan_atomic_dec(&card->wandev.if_cnt);
	if (chan->channelized_cfg){
		sdla_t *card=chan->common.card;
		if (chan->tdmv_zaptel_cfg) {
				return -EBUSY;
			chan=chan->next;
				 * in dev->priv.  It will get
 * if_init - Initialize Linux network interface.
	sdla_t*		card = (sdla_t*)chan->common.card;
	wan_device_t* 	wandev = &card->wandev;
	dev->open		= &wanpipe_xilinx_open;
	dev->stop		= &wanpipe_xilinx_close;
	dev->hard_start_xmit	= &wanpipe_xilinx_send;
	dev->get_stats		= &wanpipe_xilinx_ifstats;
	if (chan->common.usedby == TDM_VOICE ||
	    chan->common.usedby == TDM_VOICE_DCHAN ||
	    chan->common.usedby == TDM_VOICE_API) {
		dev->tx_timeout		= NULL;
		dev->tx_timeout		= &wanpipe_xilinx_tx_timeout;
       	dev->watchdog_timeo	= 2*HZ;
	dev->do_ioctl		= wanpipe_xilinx_ioctl;
	if (chan->common.usedby == BRIDGE ||
       	    chan->common.usedby == BRIDGE_NODE){
		memcpy(dev->dev_addr, "\xFE\xFC\x00\x00\x00\x00", 6);
		*(int *)(dev->dev_addr + 2) += hw_addr;
		if (chan->common.protocol != WANCONFIG_GENERIC){
			dev->flags     |= IFF_POINTOPOINT;
			dev->flags     |= IFF_NOARP;
			dev->type	= ARPHRD_PPP;
			dev->mtu		= chan->mtu;
			if (chan->common.usedby == API){
				dev->mtu+=sizeof(api_tx_hdr_t);
			dev->hard_header_len	= 0;
			if (chan->mc == WANOPT_YES){
				dev->flags 	|= IFF_MULTICAST;
			if (chan->true_if_encoding){
				DEBUG_EVENT("%s: Setting IF Type to Broadcast\n",chan->if_name);
				dev->type	= ARPHRD_PPP; /* This breaks the tcpdump */
				dev->flags     &= ~IFF_POINTOPOINT;
				dev->flags     |= IFF_BROADCAST;
				dev->type	= ARPHRD_PPP;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start);
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end);
        dev->tx_queue_len = 100;
	dev->if_mtu	= chan->mtu;
	dev->if_output	= NULL;
	dev->if_start	= NULL;	/*&wanpipe_xilinx_start;*/
	dev->if_ioctl	= NULL; /* &wplip_ioctl; */
	/* Initialize media-specific parameters */
	dev->if_flags	|= IFF_POINTOPOINT;
	dev->if_flags	|= IFF_NOARP;
	dev->if_mtu	= 1500;
	WAN_IFQ_SET_MAXLEN(&dev->if_snd, 100);
	dev->if_snd.ifq_len = 0;
	dev->if_type	= IFT_PPP;
 * if_open - Open network interface.
	sdla_t* card = (sdla_t*)chan->common.card;
        card->isr = &wp_xilinx_isr;
		return -EINVAL;
		return -EINVAL;
		return -EBUSY;
	wan_spin_lock_irq(&card->wandev.lock,&flags);
		wan_spin_unlock_irq(&card->wandev.lock,&flags);
				chan->if_name);
	if (wan_test_bit(0,&chan->tdmv_sync) &&
	    (card->wandev.state == WAN_CONNECTED ||
	     card->tdmv_conf.span_no)){
				chan->if_name);
		if (card->wandev.state == WAN_CONNECTED){
		}else if (card->tdmv_conf.span_no) {
			card->fe.fe_status = FE_CONNECTED;
			card->fe.fe_status = FE_DISCONNECTED;
	}else if (!chan->hdlc_eng && chan->common.usedby == API
                  && card->wandev.state == WAN_CONNECTED){
        if (card->wandev.state == WAN_CONNECTED){
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
 * if_close - Close network interface.
	sdla_t* card = (sdla_t*)chan->common.card;
	dev->start=0;
 * disable_comm - Main shutdown function
	/* TE1 - Unconfiging, only on shutdown */
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		card->hw_iface.hw_lock(card->hw,&smp_flags1);
		wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
		wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
		card->hw_iface.hw_unlock(card->hw,&smp_flags1);
	wan_spin_lock_irq(&card->wandev.lock,&flags);
	wan_set_bit(CARD_DOWN,&card->wandev.critical);
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	sdla_t *card = (sdla_t*)chan->common.card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++chan->if_stats.collisions;
	DEBUG_EVENT( "%s: Transmit timed out on %s\n", card->devname,wan_netif_name(dev));
			chan->if_name,
			chan->dma_status,
			chan->tx_dma_addr,
			chan->tx_dma_len);
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_LO;
        card->hw_iface.bus_read_4(card->hw,dma_descr, &reg_lo);
        dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
        card->hw_iface.bus_read_4(card->hw,dma_descr, &reg_hi);
                        card->devname,chan->if_name,chan->logic_ch_num,
        wan_clear_bit(TX_BUSY,&chan->dma_status);
 * if_send - Send a packet on a network interface.
 * 	Return a non-zero value to tell the stack
 *		non-0	packet may be re-transmitted
	WAN_ASSERT(chan->common.card == NULL);
	card = (sdla_t*)chan->common.card;
			card->devname, wan_netif_name(dev));
	if (dev->tbusy){
		 * kick start the device by making dev->tbusy = 0.  We expect
                ++chan->if_stats.collisions;
		if((SYSTEM_TICKS - chan->tick_counter) < (5 * HZ)) {
	if (chan->common.state != WAN_CONNECTED){
		++chan->if_stats.tx_carrier_errors;
		++chan->if_stats.tx_carrier_errors;
		if (chan->common.usedby == TDM_VOICE ||
		    chan->common.usedby == TDM_VOICE_DCHAN){
			if (!card->u.aft.tdmv_dchan || card->u.aft.tdmv_dchan>32){
			chan=(private_area_t*)card->u.aft.dev_to_ch_map[card->u.aft.tdmv_dchan-1];
			if (!chan->hdlc_eng){
		}else if (chan->common.usedby == API){
				++chan->if_stats.tx_dropped;
		if (chan->max_tx_bufs == 1) {
			wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
		    	if (wan_test_bit(TX_BUSY,&chan->dma_status)){
				wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
		        wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
		} else if (wan_skb_queue_len(&chan->wp_tx_pending_list) > chan->max_tx_bufs){
			wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
			wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
			if (chan->hdlc_eng) {
			if (is_tdm_api(chan,&chan->wp_tdm_api_cfg)){
				int err=wanpipe_tdm_api_tx(&chan->wp_tdm_api_cfg,&skb);
					++chan->if_stats.tx_errors;
			if (!chan->hdlc_eng && chan->cfg.data_mux){
			wan_skb_queue_tail(&chan->wp_tx_pending_list,skb);
 			if (chan->hdlc_eng) {
 	if (dev->tx_queue_len < chan->max_tx_bufs &&
	    dev->tx_queue_len > 0) {
				chan->if_name,dev->tx_queue_len);
		chan->max_tx_bufs = dev->tx_queue_len;
	if (dev->tx_queue_len > chan->max_tx_bufs &&
	    chan->max_tx_bufs != MAX_TX_BUF) {
				chan->if_name,MAX_TX_BUF);
		chan->max_tx_bufs = MAX_TX_BUF;
	return &chan->if_stats;
 * if_do_ioctl - Ioctl handler for fr
		return -ENODEV;
		return -ENODEV;
	card=(sdla_t*)chan->common.card;
				err= -EINVAL;
			wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
			err=wan_bind_api_to_svc(chan,ifr->ifr_data);
			wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
			chan->if_stats.tx_carrier_errors=0;
				err= -EINVAL;
			wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
			err=wan_unbind_api_from_svc(chan,ifr->ifr_data);
			wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
			err = chan->common.state;
			err=card->wandev.config_id;
			if (wan_atomic_read(&chan->udp_pkt_len) != 0){
				return -EBUSY;
			wan_atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
			if (wan_test_bit(0,&card->in_isr)){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EBUSY;
			wan_udp_pkt=(wan_udp_pkt_t*)chan->udp_pkt_data;
			if (WAN_COPY_FROM_USER(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			if (wan_test_bit(0,&card->in_isr)) {
						card->devname,wan_netif_name(dev));
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EBUSY;
			if (wan_atomic_read(&chan->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						card->devname,wan_atomic_read(&chan->udp_pkt_len));
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EINVAL;
			if (WAN_COPY_TO_USER(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			wan_atomic_set(&chan->udp_pkt_len,0);
				return -EINVAL;
				wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
				wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
				return WAN_COPY_TO_USER(ifr->ifr_data,&cid,sizeof(unsigned char));
			if (card->wandev.wanpipe_ioctl){
				err = card->wandev.wanpipe_ioctl(dev, ifr, cmd);
				card->devname,cmd);
			return -EOPNOTSUPP;
    	DEBUG_CFG("Xilinx Chip Configuration. -- \n");
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
		card->u.aft.num_of_time_slots=NUM_OF_T1_CHANNELS;
		card->u.aft.num_of_time_slots=NUM_OF_E1_CHANNELS;
				card->devname);
		return -EINVAL;
	if (WAN_TE1_REFCLK(&card->fe) == WAN_TE1_REFCLK_OSC){
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
        card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
        card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
        card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	DEBUG_CFG("--- Chip Reset. -- \n");
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &adapter_type);
            card->wandev.S514_cpu_no[0] == SDLA_CPU_B){
			card->devname);
		/*return -ENODEV;*/
			card->devname,adapter_type, adptr_security);
			card->devname);
                        card->devname);
                        card->devname);
                        card->devname);
                        card->devname,adptr_security);
		return -EINVAL;
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
                                        card->devname);
	card->hw_iface.hw_lock(card->hw,&smp_flags);
	err = -EINVAL;
	if (card->wandev.fe_iface.config){
		err=card->wandev.fe_iface.config(&card->fe);
	card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_OFF);
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
                                	card->devname,
               	return -EINVAL;
	if (card->wandev.fe_iface.post_init){
		err=card->wandev.fe_iface.post_init(&card->fe);
					card->devname);
		card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
		card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
                                        card->devname,reg);
    	DEBUG_CFG("--- Setup DMA control Reg. -- \n");
	card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
	DEBUG_CFG("--- Tx/Rx global enable. -- \n");
	card->hw_iface.bus_write_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG,reg);
	card->hw_iface.bus_read_4(card->hw, XILINX_DMA_RX_INTR_PENDING_REG, &tmp);
	card->hw_iface.bus_read_4(card->hw, XILINX_DMA_TX_INTR_PENDING_REG, &tmp);
	card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_RX_INTR_PENDING_REG, &tmp);
	card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_TX_INTR_PENDING_REG, &tmp);
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, (u32*)&reg);
					card->devname);
		card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
					card->devname);
		card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
				card->devname);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
        card->hw_iface.bus_write_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG,reg);
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
    	DEBUG_TEST("-- Configure Xilinx. --\n");
	chan->logic_ch_num=-1;
		return -EINVAL;
	if (chan->time_slot_map == 0){
				card->devname,chan->time_slot_map);
		return -EINVAL;
		card->devname,chan->if_name,chan->time_slot_map);
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (wan_test_bit(i,&chan->time_slot_map)){
			if (chan->first_time_slot == -1){
						card->devname,chan->if_name,i);
				chan->first_time_slot=i;
					card->devname, chan->if_name,
			if (wan_test_bit(i,&card->u.aft.time_slot_map)){
						card->devname);
						card->devname,chan->if_name,(i+1));
				return -EEXIST;
			++chan->num_of_time_slots;
	chan->logic_ch_num=request_xilinx_logical_channel_num(card, chan, &free_logic_ch);
	if (chan->logic_ch_num == -1){
		return -EBUSY;
		__FUNCTION__,__LINE__,chan->logic_ch_num,free_logic_ch);
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (wan_test_bit(i,&chan->time_slot_map)){
			wan_set_bit(i,&card->u.aft.time_slot_map);
			card->hw_iface.bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
			card->hw_iface.bus_write_4(card->hw,
			reg=chan->logic_ch_num&CONTROL_RAM_DATA_MASK;
			reg|=(chan->fifo_size_code&HDLC_FIFO_SIZE_MASK)<<HDLC_FIFO_SIZE_SHIFT;
			reg|=(chan->fifo_base_addr&HDLC_FIFO_BASE_ADDR_MASK)<<
			if (!chan->hdlc_eng){
				        i, chan->logic_ch_num,reg);
	if (free_logic_ch != -1){
		if (wan_atomic_read(&card->wandev.if_cnt)==3){
		for (i=0;i<card->u.aft.num_of_time_slots;i++){
			if (!wan_test_bit(i,&card->u.aft.time_slot_map)){
				card->hw_iface.bus_read_4(card->hw,
				card->hw_iface.bus_write_4(card->hw,
					chan->if_name,free_logic_ch);
			card->hw_iface.bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
			card->hw_iface.bus_write_4(card->hw,
                                               chan->first_time_slot,
	card->hw_iface.bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
	card->hw_iface.bus_write_4(card->hw,
			(reg|(chan->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));
	if (chan->hdlc_eng){
                        card->devname,chan->if_name);
                                       chan->first_time_slot,
                               chan->first_time_slot,
	DEBUG_CFG("\n-- Unconfigure Xilinx. --\n");
	if (wan_test_bit(0,&chan->tdmv_sync)){
	if (chan->logic_ch_num != -1){
		card->hw_iface.bus_read_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
		card->hw_iface.bus_write_4(card->hw,
				(reg|(chan->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));
                               chan->first_time_slot,
	        for (i=0;i<card->u.aft.num_of_time_slots;i++){
        	        if (wan_test_bit(i,&chan->time_slot_map)){
                        	card->hw_iface.bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
                        	card->hw_iface.bus_write_4(card->hw,
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		free_xilinx_logical_channel_num(card,chan->logic_ch_num);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		for (i=0;i<card->u.aft.num_of_time_slots;i++){
			if (wan_test_bit(i,&chan->time_slot_map)){
				wan_clear_bit(i,&card->u.aft.time_slot_map);
        dma_descr=(unsigned long)(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
                                __FUNCTION__,chan->if_name,
       	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
			card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
				card->devname,chan->if_name,i*FIFO_RESET_TIMEOUT_US);
				card->devname,chan->if_name,i*FIFO_RESET_TIMEOUT_US);
        dma_descr=(unsigned long)(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
                                __FUNCTION__,chan->if_name,
        card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
                	card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
                                card->devname,chan->if_name,i*FIFO_RESET_TIMEOUT_US);
                                card->devname,chan->if_name,i*FIFO_RESET_TIMEOUT_US);
	DEBUG_TEST("%s: Enabling Global Inter Mask !\n",chan->if_name);
	card->hw_iface.bus_read_4(card->hw,
	wan_set_bit(chan->logic_ch_num,&reg);
	card->hw_iface.bus_write_4(card->hw,
	wan_set_bit(chan->logic_ch_num,&card->u.aft.active_ch_map);
	if (chan->rx_dma_skb){
		netskb_t *skb=chan->rx_dma_skb;
		chan->rx_dma_skb=NULL;
		card->hw_iface.pci_unmap_dma(card->hw,
			 rx_el->dma_addr,
			 chan->dma_mru,
	chan->rx_dma_skb = wan_skb_dequeue(&chan->wp_rx_free_list);
	if (!chan->rx_dma_skb){
				chan->if_name,wan_skb_queue_len(&chan->wp_rx_free_list),
				wan_skb_queue_len(&chan->wp_rx_complete_list));
		while((skb=wan_skb_dequeue(&chan->wp_rx_complete_list)) != NULL){
			chan->if_stats.rx_errors++;
		if (chan->common.usedby == TDM_VOICE || chan->common.usedby == TDM_VOICE_API){
			while((skb=wan_skb_dequeue(&chan->wp_tx_pending_list)) != NULL){
				chan->if_stats.rx_errors++;
		chan->rx_dma_skb = wan_skb_dequeue(&chan->wp_rx_free_list);
		if (!chan->rx_dma_skb){
					chan->if_name,chan->logic_ch_num,chan->hdlc_eng,
					wan_skb_queue_len(&chan->wp_rx_free_list),
					wan_skb_queue_len(&chan->wp_rx_complete_list));
			return -ENOMEM;
	wan_skb_put(chan->rx_dma_skb, sizeof(wp_rx_element_t));
	rx_el = (wp_rx_element_t *)wan_skb_data(chan->rx_dma_skb);
	bus_addr = card->hw_iface.pci_map_dma(card->hw,
	      	      		wan_skb_tail(chan->rx_dma_skb),
				chan->dma_mru,
				chan->if_name,__FUNCTION__);
		return -EINVAL;
	rx_el->dma_addr=bus_addr;
    	dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_LO;
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	dma_descr=(unsigned long)(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
	if (chan->hdlc_eng){
		reg|=(chan->dma_mru>>2)&RxDMA_HI_DMA_DATA_LENGTH_MASK;
		reg|=(chan->mru>>2)&RxDMA_HI_DMA_DATA_LENGTH_MASK;
	reg|=(chan->fifo_size_code&DMA_FIFO_SIZE_MASK)<<DMA_FIFO_SIZE_SHIFT;
        reg|=(chan->fifo_base_addr&DMA_FIFO_BASE_ADDR_MASK)<<
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	wan_set_bit(0,&chan->rx_dma);
    	DEBUG_CFG("-- Close Xilinx device. --\n");
        card->hw_iface.bus_read_4(card->hw,
        wan_clear_bit(chan->logic_ch_num,&reg);
	wan_clear_bit(chan->logic_ch_num,&card->u.aft.active_ch_map);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
        card->hw_iface.bus_write_4(card->hw,
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
    	DEBUG_TX(" ------ Setup Tx DMA descriptor. --\n");
	if (wan_test_and_set_bit(TX_BUSY,&chan->dma_status)){
		return -EBUSY;
         * and we must re-transmit.*/
        if (chan->tx_dma_addr && chan->tx_dma_len){
                       	        chan->if_name,__FUNCTION__);
	if (chan->tx_dma_skb){
				chan->if_name,__FUNCTION__);
		wan_skb_free(chan->tx_dma_skb);
		chan->tx_dma_skb=NULL;
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
                        __FUNCTION__,__LINE__,chan->logic_ch_num,dma_descr);
	card->hw_iface.bus_read_4(card->hw,dma_descr, &reg);
				card->devname,reg);
		wan_clear_bit(TX_BUSY,&chan->dma_status);
		return -EFAULT;
	switch(chan->common.usedby){
		skb = wan_skb_dequeue(&chan->wp_tx_pending_list);
		if(!chan->lip_atm){
			skb=wan_skb_dequeue(&chan->wp_tx_pending_list);
			skb=atm_tx_skb_dequeue(&chan->wp_tx_pending_list, chan->tx_idle_skb, chan->if_name);
		if (chan->hdlc_eng){
			wan_clear_bit(TX_BUSY,&chan->dma_status);
			return -ENOBUFS;
		len=wan_skb_len(chan->tx_idle_skb);
		chan->tx_dma_addr = card->hw_iface.pci_map_dma(card->hw,
					  wan_skb_data(chan->tx_idle_skb),
					  wan_skb_len(chan->tx_idle_skb),
		chan->tx_dma_len = wan_skb_len(chan->tx_idle_skb);
		chan->if_stats.tx_carrier_errors++;
			if (chan->common.usedby == TDM_VOICE || chan->common.usedby == TDM_VOICE_API){
			wan_clear_bit(TX_BUSY,&chan->dma_status);
			return -EINVAL;
							card->devname,__FUNCTION__);
				if (chan->common.usedby == TDM_VOICE || chan->common.usedby == TDM_VOICE_API){
				wan_clear_bit(TX_BUSY,&chan->dma_status);
				return -EINVAL;
		chan->tx_dma_addr =
				card->hw_iface.pci_map_dma(card->hw,
		chan->tx_dma_len = wan_skb_len(skb);
	if (chan->tx_dma_addr & 0x03){
				card->devname);
			if (chan->common.usedby == TDM_VOICE || chan->common.usedby == TDM_VOICE_API){
		wan_clear_bit(TX_BUSY,&chan->dma_status);
		return -EINVAL;
		chan->tx_dma_skb=skb;
			skb,skb->list,wan_skb_data(skb),chan->tx_dma_addr);
		chan->tx_dma_skb=NULL;
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_LO;
	reg=chan->tx_dma_addr;
			__FUNCTION__,reg,chan->tx_dma_addr,dma_descr);
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
        reg|=(chan->fifo_size_code&DMA_FIFO_SIZE_MASK)<<DMA_FIFO_SIZE_SHIFT;
        reg|=(chan->fifo_base_addr&DMA_FIFO_BASE_ADDR_MASK)<<
	if (chan->hdlc_eng){
                 * non-transparent hdlc configuration */
	if (wan_test_bit(0,&chan->tdmv_sync)){
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	++chan->if_stats.tx_carrier_errors;
/*      card->hw_iface.bus_read_4(card->hw,0x78, &tmp1); */
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
	card->hw_iface.bus_read_4(card->hw,dma_descr, &reg);
		chan->errstats.Tx_dma_len_nonzero++;
    	if (!chan->tx_dma_skb){
		if (chan->hdlc_eng){
                    			card->devname);
			wan_clear_bit(TX_BUSY,&chan->dma_status);
        		wan_set_bit(0,&chan->idle_start);
			wan_clear_bit(TX_BUSY,&chan->dma_status);
		if (chan->hdlc_eng){
                                        card->devname,chan->if_name,reg);
				if (++chan->pci_retry < 3){
        				card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
			chan->pci_retry=0;
			wan_skb_set_csum(chan->tx_dma_skb, reg);
			wan_skb_queue_tail(&chan->wp_tx_complete_list,chan->tx_dma_skb);
			chan->tx_dma_skb=NULL;
			wan_clear_bit(TX_BUSY,&chan->dma_status);
			WAN_TASKLET_SCHEDULE(&chan->common.bh_task);
			netskb_t *skb = chan->tx_dma_skb;
			chan->tx_dma_skb=NULL;
			wan_clear_bit(TX_BUSY,&chan->dma_status);
			if (chan->common.usedby == TDM_VOICE || chan->common.usedby == TDM_VOICE_API){
/*	card->hw_iface.bus_read_4(card->hw,0x78, &tmp1);  */
	if (card->u.aft.tdmv_dchan){
		top_chan=wan_netif_priv(chan->common.dev);
                   		card->devname,chan->if_name,reg);
			chan->errstats.Tx_dma_errors++;
                   		card->devname,chan->if_name,reg);
			chan->errstats.Tx_dma_errors++;
                	     		card->devname,chan->if_name,reg);
                	     		card->devname,chan->if_name,reg);
                	     		card->devname,chan->if_name,reg);
				chan->errstats.Tx_pci_latency++;
                	     		card->devname,chan->if_name,reg);
			chan->errstats.Tx_pci_errors++;
		chan->if_stats.tx_dropped++;
	chan->opstats.Data_frames_Tx_count++;
	chan->opstats.Data_bytes_Tx_count+=wan_skb_len(skb);
	chan->if_stats.tx_packets++;
	chan->if_stats.tx_bytes+=wan_skb_len(skb);
        wan_set_bit(0,&chan->idle_start);
	if (wan_tracing_enabled(&top_chan->trace_info) >= 1){
		if (card->u.aft.tdmv_dchan){
			if (chan->common.usedby == TDM_VOICE_DCHAN){
			wan_capture_trace_packet(card, &top_chan->trace_info, skb, TRC_OUTGOING_FRM);
			wan_capture_trace_packet_offset(card, &top_chan->trace_info, skb,
		wan_capture_trace_packet(card, &top_chan->trace_info, skb, TRC_OUTGOING_FRM);
	if (WAN_NETIF_QUEUE_STOPPED(chan->common.dev)){
	if (chan->common.usedby == TDM_VOICE_DCHAN){
					 &chan->wp_tdm_api_dev_idx[chan->tdmv_chan];
	chan->if_stats.rx_errors=wan_skb_queue_len(&chan->wp_rx_free_list);
	chan->if_stats.tx_errors=wan_skb_queue_len(&chan->wp_tx_pending_list);
	wan_clear_bit(0,&chan->rx_dma);
	if (!chan->rx_dma_skb){
			DEBUG_EVENT("%s: Critical Error: rx_dma_skb\n",chan->if_name);
	rx_el=(wp_rx_element_t *)wan_skb_data(chan->rx_dma_skb);
	chan->if_stats.rx_frame_errors++;
/*    	card->hw_iface.bus_read_4(card->hw,0x80, &rx_empty);  */
	dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_LO;
	card->hw_iface.bus_read_4(card->hw,dma_descr, &rx_el->align);
	rx_el->align&=RxDMA_LO_ALIGNMENT_BIT_MASK;
    	dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
	card->hw_iface.bus_read_4(card->hw,dma_descr, &rx_el->reg);
	rx_el->pkt_error = chan->pkt_error;
	card->hw_iface.pci_unmap_dma(card->hw,
			 rx_el->dma_addr,
			 chan->dma_mru,
		__FUNCTION__,chan->if_name,rx_el->reg,rx_el->align,rx_el->dma_addr);
	skb=chan->rx_dma_skb;
	chan->rx_dma_skb=NULL;
	if (wan_test_bit(WP_FIFO_ERROR_BIT, &chan->pkt_error)){
		if (wan_test_bit(0,&chan->tdmv_sync)){
	if (chan->common.usedby == TDM_VOICE || chan->common.usedby == TDM_VOICE_API){
		if (!wan_test_bit(WP_FIFO_ERROR_BIT, &chan->pkt_error)){
			chan->if_stats.rx_dropped++;
		wan_skb_queue_tail(&chan->wp_rx_complete_list,skb);
		WAN_TASKLET_SCHEDULE(&chan->common.bh_task);
	chan->pkt_error=0;
/*    	card->hw_iface.bus_read_4(card->hw,0x80, &rx_empty); */
		__FUNCTION__,chan->if_name,rx_el->reg,rx_el->align,rx_el->dma_addr);
	chan->if_stats.rx_errors++;
	rx_el->align&=RxDMA_LO_ALIGNMENT_BIT_MASK;
	if (wan_test_bit(RxDMA_HI_DMA_GO_READY_BIT,&rx_el->reg)){
				card->devname,chan->if_name);
		chan->if_stats.rx_errors++;
		chan->errstats.Rx_dma_descr_err++;
	if (rx_el->reg&RxDMA_HI_DMA_PCI_ERROR_MASK){
		if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_M_ABRT){
                                   card->devname,chan->if_name,rx_el->reg);
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_T_ABRT){
                                   card->devname,chan->if_name,rx_el->reg);
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_DS_TOUT){
                                    card->devname,chan->if_name,rx_el->reg);
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_RETRY_TOUT){
                                    card->devname,chan->if_name,rx_el->reg);
		chan->if_stats.rx_errors++;
		chan->errstats.Rx_pci_errors++;
	if (chan->hdlc_eng){
		if (!wan_test_bit(RxDMA_HI_DMA_FRAME_START_BIT,&rx_el->reg)){
					card->devname,chan->if_name,rx_el->reg);
			chan->if_stats.rx_frame_errors++;
			chan->opstats.Rx_Data_discard_long_count++;
			chan->errstats.Rx_hdlc_corrupiton++;
		if (!wan_test_bit(RxDMA_HI_DMA_FRAME_END_BIT,&rx_el->reg)){
					card->devname,chan->if_name,rx_el->reg);
			chan->if_stats.rx_frame_errors++;
			chan->opstats.Rx_Data_discard_long_count++;
			chan->errstats.Rx_hdlc_corrupiton++;
			if (wan_test_bit(RxDMA_HI_DMA_CRC_ERROR_BIT,&rx_el->reg)){
                                		card->devname,chan->if_name,rx_el->reg);
				chan->if_stats.rx_errors++;
				chan->errstats.Rx_crc_err_count++;
				wan_set_bit(WP_CRC_ERROR_BIT,&rx_el->pkt_error);
			if (wan_test_bit(RxDMA_HI_DMA_FRAME_ABORT_BIT,&rx_el->reg)){
						card->devname,chan->if_name,rx_el->reg);
				chan->if_stats.rx_frame_errors++;
				chan->errstats.Rx_hdlc_corrupiton++;
				wan_set_bit(WP_ABORT_ERROR_BIT,&rx_el->pkt_error);
			if (chan->common.usedby != API && data_error){
	len=rx_el->reg&RxDMA_HI_DMA_DATA_LENGTH_MASK;
	if (chan->hdlc_eng){
		len=(((chan->dma_mru>>2)-len)<<2) - (~(rx_el->align)&RxDMA_LO_ALIGNMENT_BIT_MASK);
		if (len < 1 || len > chan->dma_mru){
			chan->if_stats.rx_frame_errors++;
			chan->errstats.Rx_hdlc_corrupiton++;
		len=(((chan->mru>>2)-len)<<2) - (~(0x03)&RxDMA_LO_ALIGNMENT_BIT_MASK);
		if (len < 1 || len > chan->mru){
			chan->if_stats.rx_frame_errors++;
	*pkt_error=rx_el->pkt_error;
	if (wan_test_bit(WP_FIFO_ERROR_BIT,&rx_el->pkt_error)){
		if (++chan->rx_fifo_err_cnt >= WP_MAX_FIFO_FRAMES){
			chan->rx_fifo_err_cnt=0;
		if (chan->rx_fifo_err_cnt){
			if (++chan->rx_fifo_err_cnt >= WP_MAX_FIFO_FRAMES){
                        	chan->rx_fifo_err_cnt=0;
				card->devname,chan->if_name,(len+20));
			chan->if_stats.rx_dropped++;
				card->devname,chan->if_name,(len+20));
			chan->if_stats.rx_dropped++;
	if (!chan->hdlc_eng && chan->cfg.data_mux){
	signed char logic_ch=-1, free_logic_ch=-1;
	*free_ch=-1;
	DEBUG_TEST("-- Request_Xilinx_logic_channel_num:--\n");
                card->u.aft.num_of_time_slots,
                card->u.aft.logic_ch_map);
		return -1;
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_and_set_bit(i,&card->u.aft.logic_ch_map)){
	if (logic_ch == -1){
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
	if (card->u.aft.dev_to_ch_map[(unsigned char)logic_ch]){
				card->devname,logic_ch);
		return -1;
	card->u.aft.dev_to_ch_map[(unsigned char)logic_ch]=(void*)chan;
	if (logic_ch > card->u.aft.top_logic_ch){
		card->u.aft.top_logic_ch=logic_ch;
	wan_clear_bit (logic_ch,&card->u.aft.logic_ch_map);
	card->u.aft.dev_to_ch_map[logic_ch]=NULL;
	if (logic_ch >= card->u.aft.top_logic_ch){
		card->u.aft.top_logic_ch=XILINX_DEFLT_ACTIVE_CH;
		for (i=0;i<card->u.aft.num_of_time_slots;i++){
			if (card->u.aft.dev_to_ch_map[i]){
				card->u.aft.top_logic_ch=i;
	DEBUG_CFG("-- Xilinx_dma_max_logic_ch :--\n");
	card->hw_iface.bus_read_4(card->hw,XILINX_DMA_CONTROL_REG, &reg);
        reg|=(card->u.aft.top_logic_ch << DMA_ACTIVE_CHANNEL_BIT_SHIFT);
        card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
	wan_skb_queue_tail(&chan->wp_rx_free_list,skb);
	while((skb=wan_skb_dequeue(&chan->wp_rx_complete_list)) != NULL){
		chan->if_stats.rx_dropped++;
			skb=wan_skb_alloc(chan->dma_mru);
                        skb=wan_skb_kalloc(chan->dma_mru);
					chan->if_name,__FUNCTION__);
			return -ENOMEM;
		wan_skb_queue_tail(&chan->wp_rx_free_list,skb);
	wan_set_bit(AFT_FE_POLL,&card->u.aft.port_task_cmd);
	WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	delay = card->wandev.fe_iface.polling(&card->fe);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
		card->wandev.fe_iface.add_timer(&card->fe, delay);
				__FUNCTION__,card->devname);
	sdla_t 		*card = chan->common.card;
	if (!wan_test_bit(0,&chan->up)){
                                chan->if_name);
		WAN_TASKLET_END(&chan->common.bh_task);
	if (card->u.aft.tdmv_dchan){
		top_chan=wan_netif_priv(chan->common.dev);
	while((skb=wan_skb_dequeue(&chan->wp_rx_complete_list)) != NULL){
		chan->if_stats.rx_errors++;
		xilinx_rx_post_complete (chan->common.card, chan,
			wan_capture_trace_packet(chan->common.card, &top_chan->trace_info,
		if (chan->common.usedby == API){
			if (chan->common.sk == NULL){
					chan->if_name);
				chan->if_stats.rx_dropped++;
				rx_hdr->wp_api_rx_hdr_error_flag=pkt_error;
						chan->if_name,
				++chan->if_stats.rx_dropped;
			new_skb->protocol = htons(PVC_PROT);
			new_skb->dev      = chan->common.dev;
			new_skb->pkt_type = WAN_PACKET_DATA;
			chan->if_stats.rx_frame_errors++;
						chan->if_name);
				++chan->if_stats.rx_dropped;
		}else if (chan->common.usedby == TDM_VOICE_DCHAN){
			 if (chan->tdmv_zaptel_cfg) {
				sdla_t *card=chan->common.card;
						(&card->wan_tdmv,
						chan->tdmv_chan,
				DEBUG_EVENT("%s: DCHAN Rx Packet critical error TDMV not compiled!\n",card->devname);
						card->devname,chan->logic_ch_num,wan_skb_len(new_skb),
						chan->tdmv_chan);
					 &chan->wp_tdm_api_dev_idx[chan->tdmv_chan];
						//rx_hdr->error_flag=pkt_error;
								chan->if_name,
						++chan->if_stats.rx_dropped;
						++chan->if_stats.rx_dropped;
                                 	DEBUG_EVENT("%s: DCHAN Rx Packet critical error op not supported ch=%i\n",card->devname,chan->tdmv_chan);
			      	  	++chan->if_stats.rx_dropped;
				DEBUG_EVENT("%s: TDM API support not compiled in\n",card->devname);
				++chan->if_stats.rx_dropped;
		 } else if (chan->common.usedby == TDM_VOICE){
						chan->if_name,
						chan->logic_ch_num);
			++chan->if_stats.rx_dropped;
		}else if (chan->common.usedby == STACK){
				++chan->if_stats.rx_dropped;
			protocol_recv(chan->common.card,chan,new_skb);
		chan->opstats.Data_frames_Rx_count++;
		chan->opstats.Data_bytes_Rx_count+=len;
		chan->if_stats.rx_packets++;
		chan->if_stats.rx_bytes+=len;
	while(chan->hdlc_eng && (skb=wan_skb_dequeue(&chan->wp_tx_complete_list)) != NULL){
		xilinx_tx_post_complete (chan->common.card,chan,skb);
	WAN_TASKLET_END(&chan->common.bh_task);
	if ((len=wan_skb_queue_len(&chan->wp_rx_complete_list))){
		DEBUG_TEST("%s: Triggering from bh rx=%d\n",chan->if_name,len);
		WAN_TASKLET_SCHEDULE(&chan->common.bh_task);
	}else if ((len=wan_skb_queue_len(&chan->wp_tx_complete_list))){
                DEBUG_TEST("%s: Triggering from bh tx=%d\n",chan->if_name,len);
		WAN_TASKLET_SCHEDULE(&chan->common.bh_task);
	if (card->wandev.state != WAN_CONNECTED){
                                  card->devname);
		for (i=0;i<card->u.aft.num_of_time_slots;i++){
			if (wan_test_bit(i,&tx_status) && wan_test_bit(i,&card->u.aft.logic_ch_map)){
				chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
				if (!wan_test_bit(0,&chan->up)){
							wan_netif_name(chan->common.dev),
							chan->common.state,
							chan->ignore_modem);
				if (chan->common.state != WAN_CONNECTED){
                                                	wan_netif_name(chan->common.dev));
				if (!chan->hdlc_eng && !wan_test_bit(0,&chan->idle_start)){
                                                	wan_netif_name(chan->common.dev));
					if (chan->hdlc_eng){
				if (chan->hdlc_eng && WAN_NET_RATELIMIT()){
					dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_LO;
					card->hw_iface.bus_read_4(card->hw,dma_descr, &reg_lo);
					dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
					card->hw_iface.bus_read_4(card->hw,dma_descr, &reg_hi);
						card->devname,
						chan->if_name,
						chan->logic_ch_num,
				err=-EINVAL;
		for (i=0;i<card->u.aft.num_of_time_slots;i++){
			if (wan_test_bit(i,&rx_status) && wan_test_bit(i,&card->u.aft.logic_ch_map)){
				chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
				if (!wan_test_bit(0,&chan->up)){
						wan_netif_name(chan->common.dev),
						chan->common.state,
						chan->ignore_modem);
				if (chan->common.state != WAN_CONNECTED){
                                                	wan_netif_name(chan->common.dev));
				chan->if_stats.rx_fifo_errors++;
				chan->errstats.Rx_overrun_err_count++;
				if (chan->hdlc_eng && WAN_NET_RATELIMIT()){
					dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_LO;
					card->hw_iface.bus_read_4(card->hw,dma_descr, &reg_lo);
					dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
					card->hw_iface.bus_read_4(card->hw,dma_descr, &reg_hi);
						card->devname,chan->if_name,chan->logic_ch_num,i,
						wan_skb_queue_len(&chan->wp_rx_complete_list),
						wan_skb_queue_len(&chan->wp_rx_free_list),
						chan->rx_dma,
				wan_set_bit(WP_FIFO_ERROR_BIT, &chan->pkt_error);
				err=-EINVAL;
	DEBUG_ISR("%s: front_end_interrupt!\n",card->devname);
	card->wandev.fe_iface.isr(&card->fe);
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
    	wan_set_bit(0,&card->in_isr);
       /* -----------------2/6/2003 9:02AM------------------
     	*  -- "Transmit/Receive DMA Engine"  interrupt disable
     	*  -- "FiFo/Line Abort Error"        interrupt disable
     	* --------------------------------------------------*/
        card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
			card->devname,XILINX_CHIP_CFG_REG,reg);
		if (++card->u.aft.chip_security_cnt > AFT_MAX_CHIP_SECURITY_CNT){
				card->devname);
				card->devname);
		card->u.aft.chip_security_cnt=0;
			if (card->wandev.fe_iface.check_isr &&
			    card->wandev.fe_iface.check_isr(&card->fe)){
				wan_set_bit(AFT_FE_INTR,&card->u.aft.port_task_cmd);
				WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
			DEBUG_EVENT("%s: ERR INTR (0x%X)\n",card->devname,reg);
        		card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_TX_INTR_PENDING_REG,&tx_fifo_status);
        		card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_RX_INTR_PENDING_REG,&rx_fifo_status);
			rx_fifo_status&=card->u.aft.active_ch_map;
			tx_fifo_status&=card->u.aft.active_ch_map;
       /* -----------------2/6/2003 9:37AM------------------
      	* --------------------------------------------------*/
		card->hw_iface.bus_read_4(card->hw,
        	card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_TX_INTR_PENDING_REG,&tx_fifo_status);
        	card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_RX_INTR_PENDING_REG,&rx_fifo_status);
		rx_fifo_status&=card->u.aft.active_ch_map;
		tx_fifo_status&=card->u.aft.active_ch_map;
				card->devname,
		dma_rx_reg&=card->u.aft.active_ch_map;
		for (i=0; i<card->u.aft.num_of_time_slots ;i++){
			     wan_test_bit(i,&card->u.aft.logic_ch_map)){
				chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
							card->devname,i);
				if (!wan_test_bit(0,&chan->up)){
                                                        card->devname,i);
				chan->if_stats.rx_frame_errors++;
					chan->if_stats.rx_frame_errors++;
					wan_set_bit(WP_FIFO_ERROR_BIT, &chan->pkt_error);
					card->devname);
				chan->if_stats.tx_fifo_errors=wan_skb_queue_len(&chan->wp_tx_pending_list);
				chan->if_stats.rx_fifo_errors=wan_skb_queue_len(&chan->wp_rx_free_list);
				if (chan->common.usedby == TDM_VOICE || chan->common.usedby == TDM_VOICE_API){
					card->hw_iface.bus_read_4(card->hw,
	        card->hw_iface.bus_read_4(card->hw,
		dma_tx_reg&=card->u.aft.active_ch_map;
				card->devname,
		for (i=0; i<card->u.aft.num_of_time_slots ;i++){
			if (wan_test_bit(i,&dma_tx_reg) && wan_test_bit(i,&card->u.aft.logic_ch_map)){
				chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
							card->devname,i);
				if (!wan_test_bit(0,&chan->up)){
                                                        card->devname,i);
				if (chan->common.usedby == TDM_VOICE ||chan->common.usedby == TDM_VOICE_API) {
             			DEBUG_TX(" ---- TX Interrupt pend. --\n");
	/* -----------------2/6/2003 10:36AM-----------------
	 * --------------------------------------------------*/
    	DEBUG_ISR("---- ISR end.-------------------\n");
    	wan_clear_bit(0,&card->in_isr);
 * "wanpipemon" utility is a user-space program that
	wan_udp_pkt = (wan_udp_pkt_t *)chan->udp_pkt_data;
	if (wan_atomic_read(&chan->udp_pkt_len) == 0){
		return -ENODEV;
	trace_info=&chan->trace_info;
	wan_udp_pkt = (wan_udp_pkt_t *)chan->udp_pkt_data;
		wan_udp_pkt->wan_udp_opp_flag = 0;
		switch(wan_udp_pkt->wan_udp_command) {
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len=0;
			wan_udp_pkt->wan_udp_return_code = 0;
			card->hw_iface.getcfg(card->hw, SDLA_COREREV, &wan_udp_pkt->wan_udp_data[0]);
			wan_udp_pkt->wan_udp_data_len=1;
			wan_udp_pkt->wan_udp_return_code = 0;
			if (card->wandev.state == WAN_CONNECTED){
				wan_udp_pkt->wan_udp_data[0]=1;
				wan_udp_pkt->wan_udp_data[0]=0;
			wan_udp_pkt->wan_udp_data_len=1;
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_return_code = 0;
			if (card->wandev.state == WAN_CONNECTED){
				wan_udp_pkt->wan_udp_data[0]=0x28;
				wan_udp_pkt->wan_udp_data[0]=0;
			wan_udp_pkt->wan_udp_data_len=1;
			wan_udp_pkt->wan_udp_return_code = 0;
			memcpy(wan_udp_pkt->wan_udp_data,&chan->opstats,sizeof(aft_op_stats_t));
			wan_udp_pkt->wan_udp_data_len=sizeof(aft_op_stats_t);
			wan_udp_pkt->wan_udp_return_code = 0;
			memset(&chan->opstats,0,sizeof(aft_op_stats_t));
			wan_udp_pkt->wan_udp_data_len=0;
			wan_udp_pkt->wan_udp_return_code = 0;
			memcpy(wan_udp_pkt->wan_udp_data,&chan->errstats,sizeof(aft_comm_err_stats_t));
			wan_udp_pkt->wan_udp_data_len=sizeof(aft_comm_err_stats_t);
			wan_udp_pkt->wan_udp_return_code = 0;
			memset(&chan->errstats,0,sizeof(aft_comm_err_stats_t));
			wan_udp_pkt->wan_udp_data_len=0;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			wan_udp_pkt->wan_udp_data_len = 0;
			if (!wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
				if (wan_udp_pkt->wan_udp_data[0] == 0){
					wan_clear_bit(1,&trace_info->tracing_enabled);
						card->devname);
				}else if (wan_udp_pkt->wan_udp_data[0] == 1){
					wan_clear_bit(2,&trace_info->tracing_enabled);
					wan_set_bit(1,&trace_info->tracing_enabled);
							card->devname);
					wan_clear_bit(1,&trace_info->tracing_enabled);
					wan_set_bit(2,&trace_info->tracing_enabled);
							card->devname);
				wan_set_bit (0,&trace_info->tracing_enabled);
						card->devname);
				wan_udp_pkt->wan_udp_return_code = 2;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			if(wan_test_bit(0,&trace_info->tracing_enabled)) {
				wan_clear_bit(0,&trace_info->tracing_enabled);
				wan_clear_bit(1,&trace_info->tracing_enabled);
				wan_clear_bit(2,&trace_info->tracing_enabled);
							card->devname);
				wan_udp_pkt->wan_udp_return_code = 1;
			if(wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
						card->devname);
				wan_udp_pkt->wan_udp_return_code = 1;
			wan_udp_pkt->wan_udp_atm_num_frames = 0;
			wan_udp_pkt->wan_udp_atm_ismoredata = 0;
			while (wan_skb_queue_len(&trace_info->trace_queue)){
				WAN_IFQ_POLL(&trace_info->trace_queue, skb);
								card->devname);
				if ((WAN_MAX_DATA_SIZE - buffer_length) < skb->m_pkthdr.len){
					wan_udp_pkt->wan_udp_atm_ismoredata = 0x01;
					   skb->m_pkthdr.len,
					   &wan_udp_pkt->wan_udp_data[buffer_length]);
				buffer_length += skb->m_pkthdr.len;
				WAN_IFQ_DEQUEUE(&trace_info->trace_queue, skb);
				wan_udp_pkt->wan_udp_atm_num_frames++;
			while ((skb=skb_dequeue(&trace_info->trace_queue)) != NULL){
				if((MAX_TRACE_BUFFER - buffer_length) < wan_skb_len(skb)){
					wan_udp_pkt->wan_udp_atm_ismoredata = 0x01;
						wan_skb_queue_head(&trace_info->trace_queue, skb);
						memcpy(&wan_udp_pkt->wan_udp_atm_data[buffer_length],
						wan_udp_pkt->wan_udp_atm_num_frames++;
				memcpy(&wan_udp_pkt->wan_udp_atm_data[buffer_length],
				wan_udp_pkt->wan_udp_atm_num_frames++;
			wan_udp_pkt->wan_udp_data_len = buffer_length;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			wan_getcurrenttime(&chan->router_up_time, NULL);
			chan->router_up_time -= chan->router_start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data =
					chan->router_up_time;
			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_return_code = 0;
				card->hw_iface.hw_lock(card->hw,&smp_flags);
				card->wandev.fe_iface.process_udp(
						&card->fe,
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				card->hw_iface.hw_unlock(card->hw,&smp_flags);
				if (wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE){
		    			wan_udp_pkt->wan_udp_data_len = sizeof(wan_femedia_t);
					wan_udp_pkt->wan_udp_return_code = CMD_OK;
					wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
		   	wan_udp_pkt->wan_udp_aft_num_frames = card->wandev.config_id;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_PLATFORM_ID;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
			wan_udp_pkt->wan_udp_data_len = 0;
			wan_udp_pkt->wan_udp_return_code = 0xCD;
			wan_udp_pkt->wan_udp_data_len = 0;
			wan_udp_pkt->wan_udp_return_code = 0xCD;
				card->devname,wan_udp_pkt->wan_udp_command);
	wan_udp_pkt->wan_ip_ttl= card->wandev.ttl;
	wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
        if (card->wandev.state != state)
                                card->devname);
                                card->devname);
                                card->devname);
                card->wandev.state = state;
		WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
 * S514-1/2/3:		V32/RS232/FT1 Front End
 * S514-4/5/7/8:	56K/T1/E1 Front End
 * 1. Front End State (card->wandev.front_end_status)
 * 2. Protocol State  (card->wandev.state)
 * 3. Interface State (dev->flags & IFF_UP)
	if (card->wandev.ignore_front_end_status == WANOPT_YES){
	if (!wan_test_bit(AFT_CHIP_CONFIGURED,&card->u.aft.chip_cfg_status)&&
	    card->fe.fe_status == FE_CONNECTED){
				card->devname,card->fe.fe_status);
		wan_set_bit(AFT_FRONT_END_UP,&card->u.aft.chip_cfg_status);
	if (card->fe.fe_status == FE_CONNECTED){
		if (!wan_test_bit(0,&card->u.aft.comm_enabled)){
			if (card->wan_tdmv.sc){
			card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_ON);
			if (card->u.aft.cfg.rbs){
				if (card->wandev.fe_iface.set_fe_sigctrl){
					card->wandev.fe_iface.set_fe_sigctrl(
								&card->fe,
		} else if (card->wandev.state != WAN_CONNECTED &&
                           wan_test_bit(0,&card->u.aft.comm_enabled)){
			if (card->wan_tdmv.sc){
			card->wandev.state = WAN_CONNECTED;
			card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_ON);
				card->devname);
		if (card->tdmv_conf.span_no){
			card->wandev.state = WAN_DISCONNECTED;
			card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_OFF);
			if (card->wan_tdmv.sc){
		if (wan_test_bit(0,&card->u.aft.comm_enabled) ||
                    card->wandev.state != WAN_DISCONNECTED){
			if (card->wan_tdmv.sc){
			card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_OFF);
        card->hw_iface.bus_read_2(card->hw,
        card->hw_iface.bus_write_2(card->hw,
        card->hw_iface.bus_read_1(card->hw,XILINX_MCPU_INTERFACE, &tmp);
        card->hw_iface.bus_write_2(card->hw,
        card->hw_iface.bus_read_2(card->hw,
	card->hw_iface.bus_write_2(card->hw,
	card->hw_iface.bus_write_1(card->hw,
        card->hw_iface.bus_write_2(card->hw,
	if (api_cmd->offset <= 0x3C){
		 card->hw_iface.pci_read_config_dword(card->hw,
						api_cmd->offset,
						(u32*)&api_cmd->data[0]);
		 api_cmd->len=4;
		card->hw_iface.peek(card->hw, api_cmd->offset, &api_cmd->data[0], api_cmd->len);
			card->devname,api_cmd->bar,api_cmd->offset,api_cmd->len);
	int			qaccess = card->wandev.state == WAN_CONNECTED ? 1 : 0;
	card->hw_iface.hw_lock(card->hw,&smp_flags);
	api_cmd->data[0] = card->fe.read_fe_reg(card->hw, qaccess, 1, (int)api_cmd->offset);
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
			card->devname,api_cmd->bar,api_cmd->offset,api_cmd->len);
			card->devname,
			api_cmd->bar,api_cmd->offset,api_cmd->len);
	if (api_cmd->len == 1){
		card->hw_iface.bus_write_1(
			card->hw,
			api_cmd->offset,
			(u8)api_cmd->data[0]);
	}else if (api_cmd->len == 2){
		card->hw_iface.bus_write_2(
			card->hw,
			api_cmd->offset,
			*(u16*)&api_cmd->data[0]);
	}else if (api_cmd->len == 4){
		card->hw_iface.bus_write_4(
			card->hw,
			api_cmd->offset,
			*(u32*)&api_cmd->data[0]);
		card->hw_iface.poke(
			card->hw,
			api_cmd->offset,
			&api_cmd->data[0],
			api_cmd->len);
	qaccess = card->wandev.state == WAN_CONNECTED ? 1 : 0;
			card->devname,
			api_cmd->bar,api_cmd->offset,api_cmd->len);
	card->hw_iface.hw_lock(card->hw,&smp_flags);
	err = card->fe.write_fe_reg(card->hw, qaccess, 1, (int)api_cmd->offset, (int)api_cmd->data[0]);
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
			(card->wandev.S514_cpu_no[0] == SDLA_CPU_A) ? 0x10 : 0x14,
			card->u.aft.bar,card->wandev.irq);
	card->hw_iface.pci_write_config_dword(card->hw,
			(card->wandev.S514_cpu_no[0] == SDLA_CPU_A) ? 0x10 : 0x14,
			card->u.aft.bar);
	card->hw_iface.pci_write_config_dword(card->hw, 0x3C, card->wandev.irq);
	card->hw_iface.pci_write_config_dword(card->hw, 0x0C, 0x0000ff00);
	int		err = -EINVAL;
	if (!ifr || !ifr->ifr_data){
		return -EINVAL;
	if (WAN_COPY_FROM_USER(&api_cmd,ifr->ifr_data,sizeof(wan_cmd_api_t))){
		return -EFAULT;
	if (WAN_COPY_TO_USER(ifr->ifr_data,&api_cmd,sizeof(wan_cmd_api_t))){
		return -EFAULT;
	card->hw_iface.bus_read_4(card->hw,
        card->hw_iface.bus_read_4(card->hw,
	for (i=0; i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
		chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
		if (!wan_test_bit(0,&chan->up)){
					__FUNCTION__,chan->if_name);
		if (wan_test_bit(0,&chan->tdmv_sync)){
        card->hw_iface.bus_read_4(card->hw,XILINX_DMA_CONTROL_REG,&reg);
        card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
	for (i=0; i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
		chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
		if (!wan_test_bit(0,&chan->up)){
		DEBUG_TEST("%s: Init interface fifo %s\n",__FUNCTION__,chan->if_name);
				card->devname,chan->if_name);
		wan_clear_bit(0,&chan->idle_start);
	for (i=0; i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
		chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
		if (!wan_test_bit(0,&chan->up)){
		DEBUG_TEST("%s: Init interface %s\n",__FUNCTION__,chan->if_name);
		if (chan->rx_dma_skb){
			netskb_t *skb=chan->rx_dma_skb;
			chan->rx_dma_skb=NULL;
			card->hw_iface.pci_unmap_dma(card->hw,
				 rx_el->dma_addr,
				 chan->dma_mru,
		while((skb=wan_skb_dequeue(&chan->wp_rx_complete_list)) != NULL){
			chan->if_stats.rx_errors++;
		if (chan->common.usedby == TDM_VOICE || chan->common.usedby == TDM_VOICE_API){
			while((skb=wan_skb_dequeue(&chan->wp_tx_pending_list)) != NULL){
				chan->if_stats.rx_errors++;
	        if (chan->tx_dma_addr && chan->tx_dma_len){
		if (chan->tx_dma_skb){
			if (chan->common.usedby == TDM_VOICE || chan->common.usedby == TDM_VOICE_API){
				aft_init_requeue_free_skb(chan, chan->tx_dma_skb);
				wan_skb_free(chan->tx_dma_skb);
			chan->tx_dma_skb=NULL;
		wan_clear_bit(TX_BUSY,&chan->dma_status);
		wan_clear_bit(0,&chan->idle_start);
		if (!chan->hdlc_eng){
						chan->if_name,err);
                                card->devname,chan->if_name);
     	card->hw_iface.bus_read_4(card->hw,
        card->hw_iface.bus_read_4(card->hw,
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	if (wan_test_bit(0,&card->u.aft.tdmv_sync)){
	wan_set_bit(0,&card->u.aft.comm_enabled);
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	card->hw_iface.bus_read_4(card->hw,XILINX_DMA_CONTROL_REG,&reg);
        card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
		wan_set_bit(CARD_DOWN,&card->wandev.critical);
	wan_clear_bit(0,&card->u.aft.comm_enabled);
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
	card->hw_iface.bus_write_4(card->hw,dma_descr, reg);
		card->hw_iface.hw_lock(card->hw,&smp_flags);
         	card->wandev.fe_iface.read_alarm(&card->fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE);
		card->wandev.fe_iface.read_pmon(&card->fe, 0);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
       	dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
       	card->hw_iface.bus_write_4(card->hw,dma_descr, reg);
	if ((skb=chan->rx_dma_skb) != NULL){
		rx_el=(wp_rx_element_t *)wan_skb_data(chan->rx_dma_skb);
		card->hw_iface.pci_unmap_dma(card->hw,
				 rx_el->dma_addr,
				 chan->dma_mru,
				__FUNCTION__,chan->if_name,rx_el->reg,rx_el->align,rx_el->dma_addr);
		chan->rx_dma_skb=NULL;
	wan_clear_bit(0,&chan->rx_dma);
	DEBUG_TEST("%s:%s: Tx Fifo Recovery \n",card->devname,chan->if_name);
	if (chan->common.usedby == TDM_VOICE || chan->common.usedby == TDM_VOICE_API){
	if (chan->hdlc_eng){
        	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
        	card->hw_iface.bus_write_4(card->hw,dma_descr, reg);
        if (chan->tx_dma_addr && chan->tx_dma_len){
         * re-transmission */
	if (chan->tx_dma_skb){
		wan_skb_queue_head(&chan->wp_tx_pending_list, chan->tx_dma_skb);
		chan->tx_dma_skb=NULL;
                if (chan->lip_atm) {
			netskb_t *tmpskb = chan->tx_dma_skb;
			chan->tx_dma_skb=NULL;
			wan_skb_queue_head(&chan->wp_tx_pending_list, chan->tx_dma_skb);
			chan->tx_dma_skb=NULL;
	if (!chan->hdlc_eng){
		if (wan_test_bit(0,&chan->idle_start)){
			++chan->if_stats.tx_fifo_errors;
		++chan->if_stats.tx_fifo_errors;
                                card->devname,chan->if_name);
	/* Re-start transmission */
	wan_clear_bit(TX_BUSY,&chan->dma_status);
		timeslot=card->u.aft.num_of_time_slots-2;
		timeslot=card->u.aft.num_of_time_slots-1;
		timeslot-=2;
		card->hw_iface.bus_read_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG,&reg);
			card->hw_iface.bus_write_4(card->hw,reg_off,data);
		if ((SYSTEM_TICKS-timeout) > 1){
				card->devname,ts_orig);
	card->hw_iface.bus_write_4(card->hw,reg_off,data);
			       card->devname,__FUNCTION__,__LINE__);
       	chan->common.state = state;
       	for (ch_ptr=chan; ch_ptr != NULL; ch_ptr=ch_ptr->next){
		ch_ptr->common.state=state;
		if (ch_ptr->tdmv_zaptel_cfg) {
		if (ch_ptr->common.usedby == TDM_VOICE_API ||
	            ch_ptr->common.usedby == TDM_VOICE_DCHAN) {
		       chan->if_name);
		wan_clear_bit(0,&chan->idle_start);
		chan->opstats.link_active_count++;
		chan->opstats.link_inactive_modem_count++;
	if (chan->common.usedby == API){
	if (chan->common.usedby == STACK){
		if (chan->num_of_time_slots == NUM_OF_T1_CHANNELS){
		}else if (chan->num_of_time_slots == 1){
		}else if (chan->num_of_time_slots == 2 || chan->num_of_time_slots == 3){
		}else if (chan->num_of_time_slots >= 4 && chan->num_of_time_slots<= 7){
		}else if (chan->num_of_time_slots >= 8 && chan->num_of_time_slots<= 15){
		}else if (chan->num_of_time_slots >= 16 && chan->num_of_time_slots<= 23){
					card->devname,chan->if_name,chan->num_of_time_slots);
			return -EINVAL;
		if (chan->num_of_time_slots == (NUM_OF_E1_CHANNELS-1)){
                }else if (chan->num_of_time_slots == 1){
                }else if (chan->num_of_time_slots == 2 || chan->num_of_time_slots == 3){
                }else if (chan->num_of_time_slots >= 4 && chan->num_of_time_slots <= 7){
                }else if (chan->num_of_time_slots >= 8 && chan->num_of_time_slots <= 15){
                }else if (chan->num_of_time_slots >= 16 && chan->num_of_time_slots <= 31){
                                        card->devname,chan->if_name,chan->num_of_time_slots);
                        return -EINVAL;
		card->devname,chan->if_name,req_fifo_size,chan->num_of_time_slots);
	fifo_size=map_fifo_baddr_and_size(card,req_fifo_size,&chan->fifo_base_addr);
	if (fifo_size == 0 || chan->fifo_base_addr == 31){
				card->devname,chan->if_name,fifo_size,chan->fifo_base_addr);
                return -EINVAL;
                card->devname,chan->if_name,req_fifo_size,chan->num_of_time_slots,fifo_size);
			chan->fifo_size_code=fifo_code_vector[i];
			card->devname,chan->if_name,req_fifo_size,fifo_size);
                card->devname,chan->if_name,fifo_size,
		chan->num_of_time_slots,chan->fifo_size_code,
		chan->fifo_base_addr);
	chan->fifo_size = fifo_size;
                        card->devname,reg,card->u.aft.fifo_addr_map);
		if (card->u.aft.fifo_addr_map & (reg<<i)){
		card->u.aft.fifo_addr_map |= reg<<i;
	                card->devname,card->u.aft.fifo_addr_map,i);
	for (i=0;i<chan->fifo_size;i++){
		card->devname,reg<<chan->fifo_base_addr, card->u.aft.fifo_addr_map);
	card->u.aft.fifo_addr_map &= ~(reg<<chan->fifo_base_addr);
                card->devname, card->u.aft.fifo_addr_map);
	chan->fifo_size=0;
	chan->fifo_base_addr=0;
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &led);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG, led);
                card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
                                return  -EINVAL;
	return -EINVAL;
	card->hw_iface.pci_unmap_dma(card->hw,
            	         chan->tx_dma_addr,
                  	 chan->tx_dma_len,
	chan->tx_dma_addr=0;
	chan->tx_dma_len=0;
	chan->common.protocol = conf->protocol;
			chan->if_name);
	return -EPROTONOSUPPORT;
	if (chan->common.protocol == WANCONFIG_PPP ||
	    chan->common.protocol == WANCONFIG_CHDLC){
		chan->common.is_netdev = 0;
			wan_iface.attach(dev, wan_netif_name(dev), chan->common.is_netdev);
					chan->if_name);
			return -EINVAL;
		chan->common.prot_ptr = dev;
		if (chan->common.protocol == WANCONFIG_CHDLC){
					chan->if_name);
					chan->if_name);
				wan_iface.detach(dev, chan->common.is_netdev);
			return -EINVAL;
	}else if (chan->common.protocol == WANCONFIG_GENERIC){
		chan->common.prot_ptr = dev;
				card->devname,chan->if_name,chan->common.protocol);
		return -EPROTONOSUPPORT;
	if (chan->common.protocol == WANCONFIG_PPP ||
	    chan->common.protocol == WANCONFIG_CHDLC){
		chan->common.prot_ptr = NULL;
			wan_iface.detach(dev, chan->common.is_netdev);
	if (chan->common.protocol == WANCONFIG_PPP ||
	    chan->common.protocol == WANCONFIG_CHDLC){
		wanpipe_generic_input(chan->common.dev, skb);
		wan_iface.input(chan->common.dev, skb);
	if (chan->common.protocol == WANCONFIG_GENERIC){
		skb->protocol = htons(ETH_P_HDLC);
		skb->dev = chan->common.dev;
	skb->protocol = htons(ETH_P_IP);
	skb->dev = chan->common.dev;
		wan_iface.input(chan->common.dev, skb);
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
		set_channel_timeslot_sync(&reg,chan->first_time_slot);
			card->devname,chan->if_name,reg);
                        card->devname,chan->if_name,reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG, reg);
        card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
                                card->devname,reg);
                                card->devname,reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG, reg);
	if (chan->common.usedby != API){
		return -ENODEV;
	if (!chan->common.sk){
		return -ENODEV;
		return -ENOMEM;
	api_rx_el->wp_api_event_channel=channel;
		return -ENOMEM;
	skb->pkt_type = WAN_PACKET_ERR;
	skb->protocol=htons(PVC_PROT);
	skb->dev=chan->common.dev;
			chan->if_name, wan_skb_len(skb));
		err=-ENODEV;
			chan->if_name);
	return -EINVAL;
		card->devname,channel,status);
	if (!wan_test_bit(channel-1, &card->u.aft.time_slot_map)){
	for (i=0; i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
		chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
		if (!wan_test_bit(0,&chan->up)){
		if (!wan_test_bit(channel-1, &chan->time_slot_map)){
		__FUNCTION__,chan->if_name,rx_el->reg,rx_el->align,rx_el->dma_addr);
	rx_el->align&=RxDMA_LO_ALIGNMENT_BIT_MASK;
	if (wan_test_bit(RxDMA_HI_DMA_GO_READY_BIT,&rx_el->reg)){
				card->devname,chan->if_name);
		chan->if_stats.rx_errors++;
		chan->errstats.Rx_dma_descr_err++;
	if (rx_el->reg&RxDMA_HI_DMA_PCI_ERROR_MASK){
		if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_M_ABRT){
                                   card->devname,chan->if_name,rx_el->reg);
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_T_ABRT){
                                   card->devname,chan->if_name,rx_el->reg);
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_DS_TOUT){
                                    card->devname,chan->if_name,rx_el->reg);
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_RETRY_TOUT){
                                    card->devname,chan->if_name,rx_el->reg);
		chan->if_stats.rx_errors++;
		chan->errstats.Rx_pci_errors++;
	len=rx_el->reg&RxDMA_HI_DMA_DATA_LENGTH_MASK;
	len=(((chan->mru>>2)-len)<<2) - (~(0x03)&RxDMA_LO_ALIGNMENT_BIT_MASK);
	return -1;
		if (wan_tracing_enabled(&chan->trace_info) >= 1){
			if (card->u.aft.tdmv_dchan == 0){
			wan_capture_trace_packet_offset(card, &chan->trace_info, skb,
			wan_capture_trace_packet(card, &chan->trace_info,
		if (chan->tdmv_zaptel_cfg){
				  chan->if_stats.rx_frame_errors++;
			if (card->wan_tdmv.sc){
				WAN_TDMV_CALL(is_rbsbits, (&card->wan_tdmv), err);
					wan_set_bit(AFT_FE_TDM_RBS,&card->u.aft.port_task_cmd);
					WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
		wan_skb_queue_tail(&chan->wp_tx_pending_list,skb);
		chan->if_stats.rx_packets++;
		chan->if_stats.rx_bytes += wan_skb_len(skb);
	if (len > chan->dma_mru){
				chan->if_name,len,chan->dma_mru);
		return -ENOMEM;
	if (!chan->tx_realign_buf){
		chan->tx_realign_buf=wan_malloc(chan->dma_mru);
		if (!chan->tx_realign_buf){
						chan->if_name);
			return -ENOMEM;
						chan->if_name,chan->dma_mru);
	memcpy(chan->tx_realign_buf,data,len);
				chan->if_name,wan_skb_tailroom(skb),len);
		return -ENOMEM;
		return -EINVAL;
	memcpy(data,chan->tx_realign_buf,len);
	chan->opstats.Data_frames_Tx_realign_count++;
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
			card->devname,card->u.aft.port_task_cmd);
	card->hw_iface.hw_lock(card->hw,&smp_flags);
	if (wan_test_bit(AFT_FE_INTR,&card->u.aft.port_task_cmd)){
		wan_clear_bit(AFT_FE_INTR,&card->u.aft.port_task_cmd);
	if (wan_test_bit(AFT_FE_POLL,&card->u.aft.port_task_cmd)){
		if (card->wandev.fe_iface.polling){
			delay = card->wandev.fe_iface.polling(&card->fe);
				card->wandev.fe_iface.add_timer(&card->fe, delay);
			wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
			wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		wan_clear_bit(AFT_FE_POLL,&card->u.aft.port_task_cmd);
	if (wan_test_bit(AFT_FE_TDM_RBS,&card->u.aft.port_task_cmd)){
		WAN_TDMV_CALL(rbsbits_poll, (&card->wan_tdmv, card), err);
		wan_clear_bit(AFT_FE_TDM_RBS,&card->u.aft.port_task_cmd);
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
	if (card->wandev.fe_iface.update_alarm_info){
		m->count =
				&card->wandev,
				(&card->fe, m, stop_cnt));
	if (card->wandev.fe_iface.update_pmon_info){
		m->count =
				&card->wandev,
				(&card->fe, m, stop_cnt));
	return m->count;
	wan_getcurrenttime(&chan->router_start_time, NULL);
	if (card->wandev.state == WAN_CONNECTED){
	if (!chan->hdlc_eng){
					chan->if_name);
        	card->hw_iface.bus_read_4(
					card->hw,
        	card->hw_iface.bus_write_4(card->hw,
                        (reg|(chan->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));
		card->hw_iface.bus_read_4(
					card->hw,
					chan->if_name,reg,reg1);
                                       chan->first_time_slot,
	wan_set_bit(0,&chan->up);
	chan->ignore_modem=0x0F;
	if (chan->channelized_cfg){
		for (chan=gchan; chan != NULL; chan=chan->next){
	chan->common.state = WAN_DISCONNECTED;
	chan->ignore_modem=0x00;
	if (chan->channelized_cfg){
		for (chan=gchan; chan != NULL; chan=chan->next){
					chan->if_name,chan->logic_ch_num);
			wan_clear_bit(0,&chan->up);
		wan_clear_bit(0,&chan->up);
			card->devname,
			card->tdmv_conf.span_no,
			card->tdmv_conf.span_no?"Enabled":"Disabled");
	if (card->tdmv_conf.span_no &&
      	    card->wan_tdmv.sc) {
	int 	dchan=card->u.aft.tdmv_dchan;
	if (IS_T1_CARD(card) && card->u.aft.tdmv_dchan){
		dchan--;
	if (chan->common.usedby != TDM_VOICE && chan->common.usedby != TDM_VOICE_API){
	if (!card->tdmv_conf.span_no){
		return -EINVAL;
	if (!conf->hdlc_streaming) {
		if (chan->common.usedby == TDM_VOICE) {
			WAN_TDMV_CALL(check_mtu, (card, conf->active_ch, &card->wandev.mtu), err);
		if (chan->common.usedby == TDM_VOICE_API) {
			 err=wp_tdmapi_check_mtu(card, conf->active_ch, 8, &card->wandev.mtu);
			return -EINVAL;
		chan->mtu = chan->mru = card->u.aft.cfg.mru = card->wandev.mtu;
	if (card->u.aft.tdmv_dchan){
		wan_set_bit(dchan,&conf->active_ch);
		conf->active_ch=conf->active_ch>>1;
	if (chan->tdmv_zaptel_cfg){
		WAN_TDMV_CALL(reg, (card, &conf->tdmv, conf->active_ch, conf->hwec.enable, chan->common.dev), err);
					chan->if_name);
			return -EINVAL;
		card->wan_tdmv.brt_enable = 1;
		conf->hdlc_streaming=0;
		WAN_TDMV_CALL(software_init, (&card->wan_tdmv), err);
	if (card->u.aft.tdmv_dchan){
		wan_clear_bit(dchan,&conf->active_ch);
	if (chan->common.usedby == TDM_VOICE){
		WAN_TDMV_CALL(unreg, (card,chan->time_slot_map), err);
		return -EINVAL;
	card=(sdla_t*)chan->common.card;
	card->hw_iface.hw_lock(card->hw,&flags);
	*rbs_bits = card->wandev.fe_iface.read_rbsbits(
						&card->fe,
	card->hw_iface.hw_unlock(card->hw,&flags);
		return -EINVAL;
	card=(sdla_t*)chan->common.card;
	card->hw_iface.hw_lock(card->hw,&flags);
	err = card->wandev.fe_iface.set_rbsbits(&card->fe,
	card->hw_iface.hw_unlock(card->hw,&flags);
	sdla_t *card=chan->common.card;
	int err=-EINVAL;
	if (!chan_ptr || !chan->common.dev || !card){
		return -EINVAL;
	if (chan->common.usedby != TDM_VOICE_DCHAN) {
		return -EINVAL;
	if (wan_skb_len(skb) > chan->mtu) {
		return -EINVAL;
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	if (wan_skb_queue_len(&chan->wp_tx_pending_list) > MAX_TX_BUF){
		wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
		return -EBUSY;
	wan_skb_queue_tail(&chan->wp_tx_pending_list,skb);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
	for (x=0;x<card->u.aft.num_of_time_slots;x++){
		if (!wan_test_bit(x,&chan->tdmapi_timeslots)){
		if (is_tdm_api(chan,&chan->wp_tdm_api_dev_idx[x])){
			wanpipe_tdm_api_update_state(&chan->wp_tdm_api_dev_idx[x], state);
	if (rxbuf_len != chan->mru) {
		chan->if_stats.rx_errors++;
		return -EINVAL;
		for (x=0;x<card->u.aft.num_of_time_slots;x++){
			if (!wan_test_bit(x,&chan->tdmapi_timeslots)){
			chan->wp_tdm_api_dev_idx[x].rx_data[y] =
			if (y == WP_TDM_API_CHUNK_SZ-1) {
				wanpipe_tdm_api_rx_tx(&chan->wp_tdm_api_dev_idx[x],
				    		       chan->wp_tdm_api_dev_idx[x].rx_data,
				    		       chan->wp_tdm_api_dev_idx[x].tx_data,
		for (x=0;x<card->u.aft.num_of_time_slots;x++){
			if (!wan_test_bit(x,&chan->tdmapi_timeslots)){
			txbuf[offset++] = chan->wp_tdm_api_dev_idx[x].tx_data[y];
			card->devname);
			card->devname);
	   /* TE1 - Unconfiging, only on shutdown */
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
	wan_set_bit(CARD_DOWN,&card->wandev.critical);
	card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_OFF);
./sdla_xilinx.c
* Copyright:	(c) 1995-2003 Sangoma Technologies Inc.
#define CVHexToAscii(b) (((unsigned char)(b) > (unsigned char)9) ? ((unsigned char)'A' + ((unsigned char)(b) - (unsigned char)10)) : ((unsigned char)'0' + (unsigned char)(b)))
	unsigned int * sp = (unsigned int *)(((char *)v) - (sizeof(unsigned int) + KMEM_SAFETYZONE*8));
	char * c1 = ((char *)v) - KMEM_SAFETYZONE*8;
	v = ((char *)v) - (sizeof(unsigned int) + KMEM_SAFETYZONE*8);
 * Rationale:  	Per-channel debugging is possible if each 
 *              the rest of X.25 channel-specific data. 
	unsigned short protocol;	/* ethertype, 0 - multiplexed */
	unsigned hold_timeout;		/* sec, before re-connecting */
	sdla_t* card;			/* -> owner */
	netdevice_t *dev;		/* -> bound devce */
	char accept_dest_addr[WAN_ADDRESS_SZ+1];   /* pattern match string in -d<string>
	char accept_src_addr[WAN_ADDRESS_SZ+1];    /* pattern match string in -s<string> 
	char accept_usr_data[WAN_ADDRESS_SZ+1];/* pattern match string in -u<string> 
 *	WANPIPE-specific entry points 
 *  		o initialize protocol-specific fields of the 
	wan_x25_conf_t*	x25_adm_conf = &card->u.x.x25_adm_conf;
	wan_x25_conf_t*	x25_conf = &card->u.x.x25_conf;
	if (conf->config_id != WANCONFIG_ADCCP){
			card->devname, conf->config_id)
		return -EINVAL;
	/* Initialize protocol-specific fields */
	card->mbox_off  = X25_MB_VECTOR + X25_MBOX_OFFS;
	card->flags_off = X25_MB_VECTOR + X25_STATUS_OFFS;
	card->rxmb_off  = X25_MB_VECTOR + X25_RXMBOX_OFFS;
		return -EIO;
		card->devname, u.str);
	card->u.x.LAPB_hdlc = 1;
	memcpy(x25_adm_conf, &conf->u.x25, sizeof(wan_x25_conf_t));
	u.cfg.t1		= conf->u.x25.t1;
	u.cfg.t2		= conf->u.x25.t2;
	u.cfg.t4		= conf->u.x25.t4;
	u.cfg.hdlcWindow	= conf->u.x25.hdlc_window;
	u.cfg.local_station_address = conf->u.x25.local_station_address;
	if (conf->clocking != WANOPT_EXTERNAL)
		u.cfg.baudRate = bps_to_speed_code(conf->bps);
	if (conf->u.x25.station != WANOPT_DTE){
        if (conf->electrical_interface != WANOPT_RS232 ){
			card->devname);
			         card->devname,
			         card->devname,
			         card->devname,
			         card->devname,
			         card->devname,
			         card->devname,
			         card->devname,
			         card->devname,
			         conf->u.x25.local_station_address);
	if (!conf->mtu || (conf->mtu >= 1024))
		card->wandev.mtu = 1024;
	else if (conf->mtu >= 512)
		card->wandev.mtu = 512;
	else if (conf->mtu >= 256)
		card->wandev.mtu = 256;
	else if (conf->mtu >= 128)
		card->wandev.mtu = 128;
		card->wandev.mtu = 64;
	x25_conf->hdlc_window 	= u.cfg.hdlcWindow;
	x25_conf->t1 		= u.cfg.t1;
	x25_conf->t2 		= u.cfg.t2;
	x25_conf->t4 		= u.cfg.t4;
	x25_conf->n2 		= u.cfg.n2;
	x25_conf->oob_on_modem 	= conf->u.x25.oob_on_modem;
		return -EIO;
		return -EIO;
	/* Initialize protocol-specific fields of adapter data space */
	card->wandev.bps	= conf->bps;
	card->wandev.electrical_interface	= conf->electrical_interface;
	card->wandev.clocking	= conf->clocking;
	card->wandev.station	= conf->u.x25.station;
	card->isr		= &wpx_isr;
	card->poll		= NULL; 
	card->disable_comm	= &disable_comm;
	card->exec		= NULL;
	card->wandev.update	= &update;
	card->wandev.new_if	= &new_if;
	card->wandev.del_if	= &del_if;
	card->wandev.get_config_info 	= &x25_get_config_info;
	card->wandev.get_status_info 	= &x25_get_status_info;
	card->wandev.get_dev_config_info= &x25_get_dev_config_info;
	card->wandev.get_if_info     	= &x25_get_if_info;
	card->wandev.set_dev_config    	= &x25_set_dev_config;
	card->wandev.set_if_info     	= &x25_set_if_info;
	card->get_snmp_data     	= &x25_snmp_data;
	card->wandev.state	= WAN_DISCONNECTED;
	card->wandev.enable_tx_int = 0;
	card->irq_dis_if_send_count = 0;
        card->irq_dis_poll_count = 0;
	card->u.x.tx_dev = NULL;
	card->u.x.no_dev = 0;
	card->u.x.hdlc_buf_status_off = 
	card->u.x.poll_device=NULL;
	card->wandev.udp_port = conf->udp_port;
	if (conf->u.x25.logging == WANOPT_YES){
			card->devname);
		card->u.x.logging = 1;
		card->u.x.logging = 0;
	if (conf->u.x25.oob_on_modem == WANOPT_YES){
			card->devname);
		card->u.x.oob_on_modem = 1;
		card->u.x.oob_on_modem = 0;
	WAN_TASKQ_INIT((&card->u.x.x25_poll_task),0,wpx_poll,card);
	init_timer(&card->u.x.x25_timer);
	card->u.x.x25_timer.data = (unsigned long)card;
	card->u.x.x25_timer.function = x25_timer_routine;
	if ((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if (wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	if (test_bit(SEND_CRIT, (void*)&wandev->critical))
		return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&wandev->dev_head));
		return -ENODEV;
	card = wandev->priv;
	DEBUG_EVENT("%s: UPDATE\n",card->devname);
	spin_lock_irqsave(&card->wandev.lock, smp_flags);
	if (*card->u.x.hdlc_buf_status & 0x40){
	spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
 *              area pointer (dev->priv).
	sdla_t* card = wandev->priv;
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)){
			card->devname);
		return -EINVAL;
	if(card->wandev.new_if_cnt++ > 0) {
						card->devname);
						card->devname);
		return -EEXIST;
						card->devname);
		return -ENOMEM;
	WAN_TASKLET_INIT((&chan->common.bh_task),0,x25api_bh,(unsigned long)chan);
	dev->priv = chan;
	strcpy(chan->name, conf->name);
	chan->card = card;
	chan->dev = dev;
	chan->tx_skb = chan->rx_skb = NULL;
	if(strcmp(conf->usedby, "WANPIPE") == 0){
			wandev->name, chan->name);
                chan->common.usedby = WANPIPE;
		chan->protocol = htons(ETH_P_IP);
        }else if(strcmp(conf->usedby, "API") == 0){
		chan->common.usedby = API;
			wandev->name, chan->name);
		wan_reg_api(chan, dev, card->devname);
		chan->protocol = htons(WP_LAPB_PROT);
		dev->priv = NULL;
	chan->enable_IPX = conf->enable_IPX;
	if (chan->enable_IPX)
		chan->protocol = htons(ETH_P_IPX);
	if (conf->network_number)
		chan->network_number = conf->network_number;
		chan->network_number = 0xDEADBEEF;
	dev->init = &if_init;
	chan->common.state = WAN_DISCONNECTED;
	sdla_t *card=wandev->priv;
	x25_channel_t* chan = dev->priv;
	WAN_TASKLET_KILL(&chan->common.bh_task);
	wan_unreg_api(dev->priv, card->devname);
	del_timer(&card->u.x.x25_timer);
 * 		(dev->init())
	x25_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->do_ioctl		= &if_ioctl;
	if (chan->common.usedby != API){
		dev->tx_timeout		= &if_tx_timeout;
		dev->watchdog_timeo	= TX_TIMEOUT;
	/* Initialize media-specific parameters */
	dev->type		= ARPHRD_PPP;		/* ARP h/w type */
	dev->flags		|= IFF_POINTOPOINT;
	dev->flags		|= IFF_NOARP;
	if (chan->common.usedby == API){
		dev->mtu	= X25_CHAN_MTU+sizeof(x25api_hdr_t);
		dev->mtu	= card->wandev.mtu; 	
	dev->hard_header_len	= 0;            /* media header length */
	dev->addr_len		= 2;		/* hardware address length */
	if (!chan->common.svc){
		*(unsigned short*)dev->dev_addr = htons(chan->common.lcn);
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start); 
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end);
        dev->tx_queue_len = 100;
 * 		(dev->open())
	x25_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
		return -EBUSY;
	++card->u.x.no_dev;
	if (card->open_cnt == 1){
		card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
		card->hw_iface.poke(card->hw, card->flags_off, &status, sizeof(status));
	chan->router_start_time = tv.tv_sec;
 * 		(dev->close())
	x25_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	dev->start=0;
	if ((chan->common.state == WAN_CONNECTED) || 
	    (chan->common.state == WAN_CONNECTING)){
	if (!card->open_cnt){
	--card->u.x.no_dev;
    	x25_channel_t* chan = dev->priv;
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++chan->if_send_stat.if_send_tbusy_timeout;
			card->devname, dev->name);
 *		non-0	packet may be re-transmitted (tbusy must be set)
	x25_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	++chan->if_send_stat.if_send_entry;
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
	if (dev->tbusy){
		if ((jiffies - chan->tick_counter) < (5*HZ)){
	chan->tick_counter = jiffies;
	if (test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)){
		printk(KERN_INFO "Hit critical in if_send()! %lx\n",card->wandev.critical);
		++chan->if_send_stat.if_send_critical_ISR;
	if (card->wandev.state != WAN_CONNECTED){
		++chan->ifstats.tx_dropped;
		++card->wandev.stats.tx_dropped;
		++chan->if_send_stat.if_send_wan_disconnected;	
	}else if (chan->protocol && (chan->protocol != skb->protocol)){
			chan->name, htons(skb->protocol), dev->name);
		printk(KERN_INFO "PROTO %Xn", htons(chan->protocol));
		++chan->ifstats.tx_errors;
		++chan->ifstats.tx_dropped;
		++card->wandev.stats.tx_dropped;
		++chan->if_send_stat.if_send_protocol_error;
	}else switch (chan->common.state){
			++chan->ifstats.tx_dropped;
			++card->wandev.stats.tx_dropped;
			++chan->if_send_stat.if_send_wan_disconnected;	
			err=chan_send(dev, skb->data, skb->len, 0);
				err=-1;
				++chan->if_send_stat.if_send_bfr_not_passed_to_adptr;
				++chan->if_send_stat.if_send_bfr_passed_to_adptr;
			++chan->ifstats.tx_dropped;	
			++card->wandev.stats.tx_dropped;
			++chan->if_send_stat.if_send_wan_disconnected;	
		if (chan->common.state == WAN_CONNECTED){
			card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
			++chan->if_send_stat.if_send_tx_int_enabled;
	clear_bit(SEND_CRIT,(void*)&card->wandev.critical);
 * 	Get ethernet-style interface statistics.
	x25_channel_t *chan = dev->priv;
	return &chan->ifstats;
	if (!dev || !(dev->flags & IFF_UP)){
		return -ENODEV;
	if (!(chan = dev->priv)){
		return -ENODEV;
	if (!(card = chan->card)){
		return -ENODEV;
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			err=wan_bind_api_to_svc(chan,ifr->ifr_data);
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
				err= -EINVAL;
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			err=wan_unbind_api_from_svc(chan,ifr->ifr_data);
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
			if (chan->common.state != WAN_DISCONNECTED){
			err = chan->common.state;
			if (atomic_read(&card->u.x.command_busy)){
				atomic_set(&card->u.x.command_busy,0);
			atomic_set(&chan->common.disconnect,0);
			atomic_set(&chan->common.command,0);
			del_timer(&card->u.x.x25_timer);
			card->u.x.x25_timer.expires=jiffies+HZ;
			add_timer(&card->u.x.x25_timer);
			atomic_set(&chan->common.command,X25_PLACE_CALL);
			del_timer(&card->u.x.x25_timer);
			card->u.x.x25_timer.expires=jiffies+1;
			add_timer(&card->u.x.x25_timer);
			DEBUG_EVENT("%s:%s PLACE CALL RC %x\n",card->devname,dev->name,err);
			atomic_set(&chan->common.command,X25_CLEAR_CALL);
			DEBUG_EVENT("%s:%s CLEAR CALL RC %i\n",card->devname,dev->name,err);
			if (atomic_read(&card->u.x.udp_pkt_len) != 0){
				return -EBUSY;
			atomic_set(&card->u.x.udp_pkt_len,sizeof(wan_udp_hdr_t));
			wan_udp_pkt=(wan_udp_pkt_t*)&card->u.x.udp_pkt_data;
			if (copy_from_user(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				atomic_set(&card->u.x.udp_pkt_len,0);
				return -EFAULT;
			spin_lock_irqsave(&card->wandev.lock, smp_flags);
			if (test_bit(0,&card->in_isr)){
						card->devname,dev->name);
				atomic_set(&card->u.x.udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
				return -EBUSY;
				atomic_set(&card->u.x.udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
				return -EINVAL;
			spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
			if (atomic_read(&card->u.x.udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						atomic_read(&card->u.x.udp_pkt_len));
				atomic_set(&card->u.x.udp_pkt_len,0);
				return -EINVAL;
			if (copy_to_user(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				atomic_set(&card->u.x.udp_pkt_len,0);
				return -EFAULT;
			atomic_set(&card->u.x.udp_pkt_len,0);
					chan->common.dev->name,cmd);
			return -EOPNOTSUPP;
			DBG_PRINTK(KERN_INFO "Ioctl: Cmd 0x%x\n",atomic_read(&chan->common.command));
			if (chan->common.usedby == API && 
			    atomic_read(&chan->common.command)){
				if (card->u.x.LAPB_hdlc && 
				    atomic_read(&chan->common.command) == X25_PLACE_CALL){
					if (atomic_read(&card->u.x.command_busy)){
						atomic_set(&card->u.x.command_busy,0);
					atomic_set(&chan->common.disconnect,0);
					atomic_set(&chan->common.command,0);
					del_timer(&card->u.x.x25_timer);
					card->u.x.x25_timer.expires=jiffies+HZ;
					add_timer(&card->u.x.x25_timer);
			if ((chan->common.usedby == API) && 
			     atomic_read(&chan->common.disconnect)){
				set_bit(0,&chan->common.disconnect);
				if (chan->common.state == WAN_CONNECTED){
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
	if (test_bit(0,&card->in_isr)){
		printk(KERN_INFO "%s: Critical in WPX_ISR\n",card->devname);
		card->hw_iface.poke(card->hw, card->flags_off, &status, sizeof(status));
	card->in_isr = 1;
	++card->statistics.isr_entry;
	if (test_bit(PERI_CRIT,(void*)&card->wandev.critical)){
		printk(KERN_INFO "%s: Critical in PERI\n",card->devname);
		card->in_isr=0;
		card->hw_iface.poke(card->hw, card->flags_off, &status, sizeof(status));
	if (test_bit(SEND_CRIT, (void*)&card->wandev.critical)){
			card->devname, card->wandev.critical, status.iflags);
		card->in_isr = 0;
		card->hw_iface.poke(card->hw, card->flags_off, &status, sizeof(status));
			++card->statistics.isr_rx;
			++card->statistics.isr_tx;
			++card->statistics.isr_spurious;
	card->in_isr = 0;
	card->hw_iface.poke(card->hw, card->flags_off, &status, sizeof(status));
 * 	This routine handles fragmented IP packets using M-bit according to the
 * 	o if M-bit is reset (i.e. it's the last packet in a sequence) then 
 * 	1. When allocating a socket buffer, if M-bit is set then more data is
	card->hw_iface.peek(card->hw, card->rxmb_off, &rxmb, sizeof(rxmb));
				card->devname, lcn);
	chan = dev->priv;
	chan->i_timeout_sofar = jiffies;
		++chan->ifstats.rx_dropped;
		++card->wandev.stats.rx_dropped;
		++chan->rx_intr_stat.rx_intr_no_socket;
		++chan->rx_intr_stat.rx_intr_bfr_not_passed_to_stack;
	dev->last_rx = jiffies;		/* timestamp */
	/* ------------ API ----------------*/
	if (chan->common.usedby == API){
			++chan->ifstats.rx_dropped;
			++card->wandev.stats.rx_dropped;
			++chan->rx_intr_stat.rx_intr_bfr_not_passed_to_stack;
		chan->rx_skb = NULL;
		WAN_TASKLET_SCHEDULE(&chan->common.bh_task);
	/* ------------- WANPIPE -------------------*/
	chan->rx_skb=NULL;
	if (!skb->protocol && !wanrouter_type_trans(skb, dev)){
		++chan->ifstats.rx_errors;
		++chan->ifstats.rx_dropped;
		++card->wandev.stats.rx_dropped;
		++chan->rx_intr_stat.rx_intr_bfr_not_passed_to_stack;
		if( handle_IPXWAN(skb->data, chan->name, 
				  chan->enable_IPX, chan->network_number, 
				  skb->protocol)){
			if( chan->enable_IPX ){
				if(chan_send(dev, skb->data, skb->len,0)){
					chan->tx_skb = skb;
					++chan->rx_intr_stat.rx_intr_bfr_not_passed_to_stack;
				++chan->ifstats.rx_dropped;
				++chan->rx_intr_stat.rx_intr_bfr_not_passed_to_stack;
			chan->ifstats.rx_bytes += skb->len;
			++chan->ifstats.rx_packets;
			++chan->rx_intr_stat.rx_intr_bfr_passed_to_stack;
	x25_channel_t*	chan = dev->priv;
	card->hw_iface.peek(card->hw, card->rxmb_off, &rxmb, sizeof(rxmb));
			card->devname);
		chan->drop_sequence = 1;	/* set flag */
		++chan->ifstats.rx_dropped;
	if (chan->common.usedby == API){
		api_data->hdr.qdm = rxmb.wan_x25_qdm;
		api_data->hdr.cause = rxmb.wan_x25_cause;
		api_data->hdr.diagn = rxmb.wan_x25_diagn;
		api_data->hdr.length = rxmb.wan_data_len;
		api_data->hdr.lcn  = rxmb.wan_x25_lcn;
		memcpy(api_data->data, rxmb.wan_data, rxmb.wan_data_len);
	new_skb->dev = dev;
	if (chan->common.usedby == API){
		new_skb->protocol = htons(X25_PROT);
		new_skb->pkt_type = WAN_PACKET_DATA;
		new_skb->protocol = chan->protocol;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
	if (card->u.x.timer_int_enabled & TMR_INT_ENABLED_CMD_EXEC){
			card->u.x.timer_int_enabled &=
			 * re-trigger tx interrupt */
			++card->statistics.isr_enable_tx_int;
	chan = dev->priv;
		if (chan->common.usedby == API){
	card->hw_iface.poke(card->hw, card->flags_off, &status, sizeof(status));
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
	if(card->u.x.timer_int_enabled & TMR_INT_ENABLED_UDP_PKT) {
		if (card->u.x.udp_type == UDP_XPIPE_TYPE){
		                card->u.x.timer_int_enabled &= 
	}else if (card->u.x.timer_int_enabled & TMR_INT_ENABLED_POLL_ACTIVE) {
		netdevice_t *dev = card->u.x.poll_device;
			card->u.x.timer_int_enabled &= ~TMR_INT_ENABLED_POLL_ACTIVE;
		chan = dev->priv;
					card->devname,chan->name,chan->common.lcn); 
		chan->i_timeout_sofar = jiffies;
         	card->u.x.timer_int_enabled &= ~TMR_INT_ENABLED_POLL_ACTIVE;
		card->u.x.poll_device=NULL;
	}else if (card->u.x.timer_int_enabled & TMR_INT_ENABLED_POLL_CONNECT_ON) {
		netdevice_t *dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		card->hw_iface.poke(card->hw, card->flags_off, &status, sizeof(status));
		card->u.x.timer_int_enabled &= ~TMR_INT_ENABLED_POLL_CONNECT_ON;
	}else if (card->u.x.timer_int_enabled & TMR_INT_ENABLED_POLL_CONNECT_OFF) {
		DEBUG_TX("%s: Poll connect, Turning OFF\n",card->devname);
		if (card->u.x.LAPB_hdlc){
			netdevice_t *dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
			send_oob_msg(card,dev,&card->wan_mbox);
		card->u.x.timer_int_enabled &= ~TMR_INT_ENABLED_POLL_CONNECT_OFF;
	}else if (card->u.x.timer_int_enabled & TMR_INT_ENABLED_POLL_DISCONNECT) {
		if (card->u.x.LAPB_hdlc){
			netdevice_t *dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		card->u.x.timer_int_enabled &= ~TMR_INT_ENABLED_POLL_DISCONNECT;
	}else if (card->u.x.timer_int_enabled & TMR_INT_ENABLED_UPDATE){
		if (*card->u.x.hdlc_buf_status & 0x40){
			card->u.x.timer_int_enabled &= ~TMR_INT_ENABLED_UPDATE;
		card->u.x.timer_int_enabled &= ~TMR_INT_ENABLED_UPDATE;
	if(!(card->u.x.timer_int_enabled & ~TMR_INT_ENABLED_CMD_EXEC)){
		card->hw_iface.poke(card->hw, card->flags_off, &status, sizeof(status));
	wan_mbox_t*		mbox = &card->wan_mbox;
	memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
	mbox->wan_command = X25_READ_MODEM_STATUS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
		modem_status = (TX25ModemStatus*)mbox->wan_data;	
		if (last_stat.status != modem_status->status){
				card->devname,DCD(modem_status->status),CTS(modem_status->status));
			last_stat.status = modem_status->status;
			if (card->u.x.oob_on_modem){
				mbox->wan_x25_pktType = mbox->wan_command;
				mbox->wan_return_code = 0x08;
				WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
					if (chan->common.usedby == API){
				if (atomic_read(&card->u.x.command_busy)){
					atomic_set(&card->u.x.command_busy,0);
	memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
	mbox->wan_command = X25_HDLC_LINK_STATUS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	printk(KERN_INFO "%s: spurious interrupt!\n", card->devname);
 * 	time-dependent housekeeping work.
	++card->statistics.poll_processed;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (test_bit(PERI_CRIT,&card->wandev.critical)){
	if (test_bit(SEND_CRIT,&card->wandev.critical)){
	switch(card->wandev.state){
	clear_bit(POLL_CRIT,&card->wandev.critical);
	wan_schedule_task(&card->u.x.x25_poll_task);
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
	}else if ((jiffies - card->state_tick) > CONNECT_TIMEOUT){
 * 	o if hold-down timeout has expired and there are open interfaces, 
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if ((chan=dev->priv) == NULL)
	if (card->open_cnt && (jiffies - card->state_tick) > HOLD_DOWN_TIME){
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
		if (jiffies-chan->disc_delay < HZ){
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
	card->u.x.timer_int_enabled |= TYPE;
		card->hw_iface.poke(card->hw, card->flags_off, &status, sizeof(status));
 * SDLA Firmware-Specific Functions 
 *  of retries is reached.  Each interface command returns non-zero return 
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_READ_CODE_VERSION;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, X25_READ_CODE_VERSION, 0) && retry--);
		int len = mbox->wan_data_len;
		memcpy(str, mbox->wan_data, len);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		memcpy(mbox->wan_data, (void*)conf, sizeof(TX25Config));
		mbox->wan_data_len  = sizeof(TX25Config);
		mbox->wan_command = X25_HDLC_SET_CONFIG;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, X25_SET_CONFIGURATION, 0) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_HDLC_READ_COMM_ERR;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, X25_HDLC_READ_COMM_ERR, 0) && retry--);
		THdlcCommErr* stats = (void*)mbox->wan_data;
		card->wandev.stats.rx_over_errors    = stats->rxOverrun;
		card->wandev.stats.rx_crc_errors     = stats->rxBadCrc;
		card->wandev.stats.rx_missed_errors  = stats->rxAborted;
		card->wandev.stats.tx_aborted_errors = stats->txAborted;
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_READ_STATISTICS;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, X25_READ_STATISTICS, 0) && retry--) ;
		TX25Stats* stats = (void*)mbox->wan_data;
		card->wandev.stats.rx_packets = stats->rxData;
		card->wandev.stats.tx_packets = stats->txData;
		memcpy(&X25Stats, mbox->wan_data, mbox->wan_data_len);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_HDLC_LINK_CLOSE;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, X25_HDLC_LINK_CLOSE, 0) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_HDLC_LINK_OPEN;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_HDLC_LINK_OPEN, 0) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_HDLC_LINK_SETUP;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_HDLC_LINK_SETUP, 0) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_data[0] = mode;
		mbox->wan_data[1] = card->wandev.irq;
		mbox->wan_data[2] = 2;
		mbox->wan_data_len = 3;
		mbox->wan_command = X25_SET_INTERRUPT_MODE;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_SET_INTERRUPT_MODE, 0) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
	int lcn = chan->common.lcn;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_x25_lcn     = lcn;
		mbox->wan_command = X25_READ_CHANNEL_CONFIG;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_READ_CHANNEL_CONFIG, lcn) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_x25_lcn     = lcn;
		mbox->wan_x25_qdm     = qdm;
		mbox->wan_command = X25_ACCEPT_CALL;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_ACCEPT_CALL, lcn) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_x25_lcn     = lcn;
		mbox->wan_x25_cause   = cause;
		mbox->wan_x25_diagn   = diagn;
		mbox->wan_command = X25_CLEAR_CALL;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_CLEAR_CALL, lcn) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
	memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
	memcpy(mbox->wan_data, buf, len);
	mbox->wan_data_len  = (unsigned short)len;
	mbox->wan_x25_lcn     = (unsigned short)lcn;
	if (card->u.x.LAPB_hdlc){
		mbox->wan_x25_pf = (unsigned char)qdm;
		mbox->wan_x25_qdm = (unsigned char)qdm;
	mbox->wan_command = cmd;
	/* The P6-PCI caching used to be a bug on old 
	if (mbox->wan_opp_flag){
		printk(KERN_INFO "%s: Critical Error: P6-PCI Cache bug!\n",
				card->devname);
				card->devname);
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	if (card->u.x.LAPB_hdlc && err == 1){
	wan_mbox_t* mbox = &card->wan_mbox;
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_IS_DATA_AVAILABLE;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
 *		non-zero return code to handle X.25 asynchronous events and 
 *		common errors. Return non-zero to repeat command or zero to 
 *    	events.  To avoid re-entrancy problems we copy mailbox to dynamically
//	unsigned dlen = ((wan_mbox_t*)card->mbox)->wan_data_len;
	unsigned dlen = ((wan_mbox_t*)&card->wan_mbox)->wan_data_len;
			card->devname);
	memcpy(mb, &card->wan_mbox, sizeof(wan_mbox_t) + dlen);
		mb->wan_data[dlen] = '\0';
		switch (mb->wan_x25_pktType & 0x7F){
				card->devname, mb->wan_x25_lcn, mb->wan_x25_cause,
				mb->wan_x25_diagn);
				card->devname, mb->wan_x25_pktType,
				mb->wan_x25_lcn, mb->wan_x25_cause, mb->wan_x25_diagn);
		switch (mb->wan_x25_pktType & 0x7F){
				card->devname, mb->wan_x25_lcn, mb->wan_x25_cause,
				mb->wan_x25_diagn);
				card->devname, mb->wan_x25_lcn,
				mb->wan_x25_pktType & 0x7F, mb->wan_x25_cause, mb->wan_x25_diagn);
			"Packet:0x%02X Diagn:0x%02X\n", card->devname,
			mb->wan_x25_lcn, mb->wan_x25_pktType, mb->wan_x25_diagn);
		printk(KERN_INFO "%s: modem failure!\n", card->devname);
			card->devname);
			card->devname, mb->wan_data[0]);
			card->devname, cmd);
		dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head)); 
		if (card->u.x.LAPB_hdlc)
		if (mb->wan_command == 0x16)
			card->devname, cmd, err, mb->wan_x25_lcn)
	DEBUG_EVENT("%s: Unsupported incoming call!\n",card->devname);
	DEBUG_EVENT("%s: Unsupported call accepted!\n",card->devname);
	DEBUG_EVENT("%s: Unsupported call accepted!\n",card->devname);
		card->devname, mb->wan_x25_cause, mb->wan_x25_diagn);
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		old_state = chan->common.state;
		if (chan->common.usedby == API){
	if (card->sk){
		wanpipe_api_listen_rx(NULL,card->sk);
		sock_put(card->sk);
		card->sk=NULL;
	unsigned new_lcn = mb->wan_x25_lcn;
	if (mb->wan_x25_pktType == 0x05)	/* call request time out */
			card->devname, new_lcn);
		card->devname, mb->wan_x25_pktType, new_lcn);
		return -EIO;
	card->hw_iface.poke(card->hw, card->flags_off, &status, sizeof(status));
	x25_channel_t* chan = dev->priv;
	if (chan->common.svc){ 
		x25_clear_call(chan->card, chan->common.lcn, 0, 0);
		if (chan->common.usedby == API)
	x25_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	if (chan->common.state != state)
				if (card->u.x.logging){
						card->devname, dev->name);
				*(unsigned short*)dev->dev_addr = htons(chan->common.lcn);
				chan->i_timeout_sofar = jiffies;
				if (card->u.x.LAPB_hdlc){
					chan->common.svc=0;
					if (chan->common.usedby == API){
				if (card->u.x.logging){
						card->devname, dev->name);
				if (card->u.x.logging){
						card->devname, dev->name);
				atomic_set(&chan->common.disconnect,0);
				atomic_set(&chan->common.command,0);
				if (card->u.x.logging){
					card->devname, dev->name);
				atomic_set(&chan->common.disconnect,0);
		chan->common.state = state;
		if (chan->common.usedby == API){
	chan->state_tick = jiffies;
 * 	Return:		0	- transmission complete
 *			1	- busy
 *    	the packet into 'complete sequence' using M-bit.
	x25_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	card->hw_iface.peek(card->hw, card->u.x.hdlc_buf_status_off, &status, 1); 
	if (chan->common.usedby == API){
		qdm = api_data->qdm;
		orig_len = len = data_len - sizeof(x25api_hdr_t);
	err=x25_send(card, chan->common.lcn, (qdm&0x07), len, data);
			chan->i_timeout_sofar = jiffies;
			dev->trans_start=jiffies;
			++chan->ifstats.tx_packets;
			chan->ifstats.tx_bytes += len;
					card->devname,dev->name);
			++chan->ifstats.tx_errors;
				card->devname,err);			
		if (*str == '-') switch (str[1]) {
				for (i = 0; i < (MAX_X25_ADDR_SIZE-2); ++i){
					info->dest[i] = ch;
				for (i = 0; i < (MAX_X25_ADDR_SIZE-2); ++i){
					info->src[i] = ch;
				for (i = 0; i < (MAX_X25_DATA_SIZE-2); ++i){
					info->user[i] = ch; 
				info->nuser = i;
				for (i = 0; i < (MAX_X25_FACL_SIZE-2); ++i){
					info->facil[i] = ch;
				info->nfacil = i;
			sendpacket[57] = '-';
		/*If we get here its an IPX-data packet, so it'll get passed up the stack.
 *  	If incoming is 0 (outgoing)- if the net numbers is ours make it 0
 *  	if incoming is 1 - if the net number is 0 make it ours 
	return WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		len=skb->len;
		if (chan->common.usedby == API){
				++chan->rx_intr_stat.rx_intr_bfr_passed_to_stack;
				++chan->ifstats.rx_packets;
				chan->ifstats.rx_bytes += len;
				++chan->ifstats.rx_dropped;
				++chan->rx_intr_stat.rx_intr_bfr_not_passed_to_stack;
	WAN_TASKLET_END((&chan->common.bh_task));
	wan_mbox_t *mbox=&card->wan_mbox;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	chan = dev->priv;
	card->hw_iface.peek(card->hw, card->u.x.hdlc_buf_status_off, &status, 1); 
					card->devname, status);
	DEBUG_EVENT("TX INTR Cmd %x\n",atomic_read(&chan->common.command));
	if (atomic_read(&chan->common.command)){
		chan->x25_api_event.hdr.qdm = mbox->wan_x25_qdm;
		chan->x25_api_event.hdr.cause = mbox->wan_x25_cause;
		chan->x25_api_event.hdr.diagn = mbox->wan_x25_diagn;
		chan->x25_api_event.hdr.pktType = mbox->wan_x25_pktType&0x7F;
		chan->x25_api_event.hdr.length  = 0;
		chan->x25_api_event.hdr.result = 0;
		chan->x25_api_event.hdr.lcn = mbox->wan_x25_lcn;
		chan->x25_api_event.hdr.mtu = card->u.x.x25_conf.defPktSize;
		chan->x25_api_event.hdr.mru = card->u.x.x25_conf.defPktSize;
		atomic_set(&chan->cmd_rc,err);
				atomic_set(&chan->common.command,0);
			case -EAGAIN:
				chan->cmd_timeout=jiffies;
	wan_mbox_t* mbox = &card->wan_mbox;
	x25_channel_t *chan=dev->priv;
	if (atomic_read(&chan->common.command) == X25_PLACE_CALL){
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_HDLC_LINK_STATUS;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
		status = (TX25LinkStatus *)mbox->wan_data;
		if (status->txQueued){
					status->txQueued);
			return -EAGAIN; 
		card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
					status->txQueued,
					flags->ghdlc_status);
			chan->disc_delay = jiffies;
		DEBUG_EVENT("%s: Link Disconnecting ...\n",card->devname);
	int len = sizeof(x25api_hdr_t)+mbox->wan_data_len;
	x25_channel_t *chan=dev->priv;
	if (chan->common.usedby != API)
		return -ENODEV;
	if (!chan->common.sk){
		return -ENODEV;
				card->devname,__FUNCTION__);
		return -EINVAL;
		return -ENOMEM;
		return -ENOMEM;
	x25_api_hdr->qdm = mbox->wan_x25_qdm;
	x25_api_hdr->cause = mbox->wan_x25_cause;
	x25_api_hdr->diagn = mbox->wan_x25_diagn;
	x25_api_hdr->pktType = mbox->wan_x25_pktType&0x7F;
	x25_api_hdr->length  = len;
	x25_api_hdr->result = 0;
	x25_api_hdr->lcn = mbox->wan_x25_lcn;
	x25_api_hdr->mtu = card->u.x.x25_conf.defPktSize;
	x25_api_hdr->mru = card->u.x.x25_conf.defPktSize;
	if (mbox->wan_data_len > 0 && mbox->wan_data_len <= X25_CALL_STR_SZ){
		buf = skb_put(skb,mbox->wan_data_len);
			return -ENOMEM;
		memcpy(buf,mbox->wan_data,mbox->wan_data_len);
	memcpy(&chan->x25_api_event,skb->data,skb->len);
	skb->pkt_type = WAN_PACKET_ERR;
	skb->protocol=htons(ETH_P_X25);
	if (chan->common.sk){
		err=wanpipe_api_sock_rx(skb,chan->common.dev,chan->common.sk);
			if (err == -EINVAL){
								chan->common.dev->name);
				__sock_put(chan->common.sk);
				clear_bit(LCN_SK_ID,&chan->common.used);
				chan->common.sk = NULL;
		printk(KERN_INFO "%s: Error: No dev for OOB\n",chan->common.dev->name);
			card->devname);
			,card->devname);
	netdevice_t *dev = find_channel(card,mbox->wan_x25_lcn);
	chan=dev->priv;
	if (chan->common.usedby == API){
	wan_mbox_t* mbox = &card->wan_mbox;
		mbox->wan_command = X25_HDLC_LINK_DISC;
		mbox->wan_data_len = 1;
		mbox->wan_x25_pf = 1;
		mbox->wan_data[0]=0;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, X25_HDLC_LINK_DISC, 0) && retry--);
				card->devname,err);
	wan_mbox_t       *mbox = &card->wan_mbox;
	wan_udp_pkt_t *wan_udp_pkt = (wan_udp_pkt_t *)&card->u.x.udp_pkt_data;
		dev = card->u.x.udp_dev;
		atomic_set(&card->u.x.udp_pkt_len,0);
	chan = dev->priv;
	lcn = chan->common.lcn;
	switch(wan_udp_pkt->wan_udp_command) {
			if(card->u.x.udp_pkt_src == UDP_PKT_FRM_NETWORK) {
                    		++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_direction_err;
			++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_type_err;
		wan_udp_pkt->wan_udp_data_len = 0;
		wan_udp_pkt->wan_udp_return_code = 0xCD; 
		switch (wan_udp_pkt->wan_udp_command) {
			mbox->wan_data_len = 0;
			memcpy(wan_udp_pkt->wan_udp_data, &chan->if_send_stat, sizeof(if_send_stat_t));
			mbox->wan_data_len = sizeof(if_send_stat_t);
			wan_udp_pkt->wan_udp_data_len =  mbox->wan_data_len;	
			memcpy(&wan_udp_pkt->wan_udp_data[0], &card->statistics, sizeof(global_stats_t));
                        memcpy(&wan_udp_pkt->wan_udp_data[sizeof(global_stats_t)],
                                &chan->rx_intr_stat, sizeof(rx_intr_stat_t));
			mbox->wan_data_len = sizeof(global_stats_t) +
			wan_udp_pkt->wan_udp_data_len =  mbox->wan_data_len;
                        memcpy(wan_udp_pkt->wan_udp_data,
                                &chan->pipe_mgmt_stat.UDP_PIPE_mgmt_kmalloc_err,
                        memcpy(&wan_udp_pkt->wan_udp_data[sizeof(pipe_mgmt_stat_t)],
                               &card->statistics, sizeof(global_stats_t));
                        wan_udp_pkt->wan_udp_return_code = 0;
                        wan_udp_pkt->wan_udp_data_len = sizeof(global_stats_t)+
                        mbox->wan_data_len = wan_udp_pkt->wan_udp_data_len;
			chan->router_up_time = tv.tv_sec - chan->router_start_time;
    	                *(unsigned long *)&wan_udp_pkt->wan_udp_data = chan->router_up_time;	
			wan_udp_pkt->wan_udp_data_len = mbox->wan_data_len = 4;
			wan_udp_pkt->wan_udp_return_code = 0;
		   	wan_udp_pkt->wan_udp_data[0] = WANCONFIG_X25;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mbox->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_LINUX_PLATFORM;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mbox->wan_data_len  = wan_udp_pkt->wan_udp_data_len = 1;
			switch (wan_udp_pkt->wan_udp_command){
				wan_udp_pkt->wan_udp_command=X25_HDLC_READ_CONFIG;
				memcpy(&mbox->wan_command, &wan_udp_pkt->wan_udp_command, sizeof(TX25Cmd));
				if(mbox->wan_data_len){ 
					memcpy(&mbox->wan_data, 
					       (char *)wan_udp_pkt->wan_udp_data, 
					       mbox->wan_data_len);
				err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
			} while (err  && x25_error(card, err, mbox->wan_command, 0) && c_retry--);
			     (mbox->wan_command == 0x06 || 
			      mbox->wan_command == 0x16)  ) ){
				++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_cmnd_OK;
				++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_cmnd_timeout;
			memcpy(&wan_udp_pkt->wan_udp_command, &mbox->wan_command, sizeof(TX25Cmd));
      	         	if(mbox->wan_data_len) {
        	               memcpy(&wan_udp_pkt->wan_udp_data, &mbox->wan_data, mbox->wan_data_len);
	wan_udp_pkt->wan_ip_ttl = card->wandev.ttl;
	len = reply_udp((u8*)&card->u.x.udp_pkt_data, mbox->wan_data_len);
        if(card->u.x.udp_pkt_src == UDP_PKT_FRM_NETWORK) {
		err = x25_send(card, lcn, 0, len, (u8*)&card->u.x.udp_pkt_data);
			++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_send_passed;
			++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_send_failed;
			memcpy(buf, (u8*)&card->u.x.udp_pkt_data, len);
			new_skb->dev = dev;
			if (chan->common.usedby == API)
                        	new_skb->protocol = htons(X25_PROT);
				new_skb->protocol = htons(ETH_P_IP);
			++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_passed_to_stack;
			++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_no_socket;
			card->devname);
	atomic_set(&card->u.x.udp_pkt_len,0);
	wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	wan_udp_pkt->wan_udp_len = temp;
	temp = wan_udp_pkt->wan_udp_sport;
	wan_udp_pkt->wan_udp_sport = 
			wan_udp_pkt->wan_udp_dport; 
	wan_udp_pkt->wan_udp_dport = temp;
		(wan_udp_pkt->wan_udp_data+mbox_len+even_bound)) = temp;	
		(wan_udp_pkt->wan_udp_data+mbox_len+even_bound+2)) = temp;
	wan_udp_pkt->wan_udp_sum = 0;
	wan_udp_pkt->wan_udp_sum = 
	wan_udp_pkt->wan_ip_len = temp;
	ip_temp = wan_udp_pkt->wan_ip_src;
	wan_udp_pkt->wan_ip_src = 
				wan_udp_pkt->wan_ip_dst;
	wan_udp_pkt->wan_ip_dst = ip_temp;
	wan_udp_pkt->wan_ip_sum = 0;
	wan_udp_pkt->wan_ip_sum = 
	memset(&chan->if_send_stat.if_send_entry,0,sizeof(if_send_stat_t));
	memset(&chan->rx_intr_stat.rx_intr_no_socket,0,sizeof(rx_intr_stat_t));
	memset(&chan->pipe_mgmt_stat.UDP_PIPE_mgmt_kmalloc_err,0,sizeof(pipe_mgmt_stat_t));
	memset(&card->statistics.isr_entry,0,sizeof(global_stats_t));
	spin_lock_irqsave(&card->wandev.lock, *smp_flags);
	spin_unlock_irqrestore(&card->wandev.lock, *smp_flags);
	DEBUG_TEST("%s: X25 TIMER ROUTINE \n",card->devname);
	++card->statistics.poll_entry;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
				card->devname);
	if (test_bit(PERI_CRIT,&card->wandev.critical)){
				card->devname);
	if (!test_and_set_bit(POLL_CRIT,&card->wandev.critical)){
	if ((card->u.x.timer_int_enabled & ~TMR_INT_ENABLED_CMD_EXEC)){
		spin_lock_irqsave(&card->wandev.lock, smp_flags);
		spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
		if ((card->u.x.timer_int_enabled & ~TMR_INT_ENABLED_CMD_EXEC)){
			del_timer(&card->u.x.x25_timer);
			card->u.x.x25_timer.expires=jiffies+(HZ/50);
			add_timer(&card->u.x.x25_timer);
	del_timer(&card->u.x.x25_timer);
	card->u.x.x25_timer.expires=jiffies+(HZ>>1);
	add_timer(&card->u.x.x25_timer);
	wan_mbox_t* mbox = &card->wan_mbox;
	mbox->wan_data[0] = 0;
	mbox->wan_data[1] = card->wandev.irq;	//ALEX_TODAY card->hw.irq;
	mbox->wan_data[2] = 2;
	mbox->wan_data_len = 3;
	mbox->wan_command = X25_SET_INTERRUPT_MODE;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	mbox->wan_command = X25_HDLC_LINK_CLOSE;
	mbox->wan_data_len  = 0;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	mbox->wan_data[0] = 0;
	mbox->wan_data[2] = 0;
	mbox->wan_data[1] = 0x01;
	mbox->wan_data_len  = 3;
	mbox->wan_command = X25_SET_GLOBAL_VARS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	if (dev == NULL || dev->priv == NULL)
	chan=dev->priv;
	chan->chan_clear_time = tv.tv_sec;
	chan->chan_clear_cause = mb->wan_x25_cause;
	chan->chan_clear_diagn = mb->wan_x25_diagn;
	if (mb->wan_data_len){
		parse_call_info(mb->wan_data, &info);
		memcpy(chan->cleared_called_addr, info.src, MAX_X25_ADDR_SIZE);
		memcpy(chan->cleared_calling_addr, info.dest, MAX_X25_ADDR_SIZE);
		memcpy(chan->cleared_facil, info.facil, MAX_X25_FACL_SIZE);
#define PROC_CFG_FRM	"%-15s| %-12s| %-5u| %-9s| %-13s| %-13s|\n"
#define PROC_STAT_FRM	"%-15s| %-12s| %-5u| %-14s|\n"
	sdla_t*		card = chan->card;
			    PROC_CFG_FRM, chan->name, card->devname, chan->ch_idx,
			    chan->x25_src_addr, chan->accept_dest_addr, chan->accept_usr_data));
	sdla_t*		card = chan->card;
			    PROC_STAT_FRM, chan->name, card->devname, 
			    chan->ch_idx, STATE_DECODE(chan->common.state)));
#define PROC_DEV_FR_SS_FRM	"%-20s| %-12s|%-20s| %-12s|\n"
#define PROC_DEV_FR_SD_FRM	"%-20s| %-12s|%-20s| %-12d|\n"
#define PROC_DEV_FR_DD_FRM	"%-20s| %-12d|%-20s| %-12d|\n"
#define PROC_DEV_FR_XD_FRM	"%-20s| 0x%-10X|%-20s| %-12d|\n"
	if (wandev == NULL || wandev->priv == NULL)
	card = (sdla_t*)wandev->priv;
	x25_conf = &card->u.x.x25_conf;
		(buf, &cnt, len, offs, &stop_cnt, &size, "Configuration for %s device\n", wandev->name));
		 "Interface", INT_DECODE(wandev->interface),
		 "CALL_SETUP_LOG", CFG_DECODE(x25_conf->logging)));
		 "Clocking", CLK_DECODE(wandev->clocking),
		 "OOB_ON_MODEM", CFG_DECODE(x25_conf->oob_on_modem)));
		 "BaudRate",wandev->bps,
		 "T1", x25_conf->t1));
		 "MTU", wandev->mtu,
		 "T2", x25_conf->t2));
		 "TTL", wandev->ttl,
		 "T4", x25_conf->t4));
		 "UDP Port",  wandev->udp_port,
		 "N2", x25_conf->n2));
		 "Station", X25_STATION_DECODE(wandev->station),
		 "T10_T20", x25_conf->t10_t20));
		 "LowestPVC", x25_conf->lo_pvc,
		 "T11_T21", x25_conf->t11_t21));
		 "HighestPVC", x25_conf->hi_pvc,
		 "T12_T22", x25_conf->t12_t22));
		 "LowestSVC", x25_conf->lo_svc,
		 "T13_T23", x25_conf->t13_t23));
		 "HighestSVC", x25_conf->hi_svc,
		 "T16_T26", x25_conf->t16_t26));
		 "HdlcWindow", x25_conf->hdlc_window,
		 "T28", x25_conf->t28));
		 "PacketWindow", x25_conf->pkt_window,
		 "R10_R20", x25_conf->r10_r20));
		 "CCITTCompat", x25_conf->ccitt_compat,
		 "R12_R22", x25_conf->r12_r22));
		 "X25Config", x25_conf->x25_conf_opt,
		 "R13_R23", x25_conf->r13_r23));
	card = (sdla_t*)wandev->priv;
			wandev->name, buffer);
	if (dev == NULL || dev->priv == NULL)
		return -EFAULT;
	chan = (x25_channel_t*)dev->priv;
	if (card->wandev.update) {
		rslt = card->wandev.update(&card->wandev);
			return (rslt) ? (-EBUSY) : (-EINVAL);
	switch(snmp->snmp_magic){
		snmp->snmp_val = 
			(card->wandev.station == WANOPT_DTE) ? SNMP_X25_DTE:
			(card->wandev.station == WANOPT_DCE) ? SNMP_X25_DCE:SNMP_X25_DXE;
	        snmp->snmp_val = card->u.x.num_of_ch;
        	snmp->snmp_val = SNMP_X25_MODULO8;
		snmp->snmp_val = card->u.x.x25_adm_conf.t10_t20;
		snmp->snmp_val = card->u.x.x25_adm_conf.t11_t21;
		snmp->snmp_val = card->u.x.x25_adm_conf.t12_t22;
		snmp->snmp_val = card->u.x.x25_adm_conf.t13_t23;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = card->u.x.x25_adm_conf.t16_t26;
		snmp->snmp_val = 0;
		snmp->snmp_val = card->u.x.x25_adm_conf.t28;
		snmp->snmp_val = 0;
		snmp->snmp_val = card->u.x.x25_adm_conf.r10_r20;
		snmp->snmp_val = card->u.x.x25_adm_conf.r12_r22;
		snmp->snmp_val = card->u.x.x25_adm_conf.r13_r23;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = card->u.x.x25_adm_conf.hi_pvc;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = (card->wandev.station == WANOPT_DTE) ? SNMP_X25_DTE:
		 	   (card->wandev.station == WANOPT_DCE) ? SNMP_X25_DCE:SNMP_X25_DXE;
		snmp->snmp_val = card->u.x.num_of_ch;
		snmp->snmp_val = SNMP_X25_MODULO8;
		snmp->snmp_val = card->u.x.x25_conf.t10_t20;
		snmp->snmp_val = card->u.x.x25_conf.t11_t21;
		snmp->snmp_val = card->u.x.x25_conf.t12_t22;
		snmp->snmp_val = card->u.x.x25_conf.t13_t23;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = card->u.x.x25_conf.t16_t26;
		snmp->snmp_val = 0;
                snmp->snmp_val = card->u.x.x25_conf.t28;
                snmp->snmp_val = 0;
                snmp->snmp_val = card->u.x.x25_conf.r10_r20;
                snmp->snmp_val = card->u.x.x25_conf.r12_r22;
                snmp->snmp_val = card->u.x.x25_conf.r13_r23;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = card->u.x.x25_conf.hi_pvc;
                snmp->snmp_val = 0;
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
        	snmp->snmp_val = X25Stats.rxCallRequest;
                snmp->snmp_val = X25Stats.txClearRqst;
                snmp->snmp_val = (card->wandev.station == WANOPT_DTE) ? 
                snmp->snmp_val = (card->wandev.station == WANOPT_DTE) ? 
                snmp->snmp_val = (card->wandev.station == WANOPT_DTE) ? 
                snmp->snmp_val = X25Stats.rxRestartRqst;
                snmp->snmp_val = X25Stats.rxData;
                snmp->snmp_val = X25Stats.rxClearRqst+X25Stats.rxResetRqst+
                snmp->snmp_val = X25Stats.rxInterrupt;
                snmp->snmp_val = X25Stats.txCallRequest;
                snmp->snmp_val = X25Stats.rxClearRqst;
                snmp->snmp_val = X25Stats.txInterrupt;
                snmp->snmp_val = X25Stats.txData;
                snmp->snmp_val = X25Stats.txCallRequest-X25Stats.rxClearRqst;
                snmp->snmp_val = X25Stats.rxCallRequest-X25Stats.txClearRqst;
                snmp->snmp_val = X25Stats.txCallRequest-X25Stats.rxClearRqst;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
		snmp->snmp_val = card->u.x.x25_conf.lo_svc;
                snmp->snmp_val = card->u.x.x25_conf.hi_svc;
                snmp->snmp_val = card->u.x.x25_conf.lo_svc;
                snmp->snmp_val = card->u.x.x25_conf.hi_svc;
                snmp->snmp_val = card->u.x.x25_conf.lo_svc;
                snmp->snmp_val = card->u.x.x25_conf.hi_svc;
               	snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = chan->chan_establ_time;
                snmp->snmp_val = chan->chan_direct;
                snmp->snmp_val = chan->ifstats.rx_bytes;
                snmp->snmp_val = chan->ifstats.rx_packets;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = X25Stats.rxInterrupt;
                snmp->snmp_val = chan->ifstats.tx_bytes;
                snmp->snmp_val = chan->ifstats.tx_packets;
                snmp->snmp_val = X25Stats.txInterrupt;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                strcpy((void*)snmp->snmp_data,
		 	(chan->chan_direct == SNMP_X25_INCOMING) ? chan->accept_src_addr : "N/A");
                strcpy((void*)snmp->snmp_data,
		        (chan->chan_direct == SNMP_X25_INCOMING) ? chan->accept_dest_addr : "N/A");
                snmp->snmp_val = 0;
                strcpy((void*)snmp->snmp_data, "N/A");
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
        	snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = chan->chan_establ_time;
                snmp->snmp_val = chan->chan_clear_time;
                snmp->snmp_val = chan->ch_idx;
                snmp->snmp_val = chan->chan_clear_cause;
                snmp->snmp_val = chan->chan_clear_diagn;
                snmp->snmp_val = chan->ifstats.rx_packets;
                snmp->snmp_val = chan->ifstats.tx_packets;
                strcpy((void*)snmp->snmp_data, 
		 	(chan->cleared_called_addr[0] != '\0') ? 
		 			chan->cleared_called_addr : "N/A");
                strcpy((void*)snmp->snmp_data,
		 	(chan->cleared_calling_addr[0] != '\0') ? 
		 			chan->cleared_calling_addr : "N/A");
                strcpy((void*)snmp->snmp_data,
		 	(chan->cleared_facil[0] != '\0') ? chan->cleared_facil : "N/A");
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;	// default size
                snmp->snmp_val = 0;	// default size
                snmp->snmp_val = (card->u.x.x25_conf.pkt_window != X25_PACKET_WINDOW) ? 
				card->u.x.x25_conf.pkt_window : 0;
                snmp->snmp_val = (card->u.x.x25_conf.pkt_window != X25_PACKET_WINDOW) ? 
				card->u.x.x25_conf.pkt_window : 0;
                snmp->snmp_val = SNMP_X25_ARC_DEFAULT;
                snmp->snmp_val = SNMP_X25_PRC_DEFAULT;
                snmp->snmp_val = SNMP_X25_FS_DEFAULT;
                snmp->snmp_val = SNMP_X25_THRUCLASS_TCDEF;
                snmp->snmp_val = SNMP_X25_THRUCLASS_TCDEF;
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                snmp->snmp_val = SNMP_X25_CHARGINGINFO_DEF;
                strcpy((void*)snmp->snmp_data, "N/A");
                snmp->snmp_val = 0;
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                snmp->snmp_val = SNMP_X25_THRUCLASS_TCDEF;
                snmp->snmp_val = SNMP_X25_THRUCLASS_TCDEF;
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                snmp->snmp_val = SNMP_X25_EXPTDATA_DEFULT;
                strcpy((void*)snmp->snmp_data, chan->accept_usr_data);
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
            	return -EAFNOSUPPORT;
#define PROC_IF_X25_S_FRM	"%-40s %-14s\n"
#define PROC_IF_X25_D_FRM	"%-40s %-14d\n"
#define PROC_IF_X25_L_FRM	"%-40s %-14ld\n"
	x25_channel_t* 	chan = (x25_channel_t*)dev->priv;
	sdla_t*		card = chan->card;
	if (!offs && card->wandev.update) {
		rslt = card->wandev.update(&card->wandev);
			case -EAGAIN:
		 (card->wandev.station == WANOPT_DTE) ? SNMP_X25_DTE:
		 (card->wandev.station == WANOPT_DCE) ? SNMP_X25_DCE:SNMP_X25_DXE));
	         "x25AdmnMaxActiveCircuits", card->u.x.num_of_ch));
   		 "x25AdmnRestartTimer", card->u.x.x25_adm_conf.t10_t20));
		 "x25AdmnCallTimer", card->u.x.x25_adm_conf.t11_t21));
		 "x25AdmnResetTimer", card->u.x.x25_adm_conf.t12_t22));
		 "x25AdmnClearTimer", card->u.x.x25_adm_conf.t13_t23));
		 "x25AdmnInterruptTimer", card->u.x.x25_adm_conf.t16_t26));
		 "x25AdmnRegistrationRequestTimer", card->u.x.x25_adm_conf.t28));
		 "x25AdmnRestartCount", card->u.x.x25_adm_conf.r10_r20));
		 "x25AdmnResetCount", card->u.x.x25_adm_conf.r12_r22));
		 "x25AdmnClearCount", card->u.x.x25_adm_conf.r13_r23));
		 "x25AdmnNumberPVCs", card->u.x.x25_adm_conf.hi_pvc));
		 (card->wandev.station == WANOPT_DTE) ? SNMP_X25_DTE:
		 (card->wandev.station == WANOPT_DCE) ? SNMP_X25_DCE:SNMP_X25_DXE));
		 "x25OperMaxActiveCircuits", card->u.x.num_of_ch));
		 "x25OperRestartTimer", card->u.x.x25_conf.t10_t20));
		 "x25OperCallTimer", card->u.x.x25_conf.t11_t21));
		 "x25OperResetTimer", card->u.x.x25_conf.t12_t22));
		 "x25OperClearTimer", card->u.x.x25_conf.t13_t23));
		 "x25OperInterruptTimer", card->u.x.x25_conf.t16_t26));
                 "x25OperRegistrationRequestTimer", card->u.x.x25_conf.t28));
                 "x25OperRestartCount",	card->u.x.x25_conf.r10_r20));
                 "x25OperResetCount", card->u.x.x25_conf.r12_r22));
                 "x25OperClearCount", card->u.x.x25_conf.r13_r23));
                 "x25OperNumberPVCs", card->u.x.x25_conf.hi_pvc));
		(card->wandev.station == WANOPT_DTE) ? 
		(card->wandev.station == WANOPT_DTE) ? 
		(card->wandev.station == WANOPT_DTE) ? 
		 X25Stats.txCallRequest-X25Stats.rxClearRqst));
		X25Stats.rxCallRequest-X25Stats.txClearRqst));
		 X25Stats.txCallRequest-X25Stats.rxClearRqst));
		 "x25ChannelLIC", card->u.x.x25_conf.lo_svc));
                 "x25ChannelHIC", card->u.x.x25_conf.hi_svc));
                 "x25ChannelLTC", card->u.x.x25_conf.lo_svc));
                 "x25ChannelHTC", card->u.x.x25_conf.hi_svc));
                 "x25ChannelLOC", card->u.x.x25_conf.lo_svc));
                 "x25ChannelHOC", card->u.x.x25_conf.hi_svc));
                 "x25CircuitEstablishTime", chan->chan_establ_time));
                 "x25CircuitDirection", chan->chan_direct));
                 "x25CircuitInOctets", chan->ifstats.rx_bytes));
                 "x25CircuitInPdus", chan->ifstats.rx_packets));
                 "x25CircuitOutOctets", chan->ifstats.tx_bytes));
                 "x25CircuitOutPdus", chan->ifstats.tx_packets));
		 (chan->chan_direct == SNMP_X25_INCOMING) ? chan->accept_src_addr : "N/A"));
		 (chan->chan_direct == SNMP_X25_INCOMING) ? chan->accept_dest_addr : "N/A"));
                 "x25ClearedCircuitTimeEstablished", chan->chan_establ_time));
                 "x25ClearedCircuitTimeCleared", chan->chan_clear_time));
                 "x25ClearedCircuitChannel", chan->ch_idx));
                 "x25ClearedCircuitClearingCause", chan->chan_clear_cause));
                 "x25ClearedCircuitDiagnosticCode", chan->chan_clear_diagn));
                 "x25ClearedCircuitInPdus", chan->ifstats.rx_packets));
                 "x25ClearedCircuitOutPdus", chan->ifstats.tx_packets));
		 (chan->cleared_called_addr[0] != '\0') ? 
		 			chan->cleared_called_addr : "N/A"));
		 (chan->cleared_calling_addr[0] != '\0') ? 
		 			chan->cleared_calling_addr : "N/A"));
		 (chan->cleared_facil[0] != '\0') ? chan->cleared_facil : "N/A"));
		 (card->u.x.x25_conf.pkt_window != X25_PACKET_WINDOW) ? 
					card->u.x.x25_conf.pkt_window : 0));
		 (card->u.x.x25_conf.pkt_window != X25_PACKET_WINDOW) ? 
					card->u.x.x25_conf.pkt_window : 0));
                 "x25CallParmUserData", chan->accept_usr_data));
	if (dev == NULL || dev->priv == NULL)
	chan = (x25_channel_t*)dev->priv;
	if (chan->card == NULL)
	card = chan->card;
			chan->name, buffer);
	if (atomic_read(&chan->common.command)){
				card->devname,
				atomic_read(&chan->common.command));
		return -EBUSY;
	chan->cmd_timeout=jiffies;
	while((jiffies-chan->cmd_timeout) < HZ){
		if (!atomic_read(&chan->common.command)){
			return atomic_read(&chan->cmd_rc);	
			card->devname,atomic_read(&chan->common.command));
	atomic_set(&chan->common.command,0);
	return -EFAULT;
	while((jiffies-timeout) < delay){
./sdla_adccp.c
* Copyright:	(c) 1995-2002 Sangoma Technologies Inc.
* Nov 7,  2000  Nenad Corbic	Fixed the Multi-Port PPP for kernels
* Aug 2,  2000  Nenad Corbic	Block the Multi-Port PPP from running on
* Jul 13, 2000	Nenad Corbic	Added Multi-PPP support.
* Oct 20, 1997 	Jaspreet Singh	Modified sdla_isr routine so that card->in_isr
*				routines. Took out 'wandev->tx_int_enabled' and
*				replaced it with 'wandev->enable_tx_int'. 
*				added "wandev->tx_int_enabled=1" line in the
    #define wpf_init(a,b) (-EPROTONOSUPPORT) 
    #define wpc_init(a,b) (-EPROTONOSUPPORT) 
   #define wpx_init(a,b) (-EPROTONOSUPPORT) 
   #define wpp_init(a,b) (-EPROTONOSUPPORT) 
   #define wp_mprot_init(a,b) (-EPROTONOSUPPORT) 
   #define wp_lip_atm_init(a,b) (-EPROTONOSUPPORT) 
   #define wp_hdlc_fr_init(a,b) (-EPROTONOSUPPORT)	
    #define wpf_init(a,b) (-EPROTONOSUPPORT) 
    #define wpc_init(a,b) (-EPROTONOSUPPORT) 
   #define wpx_init(a,b) (-EPROTONOSUPPORT) 
   #define wpp_init(a,b) (-EPROTONOSUPPORT) 
   #define wp_mprot_init(a,b) (-EPROTONOSUPPORT) 
   #define wp_lip_atm_init(a,b) (-EPROTONOSUPPORT) 
   #define wp_hdlc_fr_init(a,b) (-EPROTONOSUPPORT)	
 #define wp_asyhdlc_init(a,b) (-EPROTONOSUPPORT)
 #define wp_sdlc_init(a,b) (-EPROTONOSUPPORT)
 #define wpedu_init(a,b) (-EPROTONOSUPPORT) 
 #define wpbsc_init(a,b) (-EPROTONOSUPPORT)
  #define wpss7_init(a,b) (-EPROTONOSUPPORT) 
 #define wp_bscstrm_init(a,b) (-EPROTONOSUPPORT)
 #define wpbit_init(a,b) (-EPROTONOSUPPORT)
 #define wp_adsl_init(card,conf) (-EPROTONOSUPPORT)
 #define wp_pos_init(card,conf) (-EPROTONOSUPPORT)
 #define wp_atm_init(card,conf) (-EPROTONOSUPPORT)
 #define wp_xilinx_init(card,conf) (-EPROTONOSUPPORT)
 #define wp_aft_bri_init(card,conf) (-EPROTONOSUPPORT)
 #define wp_aft_serial_init(card,conf) (-EPROTONOSUPPORT)
 #define wp_aft_te1_init(card,conf) (-EPROTONOSUPPORT)
 #define wp_aft_analog_init(card,conf) (-EPROTONOSUPPORT)
 #define wp_aft_a600_init(card, conf) (-EPROTONOSUPPORT)
 #define wp_aft_56k_init(card,conf) (-EPROTONOSUPPORT)
 #define wp_aft_te3_init(card,conf) (-EPROTONOSUPPORT)
  #define wp_adccp_init(card,conf) (-EPROTONOSUPPORT)
  #define wp_usb_init(card,conf) (-EPROTONOSUPPORT)
	unsigned int * sp = (unsigned int *)(((char *)v) - (sizeof(unsigned int) + KMEM_SAFETYZONE*8));
	char * c1 = ((char *)v) - KMEM_SAFETYZONE*8;
	v = ((char *)v) - (sizeof(unsigned int) + KMEM_SAFETYZONE*8);
	  card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &adapter_type);	\
	      	DEBUG_EVENT("%s: Error: Protocol not supported on S514-4 T1/E1 Adapter\n", \
			    	card->devname); 				\
		err = -EPFNOSUPPORT; 						\
	        DEBUG_EVENT("%s: Error: Protocol not supported on S514-5 56K Adapter\n", \
			    	card->devname); 				\
		err = -EPFNOSUPPORT; 						\
static char fullname[]	= "WANPIPE(tm) Multi-Protocol WAN Driver Module";
MODULE_DESCRIPTION ("Sangoma WANPIPE: WAN Multi-Protocol Driver");
		DEBUG_EVENT("wanpipe: Allocating maximum %i devices: wanpipe%i - wanpipe%i.\n",
		return -ENODEV;
				tmp=tmpcard->list;
			return -ENOMEM;
		tmpcard->list=card_list;
	for (card = card_list; card; card = card->list) {
		wan_device_t* wandev = &card->wandev;
		card->next = NULL;
		sprintf(card->devname, "%s%d", drvname, ++cnt);
		wandev->magic    = ROUTER_MAGIC;
		wandev->name     = card->devname;
		wandev->priv  = card;
		wandev->enable_tx_int = 0;
		wandev->setup    = &setup;
		wandev->shutdown = &shutdown;
		wandev->ioctl    = &ioctl;
		wandev->debugging      = &debugging;
						drvname, card->devname, err);
			unregister_wan_device(tmpcard->devname);
			tmp=tmpcard->list;
		err = -ENODEV;
		unregister_wan_device(tmpcard->devname);
		tmp=tmpcard->list;
 * o call appropriate routine to perform protocol-specific initialization
	if ((wandev == NULL) || (wandev->priv == NULL) || (conf == NULL)){
		      wandev->name,
		      wandev,wandev->priv,
		return -EFAULT;
	DEBUG_EVENT("%s: Starting WAN Setup\n", wandev->name);
	card = wandev->priv;
	if (wandev->state != WAN_UNCONFIGURED){
			wandev->name);
		return -EBUSY;		/* already configured */
	card->wandev.piggyback = 0;
	DEBUG_EVENT("Processing WAN device %s...\n", wandev->name);
	wandev->del_if_cnt = 0;
	wandev->new_if_cnt = 0;
	wandev->config_id  = conf->config_id;
	switch(conf->config_id){
		conf->card_type = WANOPT_AFT;
		conf->card_type = WANOPT_AFT104;
		conf->S514_CPU_no[0] = 'A';
		conf->card_type = WANOPT_AFT_ANALOG;
		conf->S514_CPU_no[0] = 'A';
		conf->card_type = WANOPT_AFT300;
		conf->S514_CPU_no[0] = 'A';
		conf->card_type = WANOPT_AFT_ISDN;
		conf->S514_CPU_no[0] = 'A';
		conf->card_type = WANOPT_AFT_56K;
		conf->S514_CPU_no[0] = 'A';
		conf->card_type = WANOPT_AFT_SERIAL;
		conf->S514_CPU_no[0] = 'A';
		conf->card_type = WANOPT_USB_ANALOG;
	wandev->card_type  = conf->card_type;
	card->hw = sdla_register(&card->hw_iface, conf, card->devname);
	if (card->hw == NULL){
		return -EINVAL;
         * support A102 config file for A102-SH */	 
	wandev->card_type  = conf->card_type;
	wandev->config_id  = conf->config_id;
	switch (conf->card_type){
			if (!conf->data_size || (conf->data == NULL)) {
							wandev->name);
				sdla_unregister(&card->hw, card->devname);
				return -EINVAL;
				sdla_unregister(&card->hw, card->devname);
			if ((!conf->data_size || (conf->data == NULL)) && 
			    (conf->config_id != WANCONFIG_DEBUG)){
							wandev->name);
				sdla_unregister(&card->hw, card->devname);
				return -EINVAL;
				sdla_unregister(&card->hw, card->devname);
				sdla_unregister(&card->hw, card->devname);
				sdla_unregister(&card->hw, card->devname);
					card->devname,conf->card_type);
			sdla_unregister(&card->hw, card->devname);
			return -EINVAL;
	card->hw_iface.getcfg(card->hw, SDLA_CARDTYPE, &card->type);
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &card->adptr_type);
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERSUBTYPE, &card->adptr_subtype);
	card->isr=NULL;
	if (!card->wandev.piggyback && !card->configured){
		err = card->hw_iface.setup(card->hw, conf);
					card->devname,err);
			card->hw_iface.hw_down(card->hw);
			sdla_unregister(&card->hw, card->devname);
	     	if (conf->config_id == WANCONFIG_DEBUG){
						card->devname);
				card->hw_iface.hw_down(card->hw);
				sdla_unregister(&card->hw, card->devname);
				return -EINVAL;
			wanpipe_debug->u.debug.total_len = 0;
			wanpipe_debug->u.debug.total_num = 0;
			wanpipe_debug->u.debug.current_offset = 
			wanpipe_debug->configured = 1;
			wanpipe_debug->wandev.state = WAN_CONNECTED;
			wanpipe_debug->wandev.debug_read = wan_debug_read;
			//wanpipe_debug->adapter_type = card->hw.pci_adapter_type;
			spin_lock_init(&wanpipe_debug->wandev.lock);
		if(conf->card_type == WANOPT_S50X){
			irq = (conf->irq == 2) ? 9 : conf->irq; /* IRQ2 -> IRQ9 */
			irq = conf->irq;
               	spin_lock_init(&card->wandev.lock);
		/* request an interrupt vector - note that interrupts may be shared */
		if (card->wandev.config_id != WANCONFIG_BSC && 
		    card->wandev.config_id != WANCONFIG_USB_ANALOG && 
		    card->wandev.config_id != WANCONFIG_POS){ 
			      (card->type == SDLA_S508) ? 0: IRQF_SHARED, 
			       wandev->name, card)){
						wandev->name, irq);
				card->hw_iface.hw_down(card->hw);
				sdla_unregister(&card->hw, card->devname);
				return -EINVAL;
			wandev->name,card->configured,card->wandev.piggyback);
               	spin_lock_init(&card->wandev.lock);
	if (!card->configured){
		wandev->irq       = irq;
		wandev->dma       = 0;
		if(conf->card_type == WANOPT_S50X){ 
			card->hw_iface.getcfg(card->hw, SDLA_IOPORT, &wandev->ioport);
			card->hw_iface.getcfg(card->hw, SDLA_CPU, &wandev->S514_cpu_no[0]);
			card->hw_iface.getcfg(card->hw, SDLA_SLOT, &wandev->S514_slot_no);
		wandev->maddr     = (unsigned long)card->hw.dpmbase;
		wandev->msize     = card->hw.dpmsize;
		wandev->hw_opt[0] = card->hw.type;
		wandev->hw_opt[1] = card->hw.pclk;
		wandev->hw_opt[2] = card->hw.memory;
		wandev->hw_opt[3] = card->hw.fwid;
	//card->adapter_type = card->hw.pci_adapter_type;
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &card->adptr_type);
	/* Protocol-specific initialization */
	switch (conf->config_id) {
				card->devname);
		INVALID_ADAPTER_CHECK(card,conf->fe_cfg);
				card->devname);
				card->devname);
				card->devname);
				card->devname);
		if (conf->ft1){		
				card->devname);
					card->devname);
					card->devname);
		DEBUG_EVENT("%s: Starting Multi-Port Frame Relay Protocol Init.\n",
					card->devname);
	/* Extra, non-standard WANPIPE Protocols */
					card->devname);
								card->devname);
								card->devname);
		INVALID_ADAPTER_CHECK(card,conf->fe_cfg);	
								card->devname);
				card->devname);
		INVALID_ADAPTER_CHECK(card,conf->fe_cfg);	
					card->devname);
					card->devname);
					card->devname);
					card->devname);
					card->devname);
					card->devname);
					card->devname);
		if (card->adptr_type == AFT_ADPTR_A600) {
						card->devname);
						card->devname);
					card->devname);
					card->devname);
					card->devname);
					card->devname);
					card->devname);		
			wandev->name, conf->config_id);
		err = -EPROTONOSUPPORT;
		if (err == -EPROTONOSUPPORT){
					card->devname);
			DEBUG_EVENT("%s:      Re-configure the kernel and re-build the modules!\n",
					card->devname);
		if (card->disable_comm){
			card->disable_comm(card);
		wandev->state = WAN_UNCONFIGURED;
		card->configured=0;
		sdla_unregister(&card->hw, card->devname);
		if (card->next){
			card->next->next=NULL;
			card->next=NULL;
			card->devname);
		if (card->disable_comm){
			card->disable_comm(card);
		wandev->state = WAN_UNCONFIGURED;
		card->configured=0;
		sdla_unregister(&card->hw, card->devname);
		if (card->next){
			card->next->next=NULL;
			card->next=NULL;
        if(conf->card_type == WANOPT_S50X && !card->wandev.piggyback){
		card->hw_iface.getcfg(card->hw, SDLA_IORANGE, &io_range);
		if (!request_region(wandev->ioport, io_range, wandev->name)){
					card->devname);
			if (card->disable_comm){
				card->disable_comm(card);
			wandev->state = WAN_UNCONFIGURED;
			card->configured=0;
			sdla_unregister(&card->hw, card->devname);
			if (card->next){
				card->next->next=NULL;
				card->next=NULL;
			return -EBUSY;
		request_region(wandev->ioport, io_range, wandev->name);
	card->wandev.critical=0;
	if (conf->ioport <= 0) {
					card->wandev.name);
		return -EINVAL;
	if (conf->irq <= 0) {
					card->wandev.name);
		return -EINVAL;
	if (test_bit(0,&card->configured))
	for (nxt_card=card_list;nxt_card;nxt_card=nxt_card->list) {
		if (nxt_card->hw == card->hw){
			if ((nxt_card->next == NULL) &&
			    ((conf->config_id == WANCONFIG_CHDLC && 
			      nxt_card->wandev.config_id == WANCONFIG_CHDLC) ||
		             (conf->config_id == WANCONFIG_MPPP && 
			      nxt_card->wandev.config_id == WANCONFIG_MPPP)  ||
			     (conf->config_id == WANCONFIG_ASYHDLC && 
			      nxt_card->wandev.config_id == WANCONFIG_ASYHDLC)  ||
			     (conf->config_id == WANCONFIG_BSCSTRM && 
			      nxt_card->wandev.config_id == WANCONFIG_BSCSTRM))){
				*irq = nxt_card->wandev.irq;	//ALEX_TODAY nxt_card->hw.irq;
				wan_spin_lock_irq(&nxt_card->wandev.lock, &smp_flags);
				nxt_card->next = card;
				card->next = nxt_card;
				card->wandev.piggyback = WANOPT_YES;
				 * since isr will try to lock card->next if it
				spin_lock_init(&card->wandev.lock);
				wan_spin_unlock_irq(&nxt_card->wandev.lock, &smp_flags);
						 "%s:        multi-port operation!\n",
						 card->devname, nxt_card->wandev.ioport,
						 card->devname,card->devname);
						card->devname,nxt_card->wandev.config_id,
						conf->config_id);
				return -EEXIST;
	if (check_region(conf->ioport, SDLA_MAXIORANGE) && 
	    !card->wandev.piggyback) {
		DEBUG_EVENT("%s: I/O region 0x%X - 0x%X is in use!\n",
			card->wandev.name, conf->ioport,
			conf->ioport + SDLA_MAXIORANGE);
		return -EINVAL;
	if (test_bit(0,&card->configured))
	for (nxt_card=card_list;nxt_card;nxt_card=nxt_card->list) {
		if (nxt_card->wandev.state == WAN_UNCONFIGURED)
		 * the card->hw.PCI_slot_no is updated with the
		if (nxt_card->hw == card->hw){
			if ((nxt_card->next == NULL) &&
			    ((conf->config_id == WANCONFIG_CHDLC && 
			      nxt_card->wandev.config_id == WANCONFIG_CHDLC) ||
		             (conf->config_id == WANCONFIG_MPPP && 
			      nxt_card->wandev.config_id == WANCONFIG_MPPP)  ||
			     (conf->config_id == WANCONFIG_ASYHDLC && 
			      nxt_card->wandev.config_id == WANCONFIG_ASYHDLC)  ||
			     (conf->config_id == WANCONFIG_BSCSTRM && 
			      nxt_card->wandev.config_id == WANCONFIG_BSCSTRM))){
				*irq = nxt_card->wandev.irq;	//ALEX_TODAY nxt_card->hw.irq;
				wan_spin_lock_irq(&nxt_card->wandev.lock,&smp_flags);
				nxt_card->next = card;
				card->next = nxt_card;
				card->wandev.piggyback = WANOPT_YES;
				 * since isr will try to lock card->next if it
				spin_lock_init(&card->wandev.lock);
				wan_spin_unlock_irq(&nxt_card->wandev.lock,&smp_flags);
						 "%s:        multi-port operation!\n",
						 card->devname,
						 conf->S514_CPU_no[0],conf->PCI_slot_no,
						 card->devname,card->devname);
						card->devname,nxt_card->wandev.config_id,
						conf->config_id);
				return -EEXIST;
	if (test_bit(0,&card->configured))
	for (nxt_card=card_list;nxt_card;nxt_card=nxt_card->list) {
		if (nxt_card->wandev.state == WAN_UNCONFIGURED)
		 * the card->hw.PCI_slot_no is updated with the
		if (nxt_card->hw == card->hw){
					 "%s:        multi-port operation!\n",
					 card->devname,
					 conf->S514_CPU_no[0],conf->PCI_slot_no,
					 card->devname,card->devname);
			return -EEXIST;
	if (test_bit(0,&card->configured))
	for (nxt_card=card_list;nxt_card;nxt_card=nxt_card->list) {
		if (nxt_card->wandev.state == WAN_UNCONFIGURED)
		 * the card->hw.PCI_slot_no is updated with the
		if (nxt_card->hw == card->hw){
                	card->hw_iface.getcfg(card->hw, SDLA_CPU, &CPU_no);
			if (CPU_no == conf->S514_CPU_no[0]){
					 "%s:        multi-port operation!\n",
					 card->devname,
					 conf->S514_CPU_no[0],conf->PCI_slot_no,
					 card->devname,card->devname);
				return -EEXIST;
	if ((wandev == NULL) || (wandev->priv == NULL)){
		return -EFAULT;
	if (wandev->state == WAN_UNCONFIGURED){
	card = wandev->priv;
	if (card->tty_opt){
		if (card->tty_open){
				  card->devname);
			return -EBUSY;
	wandev->state = WAN_UNCONFIGURED;
	if (wandev->config_id == WANCONFIG_DEBUG){
	if (wandev->config_id == WANCONFIG_ADSL && conf != NULL){
		conf->config_id = wandev->config_id;
	set_bit(PERI_CRIT,(void*)&wandev->critical);
	if (card->disable_comm){
		card->disable_comm(card);
	wandev->state = WAN_UNCONFIGURED;
	wandev->state = WAN_UNCONFIGURED;
	if (card->type != SDLA_S514 && 
	    card->type != SDLA_ADSL && 
	    card->type != SDLA_AFT &&	
	    wandev->config_id != WANCONFIG_DEBUG &&	
	    card->type != SDLA_USB &&
	    !card->configured){
		card->hw_iface.getcfg(card->hw, SDLA_IORANGE, &io_range);
              	release_region(wandev->ioport, io_range);
	if (!card->configured){
		sdla_unregister(&card->hw, card->devname);
	      	if (card->next){
			sdla_unregister(&card->next->hw, card->next->devname);
			card->next->next=NULL;
			card->next=NULL;
	clear_bit(PERI_CRIT,(void*)&wandev->critical);
	if (card->next){
		nxt_card = card->next;
		if (nxt_card->wandev.state == WAN_UNCONFIGURED){
			if (card->wandev.piggyback){
				DEBUG_EVENT("%s: Piggyback shutting down\n",card->devname);
				if (card->hw_iface.hw_down){
					card->hw_iface.hw_down(card->next->hw);
				if (card->wandev.config_id != WANCONFIG_BSC && 
				    card->wandev.config_id != WANCONFIG_USB_ANALOG && 
				    card->wandev.config_id != WANCONFIG_POS){ 
       					free_irq(card->wandev.irq, card->next);
				card->configured = 0;
				card->next->configured = 0;
				card->wandev.piggyback = 0;
				DEBUG_EVENT("%s: Master shutting down\n",card->devname);
				if (card->hw_iface.hw_down){
					card->hw_iface.hw_down(card->hw);
				if (card->wandev.config_id != WANCONFIG_BSC && 
				    card->wandev.config_id != WANCONFIG_USB_ANALOG && 
				    card->wandev.config_id != WANCONFIG_POS){ 
					free_irq(card->wandev.irq, card);
				card->configured = 0;
				card->next->configured = 0;
				nxt_card->devname,nxt_card->wandev.state);
			card->configured = 1;
		DEBUG_EVENT("%s: Master shutting down\n",card->devname);
		if (card->hw_iface.hw_down){
			card->hw_iface.hw_down(card->hw);
		if (card->wandev.config_id != WANCONFIG_BSC && 
		    card->wandev.config_id != WANCONFIG_USB_ANALOG && 
		    card->wandev.config_id != WANCONFIG_POS &&
		    card->wandev.config_id != WANCONFIG_DEBUG){
       			free_irq(card->wandev.irq, card);
		card->configured = 0;
	if ((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	//ALEX-HWABSTR
//	if (wandev->state == WAN_UNCONFIGURED)
//		return -ENODEV;
	card = wandev->priv;
	if (test_bit(SEND_CRIT, (void*)&wandev->critical)) {
		return -EAGAIN;
		err = ioctl_dump(wandev->priv, (void*)arg);
		err = ioctl_exec(wandev->priv, (void*)arg, cmd);
		err = -EINVAL;
 * Note: when dumping memory, this routine switches curent dual-port memory
		return -EFAULT;
	card->hw_iface.getcfg(card->hw, SDLA_MEMORY, &memory);
		return -EINVAL;
		return -ENOMEM;
	card->hw_iface.peek(card->hw, dump.offset, data, dump.length);
		err = -EFAULT;
 * o call protocol-specific 'exec' function
	if (card->exec == NULL && cmd == WANPIPE_EXEC){
		return -ENODEV;
		return -EFAULT;
		return -EINVAL;
			err = card->exec(card, exec.cmd, exec.data);
 * o call protocol-specific interrupt service routine, if any.
	if (card && card->type == SDLA_AFT){
		spin_lock(&card->wandev.lock);
		if (card->isr){
			WAN_IRQ_CALL(card->isr, (card), val);
		spin_unlock(&card->wandev.lock);
	if (card && card->type == SDLA_ADSL){
		spin_lock_irqsave(&card->wandev.lock,flags);
		if (card->isr){
			WAN_IRQ_CALL(card->isr, (card), val);
		spin_unlock_irqrestore(&card->wandev.lock,flags);
	if(card->type == SDLA_S514) {	/* handle interrrupt on S514 */
                card->hw_iface.getcfg(card->hw, SDLA_CPU, &CPU_no);
		if (card->hw_iface.read_int_stat){
			card->hw_iface.read_int_stat(card->hw, &int_status);
		   (card->wandev.state == WAN_UNCONFIGURED && !card->configured)){
				if (card->hw_iface.intack){
					card->hw_iface.intack(card->hw, int_status);
		if (card->in_isr) {
			DEBUG_EVENT("%s: interrupt re-entrancy on IRQ %d\n",
				card->devname, card->wandev.irq);
			if (card->hw_iface.intack){
				card->hw_iface.intack(card->hw, int_status);
		spin_lock(&card->wandev.lock);
		if (card->next){
			spin_lock(&card->next->wandev.lock);
		if (card->hw_iface.intack){
			card->hw_iface.intack(card->hw, int_status);
		if (card->isr){
			card->isr(card);
			clear_bit(0,&card->spurious);
		if (card->next && card->next->isr){
			card->next->isr(card->next);
			clear_bit(0,&card->next->spurious);
		if (card->next){
			spin_unlock(&card->next->wandev.lock);
		spin_unlock(&card->wandev.lock);
		if (!card || ((card->wandev.state == WAN_UNCONFIGURED) && !card->configured))
		if (card->in_isr) {
			DEBUG_EVENT("%s: interrupt re-entrancy on IRQ %d!\n",
				card->devname, card->wandev.irq);
		spin_lock(&card->wandev.lock);
		if (card->next){
			spin_lock(&card->next->wandev.lock);
		if (card->hw_iface.intack){
			card->hw_iface.intack(card->hw, 0x00);
		if (card->isr)
			card->isr(card);
		if (card->next){
			spin_unlock(&card->next->wandev.lock);
		spin_unlock(&card->wandev.lock);
 * This routine is called by the protocol-specific modules when network
	++card->open_cnt;
 * This routine is called by the protocol-specific modules when network
	--card->open_cnt;
	for (card=card_list;card;card=card->list){
		--num;
	strcpy(if_info.ifr_name, dev->name);
	if ((ifaddr = in_dev->ifa_list)== NULL ){
		ip = ifaddr->ifa_local;
		ip = ifaddr->ifa_address;
		ip = ifaddr->ifa_mask;
		ip = ifaddr->ifa_broadcast;
		&(route.rt_dst))->sin_addr.s_addr = 0;
		&(route.rt_dst))->sin_family = AF_INET;
		&(route.rt_genmask))->sin_addr.s_addr = 0;
		&(route.rt_genmask)) ->sin_family = AF_INET;
	route.rt_dev = dev->name;
			card->devname,dev->name);
	sdla_t*			card = (sdla_t*)wandev->priv;
	if (wandev->state == WAN_UNCONFIGURED){
	for (card=card_list;card;card=card->list) {
		if (!strcmp(card->devname,name) &&
		    card->wandev.state != WAN_UNCONFIGURED){
	for (card=card_list;card;card=card->list) {
		if (card->sk == sk_id)
	int err=-EOPNOTSUPP;
	WAN_ASSERT2((!devname),-EINVAL);
		return -ENODEV;
	if (card->bind_api_to_svc){
		err=card->bind_api_to_svc(card,sk_id);
	WAN_ASSERT2((!devname),-EINVAL);
		return -ENODEV;
	if (card->sk == NULL){
		spin_lock_irqsave(&card->wandev.lock,flags);
		card->sk=sk_id;
		spin_unlock_irqrestore(&card->wandev.lock,flags);
			devname,card->sk);
	return -EBUSY;
		return -ENODEV;
	if (card->sk == sk_id){
		spin_lock_irqsave(&card->wandev.lock,flags);
		sock_put(card->sk);
		card->sk=NULL;
		spin_unlock_irqrestore(&card->wandev.lock,flags);
			card->devname);
	return -ENODEV;
	DEBUG_EVENT("-----------------TRACE START------------------------\n");
        	DEBUG_EVENT("%s: ---> \n",DEBUG_ARRAY[i].name);
        DEBUG_EVENT("-----------------TRACE END------------------------\n");
./sdlamain.c
# define	UNIT(file) MINOR(file->f_dentry->d_inode->i_rdev)
# define WP_CDEV_SET_MINOR(span,chan) ((((span-1)&WP_CDEV_SPAN_MASK)<<WP_CDEV_SPAN_SHIFT)|(chan&WP_CDEV_CHAN_MASK))
# define CPRIV(dev)  ((wanpipe_cdev_priv_t*)(dev->priv))
		return -EINVAL;
		return -EINVAL;
		DEBUG_EVENT("%s: Error: Wanpipe CDEV Busy - failed to free!\n",__FUNCTION__);
		DEBUG_EVENT("%s(): Error cdev->dev_ptr not initialized!\n",__FUNCTION__);
		return -1;
	if (waitqueue_active(&CPRIV(cdev)->poll_wait)){
		wake_up_interruptible(&CPRIV(cdev)->poll_wait);
	int minor=-1;
		return -1;
	if (!cdev->dev_ptr) {
		DEBUG_EVENT("%s(): Error cdev->dev_ptr not initialized!\n",__FUNCTION__);
		return -1;
	if (cdev->span < 0 || cdev->span > WP_CDEV_MAX_SPANS) {
		DEBUG_EVENT("%s(): Error span out of range %i!\n",__FUNCTION__,cdev->span);
		return -1;
	if (cdev->chan < 0 || cdev->chan > WP_CDEV_MAX_CHANS) {
		DEBUG_EVENT("%s(): Error chan out of range %i!\n",__FUNCTION__,cdev->chan);
		return -1;
	minor=WP_CDEV_SET_MINOR(cdev->span,cdev->chan);
	cdev->name[WAN_IFNAME_SZ]=0;
	if (strlen(cdev->name) == 0) {
		return -1;
	int minor=-1;
		return -1;
	if (!cdev->dev_ptr) {
		DEBUG_EVENT("%s(): Error cdev->dev_ptr not initialized!\n",__FUNCTION__);
		return -1;
	cdev->name[WAN_IFNAME_SZ]=0;
	sprintf(cdev->name, "wptdm_ctrl");
	int minor=-1;
		return -1;
	if (!cdev->dev_ptr) {
		DEBUG_EVENT("%s(): Error cdev->dev_ptr not initialized!\n",__FUNCTION__);
		return -1;
	cdev->name[WAN_IFNAME_SZ]=0;
	sprintf(cdev->name, "wanpipe");
	int minor=-1;
		return -1;
	if (!cdev->dev_ptr) {
		DEBUG_EVENT("%s(): Error cdev->dev_ptr not initialized!\n",__FUNCTION__);
		return -1;
		return -1;
	cdev->name[WAN_IFNAME_SZ]=0;
	sprintf(cdev->name, "wanpipe");
		return -ENODEV;
	minor=CPRIV(cdev)->dev_minor;
		return -ENODEV;
		return -EINVAL;
	if (!wan_test_bit(0,&cdev->init)) {
		return -ENODEV;
		return -ENOMEM;
	cdev->priv=cdev_priv;
	wan_set_bit(0,&cdev->init);
	cdev_priv->dev_minor = minor;
	wan_spin_lock_init(&cdev_priv->lock, lname);
	init_waitqueue_head(&cdev_priv->poll_wait);
			    MKDEV(WP_CDEV_MAJOR, minor), NULL, NULL,cdev->name);
	wanpipe_cdev_priv_t *cdev_priv = (wanpipe_cdev_priv_t *)cdev->priv;
	wan_clear_bit(0,&cdev->init);
	wandev.dev_cnt--;
		*counter = *counter - 1;
	cdev->priv=NULL;
		return -1;
		return -ENODEV;
	if (!wan_test_bit(0,&cdev->init)) {
		return -ENODEV;
	if (wan_test_bit(0,&cdev->used)) {
		return -EBUSY;
	file->private_data = cdev;
	wan_spin_lock(&CPRIV(cdev)->lock);
	if (cdev->ops.open) {
		err=cdev->ops.open(cdev->dev_ptr);
		err=-EINVAL;
	wan_spin_unlock(&CPRIV(cdev)->lock);
		__FUNCTION__, cdev->span, cdev->chan, CPRIV(cdev)->dev_minor);
	wanpipe_cdev_t *cdev = file->private_data;
		return -ENODEV;
	minor=CPRIV(cdev)->dev_minor;
		return -ENODEV;
		return -ENODEV;
	wan_spin_lock(&CPRIV(cdev)->lock);
	if (cdev->ops.close) {
		err=cdev->ops.close(cdev->dev_ptr);
	wan_spin_unlock(&CPRIV(cdev)->lock);
		__FUNCTION__, cdev->span, cdev->chan, CPRIV(cdev)->dev_minor);
	int err=-EINVAL;
	cdev = file->private_data;
		return -ENODEV;
		return -EFAULT;
		return -EFAULT;
	if (cdev->ops.read) {
		err=cdev->ops.read(cdev->dev_ptr, &skb, count);
		return -ENOBUFS;
		err = wan_memcpy_toiovec(msg->msg_iov,
	int err=-EINVAL;
	cdev = file->private_data;
		return -ENODEV;
		return -EFAULT;
		return -EFAULT;
		return -ENOMEM;
	err = memcpy_fromiovec(buf, msg->msg_iov, count);
		return -ENOMEM;
	if (cdev->ops.write) {
		err=cdev->ops.write(cdev->dev_ptr, skb);
				err = -EBUSY;
	int err=-EINVAL;
	cdev = file->private_data;
		return -ENODEV;
	if (cdev->ops.ioctl) {
		err=cdev->ops.ioctl(cdev->dev_ptr,cmd, (void*)data);
	cdev = file->private_data;
		return -ENODEV;
	poll_wait(file, &CPRIV(cdev)->poll_wait, wait_table);
	if (cdev->ops.poll) {
		status=cdev->ops.poll(cdev->dev_ptr);
./wanpipe_cdev_linux.c
* Copyright:	(c) 2003-2006 Sangoma Technologies Inc.
#define	UNIT(file) MINOR(file->f_dentry->d_inode->i_rdev)
		return -EINVAL;
		wp_ecdev_global_cnt--;
		return -EBUSY;
		return -EINVAL;
	wp_ecdev_global_cnt--;
		return -EINVAL;
		return -EBUSY;
	file->private_data = ec;   
	void		*ec = file->private_data;
		return -ENODEV;
	file->private_data=NULL;
	void	*ec = file->private_data;
		return -ENODEV;
		return -EINVAL;
	void	*ec = file->private_data;
		return -ENODEV;
		return -EINVAL;
./sdla_ec_dev.c
	wake_up_interruptible(&tp->write_wait);
	wake_up_interruptible(&tp->poll_wait);
	if ((tp->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
	    tp->ldisc.write_wakeup)
		(tp->ldisc.write_wakeup)(tp);
 *-F*************************************************************************/
	if (!tp->driver_data)
	return GpWanWriteRoom(tp->driver_data);
 *-F*************************************************************************/
	line = MINOR(tp->device) - tp->driver.minor_start;
		status = -ENODEV;
		return -ENODEV;
	status = GpWanOpen(tty_card_map[line], line, tp, &tp->driver_data); 
 *-F*************************************************************************/
	line = MINOR(tp->device) - tp->driver.minor_start;
	GpWanClose(tty_card_map[line],tp->driver_data);
	if (tp->driver.flush_buffer){
	 	tp->driver.flush_buffer(tp);
	if (tp->ldisc.flush_buffer){
	 	tp->ldisc.flush_buffer(tp);
 *-F*************************************************************************/
	if (tp->driver_data == NULL){
		return -EINVAL;
	return GpWanTx(tp->driver_data, fromUser, buffer, bufferLen);
	return MINOR(tp->device);
	return tp->driver.minor_start;
	tp->driver_data = ptr;
	tp->low_latency = data;
	return (void*)tp->driver.driver_state;		
 *-F*************************************************************************/
		DEBUG_EVENT("%s: Error Illegal Minor TTY number (0-%d): %i\n",
		return -EINVAL;
		return -EBUSY;	
	DEBUG_EVENT ("%s: ADSL Registering %s%d  Major=%d Minor=%i Channels=(0-%d)\n",
		    devname,ADSL_WAN_TTY_NAME,minor_no,ADSL_TTY_MAJOR,minor_no,ADSL_NR_PORTS-1);
		tp->magic           = TTY_DRIVER_MAGIC;
		tp->driver_name     = "wanpipe";
		tp->name            = ADSL_WAN_TTY_NAME;
		tp->major           = ADSL_TTY_MAJOR;
		tp->minor_start     = 0;
		tp->num             = ADSL_NR_PORTS;
		tp->type            = TTY_DRIVER_TYPE_SERIAL;
		tp->subtype         = SERIAL_TYPE_NORMAL;
		tp->init_termios    = tty_std_termios;
		tp->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
		tp->flags           = TTY_DRIVER_REAL_RAW;
		tp->refcount        = &serial_refcount;
		tp->table           = serial_table;
		tp->termios         = serial_termios;
		tp->termios_locked  = serial_termios_locked;
		tp->open            = adsl_wan_open;
		tp->close           = adsl_wan_close;
		tp->write           = adsl_wan_tx;
		tp->write_room      = adsl_wan_write_room;
		tp->chars_in_buffer = adsl_wan_chars_in_buffer;
		tp->flush_chars     = adsl_wan_flush_chars;
		tp->flush_buffer    = adsl_wan_flush_buffer;
		tp->ioctl           = NULL;// GpWanIoctl;
		tp->set_termios     = adsl_wan_set_termios;
		tp->stop            = NULL;
		tp->start           = NULL;
		tp->throttle        = NULL;
		tp->unthrottle      = NULL;
		tp->hangup          = NULL;
		tp->break_ctl       = NULL;
		tp->send_xchar      = NULL;
		tp->wait_until_sent = NULL;
		tp->read_proc       = NULL;
			return -ENODEV;
	if ((--tty_init_cnt) == 0){
 *-F*************************************************************************/
        	if ((tp->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
                    (tp->ldisc.write_wakeup != NULL)){
			(tp->ldisc.write_wakeup)(tp);
		wake_up_interruptible(&(tp->write_wait));
		wake_up_interruptible(&tp->poll_wait);
	tp->ldisc.receive_buf(tp, pData, pFlags, dataLen);
./sdla_adsl_tty.c
	while ((SYSTEM_TICKS-timeout)<(sec*HZ)){
	conf->config_id			= WANCONFIG_AFT_TE3;
	conf->u.xilinx.dma_per_ch	= MAX_RX_BUF;
	conf->u.xilinx.mru	= 1500;
	conf->protocol = WANCONFIG_HDLC;
	memcpy(conf->usedby, "WANPIPE", 7);
	conf->if_down = 0;
	conf->ignore_dcd = WANOPT_NO;
	conf->ignore_cts = WANOPT_NO;
	conf->hdlc_streaming = WANOPT_NO;
	conf->mc = 0;
	conf->gateway = 0;
	conf->active_ch = ENABLE_ALL_CHANNELS;
 * wp_xilinx_init - Cisco HDLC protocol initialization routine.
 *  o initialize protocol-specific fields of the adapter data space.
	wan_clear_bit(CARD_DOWN,&card->wandev.critical);
	if (card->wandev.config_id != WANCONFIG_AFT_TE3) {
				  card->devname, card->wandev.config_id);
		return -EINVAL;
				card->devname);
		return -EINVAL;
	if (card->adptr_subtype == AFT_SUBTYPE_SHARK) {
				card->devname);
	card->hw_iface.getcfg(card->hw, SDLA_COREREV, &card->u.aft.firm_ver);
	card->hw_iface.getcfg(card->hw, SDLA_COREID, &card->u.aft.firm_id);
	card->wandev.clocking 			= conf->clocking;
	card->wandev.ignore_front_end_status 	= conf->ignore_front_end_status;
	card->wandev.ttl 			= conf->ttl;
	card->wandev.electrical_interface 			= conf->electrical_interface;
	card->wandev.comm_port 			= conf->comm_port;
	card->wandev.udp_port   		= conf->udp_port;
	card->wandev.new_if_cnt 		= 0;
	wan_atomic_set(&card->wandev.if_cnt,0);
	card->u.aft.chip_security_cnt=0;
	memcpy(&card->u.xilinx.cfg,&conf->u.xilinx,sizeof(wan_xilinx_conf_t));
	card->u.xilinx.cfg.dma_per_ch = MAX_RX_BUF;
	if (IS_TE3(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_te3_iface_init(&card->wandev.fe_iface);
		card->fe.name = card->devname;
		card->fe.card = card;
		card->fe.write_cpld	= write_cpld;
//		card->fe.read_cpld	= read_cpld;
		card->fe.write_fe_cpld	= write_fe_cpld;
		card->fe.write_fe_reg	= card->hw_iface.fe_write;
		card->fe.read_fe_reg	= card->hw_iface.fe_read;
		card->wandev.fe_enable_timer = enable_timer;
		card->wandev.te_link_state = callback_front_end_state;
//ALEX		conf->electrical_interface =
		if (card->wandev.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
		DEBUG_EVENT("%s: Invalid Front-End media type!!\n",
				card->devname);
		return -EINVAL;
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
        card->wandev.update             = &update;
        card->wandev.new_if             = &new_if;
        card->wandev.del_if             = &del_if;
        card->disable_comm              = &disable_comm;
	card->wandev.get_config_info 	= &get_config_info;
	card->wandev.get_status_info 	= &get_status_info;
	card->wandev.get_dev_config_info= &get_dev_config_info;
	card->wandev.get_if_info     	= &get_if_info;
	card->wandev.set_dev_config    	= &set_dev_config;
	card->wandev.set_if_info     	= &set_if_info;
	card->wandev.get_info 		= &wan_aft3_get_info;
	if(card->wandev.clocking) {
		card->wandev.bps = conf->bps;
        	card->wandev.bps = 0;
        card->wandev.mtu =
                (conf->mtu >= MIN_WP_PRI_MTU) ?
                 wp_min(conf->mtu, MAX_WP_PRI_MTU) : DEFAULT_WP_PRI_MTU;
	if (!card->u.xilinx.cfg.mru){
		card->u.xilinx.cfg.mru = card->wandev.mtu;
			card->devname, card->wandev.mtu);
	card->hw_iface.getcfg(card->hw, SDLA_BASEADDR, &card->u.xilinx.bar);
	WAN_TASKQ_INIT((&card->u.aft.port_task),0,aft_port_task,card);
        card->isr = &wp_aft_te3_isr;
	DEBUG_EVENT( "%s: Init Done. Firm=%02X\n",card->devname,card->u.aft.firm_ver);
 * update - Update wanpipe device status & statistics
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	if(wan_test_bit(PERI_CRIT, (void*)&card->wandev.critical))
                return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
		return -ENODEV;
       	if(card->update_comms_stats){
		return -EAGAIN;
			chan->if_name,
			chan->dma_chain_status,
			chan->tx_chain_indx,
			chan->tx_pending_chain_indx,
			chan->rx_chain_indx,
			chan->rx_pending_chain_indx);
 * new_if - Create new logical channel.
 * to dev->priv pointer.
 * Also the dev->init pointer should also be initialized
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
			card->devname, wan_netif_name(dev));
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)){
			card->devname);
		return -EINVAL;
		WAN_MEM_ASSERT(card->devname);
		return -ENOMEM;
	chan->first_time_slot=-1;
	chan->single_dma_chain=0;
	if (conf->single_tx_buf) {
		chan->single_dma_chain=1;
	chan->single_dma_chain=1;
	strncpy(chan->if_name, wan_netif_name(dev), WAN_IFNAME_SZ);
	chan->card = card;
	wan_skb_queue_init(&chan->wp_tx_free_list);
	wan_skb_queue_init(&chan->wp_tx_pending_list);
	wan_skb_queue_init(&chan->wp_tx_complete_list);
	wan_skb_queue_init(&chan->wp_rx_free_list);
	wan_skb_queue_init(&chan->wp_rx_complete_list);
	wan_trace_info_init(&chan->trace_info,MAX_TRACE_QUEUE);
	WAN_TASKLET_INIT((&chan->common.bh_task),0,wp_bh,chan);
	chan->common.dev = dev;
	chan->tracing_enabled = 0;
	chan->route_status = NO_ROUTE;
	chan->route_removed = 0;
	if(strcmp(conf->usedby, "WANPIPE") == 0) {
			wandev->name);
		chan->common.usedby = WANPIPE;
		if (conf->if_down){
			wan_set_bit(DYN_OPT_ON,&chan->interface_down);
			   card->devname,chan->if_name);
		if (conf->protocol != WANOPT_NO){
			if (conf->ignore_dcd == WANOPT_YES || conf->ignore_cts == WANOPT_YES){
				DEBUG_EVENT( "%s: Ignore modem changes DCD/CTS\n",card->devname);
				chan->ignore_modem=1;
						card->devname);
	} else if( strcmp(conf->usedby, "API") == 0) {
		chan->common.usedby = API;
			wandev->name,chan->if_name);
		wan_reg_api(chan, dev, card->devname);
	}else if (strcmp(conf->usedby, "BRIDGE") == 0) {
		chan->common.usedby = BRIDGE;
				card->devname,chan->if_name);
	}else if (strcmp(conf->usedby, "BRIDGE_N") == 0) {
		chan->common.usedby = BRIDGE_NODE;
				card->devname,chan->if_name);
	}else if (strcmp(conf->usedby, "STACK") == 0) {
		chan->common.usedby = STACK;
		if (chan->hdlc_eng){
			card->wandev.mtu+=32;
				card->devname,chan->if_name);
				card->devname,chan->if_name);
		err=-EINVAL;
	chan->hdlc_eng = conf->hdlc_streaming;
	if (!chan->hdlc_eng){
		chan->single_dma_chain=1;
		if (card->wandev.mtu&0x03){
					card->devname,chan->if_name);
			err = -EINVAL;
	chan->time_slot_map=conf->active_ch;
	if (!chan->hdlc_eng){
		if (!chan->max_idle_size){
			chan->max_idle_size=card->wandev.mtu;
			card->devname,chan->if_name,
			chan->idle_flag,chan->max_idle_size);
		chan->idle_flag=0x7E;
		chan->tx_idle_skb = wan_skb_alloc(chan->max_idle_size);
		if (!chan->tx_idle_skb){
			err=-ENOMEM;
		buf=wan_skb_put(chan->tx_idle_skb,chan->max_idle_size);
		memset(buf,chan->idle_flag,chan->max_idle_size);
	chan->dma_mtu = card->wandev.mtu >= card->u.xilinx.cfg.mru?
				card->wandev.mtu:card->u.xilinx.cfg.mru;
	chan->dma_mtu = xilinx_valid_mtu(chan->dma_mtu);
	if (!chan->dma_mtu){
			card->devname,
			chan->if_name,
			card->wandev.mtu,card->u.xilinx.cfg.mru);
		err= -EINVAL;
	chan->dma_bufs=card->u.xilinx.cfg.dma_per_ch;
	if (chan->single_dma_chain){
		chan->dma_bufs=MAX_RX_SCHAIN_BUF;
			card->devname,chan->if_name,
			chan->dma_bufs,
			chan->dma_mtu,
			chan->single_dma_chain ? "Off":"On");
	err=aft_alloc_rx_dma_buff(card, chan, chan->dma_bufs);
	 *      is brought back up, we must know to re-astablish the
	if ((chan->gateway = conf->gateway) == WANOPT_YES){
			card->devname,chan->if_name);
	chan->mc = conf->mc;
	 * 	dev->if_init : function that will be called
	 * 	dev->priv    : private structure allocated above
					   &chan->dent,
					   chan->if_name,
			card->devname, chan->if_name);
	dev->init = &if_init;
	chan->common.is_netdev = 1;
	chan->common.iface.open = &if_open;
	chan->common.iface.close = &if_close;
	chan->common.iface.output = &if_send;
	chan->common.iface.ioctl = &if_do_ioctl;
	chan->common.iface.tx_timeout = &if_tx_timeout;
			wan_iface.attach(dev, NULL, chan->common.is_netdev);
				card->devname, wan_netif_name(dev));
		err = -EINVAL;
	wan_netif_set_mtu(dev, card->wandev.mtu);
	wan_atomic_inc(&card->wandev.if_cnt);
	chan->common.state = WAN_CONNECTING;
	while ((skb=wan_skb_dequeue(&chan->wp_tx_free_list)) != NULL){
	while ((skb=wan_skb_dequeue(&chan->wp_rx_free_list)) != NULL){
	WAN_TASKLET_KILL(&chan->common.bh_task);
	if (chan->common.usedby == API){
		wan_unreg_api(chan, card->devname);
	if (chan->tx_idle_skb){
		wan_skb_free(chan->tx_idle_skb);
		chan->tx_idle_skb=NULL;
 * del_if - Delete logical channel.
 * NOTE: DO NOT deallocate dev->priv here! It will be
	sdla_t*			card = chan->card;
	WAN_TASKLET_KILL(&chan->common.bh_task);
	if (chan->common.usedby == API){
		wan_unreg_api(chan, card->devname);
	wan_spin_lock_irq(&card->wandev.lock,&flags);
	while ((skb=wan_skb_dequeue(&chan->wp_rx_free_list)) != NULL){
	while ((skb=wan_skb_dequeue(&chan->wp_rx_complete_list)) != NULL){
	while ((skb=wan_skb_dequeue(&chan->wp_tx_free_list)) != NULL){
	if (chan->tx_realign_buf){
		wan_free(chan->tx_realign_buf);
		chan->tx_realign_buf=NULL;
	if (chan->tx_idle_skb){
         	wan_skb_free(chan->tx_idle_skb);
               chan->tx_idle_skb=NULL;
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	wanrouter_proc_delete_interface(wandev, chan->if_name);
	wan_atomic_dec(&card->wandev.if_cnt);
 * if_init - Initialize Linux network interface.
	sdla_t*		card = chan->card;
	wan_device_t* 	wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	hdlc->xmit 	= if_send;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= 2*HZ;
	dev->do_ioctl		= if_do_ioctl;
	dev->change_mtu		= if_change_mtu;
	if (chan->common.usedby == BRIDGE ||
            chan->common.usedby == BRIDGE_NODE){
		memcpy(dev->dev_addr, "\xFE\xFC\x00\x00\x00\x00", 6);
		*(int *)(dev->dev_addr + 2) += hw_addr;
		if (chan->protocol != WANCONFIG_PPP &&
		    chan->protocol != WANCONFIG_CHDLC){
			dev->flags     |= IFF_POINTOPOINT;
			dev->flags     |= IFF_NOARP;
			dev->type	= ARPHRD_PPP;
			dev->mtu		= card->wandev.mtu;
			dev->hard_header_len	= 16;
			dev->addr_len		= 0;
		if (chan->common.usedby == API){
			dev->mtu = card->wandev.mtu+sizeof(api_tx_hdr_t);
		if (chan->mc == WANOPT_YES){
			dev->flags 	|= IFF_MULTICAST;
		if (chan->true_if_encoding){
			dev->type	= ARPHRD_HDLC; /* This breaks the tcpdump */
			dev->type	= ARPHRD_PPP;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start);
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end);
        dev->tx_queue_len = 100;
 * if_open - Open network interface.
	sdla_t* card = chan->card;
		return -EBUSY;
	wan_getcurrenttime(&chan->router_start_time, NULL);
	wan_spin_lock_irq(&card->wandev.lock,&flags);
	if (card->wandev.state == WAN_CONNECTED){
		xilinx_dma_rx(card,chan,-1);
	if (!chan->hdlc_eng){
	wan_set_bit(0,&chan->up);
	if (card->wandev.state == WAN_CONNECTED){
		if (chan->common.usedby == API){
		}else if (chan->common.usedby == STACK){
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	chan->ignore_modem=0x0F;
 * if_close - Close network interface.
	sdla_t* card = chan->card;
	wan_clear_bit(0,&chan->up);
	dev->start=0;
	chan->common.state = WAN_DISCONNECTED;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	chan->ignore_modem=0x00;
 * disable_comm - Main shutdown function
	if (IS_TE3(&card->fe.fe_cfg)) {
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
	wan_spin_lock_irq(&card->wandev.lock,&flags);
	wan_set_bit(CARD_DOWN,&card->wandev.critical);
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++chan->if_stats.collisions;
				card->devname,wan_netif_name(dev));
//			chan->if_name,
//			chan->dma_status,
//			chan->tx_dma_addr,
//			chan->tx_dma_len);
	card->hw_iface.bus_read_4(card->hw,AFT_TE3_CRNT_DMA_DESC_ADDR_REG,&reg);
			chan->if_name,
			wan_test_bit(TX_INTR_PENDING,&chan->dma_chain_status),
			wan_test_bit(TX_DMA_BUSY,&chan->dma_status),
			chan->tx_chain_indx,
			chan->tx_pending_chain_indx,
		        chan->if_stats.tx_fifo_errors);
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
	if (!chan->single_dma_chain){
 * if_send - Send a packet on a network interface.
 * 	Return a non-zero value to tell the stack
 *		non-0	packet may be re-transmitted
	sdla_t *card = chan->card;
			card->devname, wan_netif_name(dev));
	if (dev->tbusy){
		 * kick start the device by making dev->tbusy = 0.  We expect
                ++chan->if_stats.collisions;
		if((SYSTEM_TICKS - chan->tick_counter) < (5 * HZ)) {
	if (chan->common.state != WAN_CONNECTED){
					chan->if_name);
		++chan->if_stats.tx_carrier_errors;
		++chan->if_stats.tx_carrier_errors;
		if (chan->common.usedby == API){
				++chan->if_stats.tx_errors;
		wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
		if (wan_skb_queue_len(&chan->wp_tx_pending_list) > MAX_TX_BUF){
			wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
		wan_skb_queue_tail(&chan->wp_tx_pending_list,skb);
			case -EBUSY:
						chan->if_name);
		wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
	card=chan->card;
	u8 *base_addr=card->u.xilinx.rx_dma_ptr;
	u8 *base_addr_tx=card->u.xilinx.tx_dma_ptr;
	addr+=chan->logic_ch_num*card->u.xilinx.dma_mtu_off;
	addr0=addr+0*card->u.xilinx.dma_mtu;
	addr1=addr+1*card->u.xilinx.dma_mtu;
			wan_skb_queue_len(&chan->wp_rx_complete_list),
			wan_skb_queue_len(&chan->wp_rx_free_list),
			wan_skb_queue_len(&chan->wp_tx_pending_list));
                        wan_skb_queue_len(&chan->wp_rx_complete_list),
                        wan_skb_queue_len(&chan->wp_rx_free_list),
                        wan_skb_queue_len(&chan->wp_tx_pending_list));
	return &chan->if_stats;
		return -ENODEV;
	if (!chan->hdlc_eng) {
		return -EINVAL;
	if (chan->common.usedby == API){
	}else if (chan->common.usedby == STACK){
	if (new_mtu > chan->dma_mtu) {
		return -EINVAL;
	dev->mtu = new_mtu;
 * if_do_ioctl - Ioctl handler for fr
		return -ENODEV;
	card=chan->card;
				err= -EINVAL;
			wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
			err=wan_bind_api_to_svc(chan,ifr->ifr_data);
			chan->if_stats.rx_dropped=0;
			chan->if_stats.tx_carrier_errors=0;
			wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
				err= -EINVAL;
			wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
			err=wan_unbind_api_from_svc(chan,ifr->ifr_data);
			wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
			err = chan->common.state;
			if (wan_atomic_read(&chan->udp_pkt_len) != 0){
				return -EBUSY;
			wan_atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
			if (wan_test_bit(0,&card->in_isr)){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EBUSY;
			wan_udp_pkt=(wan_udp_pkt_t*)chan->udp_pkt_data;
			if (WAN_COPY_FROM_USER(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			if (wan_test_bit(0,&card->in_isr)) {
						card->devname,
						wan_netif_name(chan->common.dev));
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EBUSY;
			if (wan_atomic_read(&chan->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						card->devname,wan_atomic_read(&chan->udp_pkt_len));
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EINVAL;
			if (WAN_COPY_TO_USER(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			wan_atomic_set(&chan->udp_pkt_len,0);
					card->devname,cmd);
			return -EOPNOTSUPP;
			if (card->wandev.ioctl){
				err = card->wandev.hdlc_ioctl(card, dev, ifr, cmd);
        card->hw_iface.bus_read_4(card->hw,AFT_TE3_CRNT_DMA_DESC_ADDR_REG,&reg);
                                __FUNCTION__,chan->if_name,
       	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
			card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
				card->devname,chan->if_name,i*FIFO_RESET_TIMEOUT_US);
				card->devname,chan->if_name);
      	card->hw_iface.bus_read_4(card->hw,AFT_TE3_CRNT_DMA_DESC_ADDR_REG,&reg);
                                __FUNCTION__,chan->if_name,
        card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
                	card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
                                card->devname,chan->if_name,i*FIFO_RESET_TIMEOUT_US);
                                card->devname,chan->if_name);
	DEBUG_TEST("%s: Enabling Global Inter Mask !\n",chan->if_name);
	card->hw_iface.bus_read_4(card->hw,
	wan_set_bit(chan->logic_ch_num,&reg);
	card->hw_iface.bus_write_4(card->hw,
	wan_set_bit(chan->logic_ch_num,&card->u.xilinx.active_ch_map);
    	DEBUG_CFG("-- Close Xilinx device. --\n");
        card->hw_iface.bus_read_4(card->hw,
        wan_clear_bit(chan->logic_ch_num,&reg);
	wan_clear_bit(chan->logic_ch_num,&card->u.xilinx.active_ch_map);
        card->hw_iface.bus_write_4(card->hw,
 	card->hw_iface.bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
       	card->hw_iface.bus_write_4(card->hw,
                       (reg|(chan->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));
                               chan->first_time_slot,
	DEBUG_TEST("%s: Tx interrupt wtd=%d\n",chan->if_name,wtd);
		wan_clear_bit(TX_INTR_PENDING,&chan->dma_chain_status);
	if (WAN_NETIF_QUEUE_STOPPED(chan->common.dev)){
		WAN_NETIF_WAKE_QUEUE(chan->common.dev);
		if (chan->common.usedby == API){
		}else if (chan->common.usedby == STACK){
               wan_set_bit(0,&chan->idle_start);
	if (!chan->single_dma_chain){
				card->devname,chan->if_name,reg);
                   		card->devname,chan->if_name);
			chan->errstats.Tx_dma_errors++;
                   		card->devname,chan->if_name);
			chan->errstats.Tx_dma_len_nonzero++;
			chan->errstats.Tx_pci_errors++;
                	     		card->devname,chan->if_name);
                	     		card->devname,chan->if_name);
                	     		card->devname,chan->if_name);
				chan->errstats.Tx_pci_latency++;
                	     		card->devname,chan->if_name);
		chan->if_stats.tx_errors++;
        chan->opstats.Data_frames_Tx_count++;
        chan->opstats.Data_bytes_Tx_count+=wan_skb_len(skb);
	chan->if_stats.tx_packets++;
	chan->if_stats.tx_bytes+=wan_skb_len(skb);
        wan_set_bit(0,&chan->idle_start);
	wan_capture_trace_packet(card, &chan->trace_info, skb, TRC_OUTGOING_FRM);
	 if (rx_el->reg&RxDMA_HI_DMA_PCI_ERROR_MASK){
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_M_ABRT){
                                   card->devname,chan->if_name);
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_T_ABRT){
                                   card->devname,chan->if_name);
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_DS_TOUT){
                                    card->devname,chan->if_name);
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_RETRY_TOUT){
                                    card->devname,chan->if_name);
                	DEBUG_EVENT("%s: RXDMA Unknown PCI ERROR = 0x%x\n",chan->if_name,rx_el->reg);
		return -1;
	wp_rx_element_t *rx_el=(wp_rx_element_t *)&skb->cb[0];
		__FUNCTION__,chan->if_name,rx_el->reg,rx_el->align,rx_el->dma_addr);
	chan->if_stats.rx_errors++;
	rx_el->align&=RxDMA_LO_ALIGNMENT_BIT_MASK;
	if (wan_test_bit(RxDMA_HI_DMA_GO_READY_BIT,&rx_el->reg)){
				card->devname,chan->if_name);
		chan->if_stats.rx_errors++;
		chan->errstats.Rx_dma_descr_err++;
		chan->errstats.Rx_pci_errors++;
		chan->if_stats.rx_errors++;
	if (chan->hdlc_eng){
		if (!wan_test_bit(RxDMA_HI_DMA_FRAME_START_BIT,&rx_el->reg)){
					card->devname,chan->if_name,rx_el->reg);
			chan->if_stats.rx_frame_errors++;
     			chan->opstats.Rx_Data_discard_long_count++;
                        chan->errstats.Rx_hdlc_corrupiton++;
		if (!wan_test_bit(RxDMA_HI_DMA_FRAME_END_BIT,&rx_el->reg)){
					card->devname,chan->if_name,rx_el->reg);
			chan->if_stats.rx_frame_errors++;
     			chan->opstats.Rx_Data_discard_long_count++;
                        chan->errstats.Rx_hdlc_corrupiton++;
			if (wan_test_bit(RxDMA_HI_DMA_CRC_ERROR_BIT,&rx_el->reg)){
                                		card->devname,chan->if_name,rx_el->reg,
						(rx_el->reg&RxDMA_HI_DMA_DATA_LENGTH_MASK)>>2);
				chan->if_stats.rx_frame_errors++;
			 	chan->opstats.Rx_Data_discard_long_count++;
                        	chan->errstats.Rx_hdlc_corrupiton++;
				wan_set_bit(WP_CRC_ERROR_BIT,&rx_el->pkt_error);
			if (wan_test_bit(RxDMA_HI_DMA_FRAME_ABORT_BIT,&rx_el->reg)){
						card->devname,chan->if_name,rx_el->reg);
				chan->if_stats.rx_frame_errors++;
     				chan->opstats.Rx_Data_discard_long_count++;
                        	chan->errstats.Rx_hdlc_corrupiton++;
				wan_set_bit(WP_ABORT_ERROR_BIT,&rx_el->pkt_error);
			if (chan->common.usedby != API && data_error){
	len=rx_el->reg&RxDMA_HI_DMA_DATA_LENGTH_MASK;
	if (chan->hdlc_eng){
		len=((((chan->dma_mtu>>2)-1)-len)<<2) - (~(rx_el->align)&RxDMA_LO_ALIGNMENT_BIT_MASK);
		len=(((card->wandev.mtu>>2)-len)<<2) - (~(0x03)&RxDMA_LO_ALIGNMENT_BIT_MASK);
	*pkt_error=rx_el->pkt_error;
	if (wan_test_bit(WP_FIFO_ERROR_BIT,&rx_el->pkt_error)){
		if (++chan->rx_fifo_err_cnt >= WP_MAX_FIFO_FRAMES){
			chan->rx_fifo_err_cnt=0;
		if (chan->rx_fifo_err_cnt){
			if (++chan->rx_fifo_err_cnt >= WP_MAX_FIFO_FRAMES){
                        	chan->rx_fifo_err_cnt=0;
				card->devname,chan->if_name,(len+20));
			chan->if_stats.rx_dropped++;
	memset(&skb->cb[0],0,sizeof(wp_rx_element_t));
	wan_skb_queue_tail(&chan->wp_rx_free_list,skb);
		skb=wan_skb_alloc(chan->dma_mtu);
					chan->if_name,__FUNCTION__);
			return -ENOMEM;
		wan_skb_queue_tail(&chan->wp_rx_free_list,skb);
	DEBUG_TEST("%s: %s Sdla Polling!\n",__FUNCTION__,card->devname);
	wan_set_bit(AFT_FE_POLL,&card->u.aft.port_task_cmd);
	WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
	card->hw_iface.hw_lock(card->hw,&smp_flags1);
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	WAN_FECALL(&card->wandev, polling, (&card->fe));
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
	card->hw_iface.hw_unlock(card->hw,&smp_flags1);
	DEBUG_TEST("%s: ------------ BEGIN --------------: %lu\n",
	if (!wan_test_bit(0,&chan->up)){
                                chan->if_name);
		WAN_TASKLET_END((&chan->common.bh_task));
	while((skb=wan_skb_dequeue(&chan->wp_rx_complete_list)) != NULL){
		chan->if_stats.rx_errors++;
		if (chan->common.usedby == API && chan->common.sk == NULL){
				chan->if_name);
			chan->if_stats.rx_dropped++;
		xilinx_rx_post_complete (chan->card, chan,
			wan_capture_trace_packet(chan->card, &chan->trace_info,
			if (chan->common.usedby == API){
					rx_hdr->wp_api_rx_hdr_error_flag=pkt_error;
							chan->if_name,
					++chan->if_stats.rx_dropped;
				new_skb->protocol = htons(PVC_PROT);
				new_skb->dev      = chan->common.dev;
				new_skb->pkt_type = WAN_PACKET_DATA;
				chan->if_stats.rx_frame_errors++;
						chan->if_name);
					++chan->if_stats.rx_dropped;
			}else if (chan->common.usedby == STACK){
					++chan->if_stats.rx_dropped;
				protocol_recv(chan->card,chan,new_skb);
     			chan->opstats.Data_frames_Rx_count++;
                        chan->opstats.Data_bytes_Rx_count+=len;
			chan->if_stats.rx_packets++;
			chan->if_stats.rx_bytes+=len;
		if (SYSTEM_TICKS-timeout > 3){
						chan->if_name,(unsigned long)(SYSTEM_TICKS-timeout));
	while((skb=wan_skb_dequeue(&chan->wp_tx_complete_list)) != NULL){
		xilinx_tx_post_complete (chan->card,chan,skb);
	WAN_TASKLET_END((&chan->common.bh_task));
	if ((len=wan_skb_queue_len(&chan->wp_rx_complete_list))){
		DEBUG_TEST("%s: Triggering from bh rx=%i\n",chan->if_name,len);
		WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
	}else if ((len=wan_skb_queue_len(&chan->wp_tx_complete_list))){
                DEBUG_TEST("%s: Triggering from bh tx=%i\n",chan->if_name,len);
		WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
	DEBUG_TEST("%s: ------------ END -----------------: %lu\n",
	if (card->wandev.state != WAN_CONNECTED){
                                  card->devname);
			card->devname,rx_status,tx_status);
	if (IS_TE3(&card->fe.fe_cfg)){
		num_of_logic_ch=card->u.xilinx.num_of_time_slots;
			if (wan_test_bit(i,&tx_status) && wan_test_bit(i,&card->u.xilinx.logic_ch_map)){
				chan=(private_area_t*)card->u.xilinx.dev_to_ch_map[i];
				if (!wan_test_bit(0,&chan->up)){
						wan_netif_name(chan->common.dev),chan->common.state,chan->ignore_modem);
				if (chan->common.state != WAN_CONNECTED){
                                                wan_netif_name(chan->common.dev));
				if (!chan->hdlc_eng && !wan_test_bit(0,&chan->idle_start)){
                                                	wan_netif_name(chan->common.dev));
					if (chan->hdlc_eng){
                           		card->devname,chan->if_name,chan->logic_ch_num,i);
				++chan->if_stats.tx_fifo_errors;
				err=-EINVAL;
			if (wan_test_bit(i,&rx_status) && wan_test_bit(i,&card->u.xilinx.logic_ch_map)){
				chan=(private_area_t*)card->u.xilinx.dev_to_ch_map[i];
				if (!wan_test_bit(0,&chan->up)){
						wan_netif_name(chan->common.dev),chan->common.state,chan->ignore_modem);
				if (chan->common.state != WAN_CONNECTED){
                                                wan_netif_name(chan->common.dev));
                           		card->devname,chan->if_name,chan->logic_ch_num,i,
					wan_skb_queue_len(&chan->wp_rx_complete_list),
					wan_skb_queue_len(&chan->wp_rx_free_list),
					chan->rx_dma);
				++chan->if_stats.rx_fifo_errors;
			     	dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
			        card->hw_iface.bus_read_4(card->hw, dma_descr, &reg);
				DEBUG_EVENT("%s: Hi Descriptor 0x%X\n",chan->if_name,reg);
				wan_set_bit(WP_FIFO_ERROR_BIT, &chan->pkt_error);
				err=-EINVAL;
	DEBUG_TE3("%s: front_end_interrupt!\n",card->devname);
	if (IS_TE3(&card->fe.fe_cfg)){
		WAN_FECALL(&card->wandev, isr, (&card->fe));
				card->devname);
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
    	wan_set_bit(0,&card->in_isr);
       /* -----------------2/6/2003 9:02AM------------------
     	*  -- "Transmit/Receive DMA Engine"  interrupt disable
     	*  -- "FiFo/Line Abort Error"        interrupt disable
     	* --------------------------------------------------*/
        card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
			card->devname,XILINX_CHIP_CFG_REG,reg);
		card->hw_iface.bus_read_4(card->hw,TE3_FRACT_ENCAPSULATION_REG, &freg);
				card->devname, frc_crc,reg);
		if (++card->u.aft.chip_security_cnt >
				card->devname,card->u.aft.chip_security_cnt);
			card->u.aft.chip_security_cnt=0;
				card->devname,card->u.aft.chip_security_cnt);
				card->devname);
		card->u.aft.chip_security_cnt=0;
			wan_set_bit(AFT_FE_INTR,&card->u.aft.port_task_cmd);
			WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
			card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_TX_INTR_PENDING_REG,&tx_fifo_status);
        		card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_RX_INTR_PENDING_REG,&rx_fifo_status);
			rx_fifo_status&=card->u.aft.active_ch_map;
			tx_fifo_status&=card->u.aft.active_ch_map;
       /* -----------------2/6/2003 9:37AM------------------
      	* --------------------------------------------------*/
		if (IS_TE3(&card->fe.fe_cfg)){
			num_of_logic_ch=card->u.xilinx.num_of_time_slots;
		card->hw_iface.bus_read_4(card->hw,
				card->devname,
				card->u.xilinx.active_ch_map);
		dma_rx_reg&=card->u.xilinx.active_ch_map;
			     wan_test_bit(i,&card->u.xilinx.logic_ch_map)){
				chan=(private_area_t*)card->u.xilinx.dev_to_ch_map[i];
							card->devname,i);
				if (!wan_test_bit(0,&chan->up)){
                                                        card->devname,i);
				chan->if_stats.rx_frame_errors++;
						card->devname);
	        card->hw_iface.bus_read_4(card->hw,
		dma_tx_reg&=card->u.xilinx.active_ch_map;
				card->devname,
				card->u.xilinx.active_ch_map,
			if (wan_test_bit(i,&dma_tx_reg) && wan_test_bit(i,&card->u.xilinx.logic_ch_map)){
				chan=(private_area_t*)card->u.xilinx.dev_to_ch_map[i];
							card->devname,i);
				if (!wan_test_bit(0,&chan->up)){
                                                        card->devname,i);
             			DEBUG_TEST("---- TX Interrupt pend. --\n");
					dma_tx_reg,card->u.xilinx.logic_ch_map);
			DEBUG_EVENT("%s: Enabling FIFO Interrupt\n",card->devname);
    	DEBUG_ISR("---- ISR SKB TX end.-------------------\n");
		chan=(private_area_t*)card->u.xilinx.dev_to_ch_map[0];
		if (chan && wan_test_bit(0,&chan->up)){
			++chan->if_stats.tx_dropped;
		DEBUG_TEST("%s: Tx WatchDog Expired!\n",card->devname);
		chan=(private_area_t*)card->u.xilinx.dev_to_ch_map[0];
		if (!skip_rx_wtd && chan && wan_test_bit(0,&chan->up)){
			chan->if_stats.rx_dropped++;
					chan->if_name,wan_test_bit(0,&chan->up));
			if (!chan->single_dma_chain){
				card->devname,chan);
	/* -----------------2/6/2003 10:36AM-----------------
	 * --------------------------------------------------*/
    	DEBUG_ISR("---- ISR end.-------------------\n");
    	wan_clear_bit(0,&card->in_isr);
 * "wanpipemon" utility is a user-space program that
	wan_udp_pkt = (wan_udp_pkt_t *)chan->udp_pkt_data;
	if (wan_atomic_read(&chan->udp_pkt_len) == 0){
		return -ENODEV;
	trace_info=&chan->trace_info;
	wan_udp_pkt = (wan_udp_pkt_t *)chan->udp_pkt_data;
		wan_udp_pkt->wan_udp_opp_flag = 0;
		switch(wan_udp_pkt->wan_udp_command) {
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len=0;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			wan_udp_pkt->wan_udp_data_len = 0;
			if (!wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
				if (wan_udp_pkt->wan_udp_data[0] == 0){
					wan_clear_bit(1,&trace_info->tracing_enabled);
						card->devname);
				}else if (wan_udp_pkt->wan_udp_data[0] == 1){
					wan_clear_bit(2,&trace_info->tracing_enabled);
					wan_set_bit(1,&trace_info->tracing_enabled);
							card->devname);
					wan_clear_bit(1,&trace_info->tracing_enabled);
					wan_set_bit(2,&trace_info->tracing_enabled);
							card->devname);
				wan_set_bit (0,&trace_info->tracing_enabled);
						card->devname);
				wan_udp_pkt->wan_udp_return_code = 2;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			if(wan_test_bit(0,&trace_info->tracing_enabled)) {
				wan_clear_bit(0,&trace_info->tracing_enabled);
				wan_clear_bit(1,&trace_info->tracing_enabled);
				wan_clear_bit(2,&trace_info->tracing_enabled);
							card->devname);
				wan_udp_pkt->wan_udp_return_code = 1;
			if(wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
						card->devname);
				wan_udp_pkt->wan_udp_return_code = 1;
			wan_udp_pkt->wan_udp_atm_num_frames = 0;
			wan_udp_pkt->wan_udp_atm_ismoredata = 0;
			while (wan_skb_queue_len(&trace_info->trace_queue)){
				WAN_IFQ_POLL(&trace_info->trace_queue, skb);
								card->devname);
				if ((WAN_MAX_DATA_SIZE - buffer_length) < skb->m_pkthdr.len){
					wan_udp_pkt->wan_udp_atm_ismoredata = 0x01;
					   skb->m_pkthdr.len,
					   &wan_udp_pkt->wan_udp_data[buffer_length]);
				buffer_length += skb->m_pkthdr.len;
				WAN_IFQ_DEQUEUE(&trace_info->trace_queue, skb);
				wan_udp_pkt->wan_udp_atm_num_frames++;
			while ((skb=skb_dequeue(&trace_info->trace_queue)) != NULL){
				if((MAX_TRACE_BUFFER - buffer_length) < wan_skb_len(skb)){
					wan_udp_pkt->wan_udp_atm_ismoredata = 0x01;
						wan_skb_queue_head(&trace_info->trace_queue, skb);
						memcpy(&wan_udp_pkt->wan_udp_atm_data[buffer_length],
						wan_udp_pkt->wan_udp_atm_num_frames++;
				memcpy(&wan_udp_pkt->wan_udp_atm_data[buffer_length],
				wan_udp_pkt->wan_udp_atm_num_frames++;
			wan_udp_pkt->wan_udp_data_len = buffer_length;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			wan_getcurrenttime( &chan->router_up_time, NULL );
			chan->router_up_time -= chan->router_start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data =
					chan->router_up_time;
			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_return_code = 0;
			memcpy(wan_udp_pkt->wan_udp_data,&chan->opstats,sizeof(aft_op_stats_t));
			wan_udp_pkt->wan_udp_data_len=sizeof(aft_op_stats_t);
			wan_udp_pkt->wan_udp_return_code = 0;
			memset(&chan->opstats,0,sizeof(aft_op_stats_t));
			wan_udp_pkt->wan_udp_data_len=0;
			wan_udp_pkt->wan_udp_return_code = 0;
			memcpy(wan_udp_pkt->wan_udp_data,&chan->errstats,sizeof(aft_comm_err_stats_t));
			wan_udp_pkt->wan_udp_data_len=sizeof(aft_comm_err_stats_t);
			wan_udp_pkt->wan_udp_return_code = 0;
			memset(&chan->errstats,0,sizeof(aft_comm_err_stats_t));
			wan_udp_pkt->wan_udp_data_len=0;
		   	wan_udp_pkt->wan_udp_aft_num_frames = card->wandev.config_id;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_PLATFORM_ID;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
			wan_udp_pkt->wan_udp_data_len = 0;
			wan_udp_pkt->wan_udp_return_code = 0xCD;
			if (card->wandev.fe_iface.get_fe_media){
				wan_udp_pkt->wan_udp_data[0] =
					card->wandev.fe_iface.get_fe_media(&card->fe);
				wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
				wan_udp_pkt->wan_udp_data_len = sizeof(unsigned char);
				wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
			if ((wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE) ||
			    ((wan_udp_pkt->wan_udp_command & 0xF0) == WAN_FE_UDP_CMD_START)){
				WAN_FECALL(&card->wandev, process_udp,
							(&card->fe,
							&wan_udp_pkt->wan_udp_cmd,
							&wan_udp_pkt->wan_udp_data[0]));
			wan_udp_pkt->wan_udp_data_len = 0;
			wan_udp_pkt->wan_udp_return_code = 0xCD;
				card->devname,wan_udp_pkt->wan_udp_command);
	wan_udp_pkt->wan_ip_ttl= card->wandev.ttl;
	wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
        if (card->wandev.state != state)
                                card->devname);
                                card->devname);
                                card->devname);
                card->wandev.state = state;
		WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
	wan_set_bit(AFT_FE_POLL,&card->u.aft.port_task_cmd);
	WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
 * S514-1/2/3:		V32/RS232/FT1 Front End
 * S514-4/5/7/8:	56K/T1/E1 Front End
 * 1. Front End State (card->wandev.front_end_status)
 * 2. Protocol State  (card->wandev.state)
 * 3. Interface State (dev->flags & IFF_UP)
	if (card->wandev.ignore_front_end_status == WANOPT_YES){
	WAN_FECALL(&card->wandev, get_fe_status, (&card->fe, &status,0));
		if (card->wandev.state != WAN_CONNECTED){
			card->u.xilinx.state_change_exit_isr=1;
			wan_set_bit(AFT_FE_LED,&card->u.aft.port_task_cmd);
		if (card->wandev.state != WAN_DISCONNECTED){
			card->u.xilinx.state_change_exit_isr=1;
			wan_set_bit(AFT_FE_LED,&card->u.aft.port_task_cmd);
        card->hw_iface.bus_read_2(card->hw,
        card->hw_iface.bus_write_2(card->hw,
        card->hw_iface.bus_read_1(card->hw,XILINX_MCPU_INTERFACE, &tmp);
        card->hw_iface.bus_write_2(card->hw,
        card->hw_iface.bus_read_2(card->hw,
        card->hw_iface.bus_write_2(card->hw,
	card->hw_iface.bus_write_1(card->hw,
        card->hw_iface.bus_write_2(card->hw,
        card->hw_iface.bus_read_2(card->hw,
        card->hw_iface.bus_write_2(card->hw,
	card->hw_iface.bus_write_1(card->hw,
        card->hw_iface.bus_write_2(card->hw,
	if (api_cmd->offset <= 0x3C){
		 card->hw_iface.pci_read_config_dword(card->hw,
						api_cmd->offset,
						(u32*)&api_cmd->data[0]);
		 api_cmd->len=4;
		card->hw_iface.peek(card->hw, api_cmd->offset, &api_cmd->data[0], api_cmd->len);
			card->devname,api_cmd->bar,api_cmd->offset,api_cmd->len);
			card->devname,
			api_cmd->bar,api_cmd->offset,api_cmd->len);
	card->hw_iface.poke(card->hw, api_cmd->offset, &api_cmd->data[0], api_cmd->len);
	if (api_cmd->len == 1){
		card->hw_iface.bus_write_1(
			card->hw,
			api_cmd->offset,
			(u8)api_cmd->data[0]);
	}else if (api_cmd->len == 2){
		card->hw_iface.bus_write_2(
			card->hw,
			api_cmd->offset,
			*(u16*)&api_cmd->data[0]);
	}else if (api_cmd->len == 4){
		card->hw_iface.bus_write_4(
			card->hw,
			api_cmd->offset,
			*(u32*)&api_cmd->data[0]);
		card->hw_iface.poke(
			card->hw,
			api_cmd->offset,
			&api_cmd->data[0],
			api_cmd->len);
			(card->wandev.S514_cpu_no[0] == SDLA_CPU_A) ? 0x10 : 0x14,
			card->u.xilinx.bar,card->wandev.irq);
	card->hw_iface.pci_write_config_dword(card->hw,
			(card->wandev.S514_cpu_no[0] == SDLA_CPU_A) ? 0x10 : 0x14,
			card->u.xilinx.bar);
	card->hw_iface.pci_write_config_dword(card->hw, 0x3C, card->wandev.irq);
	card->hw_iface.pci_write_config_dword(card->hw, 0x0C, 0x0000ff00);
	if (!ifr || !ifr->ifr_data){
		return -EINVAL;
	if (WAN_COPY_FROM_USER(&api_cmd,ifr->ifr_data,sizeof(wan_cmd_api_t))){
		return -EFAULT;
	if (WAN_COPY_TO_USER(ifr->ifr_data,&api_cmd,sizeof(wan_cmd_api_t))){
		return -EFAULT;
			card->devname,__FUNCTION__);
	card->hw_iface.bus_read_4(card->hw,
        card->hw_iface.bus_read_4(card->hw,
        WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (!wan_test_bit(0,&chan->up)){
				card->devname,chan->if_name);
				card->devname,chan->if_name);
				card->devname,chan->if_name);
	if (card->fe.fe_cfg.cfg.te3_cfg.fractional){
		card->hw_iface.bus_read_4(card->hw,TE3_FRACT_ENCAPSULATION_REG,&reg);
				card->devname,
	reg|=(MAX_AFT_DMA_CHAINS-1)&DMA_CHAIN_TE3_MASK;
        card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
        WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (!wan_test_bit(0,&chan->up)){
				card->devname,chan->if_name);
				card->devname,chan->if_name);
		wan_clear_bit(0,&chan->idle_start);
       	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (!wan_test_bit(0,&chan->up)){
				card->devname,chan->if_name);
                xilinx_dma_rx(card,chan,-1);
		if (!chan->hdlc_eng) {
                                card->devname,chan->if_name);
     	card->hw_iface.bus_read_4(card->hw,
        card->hw_iface.bus_read_4(card->hw,
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	card->hw_iface.bus_read_4(card->hw,XILINX_DMA_CONTROL_REG,&reg);
		card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
		card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
		chan=(private_area_t*)card->u.xilinx.dev_to_ch_map[0];
		if (chan && wan_test_bit(0,&chan->up)){
			WAN_NETIF_STOP_QUEUE(chan->common.dev);
			WAN_TASKLET_KILL(&chan->common.bh_task);
		if (chan && wan_test_bit(0,&chan->up)){
			WAN_TASKLET_INIT((&chan->common.bh_task),0,wp_bh,(unsigned long)chan);
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	card->hw_iface.bus_read_4(card->hw,XILINX_DMA_CONTROL_REG,&reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
		wan_set_bit(CARD_DOWN,&card->wandev.critical);
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
	card->hw_iface.bus_write_4(card->hw,dma_descr, reg);
	if (IS_TE3(&card->fe.fe_cfg)) {
		WAN_FECALL(&card->wandev, read_alarm, (&card->fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE));
		WAN_FECALL(&card->wandev, read_pmon, (&card->fe, 0));
        card->hw_iface.bus_read_4(card->hw,XILINX_DMA_CONTROL_REG,&reg);
        card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
	card->hw_iface.bus_read_4(card->hw,XILINX_DMA_CONTROL_REG,&reg);
        card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
	wan_clear_bit(0,&chan->idle_start);
	WAN_NETIF_WAKE_QUEUE(chan->common.dev);
	if (chan->common.usedby == API){
	}else if (chan->common.usedby == STACK){
	if (!chan->single_dma_chain){
	card->hw_iface.bus_write_4(card->hw,reg_off,data);
       if (!chan || !wan_test_bit(0,&chan->up)) {
        	return -ENODEV;
       chan->common.state = state;
               wan_clear_bit(0,&chan->idle_start);
	       chan->opstats.link_active_count++;
    	       chan->opstats.link_inactive_modem_count++;
       	if (chan->common.usedby == API){
       	if (chan->common.usedby == STACK){
	chan->common.protocol = conf->protocol;
			wan_netif_name(dev), chan->common.protocol,
			chan->if_name);
	return -1;
	if (chan->common.protocol == WANCONFIG_PPP ||
	    chan->common.protocol == WANCONFIG_CHDLC){
		chan->common.prot_ptr = dev;
		if (chan->common.protocol == WANCONFIG_CHDLC){
					chan->if_name);
					chan->if_name);
			return -EINVAL;
	}else if (chan->common.protocol == WANCONFIG_GENERIC){
		chan->common.prot_ptr = dev;
				card->devname,chan->if_name,chan->common.protocol);
		return -EPROTONOSUPPORT;
	if (chan->common.protocol == WANCONFIG_PPP ||
	    chan->common.protocol == WANCONFIG_CHDLC){
		chan->common.prot_ptr = NULL;
	}else if (chan->common.protocol == WANCONFIG_GENERIC){
				card->devname, chan->if_name);
	if (chan->common.protocol == WANCONFIG_PPP ||
	    chan->common.protocol == WANCONFIG_CHDLC){
		wanpipe_generic_input(chan->common.dev, skb);
	if (chan->common.protocol == WANCONFIG_GENERIC){
		skb->protocol = htons(ETH_P_HDLC);
		skb->dev = chan->common.dev;
	skb->protocol = htons(ETH_P_IP);
	skb->dev = chan->common.dev;
				card->devname);
    	DEBUG_CFG("T3 Exar Chip Configuration. -- \n");
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
	if (card->fe.fe_cfg.cfg.te3_cfg.clock == WAN_MASTER_CLK){
	DEBUG_CFG("--- T3 Exar Chip Reset. -- \n");
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	if (IS_DS3(&card->fe.fe_cfg)){
		card->u.xilinx.num_of_time_slots=NUM_OF_T1_CHANNELS;
		if (card->fe.fe_cfg.frame == WAN_FR_DS3_Cbit){
	}else if (IS_E3(&card->fe.fe_cfg)){
		card->u.xilinx.num_of_time_slots=NUM_OF_E1_CHANNELS;
		if (card->fe.fe_cfg.frame == WAN_FR_E3_G832){
				card->devname);
		return -EINVAL;
	if (card->fe.fe_cfg.cfg.te3_cfg.fractional){
			card->devname, reg);
                	        card->devname, reg);
	DEBUG_CFG("--- T3 Exar Chip enable/config. -- \n");
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
			card->devname,
			FE_MEDIA_DECODE(&card->fe),
			(card->fe.fe_cfg.cfg.te3_cfg.clock == WAN_MASTER_CLK)?
			 card->adptr_subtype);
	if (card->wandev.fe_iface.config){
		err = card->wandev.fe_iface.config(&card->fe);
                               	card->devname,
                             	FE_MEDIA_DECODE(&card->fe));
             		return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
				card->devname,
			return -EINVAL;
				card->devname,
		return -EINVAL;
		card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
				err = -EINVAL;
					card->devname);
		card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
		card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
                                        card->devname,reg);
	reg|=(MAX_AFT_DMA_CHAINS-1)&DMA_CHAIN_TE3_MASK;
    	DEBUG_CFG("--- Setup DMA control Reg. -- \n");
	card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
	DEBUG_CFG("--- Tx/Rx global enable. -- \n");
	card->hw_iface.bus_write_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG,reg);
	card->hw_iface.bus_read_4(card->hw, XILINX_DMA_RX_INTR_PENDING_REG, &tmp);
	card->hw_iface.bus_read_4(card->hw, XILINX_DMA_TX_INTR_PENDING_REG, &tmp);
	card->hw_iface.bus_read_4(card->hw, XILINX_HDLC_RX_INTR_PENDING_REG, &tmp);
	card->hw_iface.bus_read_4(card->hw, XILINX_HDLC_TX_INTR_PENDING_REG, &tmp);
	card->hw_iface.bus_read_4(card->hw, XILINX_CHIP_CFG_REG, (u32*)&reg);
					card->devname);
		card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
					card->devname);
		card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
    	DEBUG_CFG("--- Set Global Interrupts (0x%X)-- \n",reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	DEBUG_CFG("--- Set Global Interrupt enabled. -- \n");
    	DEBUG_TEST("-- T3 Exar Dev Configure Xilinx. --\n");
	chan->logic_ch_num=0;
	chan->first_time_slot=0;
	card->u.xilinx.logic_ch_map=0x01;
	if (!card->u.xilinx.dev_to_ch_map[0]){
		card->u.xilinx.dev_to_ch_map[0]=(void*)chan;
	if (chan->single_dma_chain){
        	card->hw_iface.bus_read_4(card->hw,XILINX_DMA_CONTROL_REG,&reg);
        	card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
	if (chan->hdlc_eng){
		if (card->fe.fe_cfg.cfg.te3_cfg.fractional){
			DEBUG_EVENT("%s: Configuring for Fractional\n",card->devname);
		if (card->fe.fe_cfg.cfg.te3_cfg.fcs == 32){
                        card->devname,chan->if_name,
			card->fe.fe_cfg.cfg.te3_cfg.fcs);
	card->hw_iface.bus_write_4(card->hw, AFT_T3_RXTX_ADDR_SELECT_REG, reg1);
	if (card->fe.fe_cfg.cfg.te3_cfg.fractional){
                               chan->first_time_slot,
                               chan->first_time_slot,
	card->hw_iface.bus_write_4(card->hw, AFT_T3_RXTX_ADDR_SELECT_REG, reg1);
	if (card->fe.fe_cfg.cfg.te3_cfg.fractional){
                               chan->first_time_slot,
                               chan->first_time_slot,
	wan_spin_lock_irq(&card->wandev.lock,&flags);
	card->u.xilinx.dev_to_ch_map[0]=NULL;
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
		card->devname);
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	sdla_t *card = chan->card;
	if (wan_test_and_set_bit(TX_HANDLER_BUSY,&chan->dma_status)){
				chan->if_name,__FUNCTION__);
	dma_chain = &chan->tx_dma_chain_table[chan->tx_pending_chain_indx];
		if (!wan_test_bit(0,&dma_chain->init)){
		dma_descr=(chan->tx_pending_chain_indx<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
		card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
		DEBUG_TEST("%s: TX DMA Handler Chain %i\n",chan->if_name,dma_chain->index);
		if (dma_chain->skb){
			if (dma_chain->skb == chan->tx_idle_skb) {
				chan->if_stats.tx_carrier_errors++;
				wan_skb_set_csum(dma_chain->skb, reg);
				wan_skb_queue_tail(&chan->wp_tx_complete_list,dma_chain->skb);
			dma_chain->skb=NULL;
		if (chan->single_dma_chain){
		if (++chan->tx_pending_chain_indx >= MAX_AFT_DMA_CHAINS){
			chan->tx_pending_chain_indx=0;
		dma_chain = &chan->tx_dma_chain_table[chan->tx_pending_chain_indx];
	wan_clear_bit(TX_HANDLER_BUSY,&chan->dma_status);
	if (wan_skb_queue_len(&chan->wp_tx_complete_list)){
		WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
#define dma_descr   dma_chain->dma_descr
#define reg	    dma_chain->reg
#define len	    dma_chain->dma_len
#define dma_ch_indx dma_chain->index
#define len_align   dma_chain->len_align
#define card	    chan->card
                    __FUNCTION__,__LINE__,chan->logic_ch_num,dma_ch_indx,dma_descr);
	card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
				card->devname,dma_ch_indx,reg);
		card->hw_iface.bus_write_4(card->hw,dma_descr,0);
		return -EBUSY;
	reg=dma_chain->dma_addr;
			__FUNCTION__,reg,dma_chain->dma_addr,dma_descr);
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
        reg|=(chan->fifo_size_code&DMA_FIFO_SIZE_MASK)<<DMA_FIFO_SIZE_SHIFT;
        reg|=(chan->fifo_base_addr&DMA_FIFO_BASE_ADDR_MASK)<<
	if (chan->single_dma_chain){
					chan->if_name,dma_ch_indx);
	if (chan->hdlc_eng){
                 * non-transparent hdlc configuration */
			__FUNCTION__,reg,dma_chain->dma_addr,len);
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	++chan->if_stats.tx_fifo_errors;
	if (dma_chain->dma_addr){
		chan->card->hw_iface.pci_unmap_dma(chan->card->hw,
			 dma_chain->dma_addr,
	 		 dma_chain->dma_len,
	if (dma_chain->skb){
		if (dma_chain->skb != chan->tx_idle_skb) {
			wan_skb_free(dma_chain->skb);
		dma_chain->skb=NULL;
	dma_chain->dma_addr=0;
	dma_chain->dma_len=0;
	wan_clear_bit(0,&dma_chain->init);
	if (dma_chain->dma_addr){
		chan->card->hw_iface.pci_unmap_dma(chan->card->hw,
			 dma_chain->dma_addr,
	 		 dma_chain->dma_len,
	if (dma_chain->skb){
		aft_init_requeue_free_skb(chan,dma_chain->skb);
		dma_chain->skb=NULL;
	dma_chain->dma_addr=0;
	dma_chain->dma_len=0;
	wan_clear_bit(0,&dma_chain->init);
	if (len > chan->dma_mtu){
				chan->if_name,len,chan->dma_mtu);
		return -ENOMEM;
	if (!chan->tx_realign_buf){
		chan->tx_realign_buf=wan_malloc(chan->dma_mtu);
		if (!chan->tx_realign_buf){
						chan->if_name);
			return -ENOMEM;
						chan->if_name,chan->dma_mtu);
	memcpy(chan->tx_realign_buf,data,len);
				chan->if_name,wan_skb_tailroom(skb),len);
		return -ENOMEM;
		return -EINVAL;
	memcpy(data,chan->tx_realign_buf,len);
	if (wan_test_and_set_bit(TX_DMA_BUSY,&chan->dma_status)){
				chan->if_name,__FUNCTION__);
		return -EBUSY;
	if (chan->tx_chain_indx >= MAX_AFT_DMA_CHAINS){
				chan->if_name,chan->tx_chain_indx);
		if (!chan->single_dma_chain){
		return -EBUSY;
	dma_chain = &chan->tx_dma_chain_table[chan->tx_chain_indx];
	if (wan_test_and_set_bit(0,&dma_chain->init)){
		wan_clear_bit(TX_DMA_BUSY,&chan->dma_status);
		return -EBUSY;
	skb=wan_skb_dequeue(&chan->wp_tx_pending_list);
		if (!chan->hdlc_eng) {
			skb=chan->tx_idle_skb;
				 		card->devname);
				wan_clear_bit(0,&dma_chain->init);
				wan_clear_bit(TX_DMA_BUSY,&chan->dma_status);
			wan_clear_bit(0,&dma_chain->init);
			wan_clear_bit(TX_DMA_BUSY,&chan->dma_status);
					chan->if_name,wan_skb_data(skb));
			wan_clear_bit(0,&dma_chain->init);
			chan->if_stats.tx_errors++;
			return -EINVAL;
                        wan_clear_bit(0,&dma_chain->init);
                        chan->if_stats.tx_errors++;
                        return -EINVAL;
	dma_chain->skb=skb;
	dma_chain->dma_addr =
			      card->hw_iface.pci_map_dma(card->hw,
				  		wan_skb_data(dma_chain->skb),
				  		wan_skb_len(dma_chain->skb),
	dma_chain->dma_len = wan_skb_len(dma_chain->skb);
			chan->if_name,dma_chain->index,
			chan->tx_chain_indx,chan->tx_pending_chain_indx,
			wan_skb_len(dma_chain->skb));
	if (!chan->single_dma_chain &&
            !wan_test_bit(TX_INTR_PENDING,&chan->dma_chain_status)){
		int pending_indx=chan->tx_pending_chain_indx;
		if (chan->tx_chain_indx >= pending_indx){
			intr = ((MAX_AFT_DMA_CHAINS-(chan->tx_chain_indx -
			intr = ((pending_indx - chan->tx_chain_indx)<=2);
					chan->if_name,dma_chain->index);
			wan_set_bit(TX_INTR_PENDING,&chan->dma_chain_status);
				chan->if_name,dma_chain->index);
		chan->if_stats.tx_errors++;
		wan_clear_bit(TX_DMA_BUSY,&chan->dma_status);
		return -EINVAL;
	if (!chan->single_dma_chain){
		if (++chan->tx_chain_indx >= MAX_AFT_DMA_CHAINS){
			chan->tx_chain_indx=0;
		if (!wan_test_bit(TX_INTR_PENDING,&chan->dma_chain_status)){
	wan_clear_bit(TX_DMA_BUSY,&chan->dma_status);
#define dma_descr   dma_chain->dma_descr
#define reg	    dma_chain->reg
#define len	    dma_chain->dma_len
#define dma_ch_indx dma_chain->index
#define len_align   dma_chain->len_align
#define card	    chan->card
	reg=dma_chain->dma_addr;
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	if (chan->single_dma_chain){
		if (card->u.aft.firm_ver >= AFT_IFT_FIMR_VER) {
					chan->if_name,dma_ch_indx);
	if (chan->hdlc_eng){
		reg|=((chan->dma_mtu>>2)-1)&RxDMA_HI_DMA_DATA_LENGTH_MASK;
		reg|=(card->wandev.mtu>>2)&RxDMA_HI_DMA_DATA_LENGTH_MASK;
	reg|=(chan->fifo_size_code&DMA_FIFO_SIZE_MASK)<<DMA_FIFO_SIZE_SHIFT;
        reg|=(chan->fifo_base_addr&DMA_FIFO_BASE_ADDR_MASK)<<
 	             __FUNCTION__,reg,dma_chain->dma_addr,dma_descr);
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	if (wan_test_and_set_bit(RX_DMA_BUSY,&chan->dma_status)){
				chan->if_name,__FUNCTION__);
		return -EBUSY;
	if (chan->single_dma_chain) {
		free_queue_len=wan_skb_queue_len(&chan->wp_rx_free_list);
			free_queue_len=wan_skb_queue_len(&chan->wp_rx_free_list);
						card->devname,__FUNCTION__);
		card->hw_iface.bus_read_4(card->hw,AFT_TE3_CRNT_DMA_DESC_ADDR_REG,&reg);
		if (chan->rx_chain_indx >= cur_dma_ptr){
			max_dma_cnt = MAX_AFT_DMA_CHAINS - (chan->rx_chain_indx-cur_dma_ptr);
			max_dma_cnt = cur_dma_ptr - chan->rx_chain_indx;
				card->devname,
			card->devname,cur_dma_ptr,chan->rx_chain_indx,max_dma_cnt);
		dma_chain = &chan->rx_dma_chain_table[chan->rx_chain_indx];
		if (wan_test_and_set_bit(0,&dma_chain->init)){
					card->devname, __FUNCTION__, __LINE__,
					dma_chain->index);
			err=-EBUSY;
		dma_chain->skb=wan_skb_dequeue(&chan->wp_rx_free_list);
		if (!dma_chain->skb){
					chan->if_name,dma_chain->index,
					wan_skb_queue_len(&chan->wp_rx_complete_list),
					wan_skb_queue_len(&chan->wp_rx_free_list));
			wan_clear_bit(0,&dma_chain->init);
			err=-EINVAL;
		dma_chain->dma_addr =
				      card->hw_iface.pci_map_dma(card->hw,
			      	       		wan_skb_tail(dma_chain->skb),
						chan->dma_mtu,
		dma_chain->dma_len  = chan->dma_mtu;
		if (!wan_test_bit(RX_INTR_PENDING,&chan->dma_chain_status)){
			free_queue_len--;
					card->devname);
				if (chan->rx_chain_indx >= cur_dma_ptr){
					intr = ((MAX_AFT_DMA_CHAINS -
						(chan->rx_chain_indx-cur_dma_ptr)) <=4);
					intr = ((cur_dma_ptr - chan->rx_chain_indx)<=4);
					chan->if_name,dma_chain->index);
				wan_set_bit(RX_INTR_PENDING,&chan->dma_chain_status);
					chan->if_name,dma_chain->index, intr);
					chan->if_name,dma_chain->index);
			chan->if_stats.rx_dropped++;
		if (chan->single_dma_chain){
		if (++chan->rx_chain_indx >= MAX_AFT_DMA_CHAINS){
			chan->rx_chain_indx=0;
	if (!chan->single_dma_chain){
	wan_clear_bit(RX_DMA_BUSY,&chan->dma_status);
	sdla_t *card = chan->card;
	if (wan_test_and_set_bit(RX_HANDLER_BUSY,&chan->dma_status)){
				chan->if_name,__FUNCTION__);
		wan_clear_bit(RX_INTR_PENDING,&chan->dma_chain_status);
	card->hw_iface.bus_read_4(card->hw,AFT_TE3_CRNT_DMA_DESC_ADDR_REG,&reg);
			card->devname,
			chan->rx_chain_indx,max_dma_cnt);
		dma_chain = &chan->rx_dma_chain_table[chan->rx_pending_chain_indx];
		if (!wan_test_bit(0,&dma_chain->init)){
				chan->if_name,__FUNCTION__,dma_chain->index);
		dma_descr=(dma_chain->index<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
		card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
				chan->if_name,__FUNCTION__,dma_chain->index);
		card->hw_iface.pci_unmap_dma(card->hw,
				 dma_chain->dma_addr,
				 chan->dma_mtu,
		rx_el=(wp_rx_element_t *)wan_skb_push(dma_chain->skb, sizeof(wp_rx_element_t));
		chan->if_stats.rx_frame_errors++;
		dma_descr=(dma_chain->index<<4) + XILINX_RxDMA_DESCRIPTOR_LO;
		card->hw_iface.bus_read_4(card->hw,dma_descr, &rx_el->align);
		rx_el->align&=RxDMA_LO_ALIGNMENT_BIT_MASK;
    		dma_descr=(dma_chain->index<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
		card->hw_iface.bus_read_4(card->hw,dma_descr, &rx_el->reg);
                	chan->errstats.Rx_pci_errors++;
                	chan->if_stats.rx_errors++;
			wan_skb_pull(dma_chain->skb, sizeof(wp_rx_element_t));
			aft_init_requeue_free_skb(chan, dma_chain->skb);
			dma_chain->skb=NULL;
			rx_el->pkt_error= dma_chain->pkt_error;
			rx_el->dma_addr = dma_chain->dma_addr;
			wan_skb_queue_tail(&chan->wp_rx_complete_list,dma_chain->skb);
					chan->if_name,dma_chain->index,
					wan_skb_queue_len(&chan->wp_rx_complete_list),
					rx_el->align,rx_el->reg,
					(*(unsigned char*)wan_skb_data(dma_chain->skb)),
					wan_skb_len(dma_chain->skb));
		dma_chain->skb=NULL;
		dma_chain->dma_addr=0;
		dma_chain->dma_len=0;
		dma_chain->pkt_error=0;
		wan_clear_bit(0,&dma_chain->init);
		if (chan->single_dma_chain){
		if (++chan->rx_pending_chain_indx >= MAX_AFT_DMA_CHAINS){
			chan->rx_pending_chain_indx=0;
	if (wan_skb_queue_len(&chan->wp_rx_complete_list)){
		DEBUG_TEST("%s: Rx Queued list triggering\n",chan->if_name);
		WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
		chan->rx_no_data_cnt=0;
	if (!chan->single_dma_chain){
		if ((chan->rx_no_data_cnt >= 0)  && (++chan->rx_no_data_cnt < 3)){
					chan->if_name);
			chan->rx_no_data_cnt=-1;
	wan_clear_bit(RX_HANDLER_BUSY,&chan->dma_status);
		chan->tx_dma_chain_table[i].index=i;
		chan->rx_dma_chain_table[i].index=i;
	sdla_t *card=chan->card;
	if (chan->single_dma_chain){
        	card->hw_iface.bus_write_4(card->hw,tx_dma_descr,reg);
		card->hw_iface.bus_write_4(card->hw,rx_dma_descr,reg);
		aft_tx_dma_chain_init(chan,&chan->tx_dma_chain_table[i]);
		aft_tx_dma_chain_init(chan,&chan->rx_dma_chain_table[i]);
#define dma_ch_indx dma_chain->index
#define card	    chan->card
	if (!wan_test_bit(0,&dma_chain->init)){
			chan->if_name,__FUNCTION__,dma_chain->index);
	card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
			chan->if_name,__FUNCTION__,dma_chain->index);
				chan->if_name,dma_ch_indx,len,dma_chain->dma_len);
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	m->count =
		WAN_FECALL(&card->wandev, update_alarm_info, (&card->fe, m, stop_cnt));
	m->count =
		WAN_FECALL(&card->wandev, update_pmon_info, (&card->fe, m, stop_cnt));
	return m->count;
	while((skb=wan_skb_dequeue(&chan->wp_rx_complete_list)) != NULL){
		chan->if_stats.rx_dropped++;
	sdla_t *card=chan->card;
	card->hw_iface.bus_read_4(card->hw,AFT_TE3_CRNT_DMA_DESC_ADDR_REG,&reg);
	DEBUG_EVENT("%s: List Descritpors:\n",chan->if_name);
			chan->if_name,
			chan->dma_chain_status,
			chan->tx_chain_indx,
			chan->tx_pending_chain_indx,
			chan->rx_chain_indx,
			chan->rx_pending_chain_indx,
			wan_skb_queue_len(&chan->wp_rx_complete_list),
                        wan_skb_queue_len(&chan->wp_rx_free_list));
		dma_chain = &chan->rx_dma_chain_table[i];
		dma_descr=(dma_chain->index<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
		card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
				chan->if_name,
				dma_chain->index,
				dma_chain->init,
				dma_chain->dma_addr?"Yes":"No",
			        dma_chain->skb?"Yes":"No");
	sdla_t *card=chan->card;
	card->hw_iface.bus_read_4(card->hw,AFT_TE3_CRNT_DMA_DESC_ADDR_REG,&reg);
	card->hw_iface.bus_read_4(card->hw,XILINX_DMA_CONTROL_REG,&dma_ctrl);
	DEBUG_EVENT("%s: List TX Descritpors:\n",chan->if_name);
			chan->if_name,
			chan->dma_chain_status,
			chan->tx_chain_indx,
			chan->tx_pending_chain_indx,
			wan_skb_queue_len(&chan->wp_tx_pending_list),
			wan_skb_queue_len(&chan->wp_tx_complete_list),
			wan_skb_queue_len(&chan->wp_tx_free_list),
		dma_chain = &chan->tx_dma_chain_table[i];
		dma_descr=(dma_chain->index<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
		card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
		dma_descr=(dma_chain->index<<4) + XILINX_TxDMA_DESCRIPTOR_LO;
		card->hw_iface.bus_read_4(card->hw,dma_descr,&low);
				chan->if_name,
				dma_chain->index,
				dma_chain->init,
				dma_chain->dma_addr?"Yes":"No",
			        dma_chain->skb?"Yes":"No",
	sdla_t *card=chan->card;
		dma_chain = &chan->rx_dma_chain_table[i];
		dma_descr=(dma_chain->index<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
		card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
		card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
		aft_rx_dma_chain_init(chan,&chan->rx_dma_chain_table[i]);
		dma_chain->skb=NULL;
		dma_chain->dma_addr=0;
		dma_chain->dma_len=0;
		dma_chain->pkt_error=0;
		wan_clear_bit(0,&dma_chain->init);
			chan->if_name,
			wan_skb_queue_len(&chan->wp_rx_complete_list),
			wan_skb_queue_len(&chan->wp_rx_free_list));
	sdla_t *card=chan->card;
	card->hw_iface.bus_read_4(card->hw,AFT_TE3_CRNT_DMA_DESC_ADDR_REG,&reg);
	if (chan->single_dma_chain){
       	chan->rx_pending_chain_indx = chan->rx_chain_indx = cur_dma_ptr;
	sdla_t *card=chan->card;
	card->hw_iface.bus_read_4(card->hw,AFT_TE3_CRNT_DMA_DESC_ADDR_REG,&reg);
	if (chan->single_dma_chain){
	chan->tx_pending_chain_indx = chan->tx_chain_indx = cur_dma_ptr;
	sdla_t *card=chan->card;
	DEBUG_TEST("%s:%s: Tx: Freeing Descripors\n",card->devname,chan->if_name);
	wan_clear_bit(TX_INTR_PENDING,&chan->dma_chain_status);
	wan_clear_bit(TX_DMA_BUSY,&chan->dma_status);
		dma_chain = &chan->tx_dma_chain_table[i];
		dma_descr=(dma_chain->index<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
		card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	while((skb=wan_skb_dequeue(&chan->wp_tx_complete_list)) != NULL){
	if (card->adptr_subtype == AFT_SUBTYPE_SHARK) {
				wan_clear_bit(0,&card->u.aft.led_ctrl);
				wan_clear_bit(2,&card->u.aft.led_ctrl);
				wan_set_bit(0,&card->u.aft.led_ctrl);
				wan_set_bit(2,&card->u.aft.led_ctrl);
				wan_clear_bit(1,&card->u.aft.led_ctrl);
				wan_clear_bit(3,&card->u.aft.led_ctrl);
				wan_set_bit(1,&card->u.aft.led_ctrl);
				wan_set_bit(3,&card->u.aft.led_ctrl);
		write_cpld(card,0x00,card->u.aft.led_ctrl);
		card->hw_iface.bus_read_4(card->hw,TE3_LOCAL_CONTROL_STATUS_REG,&reg);
		card->hw_iface.bus_write_4(card->hw,TE3_LOCAL_CONTROL_STATUS_REG,reg);
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
			card->devname,card->u.aft.port_task_cmd);
	if (wan_test_bit(AFT_FE_INTR,&card->u.aft.port_task_cmd)){
		card->hw_iface.hw_lock(card->hw,&smp_flags);
		wan_spin_lock_irq(&card->wandev.lock,&isr_flags);
		wan_clear_bit(AFT_FE_INTR,&card->u.aft.port_task_cmd);
		wan_spin_unlock_irq(&card->wandev.lock,&isr_flags);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
	if (wan_test_bit(AFT_FE_POLL,&card->u.aft.port_task_cmd)){
		card->hw_iface.hw_lock(card->hw,&smp_flags);
		wan_spin_lock_irq(&card->wandev.lock,&isr_flags);
		WAN_FECALL(&card->wandev, polling, (&card->fe));
		wan_clear_bit(AFT_FE_POLL,&card->u.aft.port_task_cmd);
		wan_spin_unlock_irq(&card->wandev.lock,&isr_flags);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
	if (wan_test_bit(AFT_FE_LED,&card->u.aft.port_task_cmd)){
		card->hw_iface.hw_lock(card->hw,&smp_flags);
		wan_spin_lock_irq(&card->wandev.lock,&isr_flags);
		if (card->wandev.state == WAN_CONNECTED){
		wan_clear_bit(AFT_FE_LED,&card->u.aft.port_task_cmd);
		wan_spin_unlock_irq(&card->wandev.lock,&isr_flags);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
			card->devname);
			card->devname);
	if (IS_TE3(&card->fe.fe_cfg)) {
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
	wan_set_bit(CARD_DOWN,&card->wandev.critical);
	card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_TX_INTR_PENDING_REG,&reg);
      	card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_RX_INTR_PENDING_REG,&reg);
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
		card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_TX_INTR_PENDING_REG,&reg);
 	     	card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_RX_INTR_PENDING_REG,&reg);
		card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
			card->devname);
./sdla_aft_te3.c
 * 4. Neither the name of the author nor the names of any co-contributors
 *	$Id: sdla_te1.c,v 1.287 2008-03-28 13:49:53 sangoma Exp $
/* Read/Write to front-end register */
		current_val=fe->read_fe_reg(				\
			((sdla_t*)fe->card)->hw,			\
			(int)(((sdla_t*)fe->card)->wandev.state==WAN_CONNECTED),		\
			(int)fe->fe_cfg.line_no,			\
			(int)((reg) + (fe->fe_cfg.line_no*PMC4_LINE_DELTA)));\
				fe->name,(unsigned char)(reg),(unsigned char)(val),current_val);\
	fe->write_fe_reg(						\
		((sdla_t*)fe->card)->hw,			\
		(int)(((sdla_t*)fe->card)->wandev.state==WAN_CONNECTED),		\
		(int)fe->fe_cfg.line_no,				\
		(int)((reg) + (fe->fe_cfg.line_no*PMC4_LINE_DELTA)),	\
	fe->write_fe_reg(						\
		((sdla_t*)fe->card)->hw,			\
		(int)(((sdla_t*)fe->card)->wandev.state==WAN_CONNECTED),		\
	fe->read_fe_reg(						\
		((sdla_t*)fe->card)->hw,			\
		(int)(((sdla_t*)fe->card)->wandev.state==WAN_CONNECTED),		\
		(int)fe->fe_cfg.line_no,				\
		(int)((reg) + (fe->fe_cfg.line_no*PMC4_LINE_DELTA)))
	fe->read_fe_reg(						\
		((sdla_t*)fe->card)->hw,			\
		(int)(((sdla_t*)fe->card)->wandev.state==WAN_CONNECTED),		\
typedef unsigned char TX_WAVEFORM[LAST_SAMPLE-FIRST_SAMPLE+1][LAST_UI-FIRST_UI+1];
 * unsigned char t1_tx_waveform_lh_0db[LAST_SAMPLE-FIRST_SAMPLE+1][LAST_UI-FIRST_UI+1] = 
 * unsigned char t1_tx_waveform_lh_75db[LAST_SAMPLE-FIRST_SAMPLE+1][LAST_UI-FIRST_UI+1] = 
 * unsigned char t1_tx_waveform_lh_15db[LAST_SAMPLE-FIRST_SAMPLE+1][LAST_UI-FIRST_UI+1] = 
 * unsigned char t1_tx_waveform_lh_225db[LAST_SAMPLE-FIRST_SAMPLE+1][LAST_UI-FIRST_UI+1] = 
/* Transmit Waveform Values for T1 Short Haul (0 - 110 ft.)
 * unsigned char t1_tx_waveform_sh_110ft[LAST_SAMPLE-FIRST_SAMPLE+1][LAST_UI-FIRST_UI+1] = 
/* Transmit Waveform Values for T1 Short Haul (110 - 220 ft.)
 * unsigned char t1_tx_waveform_sh_220ft[LAST_SAMPLE-FIRST_SAMPLE+1][LAST_UI-FIRST_UI+1] = 
/* Transmit Waveform Values for T1 Short Haul (220 - 330 ft.)
 * unsigned char t1_tx_waveform_sh_330ft[LAST_SAMPLE-FIRST_SAMPLE+1][LAST_UI-FIRST_UI+1] = 
/* Transmit Waveform Values for T1 Short Haul (330 - 440 ft.)
 * unsigned char t1_tx_waveform_sh_440ft[LAST_SAMPLE-FIRST_SAMPLE+1][LAST_UI-FIRST_UI+1] = 
/* Transmit Waveform Values for T1 Short Haul (440 - 550 ft.)
 * unsigned char t1_tx_waveform_sh_550ft[LAST_SAMPLE-FIRST_SAMPLE+1][LAST_UI-FIRST_UI+1] = 
/* Transmit Waveform Values for T1 Short Haul (550 - 660 ft.)
 * unsigned char t1_tx_waveform_sh_660ft[LAST_SAMPLE-FIRST_SAMPLE+1][LAST_UI-FIRST_UI+1] = 
 * unsigned char e1_tx_waveform_120[LAST_SAMPLE-FIRST_SAMPLE+1][LAST_UI-FIRST_UI+1] = 
 * unsigned char e1_tx_waveform_75[LAST_SAMPLE-FIRST_SAMPLE+1][LAST_UI-FIRST_UI+1] = 
	return fe->fe_cfg.media;
* Description	: Get current FE line state - is it Connected or Disconnected
* Arguments	: fe - pointer to Front End structure.	
*		  status - pointer to location where the FE line state will
*		  notused - ignored 
	*status = fe->fe_status;
			if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
			if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
			if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
			if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
			if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
			if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
			if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
			if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
			if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
			if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
			if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
		if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
	if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
	if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
	if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
 * Arguments:   is_e1 - WAN_TRUE for E1 connection, WAN_FALSE for T1 connection.
			DEBUG_EVENT("%s: Configure for High-Impedance Mode!\n",
					fe->name);
			if (fe->fe_cfg.cfg.te_cfg.te_rbs_ch & (1 << (channel -1))){
 * Arguments:   reg   - Offset in TPSC indirect space.
 *				value - New PMC register value.
					fe->name, reg, value);
				fe->name, reg, value);
 * Arguments:   reg   - Offset in TPSC indirect space.
					fe->name, reg);
					fe->name, reg);
 * Arguments:   reg   - Offset in RPSC indirect space.
 *		value - New PMC register value.
						fe->name, reg, value);
						fe->name, reg, value);
 * Arguments:   reg   - Offset in RPSC indirect space.
						fe->name, reg);
						fe->name, reg);
 * Arguments:   reg   - Offset in SIGX indirect space.
 *		value - New PMC register value.
	reg += (IS_T1_FEMEDIA(fe) ? (channel - 1) : channel);
						fe->name, reg, value);
						fe->name, reg, value);
 * Arguments:   reg   - Offset in SIGX indirect space.
		offset = (channel > 16) ? channel - 16 : channel;
		offset = (channel > 16) ? channel - 17 : channel - 1;
						fe->name, reg);
						fe->name, reg);
	DEBUG_TE1("%s: Enable Tx on channel %d\n", fe->name, channel);
		/* Set SUBS=DS[0]=DS[1]=0x0 - no change to PCM timeslot data */
		if (fe->fe_cfg.cfg.te_cfg.te_rbs_ch & (1 << (channel -1))){
	DEBUG_TE1("%s: Enable Rx on channel %d\n", fe->name, channel);
	DEBUG_TE1("%s: Disable Tx on channel %d\n", fe->name, channel);
		/* Set SUBS=1, DS0=0 - data substitution on - IDLE code replaces BTPCM timeslot data */
		if (fe->fe_cfg.cfg.te_cfg.te_rbs_ch & (1 << (channel -1))){
	DEBUG_TE1("%s: Disable Rx on channel %d\n", fe->name, channel);
		fe_cfg->media			= WAN_MEDIA_E1;
		fe_cfg->lcode			= WAN_LCODE_HDB3;
		fe_cfg->frame			= WAN_FR_NCRC4;
		fe_cfg->cfg.te_cfg.lbo		= WAN_E1_120;
		fe_cfg->cfg.te_cfg.te_clock	= WAN_NORMAL_CLK;
		fe_cfg->cfg.te_cfg.active_ch	= ENABLE_ALL_CHANNELS;
		fe_cfg->media			= WAN_MEDIA_T1;
		fe_cfg->lcode			= WAN_LCODE_B8ZS;
		fe_cfg->frame			= WAN_FR_ESF;
		fe_cfg->cfg.te_cfg.lbo		= WAN_T1_LBO_0_DB;
		fe_cfg->cfg.te_cfg.te_clock	= WAN_NORMAL_CLK;
		fe_cfg->cfg.te_cfg.active_ch	= ENABLE_ALL_CHANNELS;
		fe_cfg->cfg.te_cfg.high_impedance_mode	= WANOPT_NO;
		return -EINVAL;
 * Description: Inialize Front-End interface functions.
	fe_iface->reset			= &sdla_te_reset;
	fe_iface->global_config		= &sdla_te_global_config;
	fe_iface->global_unconfig	= &sdla_te_global_unconfig;
	fe_iface->config		= &sdla_te_config;
	fe_iface->post_init		= &sdla_te_post_init;
	fe_iface->reconfig		= &sdla_te_reconfig;
	fe_iface->unconfig		= &sdla_te_unconfig;
	fe_iface->pre_release		= &sdla_te_pre_release;
	fe_iface->isr			= &sdla_te_intr;
	fe_iface->disable_irq		= &sdla_te_disable_irq;
	fe_iface->check_isr		= &sdla_te_check_intr;
	fe_iface->polling		= &sdla_te_polling;
	fe_iface->process_udp		= &sdla_te_udp;
	fe_iface->print_fe_alarm	= &sdla_te_print_alarms;
	fe_iface->print_fe_act_channels	= &sdla_te_print_channels;
	fe_iface->set_fe_alarm		= &sdla_te_set_alarms;
	fe_iface->set_fe_sigctrl	= &sdla_te_sigctrl;
	fe_iface->read_alarm		= &sdla_te_read_alarms;
	fe_iface->read_pmon		= &sdla_te_pmon;
	fe_iface->flush_pmon		= &sdla_te_flush_pmon;
	fe_iface->get_fe_status		= &sdla_te_get_fe_status;
	fe_iface->get_fe_media		= &sdla_te_get_fe_media;
	fe_iface->set_fe_lbmode		= &sdla_te_set_lbmode;
	fe_iface->get_fe_media_string	= &sdla_te_get_fe_media_string;
	fe_iface->update_alarm_info	= &sdla_te_update_alarm_info;
	fe_iface->update_pmon_info	= &sdla_te_update_pmon_info;
	fe_iface->led_ctrl		= &sdla_te_led_ctrl;
	fe_iface->check_rbsbits		= &sdla_te_check_rbsbits;
	fe_iface->read_rbsbits		= &sdla_te_read_rbsbits;
	fe_iface->set_rbsbits		= &sdla_te_set_rbsbits;
	fe_iface->report_rbsbits	= &sdla_te_rbs_report;
	fe_iface->get_snmp_data		= &sdla_te_get_snmp_data;
	fe->fe_status = FE_UNITIALIZED;		/*FE_DISCONNECTED;*/
	WAN_LIST_INIT(&fe->event);
	wan_spin_lock_irq_init(&fe->lockirq, "wan_te1_lock");
		memcpy(&fe->fe_cfg, fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_te_default_cfg(fe, &fe->fe_cfg, WAN_MEDIA_T1);
 * 		Note: 	These register should be program only once for AFT-QUAD
 * Returns:	WANTRUE - TE1 configred successfully, otherwise WAN_FALSE.
 * 		Note: 	These register should be program only once for AFT-QUAD
 * Returns:	WANTRUE - TE1 configred successfully, otherwise WAN_FALSE.
			fe->name, FE_MEDIA_DECODE(fe));
 * Returns:	WANTRUE - TE1 configred successfully, otherwise WAN_FALSE.
	fe->te_param.xlpg_scale = PrgTransmitTemplate(fe);
		DEBUG_EVENT("%s:    Disable TX (tri-state mode)\n",
					fe->name);
		WRITE_REG(REG_XLPG_LINE_CFG, fe->te_param.xlpg_scale);
		/* RX-ELST Configuration (Reg. 0x1C) */
		/* TX-ELST Configuration (Reg. 0x20) */
		/* RX-ELST Configuration (Reg. 0x1C) */
		/* TX-ELST Configuration (Reg. 0x20) */
		/* E1-TRAN Configuration (Reg. 0x80) */
		/* E1-FRMR Frame Alignment Options (Reg 0x90) */
		/* T1-XBAS Configuration (Reg 0x54) */
		/* T1-FRMR Configuration (Reg. 0x48) */
	/* BRIF Parity/F-bit Configuration (Reg. 0x32) */
 * Returns:	WANTRUE - TE1 configred successfully, otherwise WAN_FALSE.
		/* RX-ELST Configuration (Reg. 0xQ1C) */
		/* TX-ELST Configuration (Reg. 0xQ20) */
		/* RX-ELST Configuration (Reg. 0xQ1C) */
		/* TX-ELST Configuration (Reg. 0xQ20) */
		/* E1-TRAN Configuration (Reg. 0xQ80) */
		/* E1-FRMR Frame Alignment Options (Reg 0xQ90) */
		/* T1-XBAS Configuration (Reg 0xQ54) */
		/* T1-FRMR Configuration (Reg. 0xQ48) */
	/* BRIF Parity/F-bit Configuration (Reg. 0xQ32) */
	fe->te_param.xlpg_scale = PrgTransmitTemplate(fe);
		DEBUG_EVENT("%s:    Disable TX (tri-state mode)\n",
					fe->name);
		WRITE_REG(REG_XLPG_LINE_CFG, fe->te_param.xlpg_scale);
** Description: Verify T1 Front-End configuration
** Returns:     0 - successfully, otherwise -EINVAL.
						fe->name);
						fe->name,
		return -EINVAL;
						fe->name);
						fe->name,
		return -EINVAL;
						fe->name);
						fe->name,
		return -EINVAL;
** Description: Verify E1 Front-End configuration
** Returns:     0 - successfully, otherwise -EINVAL.
					fe->name);
					fe->name,
		return -EINVAL;
					fe->name);
					fe->name,
		return -EINVAL;
					fe->name);
					fe->name,
		return -EINVAL;
					fe->name);
					fe->name,
		return -EINVAL;
	sdla_t*		card = (sdla_t*)fe->card;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &adapter_type);
	fe->te_param.max_channels = 
	//fe->te_param.lb_rx_code = LINELB_DS1LINE_DISABLE;
	switch(fe->fe_chip_id){
				fe->name, (fe->fe_chip_id >> 5));
		return -EINVAL;
		DEBUG_EVENT("%s: All channels enabled\n", fe->name);
			if (WAN_TE1_ACTIVE_CH(fe) & (1 << (i - 1))){
						fe->name, i-1);
				EnableTxChannel(fe, i-1);
				EnableRxChannel(fe, i-1);
 * Returns:	WANTRUE - TE1 configred successfully, otherwise WAN_FALSE.
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	memset(&fe->te_param, 0, sizeof(sdla_te_param_t));
	fe->fe_chip_id = value & MASK_CHIP_ID;
	switch(fe->fe_chip_id){
		fe->fe_cfg.line_no = 0;
					fe->name,
			return -EINVAL;
				fe->name, 
				(fe->fe_chip_id >> 5));
		return -EINVAL;
					fe->name,
		err =-EINVAL;
	if (err) return -EINVAL;
				fe->name, 
				DECODE_CHIPID(fe->fe_chip_id),
				fe->name, 
				fe->name, 
					fe->name, 
				fe->name, WAN_TE1_ACTIVE_CH(fe));
		return -EINVAL;
		DEBUG_EVENT("%s: Failed to configure %s Front-End chip!\n",
					fe->name,
		return -EINVAL;
	wan_set_bit(TE_CONFIGURED,(void*)&fe->te_param.critical);
					fe->name);
			/* E1-TRAN Configuration (Reg. 0x80) */
			/* E1-FRMR Frame Alignment Options (Reg 0x90) */
					fe->name);
			/* E1-TRAN Configuration (Reg. 0x80) */
			/* E1-FRMR Frame Alignment Options (Reg 0x90) */
	wan_set_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical);
		&fe->timer, 
	wan_clear_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical);
	wan_clear_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical);
	wan_set_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical);
	if (wan_test_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical)){
		wan_del_timer(&fe->timer);
	wan_clear_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical);	
		wan_spin_lock_irq(&fe->lockirq,&smp_flags);
		if (!WAN_LIST_EMPTY(&fe->event)){
			fe_event = WAN_LIST_FIRST(&fe->event);
		wan_spin_unlock_irq(&fe->lockirq,&smp_flags);
				fe->name,
				fe->name,
		if (fe->fe_status == FE_CONNECTED){
			 			 fe->name); 
			 			 fe->name); 
	if (card->wandev.te_signaling_config){
		err=card->wandev.te_signaling_config(card,timeslot_map);
		err=card->wandev.te_read_signaling_config(card);
 * 		Note: 	These register should be program only once for AFT-QUAD
 * Returns:	WANTRUE - TE1 configred successfully, otherwise WAN_FALSE.
				fe->name,
	if (!wan_test_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical)){
		DEBUG_EVENT("%s: %s(): Front-End timer is not stopped!\n",
					fe->name, __FUNCTION__);
		return -EINVAL;
	if (!wan_test_bit(TE_CONFIGURED,(void*)&fe->te_param.critical)){
		return -EINVAL;
	wan_clear_bit(TE_CONFIGURED,(void*)&fe->te_param.critical);
	if (!wan_test_bit(TE_CONFIGURED,(void*)&fe->te_param.critical)){
		return -EINVAL;
	switch(fe->fe_chip_id){
	if (fe->fe_cfg.cfg.te_cfg.ignore_yel_alarm == WANOPT_NO){
	sdla_t		*card = (sdla_t*)fe->card;
	unsigned char	curr_fe_status = fe->fe_status;
		if (fe->fe_status != FE_DISCONNECTED){
			fe->fe_status = FE_DISCONNECTED;
		}else if (fe->te_param.tx_yel_alarm && valid_rx_alarms & WAN_TE_BIT_RAI_ALARM){
		if (fe->fe_status != FE_CONNECTED){
			if (fe->te_param.tx_yel_alarm){
			fe->fe_status = FE_CONNECTED;
	if (curr_fe_status != fe->fe_status){
		if (fe->fe_status == FE_CONNECTED){
					fe->name,
					fe->name,
		if (card->wandev.te_report_alarms){
			card->wandev.te_report_alarms(card, alarms);
			if (WAN_TE1_ACTIVE_CH(fe) & (1 << (i - 1))){
							sprintf(&channels[strlen(channels)], ",%d-%d", 
									start_channel, i-1);
							sprintf(&channels[strlen(channels)], "%d-%d",
									start_channel, i-1);
	sdla_fe_cfg_t* fe_cfg = &fe->fe_cfg;
		if ((active_ch & (1 << (i - 1))) != 
		    (WAN_TE1_ACTIVE_CH(fe) & (1 << (i - 1)))){
			if (active_ch & (1 << (i - 1))) {
 * Returns:		bit 0 - ALOS	(E1/T1)
 *			bit 1 - LOS	(E1/T1)
 *			bit 2 - ALTLOS	(E1/T1)
 *			bit 3 - OOF	(E1/T1)
 *			bit 4 - RED	(E1/T1)
 *			bit 5 - AIS	(E1/T1)
 *			bit 6 - OOSMF	(E1)
 *			bit 7 - OOCMF	(E1)
 *			bit 8 - OOOF	(E1)
 *			bit 9 - RAI	(E1)
 *			bit A - YEL	(T1)
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
		fe->fe_alarm = new_alarms;
		sdla_te_print_alarms(fe, fe->fe_alarm);
	return fe->fe_alarm;
		alarms = fe->fe_alarm; 
				fe->name,
			fe->name,
		DEBUG_EVENT("%s:    ALOS   : ON\n", fe->name);
		DEBUG_EVENT("%s:    LOS    : ON\n", fe->name);
		DEBUG_EVENT("%s:    ALTLOS : ON\n", fe->name);
		DEBUG_EVENT("%s:    OOF    : ON\n", fe->name);
		DEBUG_EVENT("%s:    RAI    : ON\n", fe->name);
		DEBUG_EVENT("%s:    RED    : ON\n", fe->name);
		DEBUG_EVENT("%s:    AIS    : ON\n", fe->name);
		DEBUG_EVENT("%s:    YEL    : ON\n", fe->name);
		    fe->fe_cfg.cfg.te_cfg.ignore_yel_alarm == WANOPT_NO){
							fe->name);
				fe->te_param.tx_yel_alarm = 1;
		    fe->fe_cfg.cfg.te_cfg.ignore_yel_alarm == WANOPT_NO){
						fe->name);
				fe->te_param.tx_yel_alarm = 0;
	sdla_te_pmon_t	*pmon = &fe->fe_stats.te_pmon;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	pmon->mask = 0x00;
	pmon->mask |= WAN_TE_BIT_PMON_LCV;
		pmon->lcv_errors += pmon4;
		pmon->mask |= WAN_TE_BIT_PMON_FER;
		pmon->fer_errors	+= pmon1;
		pmon->mask |= WAN_TE_BIT_PMON_OOF;
		pmon->oof_errors	+= pmon2;
		pmon->mask |= WAN_TE_BIT_PMON_BEE;
		pmon->bee_errors	+= pmon3;
		pmon->mask |= WAN_TE_BIT_PMON_FAS;
		pmon->fas_errors	+= pmon1;
		pmon->mask |= WAN_TE_BIT_PMON_FEB;
		pmon->feb_errors	+= pmon2;
		pmon->mask |= WAN_TE_BIT_PMON_CRC4;
		pmon->crc4_errors	+= pmon3;
	fe->fe_stats.te_pmon.lcv_errors = 0;
	fe->fe_stats.te_pmon.fer_errors = 0;
	fe->fe_stats.te_pmon.oof_errors = 0;
	fe->fe_stats.te_pmon.bee_errors = 0;
	fe->fe_stats.te_pmon.fas_errors = 0;
	fe->fe_stats.te_pmon.feb_errors = 0;
	fe->fe_stats.te_pmon.crc4_errors = 0;
 * Arguments: 	card 		- pointer to device structure.
 * 		write_register 	- write register function.
 * 		read_register	- read register function.
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	if (!wan_test_bit(TE_CONFIGURED,(void*)&fe->te_param.critical)){
	if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
					fe->name,
	unsigned char	status = fe->fe_status; 
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	if (fe->fe_chip_id == CHIP_ID_COMET_QUAD){
					fe->name,
	fe->te_param.intr_src1 = READ_REG(REG_INT_SRC_1);
	fe->te_param.intr_src2 = READ_REG(REG_INT_SRC_2);
	fe->te_param.intr_src3 = READ_REG(REG_INT_SRC_3);
			fe->name,
			fe->te_param.intr_src1,
			fe->te_param.intr_src2,
			fe->te_param.intr_src3);
	if (fe->te_param.intr_src1 == 0 &&
	    fe->te_param.intr_src2 == 0 && 
	    fe->te_param.intr_src3 == 0){
				fe->name, 
			fe->name,fe->fe_alarm);
	sdla_te_set_status(fe, fe->fe_alarm);
	if (status != fe->fe_status){
		if (fe->fe_status != FE_CONNECTED){
	if (fe->fe_status==FE_CONNECTED){
		DEBUG_EVENT("%s: FE Interrupt triggering poll!\n",fe->name);
 * Arguments: 	card		- pointer to device structure.
 * 		write_register	- write register function.
 * 		read_register	- read register function.
	if (!(fe->te_param.intr_src1 & BITS_TX_INT_SRC_1 || 
	      fe->te_param.intr_src2 & BITS_TX_INT_SRC_2 ||  
     	      fe->te_param.intr_src3 & BITS_TX_INT_SRC_3)){
	if (fe->te_param.intr_src1 & BIT_INT_SRC_1_TJAT){
	if (fe->te_param.intr_src1 & BIT_INT_SRC_1_APRM){
	if (fe->te_param.intr_src2 & BIT_INT_SRC_2_TX_ELST){
	if (fe->te_param.intr_src2 & BIT_INT_SRC_2_TDPR_1){
	if (fe->te_param.intr_src2 & BIT_INT_SRC_2_TDPR_2){
	if (fe->te_param.intr_src2 & BIT_INT_SRC_2_TDPR_3){
	if (fe->te_param.intr_src3 & BIT_INT_SRC_3_TRAN){
	if (fe->te_param.intr_src3 & BIT_INT_SRC_3_XPDE){
	if (fe->te_param.intr_src3 & BIT_INT_SRC_3_BTIF){
 * Arguments: 	card		- pointer to device structure.
 * 		write_register	- write register function.
 * 		read_register	- read register function.
 * Arguments: 	card		- pointer to device structure.
 * 		write_register	- write register function.
 * 		read_register	- read register function.
	if (!(fe->te_param.intr_src1 & BITS_RX_INT_SRC_1 || 
	      fe->te_param.intr_src2 & BITS_RX_INT_SRC_2 ||  
     	      fe->te_param.intr_src3 & BITS_RX_INT_SRC_3)){
	if (fe->te_param.intr_src3 & BIT_INT_SRC_3_PDVD){
						fe->name);
						fe->name);
	if (fe->te_param.intr_src3 & BIT_INT_SRC_3_ALMI){
				if (!(fe->fe_alarm & WAN_TE_BIT_YEL_ALARM)){
							fe->name);
					fe->fe_alarm |= WAN_TE_BIT_RAI_ALARM;	//WAN_TE_BIT_YEL_ALARM;
				if (fe->fe_alarm & WAN_TE_BIT_YEL_ALARM){
							fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_RAI_ALARM;	//~WAN_TE_BIT_YEL_ALARM;
				if (!(fe->fe_alarm & WAN_TE_BIT_RED_ALARM)){
							fe->name);
					fe->fe_alarm |= WAN_TE_BIT_RED_ALARM;
				if (fe->fe_alarm & WAN_TE_BIT_RED_ALARM){
							fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_RED_ALARM;
				if (!(fe->fe_alarm & WAN_TE_BIT_AIS_ALARM)){ 
							fe->name);
					fe->fe_alarm |= WAN_TE_BIT_AIS_ALARM;
				if (fe->fe_alarm & WAN_TE_BIT_AIS_ALARM){ 
							fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_AIS_ALARM;
	if (fe->te_param.intr_src3 & BIT_INT_SRC_3_RBOC){
	if (fe->te_param.intr_src1 & BIT_INT_SRC_1_FRMR){
				if (!(fe->fe_alarm & WAN_TE_BIT_OOF_ALARM)){
						fe->name);
					fe->fe_alarm |= WAN_TE_BIT_OOF_ALARM; 
				if (fe->fe_alarm & WAN_TE_BIT_OOF_ALARM){
						fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_OOF_ALARM; 
	if (fe->te_param.intr_src3 & BIT_INT_SRC_3_RLPS){
				if (!(fe->fe_alarm & WAN_TE_BIT_ALOS_ALARM)){
						fe->name);
					fe->fe_alarm |= WAN_TE_BIT_ALOS_ALARM;
				if (fe->fe_alarm & WAN_TE_BIT_ALOS_ALARM){
						fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_ALOS_ALARM;
	if (fe->te_param.intr_src1 & BIT_INT_SRC_1_CDRC){
				if (!(fe->fe_alarm & WAN_TE_BIT_LOS_ALARM)){
							fe->name);
					fe->fe_alarm |= WAN_TE_BIT_LOS_ALARM;
				if (fe->fe_alarm & WAN_TE_BIT_LOS_ALARM){
							fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_LOS_ALARM;
					fe->name);
					fe->name);
					fe->name);
				if (!(fe->fe_alarm & WAN_TE_BIT_ALTLOS_ALARM)){
							fe->name);
					fe->fe_alarm |= WAN_TE_BIT_ALTLOS_ALARM;
				if (fe->fe_alarm & WAN_TE_BIT_ALTLOS_ALARM){
							fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_ALTLOS_ALARM;
	if (fe->te_param.intr_src1 & BIT_INT_SRC_1_PMON){
					fe->name);
	if (fe->te_param.intr_src1 & BIT_INT_SRC_1_SIGX){
			DEBUG_EVENT("%s: SIGX chg 30-25: 0x%02X\n",
		      		fe->name, SIGX_chg_30_25);
		DEBUG_EVENT("%s: SIGX chg 24-17: 0x%02X\n", 
					fe->name, SIGX_chg_24_17);
		DEBUG_EVENT("%s: SIGX chg 16-9 : 0x%02X\n", 
					fe->name, SIGX_chg_16_9);
		DEBUG_EVENT("%s: SIGX chg 8-1  : 0x%02X\n", 
					fe->name, SIGX_chg_8_1);
	fe->fe_alarm &= ~(WAN_TE_BIT_LOOPUP_CODE|WAN_TE_BIT_LOOPDOWN_CODE);
	if (fe->te_param.intr_src3 & BIT_INT_SRC_3_IBCD){
			fe->fe_alarm |= WAN_TE_BIT_LOOPUP_CODE;
			fe->fe_alarm |= WAN_TE_BIT_LOOPDOWN_CODE;
	if (fe->te_param.intr_src1 & BIT_INT_SRC_1_RJAT){
	/* 10. RX-ELST */
	if (fe->te_param.intr_src2 & BIT_INT_SRC_2_RX_ELST){
	/* 11. RDLC-1 */
	if (fe->te_param.intr_src2 & BIT_INT_SRC_2_RDLC_1){
	/* 12. RDLC-2 */
	if (fe->te_param.intr_src2 & BIT_INT_SRC_2_RDLC_2){
	/* 13. RDLC-3 */
	if (fe->te_param.intr_src2 & BIT_INT_SRC_2_RDLC_3){
 * Arguments: 	card		- pointer to device structure.
 * 		write_register	- write register function.
 * 		read_register	- read register function.
	if (!(fe->te_param.intr_src1 & BITS_RX_INT_SRC_1 || 
	      fe->te_param.intr_src2 & BITS_RX_INT_SRC_2 ||  
     	      fe->te_param.intr_src3 & BITS_RX_INT_SRC_3))
	if (fe->te_param.intr_src1 & BIT_INT_SRC_1_FRMR){
					if (!(fe->fe_alarm & WAN_TE_BIT_OOF_ALARM)){
								fe->name);
						fe->fe_alarm |= WAN_TE_BIT_OOF_ALARM; 
					if (fe->fe_alarm & WAN_TE_BIT_OOF_ALARM){
								fe->name);
						fe->fe_alarm &= ~WAN_TE_BIT_OOF_ALARM; 
					fe->name);
				fe->fe_alarm |= WAN_TE_BIT_OOSMF_ALARM; 
					fe->name);
				fe->fe_alarm &= ~WAN_TE_BIT_OOSMF_ALARM; 
						fe->name);
				fe->fe_alarm |= WAN_TE_BIT_OOCMF_ALARM; 
						fe->name);
				fe->fe_alarm &= ~WAN_TE_BIT_OOCMF_ALARM; 
					fe->name);
				fe->fe_alarm |= WAN_TE_BIT_OOOF_ALARM; 
					fe->name);
				fe->fe_alarm &= ~WAN_TE_BIT_OOOF_ALARM; 
					DEBUG_EVENT("%s: RED alarm is ON\n", fe->name);
					fe->fe_alarm |= WAN_TE_BIT_RED_ALARM;
					DEBUG_EVENT("%s: RED alarm is OFF\n", fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_RED_ALARM;
					DEBUG_EVENT("%s: AIS alarm is ON\n", fe->name);
					fe->fe_alarm |= WAN_TE_BIT_AIS_ALARM;
					DEBUG_EVENT("%s: AIS alarm is OFF\n", fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_AIS_ALARM;
					DEBUG_EVENT("%s: RAI alarm is ON\n", fe->name);
					fe->fe_alarm |= WAN_TE_BIT_RAI_ALARM;
					DEBUG_EVENT("%s: RAI alarm is OFF\n", fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_RAI_ALARM;
	if (fe->te_param.intr_src3 & BIT_INT_SRC_3_RLPS){
				if (!(fe->fe_alarm & WAN_TE_BIT_ALOS_ALARM)){
						fe->name);
					fe->fe_alarm |= WAN_TE_BIT_ALOS_ALARM;
				if (fe->fe_alarm & WAN_TE_BIT_ALOS_ALARM){
						fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_ALOS_ALARM;
	if (fe->te_param.intr_src1 & BIT_INT_SRC_1_CDRC){
				if (!(fe->fe_alarm & WAN_TE_BIT_LOS_ALARM)){
					DEBUG_EVENT("%s: LOS alarm is ON\n", fe->name);
					fe->fe_alarm |= WAN_TE_BIT_LOS_ALARM;
				if (fe->fe_alarm & WAN_TE_BIT_LOS_ALARM){
					DEBUG_EVENT("%s: LOS alarm is OFF\n", fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_LOS_ALARM;
			DEBUG_EVENT("%s: E1 line code violation!\n", fe->name);
			DEBUG_EVENT("%s: E1 line code signature detected!\n", fe->name);
			DEBUG_EVENT("%s: E1 consecutive zeros detected!\n", fe->name);
				if (!(fe->fe_alarm & WAN_TE_BIT_ALTLOS_ALARM)){
							fe->name);
					fe->fe_alarm |= WAN_TE_BIT_ALTLOS_ALARM;
				if (fe->fe_alarm & WAN_TE_BIT_ALTLOS_ALARM){
							fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_ALTLOS_ALARM;
	if (fe->te_param.intr_src1 & BIT_INT_SRC_1_PMON){
	if (fe->te_param.intr_src1 & BIT_INT_SRC_1_RJAT){
	if (fe->te_param.intr_src1 & BIT_INT_SRC_1_SIGX){
	/* 6. RX-ELST */
	if (fe->te_param.intr_src2 & BIT_INT_SRC_2_RX_ELST){
	if (fe->te_param.intr_src1 & BIT_INT_SRC_1_PRGD){
	/* 8. RDLC-1 */
	if (fe->te_param.intr_src2 & BIT_INT_SRC_2_RDLC_1){
	/* 9. RDLC-2 */
	if (fe->te_param.intr_src2 & BIT_INT_SRC_2_RDLC_2){
	/* 10. RDLC-3 */
	if (fe->te_param.intr_src2 & BIT_INT_SRC_2_RDLC_3){
		fe->fe_alarm &= ~WAN_TE_BIT_ALOS_ALARM;
					fe->name, boc_value);
						fe->name);
		if (wan_test_bit(LINELB_WAITING,(void*)&fe->te_param.critical) &&
		    wan_test_bit(LINELB_CODE_BIT,(void*)&fe->te_param.critical)){
		    	wan_clear_bit(LINELB_CODE_BIT,(void*)&fe->te_param.critical);
				fe->name,
				fe->name, WAN_TE1_BOC_LB_CODE_DECODE(boc_value));
					fe->name);
							fe->name, boc_value);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
				fe->name,
		return -EINVAL;	
			fe->name,
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	sdla_t 		*card = (sdla_t*)fe->card;
	wan_device_t	*wandev = &card->wandev;
				fe->name,
	if (wan_test_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical)){
		wan_clear_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical);
	if (!wan_test_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical)){
					fe->name);
	wan_clear_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical);
	wan_spin_lock_irq(&fe->lockirq,&smp_flags);	
	empty = WAN_LIST_EMPTY(&fe->event);
	wan_spin_unlock_irq(&fe->lockirq,&smp_flags);	
		if (wan_test_and_set_bit(TE_TIMER_EVENT_PENDING,(void*)&fe->te_param.critical)){
			DEBUG_EVENT("%s: RM timer event is pending!\n", fe->name);
		if (wandev->fe_enable_timer){
			wandev->fe_enable_timer(fe->card);
	sdla_t			*card = (sdla_t*)fe->card;
			fe->name, fe_event->type);
					fe->name);
		return -EINVAL;
	wan_spin_lock_irq(&fe->lockirq,&smp_flags);	
	if (WAN_LIST_EMPTY(&fe->event)){
		WAN_LIST_INSERT_HEAD(&fe->event, new_fe_event, next);
		WAN_LIST_FOREACH(tmp, &fe->event, next){
			DEBUG_EVENT("%s: Internal Error!!!\n", fe->name);
			wan_spin_unlock_irq(&fe->lockirq,&smp_flags);	
			return -EINVAL;
	wan_spin_unlock_irq(&fe->lockirq,&smp_flags);	
	if (wan_test_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical) ||
	    wan_test_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical)) {
	err = wan_add_timer(&fe->timer, delay);
	err = wan_add_timer(&fe->timer, delay * HZ / 1000);
		return -EINVAL;
	wan_set_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical);
 * Returns:	0  - no action is required
 *		1  - schedule front-end timer
 *		<0 - error  
	sdla_t			*card = (sdla_t*)fe->card;
	WAN_ASSERT_RC(fe->write_fe_reg == NULL, 0);
	WAN_ASSERT_RC(fe->read_fe_reg == NULL, 0);
	wan_spin_lock_irq(&fe->lockirq,&smp_flags);	
	if (WAN_LIST_EMPTY(&fe->event)){
		wan_spin_unlock_irq(&fe->lockirq,&smp_flags);	
					fe->name);
	fe_event = WAN_LIST_FIRST(&fe->event);
	wan_spin_unlock_irq(&fe->lockirq,&smp_flags);	
			fe->name, FE_MEDIA_DECODE(fe),
			fe->fe_status==FE_CONNECTED?"Con":"Disconn",
			fe_event->type);
	switch(fe_event->type){
			fe_event->type	= TE_LINELB_TIMER;
			fe_event->delay	= LINELB_TE1_TIMER;
		sdla_te_set_status(fe, fe->fe_alarm); 
		if (fe->fe_status == FE_CONNECTED){
			fe_event->type	= TE_LINKUP_TIMER;
			fe_event->delay	= POLLING_TE1_TIMER;
			fe_event->type	= TE_LINKDOWN_TIMER;
			fe_event->delay	= POLLING_TE1_TIMER;
		if (fe->fe_status == FE_CONNECTED){
			if (card->wandev.te_link_state){
				card->wandev.te_link_state(card);
			fe_event->type	= TE_LINKDOWN_TIMER;
			fe_event->delay	= POLLING_TE1_TIMER;
					fe_event->te_event.rbs_channel,
					fe_event->te_event.rbs_abcd);
		DEBUG_EVENT("%s: Re-configuring %s Front-End chip...\n",
						fe->name, FE_MEDIA_DECODE(fe));
			DEBUG_EVENT("%s: Failed to re-configuring Front-End chip!\n",
					fe->name);
		fe_event->type	= TE_LINKDOWN_TIMER;
		fe_event->delay	= POLLING_TE1_TIMER;
		fe->te_param.reg_dbg_value = READ_REG(fe_event->te_event.reg);
		DEBUG_TE1("%s: Read %s Front-End Reg:%04X=%02X\n",
					fe->name, FE_MEDIA_DECODE(fe),
					fe_event->te_event.reg,
					fe->te_param.reg_dbg_value);
		fe->te_param.reg_dbg_ready = 1;		
		DEBUG_TE1("%s: Write %s Front-End Reg:%04X=%02X\n",
					fe->name, FE_MEDIA_DECODE(fe),
					fe_event->te_event.reg,
					fe_event->te_event.value);
		WRITE_REG(fe_event->te_event.reg, fe_event->te_event.value);
	wan_clear_bit(TE_TIMER_EVENT_PENDING,(void*)&fe->te_param.critical);
	fe_event = WAN_LIST_FIRST(&fe->event);
		sdla_te_add_timer(fe, fe_event->delay);
		if (fe->te_param.lb_tx_cnt --){
			WRITE_REG(REG_T1_XBOC_CODE,fe->te_param.lb_tx_code);
				fe->name,	
				WAN_TE1_LB_ACTION_DECODE(fe->te_param.lb_tx_cmd),
				WAN_TE1_LB_MODE_DECODE(fe->te_param.lb_tx_mode)); 
		wan_clear_bit(LINELB_WAITING,(void*)&fe->te_param.critical);
		fe->te_param.lb_tx_cmd = 0x00;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	if (fe->fe_status != FE_CONNECTED){
	if (wan_test_bit(LINELB_WAITING,(void*)&fe->te_param.critical)){
				fe->name);				
	fe->te_param.lb_tx_mode	= mode;
	fe->te_param.lb_tx_cmd	= cmd;
			fe->te_param.lb_tx_code = LINELB_ACTIVATE_CODE;
			fe->te_param.lb_tx_code = LINELB_DEACTIVATE_CODE;
			fe->te_param.lb_tx_code = PAYLB_ACTIVATE_CODE;
			fe->te_param.lb_tx_code = PAYLB_DEACTIVATE_CODE;
	fe->te_param.lb_tx_cnt	= LINELB_CODE_CNT/* + LINELB_CHANNEL_CNT*/ + 1;
			fe->name, 
			WAN_TE1_BOC_LB_CODE_DECODE(fe->te_param.lb_tx_code));
	wan_set_bit(LINELB_WAITING,(void*)&fe->te_param.critical);
	wan_set_bit(LINELB_CODE_BIT,(void*)&fe->te_param.critical);
	wan_set_bit(LINELB_CHANNEL_BIT,(void*)&fe->te_param.critical);
	if (lbmode->cmd == WAN_FE_LBMODE_CMD_SET){
		sdla_te_set_lbmode(fe, lbmode->type, lbmode->mode, ENABLE_ALL_CHANNELS); 
	}else if (lbmode->cmd == WAN_FE_LBMODE_CMD_GET){
		lbmode->type_map = sdla_te_get_lbmode(fe);
	switch(udp_cmd->wan_cmd_command){
		fe_media->media		= fe->fe_cfg.media;
		fe_media->sub_media	= fe->fe_cfg.sub_media;
		fe_media->chip_id	= WAN_TE_CHIP_PMC;
		fe_media->max_ports	= fe->fe_max_ports;
		udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
		udp_cmd->wan_cmd_data_len = sizeof(wan_femedia_t); 
	    	udp_cmd->wan_cmd_data_len = sizeof(sdla_fe_lbmode_t);
	    	udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
	  	*(unsigned long *)&data[0] = fe->fe_alarm;
	        memcpy(&data[0], &fe->fe_stats, sizeof(sdla_fe_stats_t));
		if (udp_cmd->wan_cmd_fe_force){
			DEBUG_EVENT("%s: Force to read Front-End alarms\n",
						fe->name);
			fe_stats->alarms = 
	        udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
	    	udp_cmd->wan_cmd_data_len = sizeof(sdla_fe_stats_t); 
	        udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
	    		&fe->fe_cfg,
	    	udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
    	    	udp_cmd->wan_cmd_data_len = sizeof(sdla_fe_cfg_t);
		switch(fe_debug->type){
			if (fe_debug->mode == WAN_FE_DEBUG_RBS_READ){
					fe->name);
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			}else if (fe_debug->mode == WAN_FE_DEBUG_RBS_PRINT){
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			}else if (fe_debug->mode == WAN_FE_DEBUG_RBS_RX_ENABLE){
					fe->name);
				fe->fe_debug |= WAN_FE_DEBUG_RBS_RX_ENABLE;
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			}else if (fe_debug->mode == WAN_FE_DEBUG_RBS_TX_ENABLE){
					fe->name);
				fe->fe_debug |= WAN_FE_DEBUG_RBS_TX_ENABLE;
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			}else if (fe_debug->mode == WAN_FE_DEBUG_RBS_RX_DISABLE){
					fe->name);
				fe->fe_debug &= ~WAN_FE_DEBUG_RBS_RX_ENABLE;
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			}else if (fe_debug->mode == WAN_FE_DEBUG_RBS_TX_DISABLE){
					fe->name);
				fe->fe_debug &= ~WAN_FE_DEBUG_RBS_TX_ENABLE;
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			}else if (fe_debug->mode == WAN_FE_DEBUG_RBS_SET){
					if (fe_debug->fe_debug_rbs.channel < 1 ||
					    fe_debug->fe_debug_rbs.channel > 24){
							fe->name,
							fe_debug->fe_debug_rbs.channel);
					if (fe_debug->fe_debug_rbs.channel < 0 ||
					    fe_debug->fe_debug_rbs.channel > 31){
							fe->name,
							fe_debug->fe_debug_rbs.channel);
				fe_event.te_event.rbs_channel = fe_debug->fe_debug_rbs.channel;
				fe_event.te_event.rbs_abcd	= fe_debug->fe_debug_rbs.abcd;
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			if (fe_debug->mode == WAN_FE_DEBUG_ALARM_AIS_ENABLE){
					fe->name);
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			}else if (fe_debug->mode == WAN_FE_DEBUG_ALARM_AIS_DISABLE){
					fe->name);
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			if (fe->te_param.reg_dbg_busy){
				if (fe_debug->fe_debug_reg.read == 2 && fe->te_param.reg_dbg_ready){
					fe_debug->fe_debug_reg.value = fe->te_param.reg_dbg_value;
					udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
					fe->te_param.reg_dbg_busy = 0;
			fe_event.type		= (fe_debug->fe_debug_reg.read) ? 
			fe_event.te_event.reg	= (u_int16_t)fe_debug->fe_debug_reg.reg;
			fe_event.te_event.value	= fe_debug->fe_debug_reg.value;
			if (fe_debug->fe_debug_reg.read){
				fe->te_param.reg_dbg_busy = 1;
				fe->te_param.reg_dbg_ready = 0;
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
    	    	udp_cmd->wan_cmd_data_len = 0;
		switch(fe_debug->mode){
					fe->name);
			WRITE_REG(REG_XLPG_LINE_CFG, fe->te_param.xlpg_scale);
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			DEBUG_EVENT("%s: Disable Transmitter (tx tri-state mode)!\n",
					fe->name);
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
		udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
	    	udp_cmd->wan_cmd_data_len = 0;
	sdla_t*		card = (sdla_t*)fe->card;
	if ((unsigned int)channel > fe->te_param.max_channels){
				fe->name, channel);
		return -EINVAL;
	if (fe->fe_debug & WAN_FE_DEBUG_RBS_TX_ENABLE){
		DEBUG_EVENT("%s: %s:%-3d TX RBS A:%1d B:%1d C:%1d D:%1d\n",
				fe->name,
		wan_set_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_A);
		wan_clear_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_A);
		wan_set_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_B);
		wan_clear_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_B);
		wan_set_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_C);
		wan_clear_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_C);
		wan_set_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_D);
		wan_clear_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_D);
	if (fe->te_param.ptr_te_Tx_sig_off){
		card->hw_iface.poke(
			card->hw,
			fe->te_param.ptr_te_Tx_sig_off + channel - 1,
	fe->te_param.SIGX_chg_30_25 = 
	fe->te_param.SIGX_chg_24_17 = 
	fe->te_param.SIGX_chg_16_9  = 
	fe->te_param.SIGX_chg_8_1   = 
		fe->te_param.SIGX_chg_30_25) || 
	    fe->te_param.SIGX_chg_24_17 || 
	    fe->te_param.SIGX_chg_16_9 || 
	    fe->te_param.SIGX_chg_8_1){
	if (fe->fe_debug & WAN_FE_DEBUG_RBS_RX_ENABLE &&
	    fe->te_param.rx_rbs[channo] != status){
		"%s: %s:%-3d RX RBS A:%1d B:%1d C:%1d D:%1d\n",
					fe->name,
	wan_set_bit(channo, &fe->te_param.rx_rbs_status);
	fe->te_param.rx_rbs[channo] = status;
			(unsigned long*)&fe->te_param.rx_rbs_A);
			(unsigned long*)&fe->te_param.rx_rbs_A);
			(unsigned long*)&fe->te_param.rx_rbs_B);
			(unsigned long*)&fe->te_param.rx_rbs_B);
			(unsigned long*)&fe->te_param.rx_rbs_C);
			(unsigned long*)&fe->te_param.rx_rbs_C);
			(unsigned long*)&fe->te_param.rx_rbs_D);
			(unsigned long*)&fe->te_param.rx_rbs_D);
	sdla_t*		card = (sdla_t*)fe->card;
	max_channels = fe->te_param.max_channels;
		if (wan_test_bit(ch, &fe->te_param.rx_rbs_status)){
			if (card->wandev.te_report_rbsbits){
				card->wandev.te_report_rbsbits(
					fe->te_param.rx_rbs[ch]);
			wan_clear_bit(ch, &fe->te_param.rx_rbs_status);
		if (!wan_test_bit(channel-1, &ts_map)){
	sdla_t*		card = (sdla_t*)fe->card;
	if ((mode & WAN_TE_RBS_REPORT) && card->wandev.te_report_rbsbits){
		card->wandev.te_report_rbsbits(
					fe->name);
					fe->name);
		DEBUG_EVENT("%s:       ------------------------\n",
					fe->name);
					fe->name);
					fe->name);
		DEBUG_EVENT("%s:       --------------------------------\n",
					fe->name);
	int 	i, max_channels = fe->te_param.max_channels;
	_DEBUG_EVENT("%s: %s ", fe->name, msg);
		rx_a = fe->te_param.rx_rbs_A;	
		rx_b = fe->te_param.rx_rbs_B;
		rx_c = fe->te_param.rx_rbs_C;
		rx_d = fe->te_param.rx_rbs_D;
					fe->name);
		sdla_te_rbs_print_bits(fe, fe->te_param.tx_rbs_A, "TX A:");
		sdla_te_rbs_print_bits(fe, fe->te_param.tx_rbs_B, "TX B:");
		sdla_te_rbs_print_bits(fe, fe->te_param.tx_rbs_C, "TX C:");
		sdla_te_rbs_print_bits(fe, fe->te_param.tx_rbs_D, "TX D:");
		DEBUG_EVENT("%s:\n", fe->name);
		for(i = 0; i < fe->te_param.max_channels; i++) {
						fe->name,
						fe->name, channo+16);
					fe->name);
	sdla_t*		card = (sdla_t*)fe->card;
	if (fe->fe_status == FE_CONNECTED){
			if (fe->fe_status != FE_CONNECTED){
				return -EINVAL;
			       		fe->name, i, status, SIGX_addr + i);
					fe->name,
			if (report && card->wandev.te_report_rbsbits){
				card->wandev.te_report_rbsbits(
	sdla_te_pmon_t*	pmon = &fe->fe_stats.te_pmon;
	switch(snmp->snmp_magic){
		alarms = fe->fe_alarm; 
		snmp->snmp_val = 0;
			snmp->snmp_val |= SNMP_DSX1_RCVFARENDLOF;
			snmp->snmp_val |= SNMP_DSX1_RCVAIS;
			snmp->snmp_val |= SNMP_DSX1_LOSSOFFRAME;
			snmp->snmp_val |= SNMP_DSX1_LOSSOFSIGNAL;
		if (!snmp->snmp_val){
			snmp->snmp_val = SNMP_DSX1_NOALARM;
		snmp->snmp_val = pmon->lcv_errors;
		if (pmon->oof_errors){
			snmp->snmp_val = 1;
		if (IS_T1_FEMEDIA(fe) && pmon->oof_errors){
			snmp->snmp_val = 1;
		}else if (IS_E1_FEMEDIA(fe) && pmon->crc4_errors){
			snmp->snmp_val = 1;
	if (!fe->read_fe_reg || !fe->write_fe_reg){
		return -EINVAL;
		"ALOS", WAN_TE_ALOS_ALARM(fe->fe_alarm), 
		"LOS", WAN_TE_LOS_ALARM(fe->fe_alarm));
		"RED", WAN_TE_RED_ALARM(fe->fe_alarm), 
		"AIS", WAN_TE_AIS_ALARM(fe->fe_alarm));
			 "YEL", WAN_TE_YEL_ALARM(fe->fe_alarm),
			 "OOF", WAN_TE_OOF_ALARM(fe->fe_alarm));
			"OOF", WAN_TE_OOF_ALARM(fe->fe_alarm), 
	return m->count;	
			"Framing Bit Error", fe->fe_stats.te_pmon.fer_errors,
			"Line Code Violation", fe->fe_stats.te_pmon.lcv_errors);
			"Out of Frame Errors", fe->fe_stats.te_pmon.oof_errors,
			"Bit Errors", fe->fe_stats.te_pmon.bee_errors);
			"Frame Alighment Signal", fe->fe_stats.te_pmon.fas_errors,
			"Line Code Violation", fe->fe_stats.te_pmon.lcv_errors);
			"CRC4 Errors", fe->fe_stats.te_pmon.crc4_errors,
			"Far End Block Errors", fe->fe_stats.te_pmon.feb_errors);
	return m->count;
./sdla_te1.c
* Copyright:	(c) 2003-2006 Sangoma Technologies Inc.
/* Internal USB-FXO CPU registers */
static struct sdla_usb_desc sdlausb = { "Sangoma Wanpipe USB-FXO 2 Interfaces", U100_ADPTR };
	/* USB-FXO */
	struct sdla_usb_desc 	*desc = (struct sdla_usb_desc *)id->driver_info;
				SDLA_USB_NAME, desc->name, desc->adptr_type, udev->devnum);
	if (sdla_usb_create(intf, desc->adptr_type)){
		return -ENODEV;
				SDLA_USB_NAME, dev->devnum);
		wan_clear_bit(WP_USB_STATUS_READY, &hwcard->u_usb.status);
				SDLA_USB_NAME, dev->devnum);
				SDLA_USB_NAME, dev->devnum);
	DEBUG_EVENT("%s: Pre-reset USB device on %d (not implemented)!\n",
				SDLA_USB_NAME, dev->devnum);
	DEBUG_EVENT("%s: Post-Reset USB device on %d (not implemented)!\n",
				SDLA_USB_NAME, dev->devnum);
	WP_SCHEDULE(foo, "A-USB");
		if (!fast) WP_SCHEDULE(foo, "A-USB");
	WAN_ASSERT_RC(hw->hwcpu == NULL, 0xFF);
	WAN_ASSERT_RC(hw->hwcpu->hwcard == NULL, 0xFF);
	hwcard = hw->hwcpu->hwcard;
	wan_spin_lock(&hwcard->u_usb.cmd_lock);
			hw->devname,
	if (wan_test_and_set_bit(WP_USB_STATUS_TX_CMD, &hwcard->u_usb.status)){
					hw->devname);
		hwcard->u_usb.stats.cmd_overrun++;
	if (!wan_skb_queue_len(&hwcard->u_usb.tx_cmd_free_list)){
					hw->devname, wan_skb_queue_len(&hwcard->u_usb.tx_cmd_list));
		hwcard->u_usb.stats.cmd_overrun++;
	skb = wan_skb_dequeue(&hwcard->u_usb.tx_cmd_free_list);
	wan_skb_queue_tail(&hwcard->u_usb.tx_cmd_list, skb);
	if (!wan_skb_queue_len(&hwcard->u_usb.rx_cmd_list)){
		DEBUG_USB("%s: WARNING: Timeout on Read USB-FXO Reg!\n",
				hw->devname);
		hwcard->u_usb.stats.cmd_timeout++;
	skb = wan_skb_dequeue(&hwcard->u_usb.rx_cmd_list);
				hw->devname, cmd_data[1], off);
		hwcard->u_usb.stats.cmd_invalid++;
	wan_skb_queue_tail(&hwcard->u_usb.rx_cmd_free_list, skb);
	wan_clear_bit(WP_USB_STATUS_TX_CMD, &hwcard->u_usb.status);
	wan_spin_unlock(&hwcard->u_usb.cmd_lock);
			"%s: %s:%d: Critical Error: Re-entry in FE!\n",
					hw->devname,
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	wan_spin_lock(&hwcard->u_usb.cmd_lock);
	DEBUG_TX("%s: Tx Write FXO register (%02X: %d <- 0x%02X)!\n", 
			hw->devname, 
	if (!wan_skb_queue_len(&hwcard->u_usb.tx_cmd_free_list)){
					hw->devname, wan_skb_queue_len(&hwcard->u_usb.tx_cmd_list));
		hwcard->u_usb.stats.cmd_overrun++;
		wan_spin_unlock(&hwcard->u_usb.cmd_lock);
	skb = wan_skb_dequeue(&hwcard->u_usb.tx_cmd_free_list);
	wan_skb_queue_tail(&hwcard->u_usb.tx_cmd_list, skb);
	hwcard->u_usb.regs[mod_no][off]  = data;
	wan_spin_unlock(&hwcard->u_usb.cmd_lock);
			"%s: %s:%d: Critical Error: Re-entry in FE!\n",
					hw->devname,
		return -EINVAL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	if (!wan_test_bit(WP_USB_STATUS_READY, &hwcard->u_usb.status)){
	wan_spin_lock(&hwcard->u_usb.cmd_lock);
			hw->devname,(unsigned char)off,SYSTEM_TICKS);
	if (wan_test_and_set_bit(WP_USB_STATUS_TX_CMD, &hwcard->u_usb.status)){
					hw->devname);
		hwcard->u_usb.stats.cmd_overrun++;
	if (!wan_skb_queue_len(&hwcard->u_usb.tx_cmd_free_list)){
					hw->devname, wan_skb_queue_len(&hwcard->u_usb.tx_cmd_list));
		hwcard->u_usb.stats.cmd_overrun++;
	skb = wan_skb_dequeue(&hwcard->u_usb.tx_cmd_free_list);
	wan_skb_queue_tail(&hwcard->u_usb.tx_cmd_list, skb);
	if (!wan_skb_queue_len(&hwcard->u_usb.rx_cmd_list)){
		DEBUG_USB("WARNING: %s: Timeout on Read USB-CPU Reg!\n",
				hw->devname);
		hwcard->u_usb.stats.cmd_timeout++;
	skb = wan_skb_dequeue(&hwcard->u_usb.rx_cmd_list);
				hw->devname, cmd_data[1], off);
		hwcard->u_usb.stats.cmd_invalid++;
		wan_skb_queue_tail(&hwcard->u_usb.rx_cmd_free_list, skb);
	wan_skb_queue_tail(&hwcard->u_usb.rx_cmd_free_list, skb);
	wan_clear_bit(WP_USB_STATUS_TX_CMD, &hwcard->u_usb.status);
	wan_spin_unlock(&hwcard->u_usb.cmd_lock);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	wan_spin_lock(&hwcard->u_usb.cmd_lock);
	DEBUG_TX("%s: Tx Write CPU register (0x%02X <- 0x%02X)!\n", 
			hw->devname, (unsigned char)off, (unsigned char)data);
	if (!wan_skb_queue_len(&hwcard->u_usb.tx_cmd_free_list)){
					hw->devname, wan_skb_queue_len(&hwcard->u_usb.tx_cmd_list));
		hwcard->u_usb.stats.cmd_overrun++;
		wan_spin_unlock(&hwcard->u_usb.cmd_lock);
	skb = wan_skb_dequeue(&hwcard->u_usb.tx_cmd_free_list);
	wan_skb_queue_tail(&hwcard->u_usb.tx_cmd_list, skb);
	wan_spin_unlock(&hwcard->u_usb.cmd_lock);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	if (!wan_skb_queue_len(&hwcard->u_usb.rx_cmd_list)){
					hw->devname);
		return -EBUSY;
	skb = wan_skb_dequeue(&hwcard->u_usb.rx_cmd_list);
	wan_skb_queue_tail(&hwcard->u_usb.rx_cmd_free_list, skb);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
		return -EBUSY;
	wan_set_bit(event_bit, &hwcard->u_usb.status);
				hw->devname, mod_no+1, 
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	if(!wan_test_bit(event_bit, &hwcard->u_usb.status)){
		return -EINVAL;
		hwcard->u_usb.regs[mod_no][5]  = __sdla_usb_fxo_read(hw, mod_no, 5);
		hwcard->u_usb.regs[mod_no][29] = __sdla_usb_fxo_read(hw, mod_no, 29);
		hwcard->u_usb.regs[mod_no][34] = __sdla_usb_fxo_read(hw, mod_no, 34);
		hwcard->u_usb.regs[mod_no][4]  = __sdla_usb_fxo_read(hw, mod_no, 4);
				hw->devname, mod_no+1,
				hwcard->u_usb.regs[mod_no][5], hwcard->u_usb.regs[mod_no][29],
				hwcard->u_usb.regs[mod_no][34], hwcard->u_usb.regs[mod_no][4]);
	regs[0] = hwcard->u_usb.regs[mod_no][5];
	regs[1] = hwcard->u_usb.regs[mod_no][29];
	regs[2] = hwcard->u_usb.regs[mod_no][34];
	regs[3] = hwcard->u_usb.regs[mod_no][4];
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	*rxdata = &hwcard->u_usb.readchunk[mod_no][0];
	*txdata = &hwcard->u_usb.writechunk[mod_no][0];
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
		wan_set_bit(WP_USB_STATUS_RX_DATA_READY, &hwcard->u_usb.status);
		wan_clear_bit(WP_USB_STATUS_RX_DATA_READY, &hwcard->u_usb.status);
	WAN_ASSERT_RC(hw->hwcpu == NULL, 0);
	WAN_ASSERT_RC(hw->hwcpu->hwcard == NULL, 0);
	hwcard = hw->hwcpu->hwcard;
	rx_ind = hwcard->u_usb.next_rx_ind;
	if (rx_ind > hwcard->u_usb.next_read_ind){
		rx_len = rx_ind - hwcard->u_usb.next_read_ind; 
	}else if (rx_ind < hwcard->u_usb.next_read_ind){
		rx_len = MAX_READ_BUF_LEN - hwcard->u_usb.next_read_ind + rx_ind;
					hw->devname);
					hw->devname, rx_len, len);
	memcpy(data, &hwcard->u_usb.readbuf[hwcard->u_usb.next_read_ind], len);
	hwcard->u_usb.next_read_ind += len;
	WAN_ASSERT_RC(hw->hwcpu == NULL, 0);
	WAN_ASSERT_RC(hw->hwcpu->hwcard == NULL, 0);
	hwcard = hw->hwcpu->hwcard;
	memcpy(&hwcard->u_usb.writebuf[hwcard->u_usb.next_tx_ind], data, len);
	urb_write_ind = (hwcard->u_usb.urb_write_ind + 1) % MAX_WRITE_URB_COUNT;
	hwcard->u_usb.datawrite[urb_write_ind].urb.transfer_buffer = &hwcard->u_usb.writebuf[hwcard->u_usb.next_tx_ind];
	hwcard->u_usb.datawrite[urb_write_ind].urb.transfer_buffer_length = len;
	hwcard->u_usb.next_tx_ind += len;
	hwcard->u_usb.next_tx_ind = hwcard->u_usb.next_tx_ind % MAX_WRITE_BUF_LEN;
	wan_clear_bit(WP_USB_STATUS_TX_READY, &hwcard->u_usb.status);
	if (wp_usb_start_transfer(&hwcard->u_usb.datawrite[urb_write_ind])){
 				hw->devname,
				hwcard->u_usb.next_tx_ind, hwcard->u_usb.next_write_ind);
		hwcard->u_usb.stats.tx_notready_cnt++;
		hwcard->u_usb.urb_write_ind = urb_write_ind;
	WAN_ASSERT_RC(hw == NULL, -EBUSY);
	SDLA_MAGIC_RC(hw, -EBUSY);
	WAN_ASSERT_RC(hw->hwcpu == NULL, -EBUSY);
	WAN_ASSERT_RC(hw->hwcpu->hwcard == NULL, -EBUSY);
	hwcard = hw->hwcpu->hwcard;
	urb_write_ind = (hwcard->u_usb.urb_write_ind + 1) % MAX_WRITE_URB_COUNT;
	if (!wan_test_bit(1, &hwcard->u_usb.datawrite[urb_write_ind].ready)){
				hw->devname, hwcard->u_usb.datawrite[urb_write_ind].id,
		return -EBUSY;
	if (!wan_test_bit(WP_USB_STATUS_TX_READY, &hwcard->u_usb.status)){
				hw->devname, hwcard->u_usb.datawrite[urb_write_ind].id,
		return -EBUSY;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	hwcard->u_usb.isr_func	= isr_func;
	hwcard->u_usb.isr_arg	= arg;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	hwcard->u_usb.isr_func	= NULL;
	hwcard->u_usb.isr_arg	= NULL;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
				hw->devname, len, sizeof(sdla_usb_comm_err_stats_t)); 
		return -EINVAL;
	stats = &hwcard->u_usb.stats;
	sdla_usb_cpu_read(hw, SDLA_USB_CPU_REG_FIFO_STATUS, &stats->fifo_status);
	sdla_usb_cpu_read(hw, SDLA_USB_CPU_REG_UART_STATUS, &stats->uart_status);
	sdla_usb_cpu_read(hw, SDLA_USB_CPU_REG_HOSTIF_STATUS, &stats->hostif_status);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	memset(&hwcard->u_usb.stats,0,sizeof(sdla_usb_comm_err_stats_t));
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
					hw->devname,
					hw->devname,
					hw->devname,
					hw->devname,
					hw->devname, mod_no+1, 
		hwcard->u_usb.regs[mod_no][reg_no] = rx_cmd[2];
				hw->devname,
		hwcard->u_usb.stats.rx_cmd_unknown++;
		return -EINVAL;
	skb = wan_skb_dequeue(&hwcard->u_usb.rx_cmd_free_list);
	wan_skb_queue_tail(&hwcard->u_usb.rx_cmd_list, skb); 
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	rx_ind = hwcard->u_usb.next_rx_ind;
	if (rx_ind > hwcard->u_usb.next_read_ind){
		rx_len = rx_ind - hwcard->u_usb.next_read_ind; 
	}else if (rx_ind < hwcard->u_usb.next_read_ind){
		rx_len = MAX_READ_BUF_LEN - hwcard->u_usb.next_read_ind + rx_ind;
					hw->devname, (u32)SYSTEM_TICKS);
		hwcard->u_usb.stats.rx_underrun_cnt++;
		return -EINVAL;
				hw->devname, rx_len,
				hwcard->u_usb.next_read_ind,
				hwcard->u_usb.next_rx_ind,
		hwcard->u_usb.stats.rx_underrun_cnt++;
	DEBUG_RX("[RX-BH]%s:%d: RX:%d (%d:%d)\n",
			hwcard->u_usb.next_read_ind,
			hwcard->u_usb.next_rx_ind);
	off = hwcard->u_usb.next_read_ind;
	rx_data[0] = hwcard->u_usb.readchunk[0];
	rx_data[1] = hwcard->u_usb.readchunk[1];
	//memset(&hwcard->u_usb.readchunk[0][0], 0, WP_USB_MAX_CHUNKSIZE);
	//memset(&hwcard->u_usb.readchunk[1][0], 0, WP_USB_MAX_CHUNKSIZE);
		DEBUG_RX("  RX: %02X\n", (unsigned char)hwcard->u_usb.readbuf[off]);
		data		= hwcard->u_usb.readbuf[off] & 0x0F;
		start_bit	= hwcard->u_usb.readbuf[off] & 0x10;
		start_fr_bit	= hwcard->u_usb.readbuf[off] & 0x20;
						hw->devname,
						(unsigned char)hwcard->u_usb.readbuf[off],
				hwcard->u_usb.stats.rx_start_fr_err_cnt++;
						hw->devname,
						(unsigned char)hwcard->u_usb.readbuf[off],
				hwcard->u_usb.stats.rx_start_err_cnt++;
					(unsigned char)hwcard->u_usb.readbuf[off]);
			rx_data[mod_no][ind] |= (data << 4);	//sc->readchunk[mod_no][ind] |= (data << 4);
			rx_data[mod_no][ind] = data;	//sc->readchunk[mod_no][ind] = data;
		cmd = hwcard->u_usb.readbuf[off] & 0xC0;
			if (rx_cmd[rx_cmd_len] == hwcard->u_usb.ctrl_idle_pattern){
					if (!wan_skb_queue_len(&hwcard->u_usb.rx_cmd_free_list)){
								hw->devname, (u32)SYSTEM_TICKS);
						hwcard->u_usb.stats.rx_cmd_drop_cnt++;
						hwcard->u_usb.stats.rx_cmd_reset_cnt++;
								hw->devname, rx_cmd_len,
								hw->devname, rx_cmd_len,
		rx_len --;
	hwcard->u_usb.next_read_ind = off;
	if (wan_test_bit(WP_USB_STATUS_RX_DATA_READY, &hwcard->u_usb.status) && hwcard->u_usb.isr_func){
		hwcard->u_usb.isr_func(hwcard->u_usb.isr_arg);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
			hwcard->u_usb.next_tx_ind, hwcard->u_usb.next_write_ind);
	txdata[0] = hwcard->u_usb.writechunk[0];
	txdata[1] = hwcard->u_usb.writechunk[1];
	next_write_ind = hwcard->u_usb.next_write_ind; 
	memcpy(&hwcard->u_usb.writebuf[next_write_ind], &hwcard->u_usb.idlebuf[0], MAX_USB_TX_LEN); 
			WP_USB_CTRL_ENCODE(&hwcard->u_usb.writebuf[next_write_ind], ind);
			WP_USB_DATA_ENCODE(&hwcard->u_usb.writebuf[next_write_ind+ind], data);
						(unsigned char)hwcard->u_usb.writebuf[next_write_ind+ind],
						(unsigned char)hwcard->u_usb.writebuf[next_write_ind+ind+2]);
	if (wan_skb_queue_len(&hwcard->u_usb.tx_cmd_list)){
		skb = wan_skb_dequeue(&hwcard->u_usb.tx_cmd_list);
			WP_USB_CMD_ENCODE(&hwcard->u_usb.writebuf[next_write_ind+off*4], cmd[x]);
					(unsigned char)hwcard->u_usb.writebuf[next_write_ind+off*4],
					(unsigned char)hwcard->u_usb.writebuf[next_write_ind+off*4+1],
					(unsigned char)hwcard->u_usb.writebuf[next_write_ind+off*4+2],
					(unsigned char)hwcard->u_usb.writebuf[next_write_ind+off*4+3]);
		wan_skb_queue_tail(&hwcard->u_usb.tx_cmd_free_list, skb);
	if (next_write_ind == hwcard->u_usb.next_tx_ind){
		hwcard->u_usb.stats.tx_overrun_cnt++;
		hwcard->u_usb.next_write_ind = next_write_ind;
	int urb_write_ind = (hwcard->u_usb.urb_write_ind + 1) % MAX_WRITE_URB_COUNT;
	if (wan_test_bit(1, &hwcard->u_usb.datawrite[urb_write_ind].ready)){
		hwcard->u_usb.datawrite[urb_write_ind].urb.transfer_buffer = &hwcard->u_usb.writebuf[hwcard->u_usb.next_tx_ind];
		hwcard->u_usb.next_tx_ind += MAX_USB_TX_LEN;
		hwcard->u_usb.next_tx_ind = hwcard->u_usb.next_tx_ind % MAX_WRITE_BUF_LEN;
				hw->devname, bhcount,rxcount,txcount,(unsigned long)SYSTEM_TICKS);
		hwcard->u_usb.stats.tx_overrun_cnt++;
	wan_clear_bit(WP_USB_STATUS_TX_READY, &hwcard->u_usb.status);	//sc->tx_ready = 0;
	if (wp_usb_start_transfer(&hwcard->u_usb.datawrite[urb_write_ind])){
		DEBUG_EVENT("%s: Failed to program transmitter\n", hw->devname);
		hwcard->u_usb.stats.tx_notready_cnt++;
		hwcard->u_usb.urb_write_ind = urb_write_ind;
	if (!wan_test_bit(WP_USB_STATUS_TX_READY, &hwcard->u_usb.status)){
				hw->devname, bhcount,rxcount,txcount,(unsigned long)SYSTEM_TICKS);
		hwcard->u_usb.stats.tx_overrun_cnt++;
		return -EINVAL;
	hwcard->u_usb.datawrite[0].urb.transfer_buffer = &hwcard->u_usb.writebuf[hwcard->u_usb.next_tx_ind];
	hwcard->u_usb.next_tx_ind += MAX_USB_TX_LEN;
	hwcard->u_usb.next_tx_ind = hwcard->u_usb.next_tx_ind % MAX_WRITE_BUF_LEN;
	wan_clear_bit(WP_USB_STATUS_TX_READY, &hwcard->u_usb.status);	//sc->tx_ready = 0;
	if (wp_usb_start_transfer(&hwcard->u_usb.datawrite[0])){
				hw->devname, bhcount,
				hwcard->u_usb.next_tx_ind, hwcard->u_usb.next_write_ind);
		hwcard->u_usb.stats.tx_notready_cnt++;
			hw->devname, bhcount, rxcount, txcount);
	WAN_ASSERT_VOID(hw->hwcpu == NULL);
	WAN_ASSERT_VOID(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
 	DEBUG_TEST("%s:%d: ------------ BEGIN --------------: %ld\n",
	wan_spin_lock_irq(&hwcard->u_usb.lock,&flags);
	if (!wan_test_bit(WP_USB_STATUS_READY, &hwcard->u_usb.status)){
	if (wan_test_and_set_bit(WP_USB_STATUS_BH, &hwcard->u_usb.status)){
		DEBUG_EVENT("%s: [BH:%ld]: Re-entry in USB BH!\n",
				hw->devname, (unsigned long)SYSTEM_TICKS);
	wan_clear_bit(WP_USB_STATUS_BH, &hwcard->u_usb.status);
	wan_spin_unlock_irq(&hwcard->u_usb.lock,&flags);
	WAN_TASKLET_END((&hwcard->u_usb.bh_task));
	DEBUG_TEST("%s: ------------ END -----------------: %ld\n",
	struct wan_urb	*wurb = (struct wan_urb*)q->context;
	sdlahw_t	*hw = (sdlahw_t*)wurb->pvt;
	WAN_ASSERT_VOID(hw->hwcpu == NULL);
	WAN_ASSERT_VOID(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	wan_spin_lock_irq(&hwcard->u_usb.lock,&flags);
	if (!wan_test_bit(WP_USB_STATUS_READY, &hwcard->u_usb.status)){
					hw->devname, rxcount,
		hwcard->u_usb.stats.core_notready_cnt++;
		wan_spin_unlock_irq(&hwcard->u_usb.lock,&flags);
	if (q->actual_length < MAX_USB_RX_LEN){
					hw->devname, rxcount,
					q->actual_length,MAX_USB_RX_LEN);
		actual_length = q->actual_length; 
			hw->devname, wurb->id, rxcount, 
			q->actual_length, ((unsigned char*)q->transfer_buffer)[0], 
			hwcard->u_usb.next_read_ind, (unsigned char)hwcard->u_usb.readbuf[hwcard->u_usb.next_read_ind],
			hwcard->u_usb.next_rx_ind, (unsigned char)hwcard->u_usb.readbuf[hwcard->u_usb.next_rx_ind],
	if (!q->actual_length) goto read_complete_done;
	next_rx_ind = hwcard->u_usb.next_rx_ind + q->actual_length;
	next_rx_off = hwcard->u_usb.next_rx_ind + q->actual_length * hwcard->u_usb.urbcount_read;
	if (hwcard->u_usb.next_rx_ind < hwcard->u_usb.next_read_ind){
		if (next_rx_off > hwcard->u_usb.next_read_ind){
					hw->devname,		
					hwcard->u_usb.next_read_ind,hwcard->u_usb.next_rx_ind,
					q->actual_length*hwcard->u_usb.urbcount_read);
			hwcard->u_usb.stats.rx_overrun_cnt++;
			WAN_TASKLET_SCHEDULE((&hwcard->u_usb.bh_task));
	}else if (hwcard->u_usb.next_rx_ind > hwcard->u_usb.next_read_ind){
			memcpy(	&hwcard->u_usb.readbuf[0], 
				&hwcard->u_usb.readbuf[MAX_READ_BUF_LEN],
				next_rx_ind - MAX_READ_BUF_LEN);
			if (next_rx_off > hwcard->u_usb.next_read_ind){
						hw->devname,
						hwcard->u_usb.next_read_ind,hwcard->u_usb.next_rx_ind,
						q->actual_length*hwcard->u_usb.urbcount_read);
				hwcard->u_usb.stats.rx_overrun_cnt++;
				WAN_TASKLET_SCHEDULE((&hwcard->u_usb.bh_task));
	hwcard->u_usb.next_rx_ind = next_rx_ind;
	wurb->next_off = next_rx_off;	
	if (hwcard->u_usb.next_rx_ind >= hwcard->u_usb.next_read_ind){
		len = hwcard->u_usb.next_rx_ind - hwcard->u_usb.next_read_ind; 
		len = MAX_READ_BUF_LEN - hwcard->u_usb.next_read_ind + hwcard->u_usb.next_rx_ind;
	if (hwcard->u_usb.opmode == SDLA_USB_OPMODE_VOICE){
		DEBUG_RX("[RX-] %s: RX:%d %d:%d\n", 
				hw->devname, len, hwcard->u_usb.next_read_ind, hwcard->u_usb.next_rx_ind);
			if (!hwcard->u_usb.rx_sync){
								hw->devname, hwcard->u_usb.next_read_ind);
					if ((hwcard->u_usb.readbuf[hwcard->u_usb.next_read_ind] & 0x30) != 0x30){
						hwcard->u_usb.next_read_ind = (hwcard->u_usb.next_read_ind+1) % MAX_READ_BUF_LEN;
						len--;
								hw->devname,
								hwcard->u_usb.next_read_ind,
								hwcard->u_usb.next_rx_ind);
					data = WP_USB_CTRL_DECODE(&hwcard->u_usb.readbuf[hwcard->u_usb.next_read_ind]);
									hw->devname);
								hw->devname,
								hwcard->u_usb.next_read_ind,
								hwcard->u_usb.next_rx_ind);
						hwcard->u_usb.rx_sync = 1;
					hwcard->u_usb.next_read_ind = (hwcard->u_usb.next_read_ind+4) % MAX_READ_BUF_LEN;
					len -= 4;
				//if (sc->next_read_ind >= MAX_READ_BUF_LEN){
				//	sc->next_read_ind = sc->next_read_ind % MAX_READ_BUF_LEN;
				if ((hwcard->u_usb.readbuf[hwcard->u_usb.next_read_ind] & 0x30) != 0x30){
									hw->devname);
							hw->devname,
							hwcard->u_usb.next_read_ind, hwcard->u_usb.next_rx_ind,
							(unsigned char)hwcard->u_usb.readbuf[hwcard->u_usb.next_read_ind]);
					hwcard->u_usb.stats.rx_sync_err_cnt++;
					hwcard->u_usb.rx_sync = 0;
					//sc->next_read_ind++;
					hwcard->u_usb.next_read_ind = (hwcard->u_usb.next_read_ind+1) % MAX_READ_BUF_LEN;
				data = WP_USB_CTRL_DECODE(&hwcard->u_usb.readbuf[hwcard->u_usb.next_read_ind]);
									hw->devname);
							hw->devname,
							hwcard->u_usb.next_read_ind,
							hwcard->u_usb.next_rx_ind);
					hwcard->u_usb.stats.rx_sync_err_cnt++;
					hwcard->u_usb.rx_sync = 0;
					//sc->next_read_ind++;
					hwcard->u_usb.next_read_ind = (hwcard->u_usb.next_read_ind+1) % MAX_READ_BUF_LEN;
			WAN_TASKLET_SCHEDULE((&hwcard->u_usb.bh_task));
	DEBUG_TEST("%s: q->dev=%p buf:%p\n", 
				SDLA_USB_NAME, q->dev, q->transfer_buffer);
	//q->dev = sc->dev;
	q->transfer_buffer = &hwcard->u_usb.readbuf[wurb->next_off];
				hw->devname);
			hw->devname,wurb->id,rxcount,
			hwcard->u_usb.next_read_ind, hwcard->u_usb.next_rx_ind, next_rx_off);
	wan_spin_unlock_irq(&hwcard->u_usb.lock,&flags);
	struct wan_urb	*wurb = (struct wan_urb*)q->context;
	sdlahw_t	*hw = (sdlahw_t*)wurb->pvt;
	WAN_ASSERT_VOID(hw->hwcpu == NULL);
	WAN_ASSERT_VOID(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	wan_spin_lock_irq(&hwcard->u_usb.lock,&flags);
	if (!wan_test_bit(WP_USB_STATUS_READY, &hwcard->u_usb.status)){
					hw->devname, txcount,
		hwcard->u_usb.stats.core_notready_cnt++;
		wan_spin_unlock_irq(&hwcard->u_usb.lock,&flags);
	if (hwcard->u_usb.opmode == SDLA_USB_OPMODE_VOICE){
		if (q->actual_length < MAX_USB_TX_LEN){
						q->actual_length,MAX_USB_TX_LEN);
			actual_length = q->actual_length; 
	wan_set_bit(1, &wurb->ready);
	wan_set_bit(WP_USB_STATUS_TX_READY, &hwcard->u_usb.status);	//sc->tx_ready = 1;
			hw->devname, wurb->id, txcount, txcount,
			MAX_USB_TX_LEN,q->transfer_buffer_length,
			hwcard->u_usb.next_tx_ind, hwcard->u_usb.next_write_ind);
	wan_spin_unlock_irq(&hwcard->u_usb.lock,&flags);
		(((epd)->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
		(((epd)->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)
		(((epd)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==	\
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	DEBUG_USB("%s: Preparing Transfer URBs...\n", hw->devname); 
	iface_desc = intf->cur_altsetting;
	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
		endpoint = &iface_desc->endpoint[i].desc;
			DEBUG_USB("%s: Found bulk in on endpoint %d\n", hw->devname, i);
			DEBUG_USB("%s: Found bulk out on endpoint %d\n", hw->devname, i);
	for (x = 0; x < hwcard->u_usb.urbcount_read; x++) {
			usb_init_urb(&hwcard->u_usb.dataread[x].urb);
					&hwcard->u_usb.dataread[x].urb,
					hwcard->u_usb.usb_dev,
					usb_rcvbulkpipe (hwcard->u_usb.usb_dev,
							   endpoint->bEndpointAddress),
					&hwcard->u_usb.readbuf[MAX_USB_RX_LEN*x], 
					&hwcard->u_usb.dataread[x]);	//p
			hwcard->u_usb.dataread[x].next_off = MAX_USB_RX_LEN*x;
					hw->devname, x,
					endpoint->bEndpointAddress,MAX_USB_RX_LEN,
					hwcard->u_usb.dataread[x].next_off,
					&hwcard->u_usb.readbuf[MAX_USB_RX_LEN*x]);
	for (x = 0; x < hwcard->u_usb.urbcount_write; x++) {
			usb_init_urb(&hwcard->u_usb.datawrite[x].urb);
					&hwcard->u_usb.datawrite[x].urb,
					hwcard->u_usb.usb_dev,
					usb_sndbulkpipe (hwcard->u_usb.usb_dev,
							endpoint->bEndpointAddress),
					&hwcard->u_usb.writebuf[MAX_USB_TX_LEN*x], 
					&hwcard->u_usb.datawrite[x]);	//p
			hwcard->u_usb.datawrite[x].next_off = MAX_USB_TX_LEN*x;
					hw->devname, x,
					endpoint->bEndpointAddress,MAX_USB_TX_LEN,
					hwcard->u_usb.datawrite[x].next_off,
					&hwcard->u_usb.writebuf[MAX_USB_TX_LEN*x]);
	ret = usb_submit_urb(&wurb->urb, GFP_KERNEL); 
		return -EINVAL;
	wan_clear_bit(1, &wurb->ready);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	WAN_ASSERT(hwcard->u_usb.usb_dev == NULL);
	length = (((size - 1) | 3) + 1)/4;
		return -ENOMEM;
		result = usb_control_msg (hwcard->u_usb.usb_dev,
				usb_sndctrlpipe(hwcard->u_usb.usb_dev, 0),
		result = usb_control_msg (hwcard->u_usb.usb_dev,
				usb_sndctrlpipe(hwcard->u_usb.usb_dev, 0),
		return -EPROTO;
	result = usb_control_msg(	hwcard->u_usb.usb_dev,
					usb_sndctrlpipe(hwcard->u_usb.usb_dev, 0),
 * 'data' is a pointer to a pre-allocated array of integers large
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	WAN_ASSERT(hwcard->u_usb.usb_dev == NULL);
	length = (((size - 1) | 3) + 1)/4;
		return -ENOMEM;
	result = usb_control_msg (	hwcard->u_usb.usb_dev,
					usb_rcvctrlpipe (hwcard->u_usb.usb_dev, 0),
		return -EPROTO;
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
				hw->devname,hwcard->u_usb.bus_id);
	WAN_TASKLET_INIT((&hwcard->u_usb.bh_task),0,sdla_usb_bh,hw);
	WAN_IFQ_INIT(&hwcard->u_usb.rx_cmd_free_list, WP_USB_MAX_RX_CMD_QLEN);
	WAN_IFQ_INIT(&hwcard->u_usb.rx_cmd_list, WP_USB_MAX_RX_CMD_QLEN);
						hw->devname);
		wan_skb_queue_tail(&hwcard->u_usb.rx_cmd_free_list, skb);
	WAN_IFQ_INIT(&hwcard->u_usb.tx_cmd_free_list, WP_USB_MAX_TX_CMD_QLEN);
	WAN_IFQ_INIT(&hwcard->u_usb.tx_cmd_list, WP_USB_MAX_TX_CMD_QLEN);
						hw->devname);
		wan_skb_queue_tail(&hwcard->u_usb.tx_cmd_free_list, skb);
	hwcard->u_usb.rxtx_len		= WP_USB_RXTX_DATA_LEN;
	hwcard->u_usb.rxtx_count	= WP_USB_RXTX_DATA_COUNT;
	hwcard->u_usb.rxtx_total_len	= hwcard->u_usb.rxtx_len * hwcard->u_usb.rxtx_count;
	hwcard->u_usb.rxtx_buf_len	= hwcard->u_usb.rxtx_total_len * 4;
	hwcard->u_usb.read_buf_len	= hwcard->u_usb.rxtx_buf_len * (WP_USB_MAX_RW_COUNT + 2);
	hwcard->u_usb.write_buf_len	= hwcard->u_usb.rxtx_buf_len * (WP_USB_MAX_RW_COUNT + 2);
	wan_spin_lock_init(&hwcard->u_usb.cmd_lock,"usb_cmd");
	wan_spin_lock_irq_init(&hwcard->u_usb.lock,"usb_bh_lock");
	hwcard->u_usb.ctrl_idle_pattern  = WP_USB_CTRL_IDLE_PATTERN;
					hw->devname);
				hw->devname, WP_USB_BAUD_RATE);
				hw->devname, bits);
	hwcard->u_usb.urbcount_read = MAX_READ_URB_COUNT;	//4
	hwcard->u_usb.urb_read_ind = 0;
	for (x = 0; x < hwcard->u_usb.urbcount_read; x++){
		hwcard->u_usb.dataread[x].id = x;
		hwcard->u_usb.dataread[x].pvt = hw;
		wan_set_bit(1, &hwcard->u_usb.datawrite[x].ready);
	hwcard->u_usb.urbcount_write = MAX_WRITE_URB_COUNT;	//4
	hwcard->u_usb.urb_write_ind = 0;
	for (x = 0; x < hwcard->u_usb.urbcount_write; x++){
		hwcard->u_usb.datawrite[x].id = x;
		hwcard->u_usb.datawrite[x].pvt = hw;
		wan_set_bit(1, &hwcard->u_usb.datawrite[x].ready);
	if (sdla_prepare_transfer_urbs(hw, hwcard->u_usb.usb_intf)) {
				hw->devname);
	hwcard->u_usb.next_rx_ind	= 0;
	hwcard->u_usb.next_read_ind	= 0;
	hwcard->u_usb.next_tx_ind	= 0;
	hwcard->u_usb.next_write_ind	= 0;
		memset(&hwcard->u_usb.regs[mod_no][0], 0xFF, 110); 
		hwcard->u_usb.writebuf[x] = idlebuf[x];
		hwcard->u_usb.idlebuf[x] = idlebuf[x];
	usb_set_intfdata(hwcard->u_usb.usb_intf, hw);
	wan_set_bit(WP_USB_STATUS_READY, &hwcard->u_usb.status);
	/* Verifing sync with USB-FXO device */
	hwcard->u_usb.opmode = SDLA_USB_OPMODE_VOICE;
	for (x = 0; x < hwcard->u_usb.urbcount_read; x++){
					hw->devname);
		if (wp_usb_start_transfer(&hwcard->u_usb.dataread[x])) {
					hw->devname, x);
	} while(!hwcard->u_usb.rx_sync);
	if (hwcard->u_usb.rx_sync){
		hwcard->u_usb.opmode = SDLA_USB_OPMODE_VOICE;
					hw->devname, err);
					hw->devname, data8);
					hw->devname, err);
		DEBUG_EVENT("%s: USB-FXO Hardware Version %d.%d!\n",
					hw->devname, (data8 >> 4) & 0x0F, data8 & 0x0F);
					hw->devname, err);
		DEBUG_EVENT("%s: USB-FXO Firmware Version %d.%d!\n",
					hw->devname, (data8 >> 4) & 0x0F, data8 & 0x0F);
		DEBUG_EVENT("%s: USB-FXO Device in Firmware Update mode...\n",
				  hw->devname);
		hwcard->u_usb.opmode = SDLA_USB_OPMODE_API;
	wan_clear_bit(WP_USB_STATUS_READY, &hwcard->u_usb.status);
	WAN_IFQ_PURGE(&hwcard->u_usb.tx_cmd_free_list);
	WAN_IFQ_DESTROY(&hwcard->u_usb.tx_cmd_free_list);
	WAN_IFQ_PURGE(&hwcard->u_usb.rx_cmd_free_list);
	WAN_IFQ_DESTROY(&hwcard->u_usb.rx_cmd_free_list);
	WAN_TASKLET_KILL(&hwcard->u_usb.bh_task);
	usb_set_intfdata(hwcard->u_usb.usb_intf, NULL);
	return -ENODEV;
	DEBUG_EVENT("%s: Releasing private data...\n", hw->devname);
	WAN_ASSERT(hw->hwcpu == NULL);
	WAN_ASSERT(hw->hwcpu->hwcard == NULL);
	hwcard = hw->hwcpu->hwcard;
	wan_clear_bit(WP_USB_STATUS_READY, &hwcard->u_usb.status);
	WAN_IFQ_PURGE(&hwcard->u_usb.tx_cmd_free_list);
	WAN_IFQ_DESTROY(&hwcard->u_usb.tx_cmd_free_list);
	WAN_IFQ_PURGE(&hwcard->u_usb.rx_cmd_free_list);
	WAN_IFQ_DESTROY(&hwcard->u_usb.rx_cmd_free_list);
	WAN_IFQ_PURGE(&hwcard->u_usb.tx_cmd_list);
	WAN_IFQ_DESTROY(&hwcard->u_usb.tx_cmd_list);
	WAN_IFQ_PURGE(&hwcard->u_usb.rx_cmd_list);
	WAN_IFQ_DESTROY(&hwcard->u_usb.rx_cmd_list);
	for (x = 0; x < hwcard->u_usb.urbcount_read; x++){
		usb_unlink_urb(&hwcard->u_usb.dataread[x].urb);
		usb_kill_urb(&hwcard->u_usb.dataread[x].urb);
	for (x = 0; x < hwcard->u_usb.urbcount_write; x++){
		usb_unlink_urb(&hwcard->u_usb.datawrite[x].urb);
		usb_kill_urb(&hwcard->u_usb.datawrite[x].urb);
	WAN_TASKLET_KILL(&hwcard->u_usb.bh_task);
	usb_set_intfdata(hwcard->u_usb.usb_intf, NULL);
./sdladrv_usb.c
 * Copyright:	(c) 1995-2005 Sangoma Technologies Inc.
# include "zapcompat.h" /* Map of Zaptel -> DAHDI definitions */
#define DBG_FUNC_START(func)	DEBUG_EVENT("(DEBUG)(TDM Voice): %s - Start\n", func)
#define DBG_FUNC_END(func)	DEBUG_EVENT("(DEBUG)(TDM Voice): %s - End\n", func)
#define IS_TDMV_RUNNING(wp)	wan_test_bit(WP_TDMV_RUNNING, &(wp)->flags)
#define IS_TDMV_UP(wp)		wan_test_bit(WP_TDMV_UP, &(wp)->flags)
#define IS_TDMV_SIG_POLL(wp)	wan_test_bit(WP_TDMV_SIG_POLL, &(wp)->flags)
#define IS_TDMV_SIG_ENABLE(wp)	wan_test_bit(WP_TDMV_SIG_ENABLE, &(wp)->flags)
#define IS_TDMV_RBS_READY(wp)	wan_test_bit(WP_TDMV_RBS_READY, &(wp)->flags)
# define IS_CHAN_HARDHDLC(chan)	(((chan)->flags & ZT_FLAG_NOSTDTXRX) || ((chan)->flags & ZT_FLAG_HDLC))
# define IS_CHAN_HARDHDLC(chan)	((chan)->flags & ZT_FLAG_HDLC)
** wp_tdmv_te1_init() - 
	iface->check_mtu	= wp_tdmv_check_mtu;
	iface->create		= wp_tdmv_create;
	iface->remove		= wp_tdmv_remove;
	iface->reg		= wp_tdmv_reg;
	iface->unreg		= wp_tdmv_unreg;
	iface->software_init	= wp_tdmv_software_init;
	iface->state		= wp_tdmv_state;
	iface->running		= wp_tdmv_running;
	iface->rx_tx		= wp_tdmv_rx_tx;
	iface->rx_chan		= wp_tdmv_rx_chan;
	iface->rx_dchan		= wp_tdmv_rx_dchan;
	iface->rx_tx_span	= wp_tdmv_rx_tx_span;
	iface->is_rbsbits	= wp_tdmv_is_rbsbits;	//????
	iface->rbsbits_poll	= wp_tdmv_rbsbits_poll;	//?????
	iface->init		= wp_tdmv_init;
	iface->buf_rotate	= wp_tdmv_span_buf_rotate;
	iface->ec_span		= wp_tdmv_ec_span;
	max_channels = GET_TE_CHANNEL_RANGE(&card->fe);
** wp_tdmv_create() - 
	WAN_ASSERT(tdmv_conf->span_no == 0);
	memset(&card->wan_tdmv, 0x0, sizeof(wan_tdmv_t));
		if (tmp->spanno == tdmv_conf->span_no){
					card->devname);
					card->devname, tdmv_conf->span_no);
			return -EINVAL;
	card->wan_tdmv.max_timeslots	= GET_TE_CHANNEL_RANGE(&card->fe);
	card->wan_tdmv.spanno		= tdmv_conf->span_no;
	card->wandev.te_report_rbsbits  = wp_tdmv_report_rbsbits;
	card->wandev.te_report_alarms	= wp_tdmv_report_alarms;	
		return -ENOMEM;
	card->wan_tdmv.sc	= wp;
	wp->spanno		= tdmv_conf->span_no-1;
	wp->num			= wp_card_no++;
	wp->card		= card;
	wp->devname		= card->devname;
	wp->lcode		= WAN_FE_LCODE(&card->fe);
	wp->frame		= WAN_FE_FRAME(&card->fe);
	wp->lbo			= WAN_TE1_LBO(&card->fe);
	wp->ise1		= IS_E1_FEMEDIA(&card->fe) ? 1 : 0;
	wp->max_timeslots	= IS_E1_FEMEDIA(&card->fe) ? 31: 24;
	wp->max_rxtx_len		= 0;
	wan_spin_lock_irq_init(&wp->lockirq, "wan_te1tdmv_lock");
	wan_spin_lock_irq_init(&wp->tx_rx_lockirq, "wan_te1tdmv_txrx_lock");
	for (i = 0; i < sizeof(wp->chans)/sizeof(wp->chans[0]); i++) {
		wp->chans_ptrs[i] = &wp->chans[i];
	if (tdmv_conf->dchan){
		wp->dchan_map = tdmv_conf->dchan;
		if (wp->ise1) {
			wan_clear_bit(0,&wp->dchan_map);
		WAN_LIST_INSERT_AFTER(tmp, &card->wan_tdmv, next);
		WAN_LIST_INSERT_HEAD(&wan_tdmv_head, &card->wan_tdmv, next);
** wp_tdmv_reg() - 
** Returns: 	0-31	- Return TDM Voice channel number.
**		-EINVAL - otherwise
	wan_tdmv_t	*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wp = wan_tdmv->sc;
	if (wan_test_bit(WP_TDMV_REGISTER, &wp->flags)){
				card->devname);
		return -EINVAL;
	 * T1: 1-24
	 * E1: 0-31 */
	for(i = 0; i<wp->max_timeslots; i++){
			wan_set_bit(i, &wp->timeslot_map);
			if (tdmv_conf->tdmv_echo_off){
				wan_set_bit(i, &wp->echo_off_map);
				card->devname, wan_netif_name(dev));
		return -EINVAL;
				wp->devname);
				wp->devname,cnt);
			return -EINVAL;	
		if (tdmv_conf->tdmv_echo_off){
					wp->devname);
		wp->channelized = WAN_FALSE;
		if (wp->dchan_map){
				DEBUG_EVENT("%s: ERROR: Device pointer is NULL for D-chan!\n",
							wp->devname);
				return -EINVAL;
			wp->dchan_dev = dev;
		if (wan_test_bit(channo, &wp->dchan_map)){
				DEBUG_EVENT("%s: ERROR: Device pointer is NULL for D-chan!\n",
							wp->devname);
				return -EINVAL;
			wp->dchan_dev = dev;
		if (tdmv_conf->tdmv_echo_off){
					wp->devname);
		memset(wp->chans[channo].sreadchunk, WAN_TDMV_IDLE_FLAG, ZT_CHUNKSIZE);
		memset(wp->chans[channo].swritechunk, WAN_TDMV_IDLE_FLAG, ZT_CHUNKSIZE);
		wp->chans[channo].readchunk = wp->chans[channo].sreadchunk;
		wp->chans[channo].writechunk = wp->chans[channo].swritechunk;
		wp->channelized = WAN_TRUE;
	wp->hwec = ec_enable;
	wp_tdmv_check_mtu(card, active_ch, &wp->max_rxtx_len);
** wp_tdmv_del() - 
	wan_tdmv_t	*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wp = wan_tdmv->sc;
	for(channo = 0; channo < wp->max_timeslots; channo++){
		if (wan_test_bit(channo, &wp->timeslot_map)){
			wan_clear_bit(channo, &wp->timeslot_map);
			wan_clear_bit(channo, &wp->echo_off_map);
			memset(wp->chans[channo].sreadchunk, 
			memset(wp->chans[channo].swritechunk, 
			wp->chans[channo].readchunk = 
					wp->chans[channo].sreadchunk;
			wp->chans[channo].writechunk = 
					wp->chans[channo].swritechunk;
** wp_tdmv_running() - 
	wan_tdmv_t	*wan_tdmv = &card->wan_tdmv;
	wp = wan_tdmv->sc;
	if (wp && wp->usecount){
				card->devname);
		return -EINVAL;
** wp_tdmv_remove() - 
	wan_tdmv_t	*wan_tdmv = &card->wan_tdmv;
	if (!card->wan_tdmv.sc){
	wp = wan_tdmv->sc;
	if (wp && wp->timeslot_map){
				card->devname, wp->timeslot_map);
		return -EINVAL;
	if (wp && wp->usecount){
				card->devname);
		return -EINVAL;
	wan_spin_lock_irq(&wp->lockirq, &flags);
	card->wandev.te_report_rbsbits = NULL;
	card->wandev.te_report_alarms = NULL;	
	card->wandev.event_callback.dtmf = NULL;
	wan_spin_unlock_irq(&wp->lockirq, &flags);
		wan_clear_bit(WP_TDMV_RUNNING, &wp->flags);
		wan_clear_bit(WP_TDMV_UP, &wp->flags);
		wan_tdmv->sc = NULL;
		wan_tdmv->sc = NULL;
	wan_tdmv_t*	wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wp = (wp_tdmv_softc_t*)wan_tdmv->sc;
		wan_set_bit(WP_TDMV_UP, &wp->flags);
		wan_clear_bit(WP_TDMV_UP, &wp->flags);
		wp->rbs_rx_pending = wp->sig_timeslot_map;
			wp->devname,
	if (card->wandev.fe_iface.set_fe_sigctrl){
		if (wan_test_bit(WP_TDMV_SIG_POLL, &wp->flags)){
			card->wandev.fe_iface.set_fe_sigctrl(
					&card->fe, 
			card->wandev.fe_iface.set_fe_sigctrl(
					&card->fe,
   		wan_set_bit(WP_TDMV_SIG_ENABLE, &wp->flags);
   		wan_set_bit(WP_TDMV_RBS_READY, &wp->flags);
   		wan_clear_bit(WP_TDMV_RBS_READY, &wp->flags);
   		wan_clear_bit(WP_TDMV_SIG_ENABLE, &wp->flags);
				wp->devname, status);
		return -EINVAL;
** wp_tdmv_report_rbsbits() - 	Report A,B bit status changes to TDM Voice
	wan_tdmv_t*		wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT1(wan_tdmv->sc == NULL);
	wp = (wp_tdmv_softc_t*)wan_tdmv->sc;
	if (!wan_test_bit(channel-1, &wp->timeslot_map)){
	if (wp->ise1){
			if (!(wp->chans[i+15].sig & ZT_SIG_CLEAR)) {
				if (wp->chans[i+15].rxsig != rxs)
					zt_rbsbits(&wp->chans[i+15], rxs);
			if (!(wp->chans[i].sig & ZT_SIG_CLEAR)) {
				if (wp->chans[i].rxsig != rxs)
					zt_rbsbits(&wp->chans[i], rxs);
	for(i=0; i < wp->span.channels;i++){
		if (wp->chans[i].chanpos == channel)
	if (i == wp->span.channels){
	if (!(wp->chans[i].sig & ZT_SIG_CLEAR) &&
	    (wp->chans[i].rxsig != rxs)){
		zt_rbsbits(&wp->chans[i], rxs);
				wp->devname, 
				(wp->ise1) ? "E1" : "T1",
				channel, wp->chans[i].channo,
** wp_tdmv_report_alarms() - 
	wan_tdmv_t	*wan_tdmv = &card->wan_tdmv;
	wp = wan_tdmv->sc;
	wp->span.alarms &= (ZT_ALARM_RED | ZT_ALARM_BLUE | ZT_ALARM_NOTOPEN);
	prev_alarms = wp->span.alarms;
	if (wp->ise1){
		if (!wp->span.mainttimer && (te_alarm & WAN_TE_BIT_LOOPUP_CODE)){
			/* Loop-up code detected */
			if ((wp->loopupcnt++ > 80)  && (wp->span.maintstat != ZT_MAINT_REMOTELOOP)){
				card->wandev.fe_iface.set_fe_lbmode(
						&wp->card->fe,
				card->wandev.fe_iface.set_fe_lbmode(
						&wp->card->fe,
				wp->span.maintstat = ZT_MAINT_REMOTELOOP;
			wp->loopupcnt = 0;
		if (!wp->span.mainttimer && (te_alarm & WAN_TE_BIT_LOOPDOWN_CODE)){
			/* Loop-down code detected */
			if ((wp->loopdowncnt++ > 80)  && (wp->span.maintstat == ZT_MAINT_REMOTELOOP)){
				card->wandev.fe_iface.set_fe_lbmode(
						&wp->card->fe,
				card->wandev.fe_iface.set_fe_lbmode(
						&wp->card->fe,
				wp->span.maintstat = ZT_MAINT_NONE;
			wp->loopdowncnt = 0;
	if (wp->span.lineconfig & ZT_CONFIG_NOTOPEN) {
		for (x=0,j=0;x < wp->span.channels;x++){
			if ((wp->chans[x].flags & ZT_FLAG_OPEN) ||
			    (wp->chans[x].flags & ZT_FLAG_NETDEV)){
	if (wp->ise1) {
	if ((!alarms) && wp->span.alarms)
		wp->alarmtimer = ZT_ALARMSETTLE_TIME;
	if (alarms && (!wp->span.alarms)) {
				wp->devname);
		if (card->wandev.fe_iface.set_fe_alarm){
			card->wandev.fe_iface.set_fe_alarm(&card->fe, WAN_TE_BIT_YEL_ALARM);
	if (wp->span.alarms != alarms) {
			       	wp->devname,alarms);
	** if (wp->alarmtimer)
	wp->span.alarms = alarms;
	zt_alarm_notify(&wp->span);
** wp_tdmv_txcopy() - 
	wp_tdmv_softc_t	*wp = wan_tdmv->sc;
		for (x=0;x<wp->span.channels;x++){
			if (!wan_test_bit(x,&wp->timeslot_map)){
			txbuf[offset++] =  wp->chans[x].writechunk[y];
** wp_tdmv_txprep() - 
	wp_tdmv_softc_t	*wp = wan_tdmv->sc;
	zt_transmit(&wp->span);
** wp_tdmv_rxcopy() - 
	wp_tdmv_softc_t	*wp = wan_tdmv->sc;
	int		channels = wp->span.channels;
			if (wan_test_bit(x,&wp->timeslot_map)){
			wp->chans[x].readchunk[y] = value;
** wp_tdmv_rxprep() - 
	wp_tdmv_softc_t	*wp = wan_tdmv->sc;
	int		x, offset = 0, channels = wp->span.channels;
	if (!wp->echo_off_map){
			wan_tdmv_rxtx_pwr_t *pwr_rxtx = &wan_tdmv->chan_pwr[x];
			wp_tdmv_echo_check(wan_tdmv, &wp->chans[0], x);
			if(pwr_rxtx->current_state != ECHO_ABSENT){
					&wp->chans[x], 
					wp->chans[x].readchunk, 
					wp->chans[x].writechunk);
					&wp->chans[x], 
					wp->chans[x].readchunk, 
					wp->ec_chunk1[x]);
					wp->ec_chunk1[x],
					wp->chans[x].writechunk,
	zt_receive(&wp->span);
** wp_tdmv_rx_tx() - 
	wan_tdmv_t	*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wp = wan_tdmv->sc;
	if (wan_skb_len(skb) != wp->max_rxtx_len){
					wp->devname, 
					wp->max_rxtx_len); 
	wp->intcount ++;
	if (wan_test_bit(WP_TDMV_RBS_UPDATE, &wp->flags)){
		if (card->wandev.fe_iface.report_rbsbits){
			card->wandev.fe_iface.report_rbsbits(&card->fe);
		wan_clear_bit(WP_TDMV_RBS_UPDATE, &wp->flags);
		wan_clear_bit(WP_TDMV_RBS_BUSY, &wp->flags);
	return wp->max_rxtx_len;
** wp_tdmv_software_init() - 
	wp_tdmv_softc_t	*wp = wan_tdmv->sc;
	WAN_ASSERT(wp->card == NULL);
	card = wp->card;
	if (wan_test_bit(WP_TDMV_REGISTER, &wp->flags)){
					wp->devname, wp->span.spanno);
	if (wp->ise1 && wp->channelized == WAN_FALSE){
		wp->timeslot_map = wp->timeslot_map >> 1;
		wp->echo_off_map = wp->echo_off_map >> 1;
	if (wp->ise1){
		sprintf(wp->span.name, "WPE1/%d", wp->num);
		sprintf(wp->span.name, "WPT1/%d", wp->num);
	sprintf(wp->span.desc, "%s card %d", wp->devname, wp->num);
	wp->span.spanconfig = wp_tdmv_spanconfig;
	wp->span.chanconfig = wp_tdmv_chanconfig;
	wp->span.startup = wp_tdmv_startup;
	wp->span.shutdown = wp_tdmv_shutdown;
	wp->span.rbsbits = wp_tdmv_rbsbits;
	wp->span.maint = wp_tdmv_maint;
	wp->span.open = wp_tdmv_open;
	wp->span.close = wp_tdmv_close;
	wp->span.channels = wp->max_timeslots;
	wp->span.chans = wp->chans_ptrs;
	wp->span.chans = wp->chans;
	wp->span.flags = ZT_FLAG_RBS;
	wp->span.ioctl = wp_tdmv_ioctl;
	if (wp->hwec == WANOPT_YES && card->wandev.ec_dev){
		wp->span.echocan = wp_tdmv_hwec;
	if (wp->dchan_map){
				wp->devname);
		wp->span.hdlc_hard_xmit = wp_tdmv_tx_hdlc_hard;
	wp->span.pvt = wp;
	if (wp->ise1){
		wp->span.deflaw = ZT_LAW_ALAW;
		card->fe.fe_cfg.tdmv_law = WAN_TDMV_ALAW;
		wp->span.linecompat = ZT_CONFIG_HDB3 | ZT_CONFIG_CCS | ZT_CONFIG_CRC4;
		wp->span.deflaw = ZT_LAW_MULAW;
		card->fe.fe_cfg.tdmv_law = WAN_TDMV_MULAW;
		wp->span.linecompat = ZT_CONFIG_AMI | ZT_CONFIG_B8ZS | ZT_CONFIG_D4 | ZT_CONFIG_ESF;
	init_waitqueue_head(&wp->span.maintq);
	for (x=0;x<wp->span.channels;x++) {
		sprintf(wp->chans[x].name, "%s/%d", wp->span.name, x+1);
		if (wan_test_bit(x,&wp->timeslot_map)){
					wp->devname, 
					wp->chans[x].name);
			wp->chans[x].sigcap = 
			wp->chans[x].sigcap = ZT_SIG_NONE;
		wp->chans[x].pvt = wp;
		wp->chans[x].chanpos = x + 1;
		wp->chans[x].rxsig = 0x00;
	if (zt_register(&wp->span, 0)) {
					wp->devname);
		return -EINVAL;
	if (wp->span.spanno != wp->spanno +1){
						wp->spanno + 1);
						wp->devname,wp->span.spanno);
		wp->spanno = wp->span.spanno-1;
					wp->devname, wp->span.spanno);
	if (wp->channelized == WAN_FALSE && wp->dchan_map){
		if (wp->ise1) {
               		wp->dchan_map=wp->dchan_map>>1;
			wan_clear_bit(0,&wp->dchan_map);
		wp->timeslot_map &= ~wp->dchan_map;
		wp->echo_off_map &= ~wp->dchan_map;		
	wp_tdmv_check_mtu(card, wp->timeslot_map, &wp->max_rxtx_len);
	wan_set_bit(WP_TDMV_REGISTER, &wp->flags);
	if (!wan_tdmv->sig_intr_enable){
		wan_set_bit(WP_TDMV_SIG_POLL, &wp->flags);
		card->tdmv_iface.is_rbsbits	= wp_tdmv_is_rbsbits;
		card->tdmv_iface.rbsbits_poll	= wp_tdmv_rbsbits_poll;
	wp->dtmfsupport = card->u.aft.tdmv_hw_dtmf;
	if (wp->dtmfsupport == WANOPT_YES){
		DEBUG_EVENT("%s: Enable HW DTMF detection!\n", wp->devname);
		card->wandev.event_callback.dtmf = wp_tdmv_callback_dtmf;
** wp_tdmv_startup() - 
	WAN_ASSERT2(span == NULL, -ENODEV);
	WAN_ASSERT2(span->pvt == NULL, -ENODEV);
	wp		= span->pvt;
	for(i = 0; i < span->channels; i++){
		memset(wp->ec_chunk1[i],
			ZT_LIN2X(0,span->chans[i]),ZT_CHUNKSIZE);
		memset(wp->ec_chunk2[i],
			ZT_LIN2X(0,span->chans[i]),ZT_CHUNKSIZE);
		memset(wp->ec_chunk1[i],
			ZT_LIN2X(0,&span->chans[i]),ZT_CHUNKSIZE);
		memset(wp->ec_chunk2[i],
			ZT_LIN2X(0,&span->chans[i]),ZT_CHUNKSIZE);
	if (!(span->flags & ZT_FLAG_RUNNING)) {
		span->flags |= ZT_FLAG_RUNNING;
	wan_set_bit(WP_TDMV_RUNNING, &wp->flags);
** wp_tdmv_shutdown() - 
	WAN_ASSERT2(span == NULL, -ENODEV);
	WAN_ASSERT2(span->pvt == NULL, -ENODEV);
	wp		= span->pvt;
	wan_clear_bit(WP_TDMV_RUNNING, &wp->flags);
	wan_spin_lock_irq(&wp->lockirq, &flags);
	span->flags &= ~ZT_FLAG_RUNNING;
	wan_spin_unlock_irq(&wp->lockirq, &flags);
** wp_tdmv_maint() - 
	wp_tdmv_softc_t	*wp = span->pvt;
	sdla_t		*card = wp->card;
	WAN_ASSERT2(span == NULL, -ENODEV);
	WAN_ASSERT2(span->pvt == NULL, -ENODEV);
	wp		= span->pvt;
	wan_spin_lock_irq(&wp->lockirq, &flags);
	if (wp->ise1) {
				       wp->card->devname);	
				       wp->card->devname);	
				       wp->card->devname);	
			res = -ENOSYS;
					wp->card->devname, cmd);
			res = -EINVAL;
				       wp->card->devname);	
			card->wandev.fe_iface.set_fe_lbmode(
					&wp->card->fe,
			card->wandev.fe_iface.set_fe_lbmode(
					&wp->card->fe,
				       wp->card->devname);	
			card->wandev.fe_iface.set_fe_lbmode(
					&wp->card->fe,
			card->wandev.fe_iface.set_fe_lbmode(
					&wp->card->fe,
				       wp->card->devname);	
			card->wandev.fe_iface.set_fe_lbmode(
					&wp->card->fe,
			card->wandev.fe_iface.set_fe_lbmode(
					&wp->card->fe,
				       wp->card->devname);	
			card->wandev.fe_iface.set_fe_lbmode(
					&wp->card->fe,
				       wp->card->devname);	
			card->wandev.fe_iface.set_fe_lbmode(
					&wp->card->fe,
				       wp->card->devname);	
					wp->card->devname, cmd);
			res = -EINVAL;
	wan_spin_unlock_irq(&wp->lockirq, &flags);
** sigstr() - 
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wp	= chan->pvt;
	card	= (sdla_t*)wp->card;
	DEBUG_TDMV("%s: Configuring chan %d..\n", wp->devname, chan->chanpos);
	if (chan->span->flags & ZT_FLAG_RUNNING){
	if (!wan_test_and_set_bit(chan->chanpos, &wp->config_tsmap)){
		wp->timeslots++;
		if (!wan_test_and_set_bit(chan->chanpos-1, &wp->sig_timeslot_map)){
			wp->sig_timeslots ++;
			wan_set_bit(chan->chanpos-1, &wp->rbs_rx_pending);
		wp_tdmv_sigctrl(card, wp, chan->chanpos, WP_TDMV_ENABLE);
** wp_tdmv_spanconfig() - 
	WAN_ASSERT2(span == NULL, -ENODEV);
	WAN_ASSERT2(span->pvt == NULL, -ENODEV);
	wp		= span->pvt;
	card = (sdla_t*)wp->card;
	DEBUG_TDMV("%s: Configuring span device..\n", wp->devname);
	switch(wp->lcode){
		span->lineconfig |= ZT_CONFIG_AMI;
		span->lineconfig |= ZT_CONFIG_B8ZS;
		span->lineconfig |= ZT_CONFIG_HDB3;
	switch(wp->frame){
		span->lineconfig |= ZT_CONFIG_ESF;
		span->lineconfig |= ZT_CONFIG_D4;
		span->lineconfig |= ZT_CONFIG_CRC4;
	if (wp->ise1){
	       if (lc->lineconfig & ZT_CONFIG_CCS){
			span->lineconfig |= ZT_CONFIG_CCS;
			card->fe.fe_cfg.cfg.te_cfg.sig_mode = WAN_TE1_SIG_CCS;
			card->fe.fe_cfg.cfg.te_cfg.sig_mode = WAN_TE1_SIG_CAS;
		if (card->wandev.fe_iface.reconfig){
			card->wandev.fe_iface.reconfig(&card->fe);
	span->txlevel = 0;
	switch(wp->lbo){
       		DEBUG_TE1("%s: LBO 0 dB\n", card->devname);
		span->txlevel = 0;
       		DEBUG_TE1("%s: LBO 7.5 dB\n", card->devname);
		span->txlevel = 5;
       		DEBUG_TE1("%s: LBO 15 dB\n", card->devname);
		span->txlevel = 6;
       		DEBUG_TE1("%s: LBO 22.5 dB\n", card->devname);
		span->txlevel = 7;
        	DEBUG_TE1("%s: LBO 0-110 ft.\n", card->devname);
		span->txlevel = 0;
       		DEBUG_TE1("%s: LBO 110-220 ft.\n", card->devname);
		span->txlevel = 1;
       		DEBUG_TE1("%s: LBO 220-330 ft.\n", card->devname);
		span->txlevel = 2;
       		DEBUG_TE1("%s: LBO 330-440 ft.\n", card->devname);
		span->txlevel = 3;
       		DEBUG_TE1("%s: LBO 440-550 ft.\n", card->devname);
		span->txlevel = 3;
       		DEBUG_TE1("%s: LBO 550-660 ft.\n", card->devname);
		span->txlevel = 4;
	span->rxlevel = 0;
	wp->sync = lc->sync;
	if (span->flags & ZT_FLAG_RUNNING){
** wp_tdmv_rbsbits() - Set A,B bits according TDM Voice requests. 
	if ((wp = chan->pvt) == NULL) return 0;
	WAN_ASSERT2(wp->card == NULL, 0);
	card = (sdla_t*)wp->card;
	if (!wan_test_bit(chan->chanpos-1, &wp->timeslot_map)){
   	if (!wan_test_bit(WP_TDMV_SIG_ENABLE, &wp->flags)){
			wp->devname, 
			(wp->ise1) ? "E1" : "T1",
			chan->chanpos, chan->channo,
	if (wan_test_and_set_bit(chan->chanpos-1, &wp->rbs_tx_status)){
		if (ABCD_bits == wp->rbs_tx[chan->chanpos-1]){
		if (wan_test_and_set_bit(chan->chanpos-1, &wp->rbs_tx1_status)){
			if (ABCD_bits == wp->rbs_tx1[chan->chanpos-1]){
						wp->devname,
						chan->chanpos);
		wp->rbs_tx1[chan->chanpos-1] = ABCD_bits;
		wp->rbs_tx[chan->chanpos-1] = ABCD_bits;
	if (wan_test_and_set_bit(7, &wp->rbs_tx[chan->chanpos-1])){
		if (ABCD_bits == wp->rbs_tx[chan->chanpos-1]){
		if (wan_test_and_set_bit(7, &wp->rbs_tx1[chan->chanpos-1])){
			if (ABCD_bits == wp->rbs_tx1[chan->chanpos-1]){
						wp->devname,
						chan->chanpos);
		wp->rbs_tx1[chan->chanpos-1] = ABCD_bits;
		wp->rbs_tx[chan->chanpos-1] = ABCD_bits;
** wp_tdmv_is_rbsbits() -
**	Returns: 1 - start RBS poll routine, 0 - otherwise
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wp = wan_tdmv->sc;
	if (wan_test_and_set_bit(WP_TDMV_RBS_BUSY, &wp->flags)){
	if (wp->rbs_tx_status || wp->rbs_tx1_status){
		wan_clear_bit(WP_TDMV_RBS_BUSY, &wp->flags);
	wp->rbscount++;
	if (!(wp->rbscount & 0xF)){
	wan_clear_bit(WP_TDMV_RBS_BUSY, &wp->flags);
** wp_tdmv_rbsbits_poll() -
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wp = wan_tdmv->sc;
	if (wp->rbs_tx_status || wp->rbs_tx1_status){
		wan_clear_bit(WP_TDMV_RBS_BUSY, &wp->flags);
	if (wp->rbs_rx_pending){
				wp->devname,
		for(i=0; i < wp->max_timeslots;i++){
			if (wan_test_bit(i, &wp->rbs_rx_pending)){
				wan_clear_bit(i, &wp->rbs_rx_pending);
				card->wandev.fe_iface.read_rbsbits(
					&card->fe, 
		wan_set_bit(WP_TDMV_RBS_UPDATE, &wp->flags);
				wp->devname,
				(wp->rbscount % 1000) ? "Normal" : "Sanity");
	if (wp->rbscount % 1000 == 0){
		for(x = 0; x < wp->max_timeslots; x++){
			if (wan_test_bit(x, &wp->sig_timeslot_map)){
				card->wandev.fe_iface.read_rbsbits(
					&card->fe,
		if (card->wandev.fe_iface.check_rbsbits == NULL){
					wp->devname,
			return -EINVAL;
		card->wandev.fe_iface.check_rbsbits(
				&card->fe, 
				1, wp->sig_timeslot_map, 0);
		card->wandev.fe_iface.check_rbsbits(
				&card->fe, 
				9, wp->sig_timeslot_map, 0);
		card->wandev.fe_iface.check_rbsbits(
				&card->fe, 
				17, wp->sig_timeslot_map, 0);
		if (wp->ise1){	
			card->wandev.fe_iface.check_rbsbits(
					&card->fe, 
					25, wp->sig_timeslot_map, 0);
	wan_set_bit(WP_TDMV_RBS_UPDATE, &wp->flags);
** wp_tdmv_tx_rbsbits() -
	WAN_ASSERT2(wp->card == NULL, 0);
	card = (sdla_t*)wp->card;
	for(x=0;x<wp->max_timeslots;x++){
		if (wan_test_bit(x, &wp->rbs_tx_status)){
			card->wandev.fe_iface.set_rbsbits(
					&wp->card->fe, 
					wp->rbs_tx[x]);
			wan_clear_bit(x, &wp->rbs_tx_status);
			if (wan_test_bit(x, &wp->rbs_tx1_status)){
				card->wandev.fe_iface.set_rbsbits(
						&wp->card->fe, 
						wp->rbs_tx1[x]);
				wan_clear_bit(x, &wp->rbs_tx1_status);
	for(x=0;x<wp->max_timeslots;x++){
		if (wan_test_bit(7, &wp->rbs_tx[x])){
			card->wandev.fe_iface.set_rbsbits(
					&wp->card->fe, 
					wp->rbs_tx[x]);
			wan_clear_bit(7, &wp->rbs_tx[x]);
			if (wan_test_bit(7, &wp->rbs_tx1[x])){
				card->wandev.fe_iface.set_rbsbits(
						&wp->card->fe, 
						wp->rbs_tx1[x]);
				wan_clear_bit(7, &wp->rbs_tx1[x]);
** wp_tdmv_ioctl() - 
	int			err = -ENOTTY, x;
	WAN_ASSERT(chan == NULL || chan->pvt == NULL);
	wp = chan->pvt;
	WAN_ASSERT(wp->card == NULL);
	card	= wp->card;
		if (err) return -EFAULT;
		if (wp->dtmfsupport != WANOPT_YES || card->wandev.ec_dev == NULL){
			return -ENOSYS;
			wp->devname,
			wp->dtmfmask |= (1 << (chan->chanpos - 1));
			wp->dtmfmask &= ~(1 << (chan->chanpos - 1));
			wp->dtmfmutemask |= (1 << (chan->chanpos - 1));
			wp->dtmfmutemask &= ~(1 << (chan->chanpos - 1));
						wp->devname);
			return -EFAULT;
		event_ctrl->type = WAN_EVENT_EC_CHAN_MODIFY;
		event_ctrl->channel = chan->chanpos-1;
		event_ctrl->mode = (x & ZT_TONEDETECT_MUTE) ? WAN_EVENT_ENABLE : WAN_EVENT_DISABLE;
		if (wanpipe_ec_event_ctrl(card->wandev.ec_dev, card, event_ctrl)){
		err = -EINVAL;
		if (wp->dchan_dev && wp->dchan_dev->hard_start_xmit){
			err=-EOPNOTSUPP;
		WAN_ASSERT(chan == NULL || chan->pvt == NULL);
		echo_detect_chan = chan->chanpos - 1;
					wp->spanno, 
			err=-EOPNOTSUPP;
			wan_tdmv_t *wan_tdmv = &wp->card->wan_tdmv;
			wan_tdmv_rxtx_pwr_t *pwr_rxtx = &wan_tdmv->chan_pwr[echo_detect_chan];
				(chan->xlaw == __zt_mulaw ? "MULAW" : "ALAW"));
			chan->echo_detect_struct.echo_state = pwr_rxtx->current_state;
				TDMV_SAMPLE_STATE_DECODE(chan->echo_detect_struct.echo_state));
			chan->echo_detect_struct.echo_present_samples_number =
				pwr_rxtx->echo_present_samples_number_history;
			chan->echo_detect_struct.echo_absent_samples_number = 
				pwr_rxtx->echo_absent_samples_number_history;
		err = -ENOTTY;
** wp_tdmv_hwec() - 
	int		channel = chan->chanpos;
	int		err = -EINVAL;
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wp = chan->pvt;
	WAN_ASSERT2(wp->card == NULL, -ENODEV);
	card = wp->card;
	if (!wp->ise1){
		channel--;
		wan_set_bit(channel,&card->wandev.rtp_tap_call_map);
		wan_clear_bit(channel,&card->wandev.rtp_tap_call_map);
	if (card->wandev.ec_enable){
				wp->devname,
		if (card->hwec_conf.persist_disable || IS_CHAN_HARDHDLC(chan)) {
                	err = card->wandev.ec_enable(card, enable, chan->chanpos);
** wp_tdmv_open() - 
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wp = chan->pvt;
	WAN_ASSERT2(wp->card == NULL, -ENODEV);
	card = wp->card;
	wp->usecount++;
				wp->devname,
				wp->usecount,
				chan->channo,
				chan->chanpos);
** wp_tdmv_close() - 
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wp = chan->pvt;
	wp->usecount--;
				wp->devname,
				wp->usecount,
				chan->channo,
				chan->chanpos);
** wp_tdmv_release() - 
	if (wan_test_bit(WP_TDMV_REGISTER, &wp->flags)){
				wp->devname);
		wan_clear_bit(WP_TDMV_SIG_POLL, &wp->flags);
		wan_clear_bit(WP_TDMV_REGISTER, &wp->flags);
		zt_unregister(&wp->span);
		wan_clear_bit(WP_TDMV_REGISTER, &wp->flags);
	wp->alarmpos = 0;
	wp->blinktimer = 0;
	wp->alarmpos = 0;
	wp->blinktimer = 0;
** wp_tdmv_rx_dchan() - 
	wp_tdmv_softc_t	*wp = wan_tdmv->sc;
        if (!wan_test_bit(channo, &wp->dchan_map)) {
				   wp->devname,channo,wp->dchan_map);
        	return -EINVAL;
	chan	= &wp->chans[channo];
	WAN_ASSERT(chan == NULL || chan->master == NULL);
	ms = chan->master;
				wp->devname); 
		return -EINVAL;
		DEBUG_TDMV("%s: ERROR: %s not defined as D-CHAN!\n",
				wp->devname, ms->name); 
		return -EINVAL;
	if (ms->inreadbuf < 0){
		return -EINVAL;
	if (ms->inreadbuf >= ZT_MAX_NUM_BUFS){
		DEBUG_EVENT("%s: RX buffer (%s) is out of range (%d-%d)!\n",
				wp->devname, ms->name, ms->inreadbuf,ZT_MAX_NUM_BUFS); 
		return -EINVAL;
	/* FIXME wan_spin_lock_irqsave(&wp->tx_rx_lock, smp_flags); */
	wan_spin_lock_irq(&chan->lock, &smp_flags);
	buf = ms->readbuf[ms->inreadbuf];
	left = ms->blocksize - ms->readidx[ms->inreadbuf];
				wp->devname, len+2, left); 
		wan_spin_unlock_irq(&chan->lock, &smp_flags);
		return -EINVAL;
		buf[ms->readidx[ms->inreadbuf]++] = rxbuf[i];
	buf[ms->readidx[ms->inreadbuf]++] = 0x00;
	buf[ms->readidx[ms->inreadbuf]++] = 0x00;
	oldbuf = ms->inreadbuf;
	ms->readn[ms->inreadbuf] = ms->readidx[ms->inreadbuf];
	ms->inreadbuf = (ms->inreadbuf + 1) % ms->numbufs;
	if (ms->inreadbuf == ms->outreadbuf) {
		ms->inreadbuf = -1;
		ms->rxdisable = 0;
	if (ms->outreadbuf < 0) { /* start out buffer if not already */
		ms->outreadbuf = oldbuf;
	/* FIXME wan_spin_unlock_irq(&wp->tx_rx_lock, &smp_flags); */
	wan_spin_unlock_irq(&chan->lock, &smp_flags);
	if (!ms->rxdisable) { /* if receiver enabled */
					wp->devname);
		wake_up_interruptible(&ms->readbufq);
		wake_up_interruptible(&ms->sel);
		if (ms->iomask & ZT_IOMUX_READ)
			wake_up_interruptible(&ms->eventbufq);
		wakeup(&ms->readbufq);
		_selwakeup(&ms->sel);
		if (ms->iomask & ZT_IOMUX_READ)
			wakeup(&ms->eventbufq);
	WAN_ASSERT_VOID(chan->pvt == NULL);
	wp	= chan->pvt;
	WAN_ASSERT_VOID(wp->dchan_dev == NULL);
	size = chan->writen[chan->outwritebuf] - chan->writeidx[chan->outwritebuf]-2;
					wp->devname, size, res);
	err = wp->dchan_dev->hard_start_xmit(skb, wp->dchan_dev);
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wp	= chan->pvt;
	WAN_ASSERT(wp->dchan_dev == NULL);
		return -EINVAL;
	len -= 2; /* Remove checksum */
        	return -ENOMEM;
	wan_spin_lock_irq(&chan->lock, &smp_flags);
	memcpy(data, chan->writebuf[chan->inwritebuf], len);
	wan_spin_unlock_irq(&chan->lock, &smp_flags);
		err = wp->dchan_dev->hard_start_xmit(skb, wp->dchan_dev);
** wp_tdmv_rx_chan() - 
	wp_tdmv_softc_t	*wp = wan_tdmv->sc;
	WAN_ASSERT2(wp == NULL, -EINVAL);
	WAN_ASSERT2(channo < 0, -EINVAL);
	WAN_ASSERT2(channo > 31, -EINVAL);
		return -EINVAL;
	card = wp->card;
	if (wp->channelized == WAN_TRUE){
		wan_tdmv_rxtx_pwr_t *pwr_rxtx = &wan_tdmv->chan_pwr[channo];
		wp->chans[channo].readchunk = rxbuf;	
		wp->chans[channo].writechunk = txbuf;	
		wp_tdmv_echo_check(wan_tdmv, &wp->chans[channo], channo);
		if ((!card->wandev.ec_enable || card->wandev.ec_enable_map == 0) && 
		     !wan_test_bit(channo, &wp->echo_off_map)) {
			if(pwr_rxtx->current_state != ECHO_ABSENT){
					&wp->chans[channo], 
					wp->chans[channo].readchunk, 
					wp->chans[channo].writechunk);
					&wp->chans[channo], 
					wp->chans[channo].readchunk, 
					wp->ec_chunk1[channo]);
					wp->ec_chunk1[channo],
					wp->chans[channo].writechunk,
					&wp->chans[channo], 
					wp->chans[channo].readchunk, 
					wp->ec_chunk1[channo]);
					wp->ec_chunk1[channo],
					wp->ec_chunk2[channo],
					wp->ec_chunk2[channo],
					wp->chans[channo].writechunk,
			} /* if(pwr_rxtx->current_state != ECHO_ABSENT) */
		} /* if (!wan_test_bit(channo, &wp->echo_off_map)) */
		int	x, channels = wp->span.channels;
		wp->tx_unchan = txbuf;
		wp_tdmv_rxcopy(wan_tdmv, rxbuf, wp->max_rxtx_len);
		if (!wp->echo_off_map){
				wp_tdmv_echo_check(wan_tdmv, &wp->chans[0], x);
					&wp->chans[x], 
					wp->chans[x].readchunk, 
					wp->chans[x].writechunk);
					&wp->chans[x], 
					wp->chans[x].readchunk, 
					wp->ec_chunk1[x]);
					wp->ec_chunk1[x],
					wp->chans[x].writechunk,
	wan_tdmv_t	*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wp = wan_tdmv->sc; 
	rx_offset = buf_sz * card->u.aft.tdm_rx_dma_toggle;
	tx_offset = buf_sz * card->u.aft.tdm_tx_dma_toggle;
		if (wan_test_bit(x,&wp->timeslot_map)) {
			if (card->u.aft.tdmv_dchan &&
			   (card->u.aft.tdmv_dchan-1) == x) {
			wan_spin_lock(&wp->chans[x].lock);
                        ptr=(void*)((((unsigned long)wp->chans[x].readchunk) & ~(mask)) + rx_offset);
			wp->chans[x].readchunk = ptr;
                        ptr=(void*)((((unsigned long)wp->chans[x].writechunk) & ~(mask)) + tx_offset);
			wp->chans[x].writechunk = ptr;
			wan_spin_unlock(&wp->chans[x].lock);
      			prefetch(wp->chans[x].readchunk);
      			prefetch(wp->chans[x].writechunk);
			if (card->wandev.rtp_len && card->wandev.rtp_tap) {
				card->wandev.rtp_tap(card,x,
						     wp->chans[x].readchunk,
						     wp->chans[x].writechunk,
        wan_tdmv_t      *wan_tdmv = &card->wan_tdmv;
        WAN_ASSERT(wan_tdmv->sc == NULL);
        wp = wan_tdmv->sc;
	zt_ec_span(&wp->span);
** wp_tdmv_rx_tx_span() - 
	wan_tdmv_t	*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wp = wan_tdmv->sc;
	wp->intcount++;
	zt_receive(&wp->span);
	zt_transmit(&wp->span);
	if (wp->channelized == WAN_FALSE){
				wp->tx_unchan,
				wp->max_rxtx_len);
	if (wan_test_bit(WP_TDMV_RBS_UPDATE, &wp->flags)){
				wp->devname,
		if (card->wandev.fe_iface.report_rbsbits){
			card->wandev.fe_iface.report_rbsbits(&card->fe);
		wan_clear_bit(WP_TDMV_RBS_UPDATE, &wp->flags);
		wan_clear_bit(WP_TDMV_RBS_BUSY, &wp->flags);
** wp_tdmv_init() - 
	return -EINVAL;
** wp_tdmv_callback_dtmf() - 
        wan_tdmv_t      *wan_tdmv = &card->wan_tdmv;
        WAN_ASSERT1(wan_tdmv->sc == NULL);
        wp = wan_tdmv->sc;
	if (event->type != WAN_EVENT_EC_DTMF){
				card->devname, event->type);
			card->devname,
			event->channel,
			event->digit,
			(event->dtmf_port == WAN_EC_CHANNEL_PORT_ROUT)?"ROUT":"SOUT",
			(event->dtmf_type == WAN_EC_TONE_PRESENT)?"PRESENT":"STOP");
	if (!(wp->dtmfmask & (1 << (event->channel-1)))){
					card->devname,
					event->channel);
	if (event->dtmf_type == WAN_EC_TONE_PRESENT){
		wp->dtmfactive |= (1 << event->channel);
				wp->span.chans[event->channel-1],
				(ZT_EVENT_DTMFDOWN | event->digit));
				&wp->span.chans[event->channel-1],
				(ZT_EVENT_DTMFDOWN | event->digit));
		wp->dtmfactive &= ~(1 << event->channel);
				wp->span.chans[event->channel-1],
				(ZT_EVENT_DTMFUP | event->digit));
				&wp->span.chans[event->channel-1],
				(ZT_EVENT_DTMFUP | event->digit));
./sdla_tdmv.c
				hw->devname);
		return -EINVAL;
					hw->devname);
		return -EINVAL;
		return -EINVAL;
						hw->devname);
		return -EINVAL;
		return -EINVAL;
	/* must first write-enable */
		return -EINVAL;
./sdladrv_utils.c
# include "aft_core.h" /* Map of Zaptel -> DAHDI definitions */
/* Timer interrupt counter - used by activation timer T3 */
			caller_name, fe->name, WAN_FE_LINENO(fe)+1, MAX_SERIAL_LINES);
	for (; milliseconds > 0; --milliseconds){
** wp_serial_iface_init) - 
	fe_iface->global_config		= &serial_global_config;	/* not used in remora */
	fe_iface->global_unconfig	= &serial_global_unconfig;	/* not used in remora */
	fe_iface->config		= &wp_serial_config;
	fe_iface->unconfig		= &wp_serial_unconfig;
	fe_iface->post_init		= &wp_serial_post_init;
	fe_iface->if_config		= &wp_serial_if_config;
	fe_iface->if_unconfig		= &wp_serial_if_unconfig;
	fe_iface->active_map		= &wp_serial_active_map;
	fe_iface->set_fe_status		= &wp_serial_set_fe_status;
	fe_iface->get_fe_status		= &wp_serial_get_fe_status;
	fe_iface->isr			= &wp_serial_intr;
//	fe_iface->disable_irq		= &wp_serial_disable_irq;
	fe_iface->check_isr		= &wp_serial_check_intr;
	fe_iface->polling		= &wp_serial_polling;
	fe_iface->process_udp		= &wp_serial_udp;
	fe_iface->get_fe_media		= &wp_serial_fe_media;
	fe_iface->set_dtmf		= &wp_serial_set_dtmf;
	fe_iface->intr_ctrl		= &wp_serial_intr_ctrl;
	fe_iface->event_ctrl		= &wp_serial_event_ctrl;
	fe_iface->watchdog	= &wp_serial_watchdog;
	sdla_t	*card = (sdla_t*)fe->card;
	DEBUG_EVENT("%s: Executing SPI bus reset....\n", fe->name);
	card->hw_iface.bus_write_4(	card->hw,
	card->hw_iface.bus_write_4(	card->hw,
* Arguments	: pfe - pointer to Front End structure.	
* Returns	: 0 - configred successfully, otherwise non-zero value.
			fe->name, FE_MEDIA_DECODE(fe));
* Description	: Global un-configuration for Sangoma SERIAL board.
	sdla_t 	*card = (sdla_t*)fe->card;
				fe->name, FE_MEDIA_DECODE(fe));
*			wp_serial_config() - initialise the XHFC ISDN Chip.
* Arguments	:  pfe - pointer to Front End structure.
* Returns	:  0 - configred successfully, otherwise non-zero value.
	sdla_t 			*card = (sdla_t*)fe->card;
			fe->name, FE_MEDIA_DECODE(fe), WAN_FE_LINENO(fe) + 1);
	switch (card->wandev.line_coding){ 
			card->devname,
			card->wandev.line_coding);
		return -1;
	switch (card->adptr_type) {
                        card->devname);
                                card->devname,WAN_FE_LINENO(fe));
                        return -EINVAL;
                if(card->wandev.clocking) {
                                                card->devname);
                                                card->devname);
                                return -EINVAL;
                        card->devname);
                if(card->wandev.clocking) {
                        card->devname,card->adptr_type);
                return -1;
        card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_SERIAL_LINE_CFG_REG),&reg);
			card->devname,
	if (card->wandev.clocking) {
			card->devname,
			card->wandev.bps);
		aft_serial_set_baud_rate(&reg,card->wandev.bps);
			card->devname,
			card->wandev.bps);
	switch (card->wandev.line_coding){ 
			card->devname);
			card->devname);
			card->devname,
			card->wandev.line_coding);
		return -1;
	if (card->wandev.connection == WANOPT_SWITCHED){
		DEBUG_EVENT("%s: A140: Configuring for Switched CTS/RTS\n",card->devname);
	if (card->wandev.ignore_front_end_status == WANOPT_YES) {
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_SERIAL_LINE_CFG_REG),reg);
			card->devname,
			reg,card->wandev.ignore_front_end_status == WANOPT_YES?"Off":"On");
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_SERIAL_LINE_CFG_REG),reg);
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_SERIAL_LINE_CFG_REG),&reg);
			card->devname,
** wp_serial_unconfig() - 
	sdla_t 		*card = (sdla_t*)fe->card;
	switch (card->adptr_type) {
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_SERIAL_LINE_CFG_REG),reg);
** wp_serial_post_init() - 
	DEBUG_EVENT("%s: Running post initialization...\n", fe->name);
** wp_serial_if_config() - 
** wp_serial_if_unconfig() - 
* Description: Enable SERIAL interrupts - start interrupt and set interrupt mask.
** wp_serial_disable_irq() - disable all interrupts by disabling M_GLOB_IRQ_EN
	return fe->fe_cfg.media;
	return -EINVAL;
	int32_t		err = -EINVAL;
	switch(udp_cmd->wan_cmd_command){
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_data_len = (u16)err; 
		udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
	    	udp_cmd->wan_cmd_data_len = 0;
* Description	: Get current FE line state - is it Connected or Disconnected
* Arguments	: fe - pointer to Front End structure.	
*		  status - pointer to location where the FE line state will
*		  notused - ignored 
	*status = fe->fe_status;
* Arguments	: fe - pointer to Front End structure.	
*		  new_status - the new FE line state.
* Returns	: 0 - success.
*		  1 - failure.
* Arguments: mod_no -  Module number (1,2,3,... MAX_REMORA_MODULES)
* Arguments: mod_no -  Module number (1,2,3,... MAX_REMORA_MODULES)
* Arguments: mod_no -  Module number (1,2,3,... MAX_REMORA_MODULES)
* Returns:	1 - interrupt recognized and handled
*		0 - interrupt not recognized (not generated by this module)
	sdla_t			*card = (sdla_t*)fe->card;
	u8			old_fe_status = fe->fe_status;
	fe->fe_status = status;
	if (old_fe_status != fe->fe_status){
		if (fe->fe_status == FE_CONNECTED){
					fe->name,
			if (card->wandev.te_report_alarms){
				card->wandev.te_report_alarms(card, 0);
					fe->name,
			if (card->wandev.te_report_alarms){
				card->wandev.te_report_alarms(card, 1);
	sdla_t 		*card = (sdla_t*)fe->card;
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_SERIAL_LINE_CFG_REG),&reg);
	DEBUG_EVENT("%s: DCD/CTS VALUES = 0x%02X\n",card->devname,(reg>>2)&0x03);
//	u8	qaccess = card->wandev.state == WAN_CONNECTED ? 1 : 0;
//	u8	qaccess = card->wandev.state == WAN_CONNECTED ? 1 : 0;
	int	err = -EINVAL;
	if (card->hw_iface.fe_test_and_set_bit(card->hw,0)){
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			card->devname, __FUNCTION__,__LINE__);
	if (card->hw_iface.write_cpld){
		err = card->hw_iface.write_cpld(card->hw, (u16)off, (u8)data);
	card->hw_iface.fe_clear_bit(card->hw,0);
	int	err = -EINVAL;
	if (card->hw_iface.fe_test_and_set_bit(card->hw,0)){
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			card->devname, __FUNCTION__,__LINE__);
	if (card->hw_iface.read_cpld){
		err = card->hw_iface.read_cpld(card->hw, (u16)cpld_off, &tmp);
	card->hw_iface.fe_clear_bit(card->hw,0);
./sdla_serial.c
* Copyright:	(c) 1995-2003 Sangoma Technologies Inc.
* Oct 10, 2001  Nenad Corbic	 o Added the dev->do_ioctl function to replace
* Dec 19, 1997	Jaspreet Singh	 o Added multi-channel IPX support
#define CVHexToAscii(b) (((unsigned char)(b) > (unsigned char)9) ? ((unsigned char)'A' + ((unsigned char)(b) - (unsigned char)10)) : ((unsigned char)'0' + (unsigned char)(b)))
	unsigned int * sp = (unsigned int *)(((char *)v) - (sizeof(unsigned int) + KMEM_SAFETYZONE*8));
	char * c1 = ((char *)v) - KMEM_SAFETYZONE*8;
	v = ((char *)v) - (sizeof(unsigned int) + KMEM_SAFETYZONE*8);
 * Rationale:  	Per-channel debugging is possible if each 
 *              the rest of X.25 channel-specific data. 
	unsigned short protocol;	/* ethertype, 0 - multiplexed */
	unsigned hold_timeout;		/* sec, before re-connecting */
	sdla_t* card;			/* -> owner */
	char accept_dest_addr[WAN_ADDRESS_SZ+1];   /* pattern match string in -d<string>
	char accept_src_addr[WAN_ADDRESS_SZ+1];    /* pattern match string in -s<string> 
	char accept_usr_data[WAN_ADDRESS_SZ+1];/* pattern match string in -u<string> 
 *	WANPIPE-specific entry points 
 *  		o initialize protocol-specific fields of the 
	wan_x25_conf_t*	x25_adm_conf = &card->u.x.x25_adm_conf;
	wan_x25_conf_t*	x25_conf = &card->u.x.x25_conf;
	if (conf->config_id != WANCONFIG_X25){
			card->devname, conf->config_id)
		return -EINVAL;
	/* Initialize protocol-specific fields */
	card->mbox_off  = X25_MB_VECTOR + X25_MBOX_OFFS;
	card->rxmb_off  = X25_MB_VECTOR + X25_RXMBOX_OFFS;
	card->flags_off = X25_MB_VECTOR + X25_STATUS_OFFS;
	card->intr_type_off = card->flags_off + offsetof(TX25Status, iflags);
	card->intr_perm_off = card->flags_off + offsetof(TX25Status, imask);
		return -EIO;
	if (conf->u.x25.LAPB_hdlc_only == WANOPT_YES){
			return -EIO;	
				card->devname, u.str);
		card->u.x.LAPB_hdlc = 1;
				card->devname, u.str);
		card->u.x.LAPB_hdlc = 0;
	memcpy(x25_adm_conf, &conf->u.x25, sizeof(wan_x25_conf_t));
	if (!x25_adm_conf->cmd_retry_timeout){
		x25_adm_conf->cmd_retry_timeout=5;
			card->devname,
			x25_adm_conf->cmd_retry_timeout);
	card->wandev.ignore_front_end_status = conf->ignore_front_end_status;
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
	u.cfg.options		= 0x0090;	/* disable D-bit pragmatics */
	if (conf->u.x25.x25_conf_opt){
		u.cfg.options = conf->u.x25.x25_conf_opt;
	if (conf->clocking != WANOPT_EXTERNAL)
		u.cfg.baudRate = bps_to_speed_code(conf->bps);
	if (conf->u.x25.station != WANOPT_DTE){
        if (conf->electrical_interface != WANOPT_RS232 ){
	card->wandev.mtu = conf->mtu;
	if (!conf->u.x25.defPktSize){
		conf->u.x25.defPktSize = 1024;
				card->devname);
	err=baud_rate_check(conf->u.x25.defPktSize);
				card->devname,conf->u.x25.defPktSize);
	if (!conf->u.x25.pktMTU){
		conf->u.x25.pktMTU = 1024;
				card->devname);
	err=baud_rate_check(conf->u.x25.pktMTU);
				card->devname,conf->u.x25.defPktSize);
	if (conf->u.x25.pktMTU > card->wandev.mtu){
				card->devname,card->wandev.mtu,conf->u.x25.pktMTU);
		return -EINVAL;
	u.cfg.pktMTU = conf->u.x25.pktMTU;
	u.cfg.defPktSize = conf->u.x25.defPktSize;
	if (!card->u.x.LAPB_hdlc){
		DEBUG_EVENT("%s: Configuring: X25/LapB \n",card->devname);
				card->devname,X25_STATION_DECODE(conf->u.x25.station)); 
				card->devname,conf->u.x25.defPktSize); 
				card->devname,conf->u.x25.pktMTU);
				card->devname,conf->u.x25.pkt_window);
				card->devname,conf->u.x25.hdlc_window);
	if (card->u.x.LAPB_hdlc){
		DEBUG_EVENT("%s: Configuring: LapB \n",card->devname);
				card->devname,X25_STATION_DECODE(conf->u.x25.station)); 
				card->devname,u.cfg.defPktSize);
				card->devname,conf->u.x25.hdlc_window);
	if (conf->u.x25.hi_pvc){
		card->u.x.x25_conf.hi_pvc = 
			wp_min(conf->u.x25.hi_pvc, MAX_LCN_NUM);
		card->u.x.x25_conf.lo_pvc = 
			wp_min(conf->u.x25.lo_pvc, card->u.x.x25_conf.hi_pvc);
	if (conf->u.x25.hi_svc){
		card->u.x.x25_conf.hi_svc = 
			wp_min(conf->u.x25.hi_svc, MAX_LCN_NUM);
		card->u.x.x25_conf.lo_svc = 
			wp_min(conf->u.x25.lo_svc, card->u.x.x25_conf.hi_svc);
	card->u.x.num_of_ch = 0;
	if (card->u.x.x25_conf.hi_svc != 0){
		card->u.x.num_of_ch = 
			(card->u.x.x25_conf.hi_svc - card->u.x.x25_conf.lo_svc) + 1;
	if (card->u.x.x25_conf.hi_pvc != 0){
		card->u.x.num_of_ch += 
			(card->u.x.x25_conf.hi_pvc - card->u.x.x25_conf.lo_pvc) + 1;
	if (card->u.x.num_of_ch == 0){
				 card->devname,card->devname);
		return -ECHRNG;
	u.cfg.loPVC = card->u.x.x25_conf.lo_pvc;
	u.cfg.hiPVC = card->u.x.x25_conf.hi_pvc;
	u.cfg.loTwoWaySVC = card->u.x.x25_conf.lo_svc;
	u.cfg.hiTwoWaySVC = card->u.x.x25_conf.hi_svc;
	if (conf->u.x25.hdlc_window)
		u.cfg.hdlcWindow = wp_min(conf->u.x25.hdlc_window, 7);
	if (conf->u.x25.pkt_window)
		u.cfg.pktWindow = wp_min(conf->u.x25.pkt_window, 7);
	if (conf->u.x25.t1)
		u.cfg.t1 = wp_min(conf->u.x25.t1, 30);
	if (conf->u.x25.t2)
		u.cfg.t2 = wp_min(conf->u.x25.t2, 29);
	if (conf->u.x25.t4)
		u.cfg.t4 = wp_min(conf->u.x25.t4, 240);
	if (conf->u.x25.n2)
		u.cfg.n2 = wp_min(conf->u.x25.n2, 30);
	if (conf->u.x25.t10_t20)
		u.cfg.t10t20 = wp_min(conf->u.x25.t10_t20,255);
	if (conf->u.x25.t11_t21)
		u.cfg.t11t21 = wp_min(conf->u.x25.t11_t21,255);
	if (conf->u.x25.t12_t22)
		u.cfg.t12t22 = wp_min(conf->u.x25.t12_t22,255);
	if (conf->u.x25.t13_t23)	
		u.cfg.t13t23 = wp_min(conf->u.x25.t13_t23,255);
	if (conf->u.x25.t16_t26)
		u.cfg.t16t26 = wp_min(conf->u.x25.t16_t26, 255);
	if (conf->u.x25.t28)
		u.cfg.t28 = wp_min(conf->u.x25.t28, 255);
	if (conf->u.x25.r10_r20)
		u.cfg.r10r20 = wp_min(conf->u.x25.r10_r20,250);
	if (conf->u.x25.r12_r22)
		u.cfg.r12r22 = wp_min(conf->u.x25.r12_r22,250);
	if (conf->u.x25.r13_r23)
		u.cfg.r13r23 = wp_min(conf->u.x25.r13_r23,250);
	if (conf->u.x25.ccitt_compat)
		u.cfg.ccittCompat = conf->u.x25.ccitt_compat;
				card->devname,u.cfg.loPVC);
				card->devname,u.cfg.hiPVC);
				card->devname,u.cfg.loTwoWaySVC);
				card->devname,u.cfg.hiTwoWaySVC);
				card->devname,card->u.x.num_of_ch);
	x25_conf->lo_pvc 	= u.cfg.loPVC;
	x25_conf->hi_pvc 	= u.cfg.hiPVC;
	x25_conf->lo_svc 	= u.cfg.loTwoWaySVC;
	x25_conf->hi_svc 	= u.cfg.hiTwoWaySVC;
	x25_conf->hdlc_window 	= u.cfg.hdlcWindow;
	x25_conf->pkt_window 	= u.cfg.pktWindow;
	x25_conf->t1 		= u.cfg.t1;
	x25_conf->t2 		= u.cfg.t2;
	x25_conf->t4 		= u.cfg.t4;
	x25_conf->n2 		= u.cfg.n2;
	x25_conf->t10_t20 	= u.cfg.t10t20;
	x25_conf->t11_t21 	= u.cfg.t11t21;
	x25_conf->t12_t22 	= u.cfg.t12t22;
	x25_conf->t13_t23 	= u.cfg.t13t23;
	x25_conf->t16_t26 	= u.cfg.t16t26;
	x25_conf->t28 		= u.cfg.t28;
	x25_conf->r10_r20 	= u.cfg.r10r20;
	x25_conf->r12_r22 	= u.cfg.r12r22;
	x25_conf->r13_r23	= u.cfg.r13r23;
	x25_conf->ccitt_compat 	= u.cfg.ccittCompat;
	x25_conf->x25_conf_opt 	= u.cfg.options;
	x25_conf->oob_on_modem 	= conf->u.x25.oob_on_modem;
	x25_conf->pktMTU	= u.cfg.pktMTU;
	x25_conf->defPktSize    = u.cfg.defPktSize;
	x25_conf->cmd_retry_timeout = x25_adm_conf->cmd_retry_timeout;
	if (card->u.x.LAPB_hdlc){
			return -EIO;
			return -EIO;
		return -EIO;
	/* Initialize protocol-specific fields of adapter data space */
	card->wandev.bps	= conf->bps;
	card->wandev.electrical_interface	= conf->electrical_interface;
	card->wandev.clocking	= conf->clocking;
	card->wandev.station	= conf->u.x25.station;
	card->isr		= &wpx_isr;
	card->poll		= NULL;
	card->disable_comm	= &disable_comm;
	card->exec		= NULL;
	card->wandev.update	= &update;
	card->wandev.new_if	= &new_if;
	card->wandev.del_if	= &del_if;
	card->bind_api_to_svc	= &bind_api_to_svc;
	card->wandev.get_config_info 	= &x25_get_config_info;
	card->wandev.get_status_info 	= &x25_get_status_info;
	card->wandev.set_dev_config    	= &x25_set_dev_config;
	card->wandev.set_if_info     	= &x25_set_if_info;
	card->get_snmp_data     	= &x25_snmp_data;
	card->wandev.state	= WAN_DISCONNECTED;
	card->wandev.enable_tx_int = 0;
	card->irq_dis_if_send_count = 0;
        card->irq_dis_poll_count = 0;
	card->u.x.tx_dev = NULL;
	card->u.x.no_dev = 0;
	card->u.x.hdlc_buf_status_off = 
	card->u.x.poll_device=NULL;
	card->wandev.udp_port = conf->udp_port;
	if (conf->u.x25.logging == WANOPT_YES){
			card->devname);
		card->u.x.logging = 1;
		card->u.x.logging = 0;
	if (conf->u.x25.oob_on_modem == WANOPT_YES){
			card->devname);
		card->u.x.oob_on_modem = 1;
		card->u.x.oob_on_modem = 0;
	WAN_TASKQ_INIT((&card->u.x.x25_poll_task),0,wpx_poll,card);
	init_timer(&card->u.x.x25_timer);
	card->u.x.x25_timer.data = (unsigned long)card;
	card->u.x.x25_timer.function = x25_timer_routine;
	skb_queue_head_init(&card->u.x.trace_queue);
	if ((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if (wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	if (test_bit(SEND_CRIT, (void*)&wandev->critical))
		return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&wandev->dev_head));
		return -ENODEV;
	card = wandev->priv;
	spin_lock_irqsave(&card->wandev.lock, smp_flags);
	card->hw_iface.peek(card->hw, card->u.x.hdlc_buf_status_off, &status, 1);
		err=-EBUSY;
	spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
 *              area pointer (dev->priv).
	sdla_t* card = wandev->priv;
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)){
			card->devname);
		return -EINVAL;
	if(card->wandev.new_if_cnt++ > 0 && card->u.x.LAPB_hdlc) {
						card->devname);
						card->devname);
		return -EEXIST;
						card->devname);
		return -ENOMEM;
	WAN_TASKLET_INIT((&chan->common.bh_task),0,x25api_bh,(unsigned long)chan);
	dev->priv = chan;
	strcpy(chan->name, conf->name);
	chan->card = card;
	chan->tx_skb = chan->rx_skb = NULL;
	if (conf->addr[0] == '@'){		/* SVC */
		chan->common.svc = 1;
		strncpy(chan->addr, &conf->addr[1], WAN_ADDRESS_SZ);
		strncpy(chan->x25_src_addr, 
			&conf->x25_src_addr[0], WAN_ADDRESS_SZ);
		strncpy(chan->accept_dest_addr,
			&conf->accept_dest_addr[0], WAN_ADDRESS_SZ);
		strncpy(chan->accept_src_addr, 
			&conf->accept_src_addr[0], WAN_ADDRESS_SZ);
		strncpy(chan->accept_usr_data, 
			&conf->accept_usr_data[0], WAN_ADDRESS_SZ);
		chan->idle_timeout = (conf->idle_timeout) ? 
					conf->idle_timeout : 90;
		chan->hold_timeout = (conf->hold_timeout) ? 
					conf->hold_timeout : 10;
	}else if (is_digit(conf->addr[0])){	/* PVC */
		int lcn = dec_to_uint(conf->addr, 0);
		if ((lcn >= card->u.x.x25_conf.lo_pvc) && (lcn <= card->u.x.x25_conf.hi_pvc)){
				wandev->name, lcn, chan->name);
			err = -EINVAL;
			wandev->name, chan->name);
		err = -EINVAL;
	if(strcmp(conf->usedby, "WANPIPE") == 0){
			wandev->name, chan->name);
                chan->common.usedby = WANPIPE;
		chan->protocol = htons(ETH_P_IP);
        }else if(strcmp(conf->usedby, "API") == 0){
		chan->common.usedby = API;
			wandev->name, chan->name);
		chan->protocol = htons(X25_PROT);
		wan_reg_api(chan,dev,card->devname);
		dev->priv = NULL;
	chan->enable_IPX = conf->enable_IPX;
	if (chan->enable_IPX)
		chan->protocol = htons(ETH_P_IPX);
	if (conf->network_number)
		chan->network_number = conf->network_number;
		chan->network_number = 0xDEADBEEF;
	dev->init = &if_init;
	err = wanrouter_proc_add_interface(wandev, &chan->dent, chan->name, dev);
			card->devname, chan->name);
	spin_lock_init(&chan->lock);
	sdla_t *card=wandev->priv;
	x25_channel_t* chan = dev->priv;
	wanrouter_proc_delete_interface(wandev, chan->name);
	WAN_TASKLET_KILL(&chan->common.bh_task);
	wan_unreg_api(chan, card->devname);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	card->u.x.tx_dev=NULL;
	card->u.x.cmd_dev=NULL;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	del_timer(&card->u.x.x25_timer);
 * 		(dev->init())
	x25_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->do_ioctl		= &x25_ioctl;
	if (chan->common.usedby != API){
		dev->tx_timeout		= &if_tx_timeout;
		dev->watchdog_timeo	= TX_TIMEOUT;
	/* Initialize media-specific parameters */
	dev->type		= ARPHRD_PPP;		/* ARP h/w type */
	dev->flags		|= IFF_POINTOPOINT;
	dev->flags		|= IFF_NOARP;
	if (chan->common.usedby == API){
		dev->mtu	= X25_CHAN_MTU+sizeof(x25api_hdr_t);
		dev->mtu	= card->wandev.mtu; 	
	dev->hard_header_len	= 0;            /* media header length */
	dev->addr_len		= 2;		/* hardware address length */
	if (!chan->common.svc){
		*(unsigned short*)dev->dev_addr = htons(chan->common.lcn);
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start); //ALEX_TODAY (unsigned long)wandev->maddr;
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end); //ALEX_TODAY wandev->maddr + wandev->msize - 1;
        dev->tx_queue_len = 100;
 * 		(dev->open())
	x25_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
		return -EBUSY;
	++card->u.x.no_dev;
	if (!card->u.x.LAPB_hdlc){
		if (card->open_cnt == card->u.x.num_of_ch){
			del_timer(&card->u.x.x25_timer);
			card->u.x.x25_timer.expires=jiffies+HZ;
			add_timer(&card->u.x.x25_timer);
	chan->router_start_time = tv.tv_sec;
	if (!chan->common.svc && chan->common.usedby == WANPIPE){
		spin_lock_irqsave(&card->wandev.lock,flags);
					card->devname,chan->name,err);
		spin_unlock_irqrestore(&card->wandev.lock,flags);
 * 		(dev->close())
	x25_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	dev->start=0;
	if ((chan->common.state == WAN_CONNECTED) || 
	    (chan->common.state == WAN_CONNECTING)){
	if (!card->open_cnt){
		if (card->sk){
			protocol_disconnected(card->sk);
			sock_put(card->sk);
			card->sk=NULL;
	--card->u.x.no_dev;
    	x25_channel_t* chan = dev->priv;
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++chan->if_send_stat.if_send_tbusy_timeout;
			card->devname, dev->name);
 *		non-0	packet may be re-transmitted (tbusy must be set)
	x25_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	++chan->if_send_stat.if_send_entry;
	if (dev->tbusy){
		++chan->if_send_stat.if_send_tbusy;
		if ((jiffies - chan->tick_counter) < (5*HZ)){
	chan->tick_counter = jiffies;
	if (test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)){
		printk(KERN_INFO "Hit critical in if_send()! %lx\n",card->wandev.critical);
                        chan->common.lcn)) {
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, INTR_ON_TIMER);
                                chan->if_send_stat.if_send_PIPE_request++;
		clear_bit(SEND_CRIT,(void*)&card->wandev.critical);
	if (chan->transmit_length){
		if (chan->common.state != WAN_CONNECTED){
			chan->transmit_length=0;
			atomic_inc(&card->u.x.tx_interrupts_pending);
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, INTR_ON_TX_FRAME);
			clear_bit(SEND_CRIT,(void*)&card->wandev.critical);
	if (card->wandev.state != WAN_CONNECTED ||
	    chan->common.state != WAN_CONNECTED){
		++chan->ifstats.tx_dropped;
		++card->wandev.stats.tx_dropped;
		++chan->if_send_stat.if_send_wan_disconnected;	
	}else if (chan->common.usedby == API &&
	          skb->protocol!=htons(WP_X25_PROT) && 
		  skb->protocol!=htons(ETH_P_X25)){
			chan->name, htons(skb->protocol), htons(chan->protocol));
		++chan->ifstats.tx_errors;
		++chan->ifstats.tx_dropped;
		++card->wandev.stats.tx_dropped;
		++chan->if_send_stat.if_send_protocol_error;
	}else switch (chan->common.state){
			if (chan->common.usedby == API){
				++chan->ifstats.tx_dropped;
				++card->wandev.stats.tx_dropped;
					++chan->ifstats.tx_dropped;
					++card->wandev.stats.tx_dropped;
			if( skb->protocol == htons(ETH_P_IPX)) {
				if(chan->enable_IPX) {
					switch_net_numbers( skb->data, 
						chan->network_number, 0);
					++card->wandev.stats.tx_dropped;
					++chan->ifstats.tx_dropped;
					++chan->if_send_stat.if_send_protocol_error;
			chan_send(dev, skb->data, skb->len, 0);
			++chan->ifstats.tx_dropped;	
			++card->wandev.stats.tx_dropped;
	clear_bit(SEND_CRIT,(void*)&card->wandev.critical);
        x25_channel_t* chan = dev->priv;
        sdla_t* card = chan->card;
	++chan->if_send_stat.if_send_adptr_bfrs_full;
        if(chan->transmit_length) {
				card->devname);
	if (chan->common.usedby == API){
			++chan->ifstats.tx_dropped;	
			++card->wandev.stats.tx_dropped;
				card->devname);
		if (len > dev->mtu || len > X25_CHAN_MTU) {
			++chan->ifstats.tx_dropped;	
			++card->wandev.stats.tx_dropped;
				card->devname);
	 * The tx_offset must be re-initialized to zero,
	chan->tx_offset = 0;
        chan->transmit_length = len;
        memcpy(chan->transmit_buffer, buf, len);
	++chan->if_send_stat.if_send_tx_int_enabled;
	atomic_inc(&card->u.x.tx_interrupts_pending);
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, INTR_ON_TX_FRAME);
 * 	Get ethernet-style interface statistics.
	x25_channel_t *chan = dev->priv;
	return &chan->ifstats;
	if (!dev || !(dev->flags & IFF_UP)){
		return -ENODEV;
	if ((chan=dev->priv) == NULL){
		return -ENODEV;
	card=chan->card;
			card->devname,dev->name,cmd,DECODE_X25_CMD(cmd),ifr,chan->common.lcn);
			if (!test_bit(0,&card->u.x.card_ready)){
				atomic_set(&chan->common.command,0);
				err = -EBUSY;
			if (card->u.x.LAPB_hdlc){
				spin_lock_irqsave(&card->wandev.lock,flags);
				spin_unlock_irqrestore(&card->wandev.lock,flags);
			if (card->wandev.state != WAN_CONNECTED ||
			    chan->common.state != WAN_DISCONNECTED){
 				err = -EBUSY;
			atomic_set(&chan->common.command,X25_PLACE_CALL);
			DEBUG_TEST("%s:%s PLACE CALL RC %x\n",card->devname,dev->name,err);
			if (card->wandev.state != WAN_CONNECTED){
 				err = -EINVAL;
			if (chan->common.state == WAN_DISCONNECTED || 
			    chan->common.state == WAN_DISCONNECTING){
 				err = -EINVAL;
			if (!chan->common.svc){
				err=-EINVAL;
			if (chan->common.state == WAN_DISCONNECTED){
				err = -ENETDOWN;
			if (chan->x25_api_cmd_hdr.qdm & 0x80){
				if (chan->transmit_length){
							chan->common.dev->name);
					err= -EBUSY;
			atomic_set(&chan->common.command,X25_CLEAR_CALL);
			if (err == -EFAULT){
				err=x25_clear_call(card,chan->common.lcn,0,0,0,
						   chan->call_string,strlen(chan->call_string));
					err=-EINVAL;
						card->devname,chan->common.dev->name);
			if (chan->common.state != WAN_CONNECTING){
				err = -EBUSY;
			atomic_set(&chan->common.command,X25_ACCEPT_CALL);
			DEBUG_TEST("%s:%s ACCEPT CALL RC %x\n",card->devname,dev->name,err);
			atomic_set(&chan->common.command,X25_RESET);
			DEBUG_TEST("%s:%s RESET CALL RC %x\n",card->devname,dev->name,err);
			atomic_set(&chan->common.command,X25_WP_INTERRUPT);
			DEBUG_TEST("%s:%s INTERRUPT RC %x\n",card->devname,dev->name,err);
			if (ifr && ifr->ifr_data){
				err = copy_from_user(&chan->pid,
				  	              ifr->ifr_data,
			if (ifr && ifr->ifr_data){
				err = copy_from_user(&chan->dlabel[0],
				  	              ifr->ifr_data,
				chan->dlabel[WAN_IF_LABEL_SZ]=0;
				err= -EINVAL;
			if (card->u.x.LAPB_hdlc){
				set_bit(0,&card->u.x.card_ready);
			if (!test_bit(0,&card->u.x.card_ready)){
				atomic_set(&chan->common.command,0);
				err = -EBUSY;
			if (ifr->ifr_data && !chan->common.sk){
				if (!spin_is_locked(&card->wandev.lock)){
					spin_lock_irqsave(&card->wandev.lock,flags);
					chan->common.sk = (struct sock*)ifr->ifr_data;
					sock_hold(chan->common.sk);
					set_bit(LCN_SK_ID,&chan->common.used);
					spin_unlock_irqrestore(&card->wandev.lock,flags);
					chan->common.sk = (struct sock*)ifr->ifr_data;
					sock_hold(chan->common.sk);
					set_bit(LCN_SK_ID,&chan->common.used);
			err= -EBUSY;
				err= -EINVAL;
			spin_lock_irqsave(&card->wandev.lock,flags);
			err=wan_unbind_api_from_svc(chan,ifr->ifr_data);
			spin_unlock_irqrestore(&card->wandev.lock,flags);
			if (atomic_read(&chan->common.receive_block)){
				card->hw_iface.peek(card->hw,
						    card->intr_perm_off,
				atomic_set(&chan->common.receive_block,0);
								card->devname);
					card->hw_iface.poke(card->hw,
							    card->intr_perm_off,
			if (chan->common.svc){
				atomic_set(&chan->common.disconnect,1);
			if (card->u.x.LAPB_hdlc){
				spin_lock_irqsave(&card->wandev.lock,flags);
				spin_unlock_irqrestore(&card->wandev.lock,flags);
				err= -EINVAL;
			if (test_bit(LCN_SK_ID,&chan->common.used) && chan->common.sk){
				sock_hold(chan->common.sk);
				ifr->ifr_data = (void*)chan->common.sk;
				ifr->ifr_data = NULL;
			err=chan->transmit_length;
			if (atomic_read(&chan->common.receive_block)){
				WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
			err = chan->common.state;
			if (atomic_read(&card->u.x.udp_pkt_len) != 0){
				err = -EBUSY;
			atomic_set(&card->u.x.udp_pkt_len,sizeof(wan_udp_hdr_t));
			wan_udp_pkt=(wan_udp_pkt_t*)&card->u.x.udp_pkt_data;
			if (copy_from_user(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				atomic_set(&card->u.x.udp_pkt_len,0);
				err = -EINVAL;
			spin_lock_irqsave(&card->wandev.lock, flags);
			if (test_bit(0,&card->in_isr)){
						card->devname,dev->name);
				atomic_set(&card->u.x.udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, flags);
				err = -EINVAL;
				atomic_set(&card->u.x.udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, flags);
				err = -EINVAL;
			spin_unlock_irqrestore(&card->wandev.lock, flags);
			if (atomic_read(&card->u.x.udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						atomic_read(&card->u.x.udp_pkt_len));
				atomic_set(&card->u.x.udp_pkt_len,0);
				err = -EINVAL;
			if (copy_to_user(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				atomic_set(&card->u.x.udp_pkt_len,0);
				err = -EFAULT;
			atomic_set(&card->u.x.udp_pkt_len,0);
					chan->common.dev->name,cmd);
			err= -EOPNOTSUPP;
	if (!card->hw){
	if (test_bit(0,&card->in_isr)){
		printk(KERN_INFO "%s: Critical in WPX_ISR\n",card->devname);
		card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->in_isr = 1;
	++card->statistics.isr_entry;
	if (test_bit(PERI_CRIT,(void*)&card->wandev.critical)){
		card->in_isr=0;
		card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	if (test_bit(SEND_CRIT, (void*)&card->wandev.critical)){
		card->hw_iface.peek(card->hw, card->intr_type_off, &intr_type, 1);
			card->devname, 
			card->wandev.critical, 
		card->in_isr = 0;
		card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.peek(card->hw, card->intr_type_off, &intr_type, 1);
	card->in_isr = 0;
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
 * 	This routine handles fragmented IP packets using M-bit according to the
 * 	o if M-bit is reset (i.e. it's the last packet in a sequence) then 
 * 	1. When allocating a socket buffer, if M-bit is set then more data is
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
	card->hw_iface.peek(card->hw, card->rxmb_off, &rxmb_cmd, sizeof(rxmb_cmd));
			card->devname, lcn);
	chan = dev->priv;
	chan->i_timeout_sofar = jiffies;
		++chan->ifstats.rx_dropped;
		++card->wandev.stats.rx_dropped;
		++chan->rx_intr_stat.rx_intr_no_socket;
		++chan->rx_intr_stat.rx_intr_bfr_not_passed_to_stack;
	dev->last_rx = jiffies;		/* timestamp */
	chan->rx_skb=NULL;
	/* ------------ API ----------------*/
	if (chan->common.usedby == API){
			WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
				card->devname,chan->common.dev->name);
				card->devname);
			card->hw_iface.poke(card->hw,
					    card->intr_perm_off,
			atomic_set(&chan->common.receive_block,1);
					card->devname);
			++chan->ifstats.rx_dropped;
			++card->wandev.stats.rx_dropped;
			++chan->rx_intr_stat.rx_intr_bfr_not_passed_to_stack;
	/* ------------- WANPIPE -------------------*/
	if (!skb->protocol && !wanrouter_type_trans(skb, dev)){
		++chan->ifstats.rx_errors;
		++chan->ifstats.rx_dropped;
		++card->wandev.stats.rx_dropped;
		++chan->rx_intr_stat.rx_intr_bfr_not_passed_to_stack;
		if(handle_IPXWAN(skb->data, chan->name, 
				  chan->enable_IPX, chan->network_number, 
				  skb->protocol)){
			if( chan->enable_IPX ){
				if(chan_send(dev, skb->data, skb->len,0)){
					chan->tx_skb = skb;
					++chan->rx_intr_stat.rx_intr_bfr_not_passed_to_stack;
				++chan->ifstats.rx_dropped;
				++chan->rx_intr_stat.rx_intr_bfr_not_passed_to_stack;
			chan->ifstats.rx_bytes += skb->len;
			++chan->ifstats.rx_packets;
			++chan->rx_intr_stat.rx_intr_bfr_passed_to_stack;
	x25_channel_t *chan = dev->priv;
	card->hw_iface.peek(card->hw, card->rxmb_off, &rxmb_cmd, sizeof(rxmb_cmd));
	if (chan->common.usedby == WANPIPE){
		if (chan->drop_sequence){
				chan->drop_sequence = 0;
		if (chan->rx_skb)
			new_skb = chan->rx_skb;
		if (chan->common.usedby == WANPIPE){
			bufsize = (qdm & 0x01) ? dev->mtu : len;
				card->devname);
			chan->drop_sequence = 1;	/* set flag */
			++chan->ifstats.rx_dropped;
		if (chan->common.usedby == WANPIPE){
			chan->rx_skb = NULL;
				chan->drop_sequence = 1;
				"on interface %s!\n", card->devname, dev->name);
		++chan->ifstats.rx_length_errors;
	if (chan->common.usedby == API){
		api_data->hdr.qdm = rxmb_cmd.wan_cmd_x25_qdm;
		api_data->hdr.cause = rxmb_cmd.wan_cmd_x25_cause;
		api_data->hdr.diagn = rxmb_cmd.wan_cmd_x25_diagn;
		api_data->hdr.length = rxmb_cmd.wan_cmd_data_len;
		api_data->hdr.lcn  = rxmb_cmd.wan_cmd_x25_lcn;
		card->hw_iface.peek(card->hw, card->rxmb_off + offsetof(wan_mbox_t, wan_data),
			  api_data->data, rxmb_cmd.wan_cmd_data_len);
		card->hw_iface.peek(card->hw, card->rxmb_off + offsetof(wan_mbox_t, wan_data),
	new_skb->dev = dev;
	if (chan->common.usedby == API){
		new_skb->protocol = htons(X25_PROT);
		new_skb->pkt_type = WAN_PACKET_DATA;
		new_skb->protocol = chan->protocol;
	if ((qdm & 0x01) && (chan->common.usedby == WANPIPE)){ 
		chan->rx_skb = new_skb;
	wan_mbox_t* mbox = &card->wan_mbox;
	if (jiffies-card->u.x.trace_timeout > 3*HZ){
		wan_skb_queue_purge(&card->u.x.trace_queue);
		DEBUG_EVENT("%s: Trace Timeout: disabling trace\n",card->devname);
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = XPIPE_DISABLE_TRACING;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
	mbox->wan_command = X25_READ_TRACE_DATA;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	trace = (TX25Trace*)mbox->wan_data;	
			card->devname,trace->length);
	card->u.x.trace_lost_cnt+=trace->lost_cnt;
	if (trace->length > X25_MAX_DATA+7){
				card->devname,trace->length,X25_MAX_DATA);
		card->u.x.trace_lost_cnt++;
	if (wan_skb_queue_len(&card->u.x.trace_queue) > MAX_X25_TRACE_QUEUE){
				card->devname,MAX_X25_TRACE_QUEUE);
		card->u.x.trace_lost_cnt++;
	if (trace->lost_cnt){
				card->devname,trace->lost_cnt);
	if (alloc_and_init_skb_buf(card,&skb,sizeof(trace_data_t)+trace->length)){
		card->u.x.trace_lost_cnt++;
		card->u.x.trace_lost_cnt++;
	trace->lost_cnt=card->u.x.trace_lost_cnt;
	card->u.x.trace_lost_cnt=0;
		trace_hdr->sec=tv.tv_sec;
		trace_hdr->usec=tv.tv_usec;
	if (trace->length){
		buf = skb_put(skb,trace->length);
		memcpy(buf,trace->data,trace->length);	
	wan_skb_queue_tail(&card->u.x.trace_queue,skb);
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
	if (card->u.x.timer_int_enabled & TMR_INT_ENABLED_CMD_EXEC){
			if (atomic_read(&card->u.x.tx_interrupt_cmd) <= 0){
				atomic_set(&card->u.x.tx_interrupt_cmd,0);
				card->u.x.timer_int_enabled &=
			 * re-trigger tx interrupt */
	if (card->u.x.tx_dev == NULL){
		dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		card->u.x.tx_dev = dev;
	dev = card->u.x.tx_dev;
		chan = dev->priv;
		if (!chan || !(dev->flags&IFF_UP)){
		if (chan->transmit_length){
			if (chan->common.state != WAN_CONNECTED){
				chan->transmit_length = 0;
				chan->tx_offset=0;
				++card->wandev.stats.tx_dropped;
				++chan->ifstats.tx_dropped;
					if (chan->common.usedby == API){
			card->hw_iface.peek(card->hw, card->u.x.hdlc_buf_status_off, &tmp, 1);
			if ((status.cflags[chan->ch_idx] & 0x40 || card->u.x.LAPB_hdlc) && 
		if (++i >= card->u.x.no_dev){
					card->devname);
	card->u.x.tx_dev = dev;
		atomic_dec(&card->u.x.tx_interrupts_pending);
		if (atomic_read(&card->u.x.tx_interrupts_pending) <= 0){
			atomic_set(&card->u.x.tx_interrupts_pending,0);
			card->hw_iface.clear_bit(card->hw, card->intr_perm_off, INTR_ON_TX_FRAME); 
	if (card->u.x.no_dev == 1){
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (devle->dev == dev){
				dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	x25_channel_t* chan = dev->priv; 
	if (chan_send (dev,chan->transmit_buffer,chan->transmit_length,1)){
	chan->transmit_length=0;
	chan->tx_offset=0;
		if (chan->common.usedby == API){
			card->devname,card->u.x.timer_int_enabled);
	if(card->u.x.timer_int_enabled & TMR_INT_ENABLED_UDP_PKT) {
		card->hw_iface.peek(card->hw, card->u.x.hdlc_buf_status_off, &tmp, 1); 
		if ((tmp & 0x40) && card->u.x.udp_type == UDP_XPIPE_TYPE){
		                card->u.x.timer_int_enabled &= 
	}else if (card->u.x.timer_int_enabled & TMR_INT_ENABLED_POLL_ACTIVE) {
		netdevice_t *dev = card->u.x.poll_device;
			card->u.x.timer_int_enabled &= ~TMR_INT_ENABLED_POLL_ACTIVE;
		chan = dev->priv;
					card->devname,chan->name,chan->common.lcn); 
		chan->i_timeout_sofar = jiffies;
         	card->u.x.timer_int_enabled &= ~TMR_INT_ENABLED_POLL_ACTIVE;
		card->u.x.poll_device=NULL;
	}else if (card->u.x.timer_int_enabled & TMR_INT_ENABLED_POLL_CONNECT_ON) {
		if (card->u.x.LAPB_hdlc){
			netdevice_t *dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, INTR_ON_TX_FRAME);
		card->u.x.timer_int_enabled &= ~TMR_INT_ENABLED_POLL_CONNECT_ON;
	}else if (card->u.x.timer_int_enabled & TMR_INT_ENABLED_POLL_CONNECT_OFF) {
		if (card->u.x.LAPB_hdlc){
			netdevice_t *dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
			send_oob_msg(card,dev,&card->wan_mbox);
		card->u.x.timer_int_enabled &= ~TMR_INT_ENABLED_POLL_CONNECT_OFF;
	}else if (card->u.x.timer_int_enabled & TMR_INT_ENABLED_POLL_DISCONNECT) {
		if (card->u.x.LAPB_hdlc){
			dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		card->u.x.timer_int_enabled &= ~TMR_INT_ENABLED_POLL_DISCONNECT;
	}else if (card->u.x.timer_int_enabled & TMR_INT_ENABLED_UPDATE){
		card->hw_iface.peek(card->hw, card->u.x.hdlc_buf_status_off, &tmp, 1); 
			card->u.x.timer_int_enabled &= ~TMR_INT_ENABLED_UPDATE;
	if(!(card->u.x.timer_int_enabled & ~TMR_INT_ENABLED_CMD_EXEC)){
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, INTR_ON_TIMER);
	wan_mbox_t* mbox = &card->wan_mbox;
	memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
	mbox->wan_command = X25_READ_MODEM_STATUS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
		modem_status = (TX25ModemStatus*)mbox->wan_data;	
		if (last_stat.status != modem_status->status){
					card->devname,
					DCD(modem_status->status),
					CTS(modem_status->status));
			last_stat.status = modem_status->status;
			if (card->u.x.oob_on_modem){
				mbox->wan_x25_pktType = mbox->wan_command;
				mbox->wan_return_code = 0x08;
				WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
					chan=dev->priv;
					if (chan->common.usedby == API){
	memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
	mbox->wan_command = X25_HDLC_LINK_STATUS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	printk(KERN_INFO "%s: spurious interrupt!\n", card->devname);
 * 	time-dependent housekeeping work.
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (card->open_cnt != card->u.x.num_of_ch){
	if (test_bit(PERI_CRIT,&card->wandev.critical)){
	if (test_bit(SEND_CRIT,&card->wandev.critical)){
	switch(card->wandev.state){
	clear_bit(POLL_CRIT,&card->wandev.critical);
	WAN_TASKQ_SCHEDULE((&card->u.x.x25_poll_task));
	card->hw_iface.peek(card->hw, card->flags_off + offsetof(TX25Status, gflags), &gflags, 1);
	DEBUG_TEST("%s: Poll Connecting 0x%X\n",card->devname,gflags);
	}else if ((jiffies - card->state_tick) > CONNECT_TIMEOUT){
 * 	o if hold-down timeout has expired and there are open interfaces, 
	if (!card->u.x.LAPB_hdlc && card->open_cnt && 
	    ((jiffies - card->state_tick) > HOLD_DOWN_TIME)){
	if ((dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head))) == NULL)
	if ((chan=dev->priv) == NULL)
	wan_mbox_t* mbox = &card->wan_mbox;
	card->hw_iface.peek(card->hw, X25_TX_TIMEOUT_OFFS, &tx_timeout, 1);
		card->hw_iface.poke(card->hw, X25_TX_TIMEOUT_OFFS, &tx_timeout, 1);
					card->devname);
		spin_lock_irqsave(&card->wandev.lock, flags);
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_HDLC_LINK_STATUS;
		card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
		spin_unlock_irqrestore(&card->wandev.lock, flags);
	card->hw_iface.peek(card->hw, X25_MODEM_STATE_OFFS, &modem_status, 1);
		if (card->wandev.ignore_front_end_status == WANOPT_NO){
					card->devname,
			spin_lock_irqsave(&card->wandev.lock, flags);
			memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
			mbox->wan_command = X25_HDLC_LINK_STATUS;
			card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
			spin_unlock_irqrestore(&card->wandev.lock, flags);
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
		DEBUG_EVENT("%s: Lapb hdlc link down!\n",card->devname);
		spin_lock_irqsave(&card->wandev.lock, flags);
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_HDLC_LINK_STATUS;
		card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
		spin_unlock_irqrestore(&card->wandev.lock, flags);
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if ( chan->common.svc && 
		     chan->common.state == WAN_CONNECTED &&
		     chan->common.usedby == WANPIPE ){
			if( (jiffies - chan->i_timeout_sofar) / HZ > chan->idle_timeout ){
				card->u.x.poll_device=dev;
		if (chan->common.state == WAN_CONNECTED &&
		    atomic_read(&chan->common.disconnect) &&
		    !chan->common.sk && chan->common.svc &&
		    chan->common.lcn){
					card->devname,chan->common.dev->name,chan->common.lcn);
			spin_lock_irqsave(&card->wandev.lock, flags);
			if (x25_clear_call(card,chan->common.lcn,
					   chan->x25_api_cmd_hdr.cause, 
				   	   chan->x25_api_cmd_hdr.diagn,0,NULL,0) == 0){
				atomic_set(&chan->common.disconnect,0);
			spin_unlock_irqrestore(&card->wandev.lock, flags);
	card->u.x.timer_int_enabled |= TYPE;
		atomic_inc(&card->u.x.tx_interrupt_cmd);
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, INTR_ON_TX_FRAME);
		card->hw_iface.peek(card->hw, card->intr_perm_off, &intr_perm, 1);
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, INTR_ON_TIMER);
 * SDLA Firmware-Specific Functions 
 *  of retries is reached.  Each interface command returns non-zero return 
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_READ_CODE_VERSION;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, X25_READ_CODE_VERSION, 0) && retry--);
		int len = mbox->wan_data_len;
		memcpy(str, mbox->wan_data, len);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		memcpy(mbox->wan_data, (void*)conf, sizeof(TX25Config));
		mbox->wan_data_len  = sizeof(TX25Config);
		mbox->wan_command = X25_SET_CONFIGURATION;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_SET_CONFIGURATION, 0) && retry-- );
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		memcpy(mbox->wan_data, (void*)conf, sizeof(TX25Config));
		mbox->wan_data_len  = sizeof(TX25Config);
		mbox->wan_command = X25_HDLC_SET_CONFIG;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, X25_SET_CONFIGURATION, 0) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = SET_PROTOCOL_LEVEL;
		mbox->wan_data_len = 1;
		mbox->wan_data[0] = HDLC_LEVEL; //| DO_HDLC_LEVEL_ERROR_CHECKING; 	
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, SET_PROTOCOL_LEVEL, 0) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_HDLC_READ_COMM_ERR;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, X25_HDLC_READ_COMM_ERR, 0) && retry--);
		THdlcCommErr* stats = (void*)mbox->wan_data;
		card->wandev.stats.rx_over_errors    = stats->rxOverrun;
		card->wandev.stats.rx_crc_errors     = stats->rxBadCrc;
		card->wandev.stats.rx_missed_errors  = stats->rxAborted;
		card->wandev.stats.tx_aborted_errors = stats->txAborted;
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_READ_STATISTICS;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, X25_READ_STATISTICS, 0) && retry--) ;
		TX25Stats* stats = (void*)mbox->wan_data;
		card->wandev.stats.rx_packets = stats->rxData;
		card->wandev.stats.tx_packets = stats->txData;
		memcpy(&X25Stats, mbox->wan_data, mbox->wan_data_len);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_HDLC_LINK_CLOSE;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, X25_HDLC_LINK_CLOSE, 0) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_HDLC_LINK_OPEN;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_HDLC_LINK_OPEN, 0) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_HDLC_LINK_SETUP;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_HDLC_LINK_SETUP, 0) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_data[0] = 0;
		mbox->wan_data[2] = 0;
		mbox->wan_data[1] = dtr ? 0x02 : 0x01;
		mbox->wan_data_len  = 3;
		mbox->wan_command = X25_SET_GLOBAL_VARS;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_SET_GLOBAL_VARS, 0) && retry-- );
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_data[0] = mode;
		mbox->wan_data[1] = card->wandev.irq;	// ALEX_TODAY card->hw.irq;
		mbox->wan_data[2] = 2;
		mbox->wan_data_len = 3;
		mbox->wan_command = X25_SET_INTERRUPT_MODE;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_SET_INTERRUPT_MODE, 0) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
	int lcn = chan->common.lcn;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_x25_lcn     = lcn;
		mbox->wan_command = X25_READ_CHANNEL_CONFIG;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_READ_CHANNEL_CONFIG, lcn) && retry--);
		card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
		if (card->u.x.x25_conf.hi_svc <= X25_MAX_CHAN){ 
			chan->ch_idx = lcn - 1;
			switch (mbox->wan_data[0] & 0x1F)
			chan->ch_idx = lcn - 1 - offset;
		switch(mbox->wan_data[1] & 0x38)
				chan->tx_pkt_size = 16; 
				chan->tx_pkt_size = 32; 
				chan->tx_pkt_size = 64; 
				chan->tx_pkt_size = 128; 
				chan->tx_pkt_size = 256; 
				chan->tx_pkt_size = 512; 
				chan->tx_pkt_size = 1024; 
		if (card->u.x.logging)
				card->devname, lcn, chan->tx_pkt_size);
	wan_mbox_t* mbox = &card->wan_mbox;
	if (chan->common.usedby == WANPIPE){
		if (chan->protocol == htons(ETH_P_IP)){
			if(strcmp(&chan->x25_src_addr[0], "") == 0){
				sprintf(chan->call_string, "-d%s -uCC", chan->addr);
				sprintf(chan->call_string, "-d%s -s%s -uCC", 
						chan->addr, 
						chan->x25_src_addr);
			printk(KERN_INFO "%s: Call String : %s \n", card->devname, chan->call_string);
		}else if (chan->protocol == htons(ETH_P_IPX)){
			sprintf(chan->call_string, "-d%s -u800000008137", chan->addr);
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		strcpy(mbox->wan_data, chan->call_string);
		mbox->wan_data_len  = strlen(chan->call_string);
		mbox->wan_command = X25_PLACE_CALL;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, X25_PLACE_CALL, 0) && retry--);
		bind_lcn_to_dev (card, chan->common.dev, mbox->wan_x25_lcn);
	chan->x25_api_event.hdr.qdm = mbox->wan_x25_qdm;
	chan->x25_api_event.hdr.cause = mbox->wan_x25_cause;
	chan->x25_api_event.hdr.diagn = mbox->wan_x25_diagn;
	chan->x25_api_event.hdr.pktType = mbox->wan_x25_pktType&0x7F;
	chan->x25_api_event.hdr.length  = 0;
	chan->x25_api_event.hdr.result = 0;
	chan->x25_api_event.hdr.lcn = mbox->wan_x25_lcn;
	chan->x25_api_event.hdr.mtu = card->u.x.x25_conf.defPktSize;
	chan->x25_api_event.hdr.mru = card->u.x.x25_conf.defPktSize;
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_x25_lcn     = lcn;
		mbox->wan_x25_qdm     = qdm;
		mbox->wan_command = X25_ACCEPT_CALL;
			mbox->wan_data_len = len;
			strncpy(mbox->wan_data,data,len);
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_ACCEPT_CALL, lcn) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_x25_lcn     = lcn;
		mbox->wan_x25_qdm     = qdm;
		mbox->wan_command = X25_WP_INTERRUPT;
			mbox->wan_data_len = len;
			strncpy(mbox->wan_data,data,len);
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_WP_INTERRUPT, lcn) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
	DEBUG_TEST("%s:%s: LCN=%i QDM %x\n",__FUNCTION__,card->devname,lcn,qdm);
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_x25_qdm     = qdm;
		mbox->wan_x25_lcn     = lcn;
		mbox->wan_x25_cause   = cause;
		mbox->wan_x25_diagn   = diagn;
		mbox->wan_command = X25_CLEAR_CALL;
			mbox->wan_data_len = len;
			strncpy(mbox->wan_data,data,len);
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_CLEAR_CALL, lcn) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
	DEBUG_TEST("%s:%s: LCN=%i QDM %x\n",__FUNCTION__,card->devname,lcn,qdm);
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_x25_qdm     = qdm;
		mbox->wan_x25_lcn     = lcn;
		mbox->wan_x25_cause   = cause;
		mbox->wan_x25_diagn   = diagn;
		mbox->wan_command = X25_RESET;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, X25_RESET, lcn) && retry--);
	wan_mbox_t* mbox = &card->wan_mbox;
	if (card->u.x.LAPB_hdlc)
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		memcpy(mbox->wan_data, buf, len);
		mbox->wan_data_len  = (unsigned short)len;
		mbox->wan_x25_lcn     = (unsigned short)lcn;
		if (card->u.x.LAPB_hdlc){
			mbox->wan_x25_pf = (unsigned char)qdm;
			mbox->wan_x25_qdm = (unsigned char)qdm;
		mbox->wan_command = cmd;
		/* The P6-PCI caching used to be a bug on old 
		if (mbox->wan_opp_flag){
			printk(KERN_INFO "%s: Critical Error: P6-PCI Cache bug!\n",
					card->devname);
					card->devname);
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && x25_error(card, err, cmd , lcn) && retry--);
	if (card->u.x.LAPB_hdlc && err == 1){
	wan_mbox_t* mbox = &card->wan_mbox;
	card->hw_iface.peek(card->hw, card->flags_off + offsetof(TX25Status, gflags), &gflags, 1);
		memset(&mbox->wan_command, 0, sizeof(TX25Cmd));
		mbox->wan_command = X25_IS_DATA_AVAILABLE;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
 *		non-zero return code to handle X.25 asynchronous events and 
 *		common errors. Return non-zero to repeat command or zero to 
 *    	events.  To avoid re-entrancy problems we copy mailbox to dynamically
	wan_mbox_t* mb = &card->wan_mbox;
	unsigned dlen = mb->wan_data_len;
			card->devname);
	memcpy(mb, card->mbox, sizeof(wan_mbox_t) + dlen);
		mb->wan_data[dlen] = '\0';
		switch (mb->wan_x25_pktType & 0x7F){
				card->devname, mb->wan_x25_lcn, mb->wan_x25_cause,
				mb->wan_x25_diagn);
				card->devname, mb->wan_x25_pktType&0x7F,
				mb->wan_x25_lcn, mb->wan_x25_cause, mb->wan_x25_diagn);
		switch (mb->wan_x25_pktType & 0x7F){
				card->devname, mb->wan_x25_lcn, mb->wan_x25_cause,
				mb->wan_x25_diagn);
				card->devname, mb->wan_x25_lcn,
				mb->wan_x25_pktType & 0x7F, mb->wan_x25_cause, mb->wan_x25_diagn);
			"Packet:0x%02X Diagn:0x%02X\n", card->devname,
			mb->wan_x25_lcn, mb->wan_x25_pktType&0x7F, mb->wan_x25_diagn);
			card->devname);
			card->devname, mb->wan_data[0]);
			card->devname, cmd);
		if (card->u.x.LAPB_hdlc)
		if (mb->wan_command == 0x16)
		if (mb->wan_command == 0x06)
			card->devname, cmd, err, mb->wan_x25_lcn)
	wan_device_t* wandev = &card->wandev;
	int new_lcn = mb->wan_x25_lcn;
			card->devname, new_lcn);
			"on LCN %d!\n", card->devname, new_lcn);
	parse_call_info(mb->wan_data, info);
	if (card->u.x.logging){
			card->devname, new_lcn);
	user_data = hex_to_uint(info->user,2);
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (chan->common.usedby == API){
		if (!chan->common.svc || (chan->common.state != WAN_DISCONNECTED)){
		if (chan->protocol == htons(ETH_P_IP) && user_data != NLPID_IP){
		if (chan->protocol == htons(ETH_P_IPX) && user_data != NLPID_SNAP){
		if (user_data == NLPID_IP && chan->protocol != htons(ETH_P_IP)){
				       htons(chan->protocol), info->user[0]);
		if (user_data == NLPID_SNAP && chan->protocol != htons(ETH_P_IPX)){
				       htons(chan->protocol));
		if (is_match_found(info->dest, chan->accept_dest_addr) &&
		    is_match_found(info->src, chan->accept_src_addr) &&
		    is_match_found(&info->user[2], chan->accept_usr_data)){
		if (card->sk != NULL){
						card->devname);
				card->devname);
	}else if (info->nuser == 0){
			card->devname, new_lcn)
			chan->protocol = htons(0);
				"on LCN %d!\n", card->devname, user_data, new_lcn);
		bind_lcn_to_dev (card, chan->common.dev, new_lcn);
	/* case ?? - must exactly match */
	if (chan[strlen(chan) - 1] != '*' && chan[0] != '*' && strlen(chan)){
	if ( chan[0] != '*' && chan[strlen(chan) - 1] == '*'){
		if (strncmp(info, &chan[0], strlen(chan) - 1) == 0)	return 1;
	if ( chan[0] == '*' && chan[strlen(chan) - 1] != '*'){	
		if (strncmp(&info[strlen(info) - strlen(chan)+1], &chan[1], strlen(chan) - 1) == 0)
	if ( chan[0] == '*' && chan[strlen(chan) - 1] == '*'){
		strncpy(temp, &chan[1], strlen(chan) - 2);
		temp[strlen(chan) - 2] = '\0';
	/* if got here the string is empty - do not accept call */
	unsigned new_lcn = mb->wan_x25_lcn;
			card->devname, new_lcn);
	if (card->u.x.logging)	
			card->devname, dev->name, new_lcn);
	chan = dev->priv;
	if (chan->common.usedby == API){
		chan->x25_api_event.hdr.qdm = mb->wan_x25_qdm;
		chan->x25_api_event.hdr.cause = mb->wan_x25_cause;
		chan->x25_api_event.hdr.diagn = mb->wan_x25_diagn;
		chan->x25_api_event.hdr.pktType = mb->wan_x25_pktType&0x7F;
		chan->x25_api_event.hdr.length  = 0;
		chan->x25_api_event.hdr.result = 0;
		chan->x25_api_event.hdr.lcn = mb->wan_x25_lcn;
		chan->x25_api_event.hdr.mtu = card->u.x.x25_conf.defPktSize;
		chan->x25_api_event.hdr.mru = card->u.x.x25_conf.defPktSize;
	unsigned new_lcn = mb->wan_x25_lcn;
	if (card->u.x.logging){
		card->devname, new_lcn, mb->wan_x25_cause, mb->wan_x25_diagn);
				card->devname);
	chan=dev->priv;
	old_state = chan->common.state;
	if (chan->common.usedby == API){
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
		card->devname, mb->wan_x25_cause, mb->wan_x25_diagn);
	card->hw_iface.poke(card->hw, X25_TX_TIMEOUT_OFFS, &tx_timeout, 1);
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		old_state = chan->common.state;
		if (chan->common.usedby == API){
		if (chan->common.svc){
			if (chan->common.usedby == WANPIPE){
		atomic_set(&chan->common.command,0);
	if (card->sk){
		wanpipe_api_listen_rx(NULL,card->sk);
		sock_put(card->sk);
		card->sk=NULL;
	 * re-enabled */
		card->hw_iface.poke(card->hw, 
				    card->intr_perm_off,
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
		"%s: Lapb layer disconnected!\n",card->devname);
	clear_bit(0,&card->u.x.card_ready);
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		old_state = chan->common.state;
		if (chan->common.usedby == API){
			mb->wan_x25_pktType=x25_pkt_type;
	if (card->sk){
		wanpipe_api_listen_rx(NULL,card->sk);
		sock_put(card->sk);
		card->sk=NULL;
	 * re-enabled */
		card->hw_iface.poke(card->hw, 
				    card->intr_perm_off,
	unsigned new_lcn = mb->wan_x25_lcn;
	if ((mb->wan_x25_pktType&0x7F) == 0x05)	/* call request time out */
			card->devname, new_lcn);
		card->devname, mb->wan_x25_pktType&0x7F, new_lcn);
		DEBUG_EVENT("%s: Failed to open hdlc and setup hdlc\n",card->devname);
		return -EIO;
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, INTR_ON_TIMER);
	WAN_LIST_FOREACH(devle, &wandev->dev_head, dev_link){
		if (((x25_channel_t*)dev->priv)->common.lcn == lcn){ 
	x25_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	if (chan->common.svc && chan->common.usedby == WANPIPE){
		if (!chan->addr[0]){
					card->devname);
			return -EINVAL;	/* no destination address */
			card->devname, chan->addr);
			return -EIO;
			return -EIO;
	x25_channel_t* chan = dev->priv;
	if (chan->common.svc){ 
		x25_clear_call(chan->card, chan->common.lcn, 0, 0, 0,NULL,0);
		if (chan->common.usedby == API)
	x25_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	if (chan->common.state != state)
				if (card->u.x.logging){
						card->devname, dev->name,chan->common.lcn);
				*(unsigned short*)dev->dev_addr = htons(chan->common.lcn);
				chan->i_timeout_sofar = jiffies;
				if (card->u.x.LAPB_hdlc){
					chan->common.svc=0;
				if (card->u.x.logging){
						card->devname, dev->name, chan->common.lcn);
				if (card->u.x.logging){
						card->devname, dev->name,chan->common.lcn);
				if (!card->u.x.LAPB_hdlc){
					atomic_set(&chan->common.disconnect,0);
				if (chan->common.svc) {
					*(unsigned short*)dev->dev_addr = 0;
					card->u.x.svc_to_dev_map[(chan->common.lcn%X25_MAX_CHAN)]=NULL;
		                	chan->common.lcn = 0;
				if (chan->transmit_length){
					chan->transmit_length=0;
					chan->tx_offset=0;
				 * re-enabled */
				if (atomic_read(&chan->common.receive_block)){
					card->hw_iface.peek(card->hw,
						       	    card->intr_perm_off,
					atomic_set(&chan->common.receive_block,0);
								card->devname);
						card->hw_iface.poke(card->hw,
							       	    card->intr_perm_off,
				if (wan_skb_queue_len(&chan->common.rx_queue)){
							chan->common.dev->name);
					wan_skb_queue_purge(&chan->common.rx_queue);	
				atomic_set(&chan->common.command,0);
				atomic_set(&chan->cmd_rc,0);
				if (card->u.x.logging){
					card->devname, dev->name,chan->common.lcn);
				atomic_set(&chan->common.disconnect,0);
		chan->common.state = state;
	chan->state_tick = jiffies;
 * 	Return:		0	- transmission complete
 *			1	- busy
 *    	the packet into 'complete sequence' using M-bit.
	x25_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	card->hw_iface.peek(card->hw, card->flags_off, &status, sizeof(status));
	card->hw_iface.peek(card->hw, card->u.x.hdlc_buf_status_off, &tmp, 1); 
	if ((!(status.cflags[chan->ch_idx] & 0x40) && !card->u.x.LAPB_hdlc)  || 
			++card->wandev.stats.tx_dropped;
			++chan->ifstats.tx_dropped;
				card->devname,dev->name);
			++chan->if_send_stat.if_send_bfr_not_passed_to_adptr;
	if (chan->common.usedby == API){
		qdm = api_data->qdm;
		orig_len = len = data_len - sizeof(x25api_hdr_t);
		len -= chan->tx_offset;
		data = (unsigned char*)data + chan->tx_offset;
	if (len > chan->tx_pkt_size && !card->u.x.LAPB_hdlc){
		 * the chan->tx_offset value. We must start
		len = chan->tx_pkt_size;
	switch(x25_send(card, chan->common.lcn, (qdm&0x07), len, data)){
			chan->i_timeout_sofar = jiffies;
			dev->trans_start=jiffies;
			if ((qdm & M_BIT) && !card->u.x.LAPB_hdlc){
				chan->tx_offset += len;
					DEBUG_EVENT("%s:%s: Critical Error: qdm set in non-interrupt mode!\n",
							card->devname);
					++chan->ifstats.tx_packets;
					chan->ifstats.tx_bytes += len;
					++chan->if_send_stat.if_send_bfr_passed_to_adptr;
					if (chan->tx_offset < orig_len){
				++chan->ifstats.tx_packets;
				chan->ifstats.tx_bytes += len;
				++chan->if_send_stat.if_send_bfr_passed_to_adptr;
						card->devname,dev->name);
				++chan->ifstats.tx_dropped;
				++card->wandev.stats.tx_dropped;
				++chan->if_send_stat.if_send_bfr_not_passed_to_adptr;
						card->devname,dev->name);
			++chan->ifstats.tx_errors;
					card->devname,dev->name);
				++chan->ifstats.tx_dropped;
				++card->wandev.stats.tx_dropped;
				++chan->if_send_stat.if_send_bfr_not_passed_to_adptr;
					card->devname,dev->name);			
		if (*str == '-') switch (str[1]) {
				for (i = 0; i < (MAX_X25_ADDR_SIZE-2); ++i){
					info->dest[i] = ch;
				for (i = 0; i < (MAX_X25_ADDR_SIZE-2); ++i){
					info->src[i] = ch;
				for (i = 0; i < (MAX_X25_DATA_SIZE-2); ++i){
					info->user[i] = ch; 
				info->nuser = i;
				for (i = 0; i < (MAX_X25_FACL_SIZE-2); ++i){
					info->facil[i] = ch;
				info->nfacil = i;
	for (val = 0; len && is_digit(*str); ++str, --len)
		val = (val * 10) + (*str - (unsigned)'0');
	for (val = 0; len; ++str, --len)
			val = (val << 4) + (ch - (unsigned)'0');
			val = (val << 4) + ((ch & 0xDF) - (unsigned)'A' + 10);
			sendpacket[57] = '-';
		/*If we get here its an IPX-data packet, so it'll get passed up the stack.
 *  	If incoming is 0 (outgoing)- if the net numbers is ours make it 0
 *  	if incoming is 1 - if the net number is 0 make it ours 
	if (card->u.x.LAPB_hdlc){
		return WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
				if (card->u.x.svc_to_dev_map[lcn])
					return card->u.x.svc_to_dev_map[lcn];
				if (card->u.x.pvc_to_dev_map[lcn])
					return card->u.x.pvc_to_dev_map[lcn];
				if (card->u.x.svc_to_dev_map[new_lcn])
					return card->u.x.svc_to_dev_map[new_lcn];
				if (card->u.x.pvc_to_dev_map[new_lcn])
					return card->u.x.pvc_to_dev_map[new_lcn];
	x25_channel_t *chan = dev->priv;
	if (chan->common.svc){
		card->u.x.svc_to_dev_map[(lcn % X25_MAX_CHAN)] = dev;
		card->u.x.pvc_to_dev_map[(lcn % X25_MAX_CHAN)] = dev;
	chan->common.lcn = lcn;
	sdla_t* card = chan->card;
		len=skb->len;
		if (chan->common.usedby == API){
				++chan->rx_intr_stat.rx_intr_bfr_passed_to_stack;
				++chan->ifstats.rx_packets;
				chan->ifstats.rx_bytes += len;
			}else if (err == -ENOMEM){
				DEBUG_EVENT("%s:%s: Warning: API socket full!\n",card->devname,chan->common.dev->name);
				wan_skb_queue_head(&chan->common.rx_queue,skb);
				++chan->ifstats.rx_dropped;
		if (atomic_read(&chan->common.receive_block)){
			card->hw_iface.peek(card->hw,
				       	    card->intr_perm_off,
			atomic_set(&chan->common.receive_block,0);
				DEBUG_EVENT("%s: Disabling x25 flow control!\n",card->devname);
				card->hw_iface.poke(card->hw,
					       	    card->intr_perm_off,
	WAN_TASKLET_END((&chan->common.bh_task));
	x25_channel_t *chan = dev->priv;
	if (!chan->common.sk){
	wanpipe_api_poll_wake(chan->common.sk);
	volatile wan_mbox_t* mbox = &card->wan_mbox;
	if (!test_and_set_bit(0,&card->u.x.card_ready)){
				card->devname);
		card->u.x.cmd_dev=NULL;
	if (card->u.x.cmd_dev == NULL){
		card->u.x.cmd_dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	dev = card->u.x.cmd_dev;
		chan = dev->priv;
		if (!chan || !(dev->flags&IFF_UP)){
		if (atomic_read(&chan->common.command)){ 
			chan->x25_api_event.hdr.qdm = mbox->wan_x25_qdm;
			chan->x25_api_event.hdr.cause = mbox->wan_x25_cause;
			chan->x25_api_event.hdr.diagn = mbox->wan_x25_diagn;
			chan->x25_api_event.hdr.pktType = mbox->wan_x25_pktType&0x7F;
			chan->x25_api_event.hdr.length  = 0;
			chan->x25_api_event.hdr.result = 0;
			chan->x25_api_event.hdr.lcn = mbox->wan_x25_lcn;
			chan->x25_api_event.hdr.mtu = card->u.x.x25_conf.defPktSize;
			chan->x25_api_event.hdr.mru = card->u.x.x25_conf.defPktSize;
			atomic_set(&chan->cmd_rc,err);
				atomic_set(&chan->common.command,0);
			case -EAGAIN:
				chan->cmd_timeout=jiffies;
		if (++i == card->u.x.no_dev){
					card->devname);
	card->u.x.cmd_dev = dev;
		atomic_dec(&card->u.x.tx_interrupt_cmd);
	wan_mbox_t* mbox = &card->wan_mbox;
	int err=-EINVAL;
	x25_channel_t *chan = dev->priv;
	card->hw_iface.peek(card->hw, card->u.x.hdlc_buf_status_off, &status, 1);
				card->devname);
		return -EAGAIN;
	if ((!chan->common.svc) && (atomic_read(&chan->common.command) == X25_PLACE_CALL)){
		if (card->u.x.LAPB_hdlc){
				return -ENETDOWN;
			DBG_PRINTK(KERN_INFO "%s: PVC is CONNECTING\n",card->devname);
				return -ENETDOWN;
		return -EINVAL;
			__FUNCTION__,card->devname,dev->name,
			atomic_read(&chan->common.command),
			chan->common.lcn);
	switch (atomic_read(&chan->common.command)){
					card->devname,dev->name, mbox->wan_x25_lcn);
			bind_lcn_to_dev (card, dev, mbox->wan_x25_lcn);
			err=-ENETDOWN;
				    chan->common.lcn,
				    chan->call_string,
				    strlen(chan->call_string));
				card->devname,dev->name,mbox->wan_x25_lcn);
			bind_lcn_to_dev (card, dev, mbox->wan_x25_lcn);
				if (x25_clear_call(card, chan->common.lcn, 0, 0, 0, NULL,0) == CMD_OK){
					err=-ENETDOWN;
						card->devname);
					err=-EINVAL;
			err = -EAGAIN;
			DBG_PRINTK(KERN_INFO "%s: ACCEPT FAILED\n",card->devname);
			if (x25_clear_call(card, chan->common.lcn, 0, 0, 0, NULL,0) == CMD_OK){
				err = -ENETDOWN;
						card->devname);
				err = -EINVAL;
		err=x25_clear_call(card,chan->common.lcn,
				   chan->x25_api_cmd_hdr.cause, 
				   chan->x25_api_cmd_hdr.diagn,
				   chan->call_string,
				   strlen(chan->call_string));
				    card->devname,dev->name,
				    mbox->wan_x25_lcn,chan->common.lcn);
			err=-EAGAIN;
			err = -EINVAL;
                         * chan->disconnect which will signal
				card->devname,err); 
			return -EINVAL;
		err=x25_reset_call(card,chan->common.lcn,
				   chan->x25_api_cmd_hdr.cause, 
				   chan->x25_api_cmd_hdr.diagn,
				    card->devname,dev->name,
				    mbox->wan_x25_lcn,chan->common.lcn);
			err=-EAGAIN;
			err = -EINVAL;
                         * chan->disconnect which will signal
				card->devname,err); 
			return -EINVAL;
				  chan->common.lcn,
				  chan->call_string,
				  strlen(chan->call_string));
				    card->devname,dev->name,
				    mbox->wan_x25_lcn,chan->common.lcn);
			err=-EAGAIN;
			err = -EINVAL;
                         * chan->disconnect which will signal
				card->devname,err); 
			return -EINVAL;
	int len = sizeof(x25api_hdr_t)+mbox->wan_data_len;
	if (!card->sk){
				card->devname);
		return -ENODEV;
				card->devname);
		return -ENODEV;
	chan=dev->priv;
		printk(KERN_INFO "%s: API incoming call, no memory\n",card->devname);
		return -ENOMEM;
		return -ENOMEM;
	x25_api_hdr->qdm = mbox->wan_x25_qdm;
	x25_api_hdr->cause = mbox->wan_x25_cause;
	x25_api_hdr->diagn = mbox->wan_x25_diagn;
	x25_api_hdr->pktType = mbox->wan_x25_pktType&0x7F;
	x25_api_hdr->length  = mbox->wan_data_len;
	x25_api_hdr->result = 0;
	x25_api_hdr->lcn = lcn;
	x25_api_hdr->mtu = card->u.x.x25_conf.defPktSize;
	x25_api_hdr->mru = card->u.x.x25_conf.defPktSize;
	if (mbox->wan_data_len > 0 && mbox->wan_data_len <= X25_CALL_STR_SZ){
		buf = skb_put(skb,mbox->wan_data_len);
			return -ENOMEM;
		memcpy(buf,mbox->wan_data,mbox->wan_data_len);
	memcpy(&chan->x25_api_event,skb->data,skb->len);
	skb->pkt_type = WAN_PACKET_ERR;
	skb->dev=dev;
	skb->destructor=wan_skb_destructor;
	skb->protocol=htons(ETH_P_X25);
	err=wanpipe_api_listen_rx(skb,card->sk);
	dev = find_channel(card,mb->wan_x25_lcn);
			card->devname, mb->wan_x25_lcn);
	chan=dev->priv;
			card->devname, dev->name, mb->wan_x25_lcn);
	old_state = chan->common.state;
	int len = sizeof(x25api_hdr_t)+mbox->wan_data_len;
	x25_channel_t *chan=dev->priv;
	if (chan->common.usedby != API)
		return -ENODEV;
	if (!chan->common.sk){
		return -ENODEV;
				card->devname,__FUNCTION__);
		return -EINVAL;
		return -ENOMEM;
		return -ENOMEM;
	x25_api_hdr->qdm = mbox->wan_x25_qdm;
	x25_api_hdr->cause = mbox->wan_x25_cause;
	x25_api_hdr->diagn = mbox->wan_x25_diagn;
	x25_api_hdr->pktType = mbox->wan_x25_pktType&0x7F;
	x25_api_hdr->length = mbox->wan_data_len;
	x25_api_hdr->result = 0;
	x25_api_hdr->lcn = mbox->wan_x25_lcn;
	x25_api_hdr->mtu = card->u.x.x25_conf.defPktSize;
	x25_api_hdr->mru = card->u.x.x25_conf.defPktSize;
	if (mbox->wan_data_len > 0 && mbox->wan_data_len <= X25_CALL_STR_SZ){
		buf = skb_put(skb,mbox->wan_data_len);
			return -ENOMEM;
		memcpy(buf,mbox->wan_data,mbox->wan_data_len);
	memcpy(&chan->x25_api_event,skb->data,skb->len);
	skb->pkt_type = WAN_PACKET_ERR;
	skb->protocol=htons(ETH_P_X25);
				chan->common.dev->name);
			card->devname);
			,card->devname);
	netdevice_t *dev = find_channel(card,mbox->wan_x25_lcn);
	chan=dev->priv;
	if (chan->common.usedby == API){
	wan_mbox_t* mbox = &card->wan_mbox;
		mbox->wan_command = X25_HDLC_LINK_DISC;
		mbox->wan_data_len = 1;
		mbox->wan_data[0]=0;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err  && x25_error(card, err, X25_HDLC_LINK_DISC, 0) && retry--);
		printk(KERN_INFO "%s: Hdlc Link Down Failed %x\n",card->devname,err);
	x25_channel_t *chan = dev->priv;
	switch (atomic_read(&chan->common.command)&0x7F){
			if (chan->common.state != WAN_DISCONNECTED)
			if (chan->common.state == WAN_DISCONNECTED)
			if (chan->common.state != WAN_CONNECTING)
			if (chan->common.state != WAN_CONNECTED)
			if (chan->common.state != WAN_CONNECTED)
			card->devname,atomic_read(&chan->common.command),dev->name, 
			chan->common.lcn, chan->common.state);
	wan_mbox_t*	mbox = &card->wan_mbox;
	wan_udp_pkt_t *wan_udp_pkt = (wan_udp_pkt_t *)&card->u.x.udp_pkt_data;
		dev = card->u.x.udp_dev;
		atomic_set(&card->u.x.udp_pkt_len,0);
	chan = dev->priv;
	lcn = chan->common.lcn;
	switch(wan_udp_pkt->wan_udp_command) {
			if(card->u.x.udp_pkt_src == UDP_PKT_FRM_NETWORK) {
                    		++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_direction_err;
			// ALEX_TODAY if(card->hw.fwid !=  SFID_X25_508) {
			if (card->type == SDLA_S508){
				++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_type_err;
		wan_udp_pkt->wan_udp_data_len = 0;
		//ALEX_TODAY wan_udp_pkt->wan_udp_return_code = (card->hw.fwid != SFID_X25_508) ? 0x1F : 0xCD;
		wan_udp_pkt->wan_udp_return_code = (card->type != SDLA_S508) ? 0x1F : 0xCD;
		switch (wan_udp_pkt->wan_udp_command) {
			mbox->wan_data_len = 0;
			memcpy(wan_udp_pkt->wan_udp_data, &chan->if_send_stat, sizeof(if_send_stat_t));
			mbox->wan_data_len = sizeof(if_send_stat_t);
			wan_udp_pkt->wan_udp_data_len =  mbox->wan_data_len;	
			memcpy(&wan_udp_pkt->wan_udp_data[0], &card->statistics, sizeof(global_stats_t));
                        memcpy(&wan_udp_pkt->wan_udp_data[sizeof(global_stats_t)],
                                &chan->rx_intr_stat, sizeof(rx_intr_stat_t));
			mbox->wan_data_len = sizeof(global_stats_t) +
			wan_udp_pkt->wan_udp_data_len =  mbox->wan_data_len;
                        memcpy(wan_udp_pkt->wan_udp_data,
                                &chan->pipe_mgmt_stat.UDP_PIPE_mgmt_kmalloc_err,
                        memcpy(&wan_udp_pkt->wan_udp_data[sizeof(pipe_mgmt_stat_t)],
                               &card->statistics, sizeof(global_stats_t));
                        wan_udp_pkt->wan_udp_return_code = 0;
                        wan_udp_pkt->wan_udp_data_len = sizeof(global_stats_t)+
                        mbox->wan_data_len = wan_udp_pkt->wan_udp_data_len;
			chan->router_up_time = tv.tv_sec - chan->router_start_time;
    	                *(unsigned long *)&wan_udp_pkt->wan_udp_data = chan->router_up_time;	
			wan_udp_pkt->wan_udp_data_len = mbox->wan_data_len = 4;
			wan_udp_pkt->wan_udp_return_code = 0;
		   	wan_udp_pkt->wan_udp_data[0] = card->wandev.config_id;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mbox->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_LINUX_PLATFORM;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mbox->wan_data_len  = wan_udp_pkt->wan_udp_data_len = 1;
			card->u.x.trace_timeout=jiffies;
			new_skb=wan_skb_dequeue(&card->u.x.trace_queue);
				wan_udp_pkt->wan_udp_return_code = 1;
		    		mbox->wan_data_len  = wan_udp_pkt->wan_udp_data_len = 0;
			memcpy(wan_udp_pkt->wan_udp_data,new_skb->data,new_skb->len);
			wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mbox->wan_data_len  = wan_udp_pkt->wan_udp_data_len = new_skb->len;
			card->u.x.trace_timeout=jiffies;
			wan_skb_queue_purge(&card->u.x.trace_queue);
			if (card->u.x.LAPB_hdlc){
				switch (wan_udp_pkt->wan_udp_command){
					wan_udp_pkt->wan_udp_command=X25_HDLC_READ_CONFIG;
				memcpy(&mbox->wan_command, &wan_udp_pkt->wan_udp_command, sizeof(TX25Cmd));
				if(mbox->wan_data_len){ 
					memcpy(&mbox->wan_data, 
					       (char *)wan_udp_pkt->wan_udp_data, 
					       mbox->wan_data_len);
				err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
			} while (err  && x25_error(card, err, mbox->wan_command, 0) && c_retry--);
			     (mbox->wan_command == 0x06 || 
			      mbox->wan_command == 0x16)  ) ){
				++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_cmnd_OK;
				++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_cmnd_timeout;
			memcpy(&wan_udp_pkt->wan_udp_command, &mbox->wan_command, sizeof(TX25Cmd));
      	         	if(mbox->wan_data_len) {
        	               memcpy(&wan_udp_pkt->wan_udp_data, &mbox->wan_data, mbox->wan_data_len);
	wan_udp_pkt->wan_ip_ttl = card->wandev.ttl;
	len = reply_udp((u8*)&card->u.x.udp_pkt_data, mbox->wan_data_len);
        if(card->u.x.udp_pkt_src == UDP_PKT_FRM_NETWORK) {
		err = x25_send(card, lcn, 0, len, (u8*)&card->u.x.udp_pkt_data);
			++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_send_passed;
			++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_send_failed;
			memcpy(buf, (u8*)&card->u.x.udp_pkt_data, len);
			new_skb->dev = dev;
			if (chan->common.usedby == API)
                        	new_skb->protocol = htons(X25_PROT);
				new_skb->protocol = htons(ETH_P_IP);
			++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_passed_to_stack;
			++chan->pipe_mgmt_stat.UDP_PIPE_mgmt_no_socket;
			card->devname);
	atomic_set(&card->u.x.udp_pkt_len,0);
	wan_udp_pkt_t *wan_udp_pkt = (wan_udp_pkt_t *)skb->data;
	if (skb->len < sizeof(wan_udp_pkt_t)){
        if((wan_udp_pkt->wan_ip_p == UDPMGMT_UDP_PROTOCOL) &&
		(wan_udp_pkt->wan_udp_dport == ntohs(card->wandev.udp_port)) &&
		(wan_udp_pkt->wan_udp_request_reply == UDPMGMT_REQUEST)) {
                        if(!strncmp(wan_udp_pkt->wan_udp_signature,
			if(!strncmp(wan_udp_pkt->wan_udp_signature,
				card->devname);
	wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	wan_udp_pkt->wan_udp_len = temp;
	temp = wan_udp_pkt->wan_udp_sport;
	wan_udp_pkt->wan_udp_sport = 
			wan_udp_pkt->wan_udp_dport; 
	wan_udp_pkt->wan_udp_dport = temp;
		(wan_udp_pkt->wan_udp_data+mbox_len+even_bound)) = temp;	
		(wan_udp_pkt->wan_udp_data+mbox_len+even_bound+2)) = temp;
	wan_udp_pkt->wan_udp_sum = 0;
	wan_udp_pkt->wan_udp_sum = 
	wan_udp_pkt->wan_ip_len = temp;
	ip_temp = wan_udp_pkt->wan_ip_src;
	wan_udp_pkt->wan_ip_src = 
				wan_udp_pkt->wan_ip_dst;
	wan_udp_pkt->wan_ip_dst = ip_temp;
	wan_udp_pkt->wan_ip_sum = 0;
	wan_udp_pkt->wan_ip_sum = 
        if(!atomic_read(&card->u.x.udp_pkt_len) && (skb->len <= sizeof(card->u.x.udp_pkt_data))){
		atomic_set(&card->u.x.udp_pkt_len,skb->len);
                card->u.x.udp_type = udp_type;
                card->u.x.udp_pkt_src = udp_pkt_src;
                card->u.x.udp_lcn = lcn;
		card->u.x.udp_dev = dev;
                memcpy((u8*)&card->u.x.udp_pkt_data, skb->data, skb->len);
                card->u.x.timer_int_enabled |= TMR_INT_ENABLED_UDP_PKT;
							card->devname,lcn);
	memset(&chan->if_send_stat.if_send_entry,0,sizeof(if_send_stat_t));
	memset(&chan->rx_intr_stat.rx_intr_no_socket,0,sizeof(rx_intr_stat_t));
	memset(&chan->pipe_mgmt_stat.UDP_PIPE_mgmt_kmalloc_err,0,sizeof(pipe_mgmt_stat_t));
	memset(&card->statistics.isr_entry,0,sizeof(global_stats_t));
	spin_lock_irqsave(&card->wandev.lock, *smp_flags);
	spin_unlock_irqrestore(&card->wandev.lock, *smp_flags);
	if (test_bit(PERI_CRIT,&card->wandev.critical)){
				card->devname);
	if (card->open_cnt != card->u.x.num_of_ch){
				card->devname);
	if (!WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head))){
				card->devname);
	if (!test_and_set_bit(POLL_CRIT,&card->wandev.critical)){
	card->u.x.x25_timer.expires=jiffies+(HZ>>1);
	add_timer(&card->u.x.x25_timer);
	wan_mbox_t* mbox = &card->wan_mbox;
	mbox->wan_data[0] = 0;
	// ALEX_TODAY if (card->hw.fwid == SFID_X25_508){
	if (card->type == SDLA_S508){
		mbox->wan_data[1] = card->wandev.irq; // ALEX_TODAY card->hw.irq;
		mbox->wan_data[2] = 2;
		mbox->wan_data_len = 3;
	 	mbox->wan_data_len  = 1;
	mbox->wan_command = X25_SET_INTERRUPT_MODE;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	mbox->wan_command = X25_HDLC_LINK_CLOSE;
	mbox->wan_data_len  = 0;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	mbox->wan_data[0] = 0;
	mbox->wan_data[2] = 0;
	mbox->wan_data[1] = 0x01;
	mbox->wan_data_len  = 3;
	mbox->wan_command = X25_SET_GLOBAL_VARS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	if (dev == NULL || dev->priv == NULL)
	chan=dev->priv;
	chan->chan_clear_time = tv.tv_sec;
	chan->chan_clear_cause = mb->wan_x25_cause;
	chan->chan_clear_diagn = mb->wan_x25_diagn;
	if (mb->wan_data_len){
		parse_call_info(mb->wan_data, &info);
		memcpy(chan->cleared_called_addr, info.src, MAX_X25_ADDR_SIZE);
		memcpy(chan->cleared_calling_addr, info.dest, MAX_X25_ADDR_SIZE);
		memcpy(chan->cleared_facil, info.facil, MAX_X25_FACL_SIZE);
#define PROC_CFG_FRM	"%-15s| %-12s| %-5u| %-9s| %-13s| %-13s|\n"
#define PROC_STAT_FRM	"%-15s| %-12s| %-5u| %-14s|\n"
	sdla_t*		card = chan->card;
		return m->count;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		PROC_CFG_FRM, chan->name, card->devname, chan->ch_idx,
		chan->x25_src_addr, chan->accept_dest_addr, chan->accept_usr_data);
	return m->count;
	sdla_t*		card = chan->card;
		return m->count;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		PROC_STAT_FRM, chan->name, card->devname, 
		chan->ch_idx, STATE_DECODE(chan->common.state));
	return m->count;
#define PROC_DEV_FR_SS_FRM	"%-20s| %-12s|%-20s| %-12s|\n"
#define PROC_DEV_FR_SD_FRM	"%-20s| %-12s|%-20s| %-12d|\n"
#define PROC_DEV_FR_DD_FRM	"%-20s| %-12d|%-20s| %-12d|\n"
#define PROC_DEV_FR_XD_FRM	"%-20s| 0x%-10X|%-20s| %-12d|\n"
	card = (sdla_t*)wandev->priv;
			wandev->name, buffer);
	if (dev == NULL || dev->priv == NULL)
		return -EFAULT;
	chan = (x25_channel_t*)dev->priv;
	if (card->wandev.update) {
		rslt = card->wandev.update(&card->wandev);
			return (rslt) ? (-EBUSY) : (-EINVAL);
	switch(snmp->snmp_magic){
		snmp->snmp_val = 
			(card->wandev.station == WANOPT_DTE) ? SNMP_X25_DTE:
			(card->wandev.station == WANOPT_DCE) ? SNMP_X25_DCE:SNMP_X25_DXE;
	        snmp->snmp_val = card->u.x.num_of_ch;
        	snmp->snmp_val = SNMP_X25_MODULO8;
		snmp->snmp_val = card->u.x.x25_adm_conf.t10_t20;
		snmp->snmp_val = card->u.x.x25_adm_conf.t11_t21;
		snmp->snmp_val = card->u.x.x25_adm_conf.t12_t22;
		snmp->snmp_val = card->u.x.x25_adm_conf.t13_t23;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = card->u.x.x25_adm_conf.t16_t26;
		snmp->snmp_val = 0;
		snmp->snmp_val = card->u.x.x25_adm_conf.t28;
		snmp->snmp_val = 0;
		snmp->snmp_val = card->u.x.x25_adm_conf.r10_r20;
		snmp->snmp_val = card->u.x.x25_adm_conf.r12_r22;
		snmp->snmp_val = card->u.x.x25_adm_conf.r13_r23;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = card->u.x.x25_adm_conf.hi_pvc;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = (card->wandev.station == WANOPT_DTE) ? SNMP_X25_DTE:
		 	   (card->wandev.station == WANOPT_DCE) ? SNMP_X25_DCE:SNMP_X25_DXE;
		snmp->snmp_val = card->u.x.num_of_ch;
		snmp->snmp_val = SNMP_X25_MODULO8;
		snmp->snmp_val = card->u.x.x25_conf.t10_t20;
		snmp->snmp_val = card->u.x.x25_conf.t11_t21;
		snmp->snmp_val = card->u.x.x25_conf.t12_t22;
		snmp->snmp_val = card->u.x.x25_conf.t13_t23;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = card->u.x.x25_conf.t16_t26;
		snmp->snmp_val = 0;
                snmp->snmp_val = card->u.x.x25_conf.t28;
                snmp->snmp_val = 0;
                snmp->snmp_val = card->u.x.x25_conf.r10_r20;
                snmp->snmp_val = card->u.x.x25_conf.r12_r22;
                snmp->snmp_val = card->u.x.x25_conf.r13_r23;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = card->u.x.x25_conf.hi_pvc;
                snmp->snmp_val = 0;
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
        	snmp->snmp_val = X25Stats.rxCallRequest;
                snmp->snmp_val = X25Stats.txClearRqst;
                snmp->snmp_val = (card->wandev.station == WANOPT_DTE) ? 
                snmp->snmp_val = (card->wandev.station == WANOPT_DTE) ? 
                snmp->snmp_val = (card->wandev.station == WANOPT_DTE) ? 
                snmp->snmp_val = X25Stats.rxRestartRqst;
                snmp->snmp_val = X25Stats.rxData;
                snmp->snmp_val = X25Stats.rxClearRqst+X25Stats.rxResetRqst+
                snmp->snmp_val = X25Stats.rxInterrupt;
                snmp->snmp_val = X25Stats.txCallRequest;
                snmp->snmp_val = X25Stats.rxClearRqst;
                snmp->snmp_val = X25Stats.txInterrupt;
                snmp->snmp_val = X25Stats.txData;
                snmp->snmp_val = X25Stats.txCallRequest-X25Stats.rxClearRqst;
                snmp->snmp_val = X25Stats.rxCallRequest-X25Stats.txClearRqst;
                snmp->snmp_val = X25Stats.txCallRequest-X25Stats.rxClearRqst;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
		snmp->snmp_val = card->u.x.x25_conf.lo_svc;
                snmp->snmp_val = card->u.x.x25_conf.hi_svc;
                snmp->snmp_val = card->u.x.x25_conf.lo_svc;
                snmp->snmp_val = card->u.x.x25_conf.hi_svc;
                snmp->snmp_val = card->u.x.x25_conf.lo_svc;
                snmp->snmp_val = card->u.x.x25_conf.hi_svc;
               	snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = chan->chan_establ_time;
                snmp->snmp_val = chan->chan_direct;
                snmp->snmp_val = chan->ifstats.rx_bytes;
                snmp->snmp_val = chan->ifstats.rx_packets;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = X25Stats.rxInterrupt;
                snmp->snmp_val = chan->ifstats.tx_bytes;
                snmp->snmp_val = chan->ifstats.tx_packets;
                snmp->snmp_val = X25Stats.txInterrupt;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                strcpy((void*)snmp->snmp_data,
		 	(chan->chan_direct == SNMP_X25_INCOMING) ? chan->accept_src_addr : "N/A");
                strcpy((void*)snmp->snmp_data,
		        (chan->chan_direct == SNMP_X25_INCOMING) ? chan->accept_dest_addr : "N/A");
                snmp->snmp_val = 0;
                strcpy((void*)snmp->snmp_data, "N/A");
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
        	snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = chan->chan_establ_time;
                snmp->snmp_val = chan->chan_clear_time;
                snmp->snmp_val = chan->ch_idx;
                snmp->snmp_val = chan->chan_clear_cause;
                snmp->snmp_val = chan->chan_clear_diagn;
                snmp->snmp_val = chan->ifstats.rx_packets;
                snmp->snmp_val = chan->ifstats.tx_packets;
                strcpy((void*)snmp->snmp_data, 
		 	(chan->cleared_called_addr[0] != '\0') ? 
		 			chan->cleared_called_addr : "N/A");
                strcpy((void*)snmp->snmp_data,
		 	(chan->cleared_calling_addr[0] != '\0') ? 
		 			chan->cleared_calling_addr : "N/A");
                strcpy((void*)snmp->snmp_data,
		 	(chan->cleared_facil[0] != '\0') ? chan->cleared_facil : "N/A");
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;
                snmp->snmp_val = 0;	// default size
                snmp->snmp_val = 0;	// default size
                snmp->snmp_val = (card->u.x.x25_conf.pkt_window != X25_PACKET_WINDOW) ? 
				card->u.x.x25_conf.pkt_window : 0;
                snmp->snmp_val = (card->u.x.x25_conf.pkt_window != X25_PACKET_WINDOW) ? 
				card->u.x.x25_conf.pkt_window : 0;
                snmp->snmp_val = SNMP_X25_ARC_DEFAULT;
                snmp->snmp_val = SNMP_X25_PRC_DEFAULT;
                snmp->snmp_val = SNMP_X25_FS_DEFAULT;
                snmp->snmp_val = SNMP_X25_THRUCLASS_TCDEF;
                snmp->snmp_val = SNMP_X25_THRUCLASS_TCDEF;
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                snmp->snmp_val = SNMP_X25_CHARGINGINFO_DEF;
                strcpy((void*)snmp->snmp_data, "N/A");
                snmp->snmp_val = 0;
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                snmp->snmp_val = SNMP_X25_THRUCLASS_TCDEF;
                snmp->snmp_val = SNMP_X25_THRUCLASS_TCDEF;
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
                snmp->snmp_val = SNMP_X25_EXPTDATA_DEFULT;
                strcpy((void*)snmp->snmp_data, chan->accept_usr_data);
                strcpy((void*)snmp->snmp_data, "N/A");
                strcpy((void*)snmp->snmp_data, "N/A");
            	return -EAFNOSUPPORT;
#define PROC_IF_X25_S_FRM	"%-40s %-14s\n"
#define PROC_IF_X25_D_FRM	"%-40s %-14d\n"
#define PROC_IF_X25_L_FRM	"%-40s %-14ld\n"
	if (dev == NULL || dev->priv == NULL)
	chan = (x25_channel_t*)dev->priv;
	if (chan->card == NULL)
	card = chan->card;
			chan->name, buffer);
		return -EINVAL;
	return -EINVAL;
	x25_channel_t *chan = dev->priv;
	clear_bit(0,(void *)&chan->common.rw_bind);
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (!dev || !wan_netif_priv(dev) || !(dev->flags&IFF_UP)){
		if (chan->common.usedby == API && chan->common.svc){
			if (!test_and_set_bit(0,(void *)&chan->common.rw_bind)){
				if (chan->common.state != WANSOCK_DISCONNECTED){
					clear_bit(0,(void *)&chan->common.rw_bind);
	WAN_ASSERT2((sk_id==NULL),-ENODEV);
		return -ENODEV;
	chan = dev->priv;
	chan->common.sk=sk_id;
	set_bit(LCN_SK_ID,&chan->common.used);
	return dev->ifindex;
	memset(&chan->x25_api_cmd_hdr,0,sizeof(x25api_hdr_t));
	memset(chan->call_string,0,sizeof(chan->call_string));
		return -EINVAL;
	x25api = (x25api_t*)ifr->ifr_data;
		DEBUG_EVENT("%s: No ifr->ifr_data ptr!\n",__FUNCTION__);
		return -EINVAL;
	err = copy_from_user(&chan->x25_api_cmd_hdr,x25api,sizeof(x25api_hdr_t));
	if (x25api->hdr.length > 0 && x25api->hdr.length <= X25_CALL_STR_SZ){
		err = copy_from_user(chan->call_string,x25api->data,x25api->hdr.length);
				chan->common.dev->name,
				x25api->hdr.length ? "Call string too big" : 
		err = -EINVAL;
		return -EINVAL;
	x25api = (x25api_t*)ifr->ifr_data;
		DEBUG_EVENT("%s: No ifr->ifr_data ptr!\n",__FUNCTION__);
		return -EINVAL;
	err=copy_to_user(x25api,&chan->x25_api_event,sizeof(x25api_t));
	memset(&chan->x25_api_cmd_hdr,0,sizeof(x25api_hdr_t));
	if (ifr && ifr->ifr_data){
		x25api = (x25api_t*)ifr->ifr_data;
		err=copy_from_user(&chan->x25_api_cmd_hdr,
	memset(chan->call_string,0,sizeof(chan->call_string));
	if (ifr && ifr->ifr_data){
		x25api = (x25api_t*)ifr->ifr_data;
		if (x25api->hdr.length > 0 && x25api->hdr.length <= X25_CALL_STR_SZ){
			err = copy_from_user(chan->call_string,
					     x25api->data,
					     x25api->hdr.length);
	if (chan->common.usedby == API && chan->common.sk){
		if (chan->common.state != WAN_CONNECTED && test_bit(0,&chan->api_state)){
			clear_bit(0,&chan->api_state);
			protocol_disconnected (chan->common.sk);
			wan_unbind_api_from_svc(chan,chan->common.sk);
		if (chan->common.state == WAN_CONNECTED && !test_bit(0,&chan->api_state)){
			set_bit(0,&chan->api_state);
			err=protocol_connected (chan->common.dev,chan->common.sk);
			if (err == -EINVAL){
				int lcn=chan->common.lcn;
						chan->common.dev->name);
				wan_unbind_api_from_svc(chan,chan->common.sk);
		if (chan->common.state == WAN_DISCONNECTED){
			err = protocol_disconnected (chan->common.sk);
			wan_unbind_api_from_svc(chan,chan->common.sk);
	if (chan->common.state != WAN_CONNECTED){
		clear_bit(0,&chan->api_state);
	if (card->wandev.state != WAN_CONNECTED){
		return -ENOTCONN;
	if (atomic_read(&chan->common.command)){
				card->devname,
				atomic_read(&chan->common.command));
		return -EBUSY;
	chan->cmd_timeout=jiffies;
	while((jiffies-chan->cmd_timeout) < (card->u.x.x25_conf.cmd_retry_timeout*HZ)){
		if (!atomic_read(&chan->common.command)){
			return atomic_read(&chan->cmd_rc);	
			card->devname,atomic_read(&chan->common.command));
	atomic_set(&chan->common.command,0);
	return -EFAULT;
	netdevice_t *dev=chan->common.dev;
		del_timer(&card->u.x.x25_timer);
		card->u.x.x25_timer.expires=jiffies+HZ;
		add_timer(&card->u.x.x25_timer);
		err=-ENETDOWN;
./sdla_x25.c
* Copyright:	(c) 2003-2005 Sangoma Technologies Inc.
		card->devname,chan->if_name,req_fifo_size,chan->num_of_time_slots);
	fifo_size=(unsigned char)aft_map_fifo_baddr_and_size(card,req_fifo_size,&chan->fifo_base_addr);
	if (fifo_size == 0 || chan->fifo_base_addr == 31){
				card->devname,chan->if_name,fifo_size,chan->fifo_base_addr);
                return -EINVAL;
                card->devname,chan->if_name,req_fifo_size,chan->num_of_time_slots,fifo_size);
			chan->fifo_size_code=fifo_code_vector[i];
			card->devname,chan->if_name,req_fifo_size,fifo_size);
                card->devname,chan->if_name,fifo_size,
		chan->num_of_time_slots,chan->fifo_size_code,
		chan->fifo_base_addr);
	chan->fifo_size = fifo_size;
                        card->devname,reg,card->u.aft.fifo_addr_map);
		if (card->u.aft.fifo_addr_map & (reg<<i)){
		card->u.aft.fifo_addr_map |= reg<<i;
	                card->devname,card->u.aft.fifo_addr_map,i);
	for (i=0;i<chan->fifo_size;i++){
		card->devname,reg<<chan->fifo_base_addr, card->u.aft.fifo_addr_map);
	card->u.aft.fifo_addr_map &= ~(reg<<chan->fifo_base_addr);
                card->devname, card->u.aft.fifo_addr_map);
	chan->fifo_size=0;
	chan->fifo_base_addr=0;
	signed char logic_ch=-1;
	DEBUG_TEST("-- Request_Xilinx_logic_channel_num:--\n");
                card->u.aft.num_of_time_slots,
                card->u.aft.logic_ch_map);
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (wan_test_bit(i,&chan->time_slot_map)){
			if (chan->first_time_slot == -1){
						card->devname,i);
				chan->first_time_slot=i;
			chan->last_time_slot=i;
					card->devname, chan->if_name,i+1);
			if (wan_test_bit(i,&card->u.aft.time_slot_map)){
						card->devname);
						card->devname,chan->if_name,(i+1));
				return -EEXIST;
				card->devname);
		chan->first_time_slot = -1;
		return -1;
		return -1;
	logic_ch = (signed char)chan->first_time_slot;
	if (wan_test_and_set_bit(logic_ch,&card->u.aft.logic_ch_map)){
		return -1;
	if (logic_ch == -1){
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
	if (card->u.aft.dev_to_ch_map[(unsigned char)logic_ch]){
				card->devname,logic_ch);
		return -1;
	card->u.aft.dev_to_ch_map[(unsigned char)logic_ch]=(void*)chan;
	if (logic_ch >= card->u.aft.top_logic_ch){
		card->u.aft.top_logic_ch=logic_ch;
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
				card->devname, card->wandev.comm_port+1);
		card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
				err=-EINVAL;
				err=-EINVAL;
			card->devname,i);
	card->hw_iface.bus_read_4(card->hw, 0x1090, &reg_1090);	
	switch (WAN_FE_NETWORK_SYNC(&card->fe)) {
					card->devname);
						card->devname);
					card->devname);
					card->devname);
/* daughter card is required for line clock output - not supported yet*/
					card->devname);
					card->devname);
					card->devname);
	card->hw_iface.bus_write_4(card->hw, 0x1090, reg_1090);	
			wan_set_bit(0,&card->fe_ignore_intr);
	card->hw_iface.getcfg(card->hw, SDLA_HWCPU_USEDCNT, &used_cnt);
		card->hw_iface.bus_read_4(card->hw, AFT_PORT_REG(card,AFT_CHIP_CFG_REG), &reg);
		DEBUG_CFG("--- AFT Chip Reset. -- \n");
		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),reg);
			card->fe_no_intr=1;	
			DEBUG_CFG("--- Chip enable/config. -- \n");
			if (WAN_FE_NETWORK_SYNC(&card->fe)){	/*card->fe.fe_cfg.cfg.remora.network_sync*/
						card->devname);
		DEBUG_CFG("--- Chip enable/config. -- \n");
		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),reg);
		if (WAN_FE_NETWORK_SYNC(&card->fe)){
			DEBUG_EVENT("%s: Ignoring Network Sync\n", card->devname);
							card->devname);
			return -EINVAL;
	DEBUG_EVENT("%s: Global Front End Configuration!\n",card->devname);
	err = -EINVAL;
	if (card->wandev.fe_iface.config){
		err = card->wandev.fe_iface.config(&card->fe);
					card->devname);
		return -EINVAL;
	if (card->wandev.fe_iface.post_init){
		err=card->wandev.fe_iface.post_init(&card->fe);
	DEBUG_EVENT("%s: Remora config done!\n",card->devname);
	card->hw_iface.getcfg(card->hw, SDLA_HWCPU_USEDCNT, &used_cnt);
	if (card->wandev.fe_iface.unconfig){
		card->wandev.fe_iface.unconfig(&card->fe);
		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),reg);
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
				card->devname, card->wandev.comm_port+1);
		return -EBUSY;
	card->hw_iface.bus_read_4(card->hw,
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),reg);
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),reg);
	if (card->adptr_type == AFT_ADPTR_FLEXBRI) {
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),&reg);
					card->devname,reg);
                                        card->devname,reg);
	if (card->adptr_subtype == AFT_SUBTYPE_SHARK){
		card->hw_iface.getcfg(card->hw, SDLA_HWEC_NO, &max_ec_chans);
		card->hw_iface.getcfg(card->hw, SDLA_CHANS_NO, &max_chans_no);
		card->hw_iface.getcfg(card->hw, SDLA_CHANS_MAP, &fe_chans_map);
		card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG), &cfg_reg);
					card->devname);
				card->devname,
			return -EINVAL;
			card->wandev.ec_dev = wanpipe_ec_register(
							(void*)&conf->oct_conf);
				card->wandev.hwec_reset = aft_a600_hwec_reset;
				card->wandev.hwec_reset = aft_analog_hwec_reset;
			card->wandev.hwec_enable = aft_analog_hwec_enable;
						card->devname);
						card->devname);
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), reg);
	card->u.aft.lcfg_reg=reg;
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),reg);
		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_ANALOG_DATA_MUX_CTRL_REG),reg);
	card->hw_iface.getcfg(card->hw, SDLA_HWCPU_USEDCNT, &used_cnt);	
	if (card->adptr_subtype == AFT_SUBTYPE_SHARK){
		if (card->wandev.ec_dev){
			wanpipe_ec_unregister(card->wandev.ec_dev, card);
						card->devname);
		card->wandev.hwec_enable = NULL;
		card->wandev.ec_dev = NULL;
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),reg);
	ctrl_ram_reg+=(chan->first_time_slot*4);
		wan_set_bit(chan->first_time_slot,&card->u.aft.time_slot_map);
		card->hw_iface.bus_read_4(card->hw, ctrl_ram_reg, &reg);
		aft_ctrlram_set_logic_ch(&reg,chan->logic_ch_num);
		aft_ctrlram_set_fifo_size(&reg,chan->fifo_size_code);
		aft_ctrlram_set_fifo_base(&reg,chan->fifo_base_addr);
		if (chan->hdlc_eng){
		if (chan->cfg.data_mux){
		if (0){ /* FIXME card->fe.fe_cfg.cfg.te1cfg.fcs == 32){ */
				card->devname, chan->if_name, chan->logic_ch_num, chan->first_time_slot,
		card->hw_iface.bus_write_4(card->hw, ctrl_ram_reg, reg);
	chan->logic_ch_num=aft_request_logical_channel_num(card, chan);
	if (chan->logic_ch_num == -1){
		return -EBUSY;
	dma_ram_reg+=(chan->logic_ch_num*4);
	card->hw_iface.bus_write_4(card->hw, dma_ram_reg, reg);
	card->hw_iface.bus_read_4(card->hw, dma_ram_reg, &reg);
	aft_dmachain_set_fifo_size(&reg, chan->fifo_size_code);
	aft_dmachain_set_fifo_base(&reg, chan->fifo_base_addr);
	if (chan->channelized_cfg && !chan->hdlc_eng){
		aft_dmachain_enable_tdmv_and_mtu_size(&reg,chan->mru);
	card->hw_iface.bus_write_4(card->hw, dma_ram_reg, reg);
	if (chan->channelized_cfg && !chan->hdlc_eng){
		card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),&reg);
		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),reg);
		card->u.aft.lcfg_reg=reg;
		wan_set_bit(chan->logic_ch_num,&card->u.aft.tdm_logic_ch_map);
	if (card->wandev.fe_iface.if_config){
		card->wandev.fe_iface.if_config(
					&card->fe,
					chan->time_slot_map,
					chan->common.usedby);
	if (card->wandev.fe_iface.if_unconfig){
		card->wandev.fe_iface.if_unconfig(
					&card->fe,
					chan->time_slot_map,
					chan->common.usedby);
	if (chan->logic_ch_num != -1){
		dma_ram_reg+=(chan->logic_ch_num*4);
		card->hw_iface.bus_read_4(card->hw, dma_ram_reg, &reg);
		card->hw_iface.bus_write_4(card->hw, dma_ram_reg, reg);
		aft_free_logical_channel_num(card,chan->logic_ch_num);
		for (i=0;i<card->u.aft.num_of_time_slots;i++){
			if (wan_test_bit(i,&chan->time_slot_map)){
				wan_clear_bit(i,&card->u.aft.time_slot_map);
		if (chan->channelized_cfg && !chan->hdlc_eng){
			card->hw_iface.bus_read_4(card->hw,
			card->hw_iface.bus_write_4(card->hw,
			wan_clear_bit(chan->logic_ch_num,&card->u.aft.tdm_logic_ch_map);
    card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG), &cfg_reg);
	if (card->hw_iface.fe_test_and_set_bit(card->hw,0)){
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			card->devname, __FUNCTION__,__LINE__);
        card->hw_iface.bus_read_2(card->hw,
        card->hw_iface.bus_write_2(card->hw,
        card->hw_iface.bus_read_1(card->hw,AFT_MCPU_INTERFACE, &tmp);
        card->hw_iface.bus_write_2(card->hw,
	card->hw_iface.fe_clear_bit(card->hw,0);
	if (card->hw_iface.fe_test_and_set_bit(card->hw,0)){
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			card->devname, __FUNCTION__,__LINE__);
        card->hw_iface.bus_read_2(card->hw,
        card->hw_iface.bus_write_2(card->hw,
	card->hw_iface.bus_write_1(card->hw,
        card->hw_iface.bus_write_2(card->hw,
	card->hw_iface.fe_clear_bit(card->hw,0);
	int		err = -EINVAL;
	card->hw_iface.hw_lock(card->hw,&smp_flags);
	wan_spin_lock_irq(&card->wandev.lock,&flags);
	card->hw_iface.bus_read_4(card->hw, 
			    card->devname);
		card->hw_iface.bus_write_4(card->hw,
			    card->devname);
		card->hw_iface.bus_write_4(card->hw, 
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
	int		err = -EINVAL;
	card->hw_iface.hw_lock(card->hw,&smp_flags);
	wan_spin_lock_irq(&card->wandev.lock,&flags);
					card->devname);
					card->devname);
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
	analog_chan = (fe_chan-1); /* {0,1}, {2,3}, {4,5}... */
	card->hw_iface.bus_read_4(
					card->hw,
	DEBUG_HWEC("[HWEC A700]: %s: writing: off:0x%X val:0x%08X!\n",card->devname,
	card->hw_iface.bus_write_4(
				card->hw,
** Return:	0   - success
**		1   - channel out of channel map
**		< 0 - failed
	int		hw_chan = fe_chan-1;
	if (card->adptr_type == AFT_ADPTR_FLEXBRI) {
	card->hw_iface.bus_read_4(
			card->hw,
			card->devname,
	card->hw_iface.bus_write_4(
			card->hw,
./aft_analog.c
* Copyright:	(c) 1995-2003 Sangoma Technologies Inc.
* Dec 03, 2001  Gideon Hack	o Updated for S514-5 56K adatper
*				   disabled and dev->tbusy was set to 1.
*                                  the if clause for it(0,dev->tbusy) 
*				   set_bit(0,dev->tbusy).  Since an interrupt 
* 				   makes dev->tbusy = 0, this effect was undone 
*                                  by making dev->tbusy = 1 in the if clause.
*				   are disabled then do not make dev->tbusy = 1
#define CVHexToAscii(b) (((unsigned char)(b) > (unsigned char)9) ? ((unsigned char)'A' + ((unsigned char)(b) - (unsigned char)10)) : ((unsigned char)'0' + (unsigned char)(b)))
 * interface to keep the rest of channel-specific data.
	sdla_t *card;			/* -> owner */
 * wpf_init - Frame relay protocol initialization routine.
 *  o initialize protocol-specific fields of the adapter data space.
	if (conf->config_id != WANCONFIG_FR) {
			card->devname, conf->config_id);
		return -EINVAL;
	/* Initialize protocol-specific fields of adapter data space */
	card->mbox_off  = FR_MB_VECTOR + FR508_MBOX_OFFS; 
	card->flags_off = FR_MB_VECTOR + FR508_FLAG_OFFS;
        card->isr = &fr_isr;
    	card->intr_type_off = 
			card->flags_off +
	card->intr_perm_off = 
			card->flags_off +
	card->wandev.ignore_front_end_status = conf->ignore_front_end_status;
	//ALEX_TODAY err=check_conf_hw_mismatch(card,conf->te_cfg.media);
	err = (card->hw_iface.check_mismatch) ? 
			card->hw_iface.check_mismatch(card->hw,conf->fe_cfg.media) : -EINVAL;
	if (IS_TE1_MEDIA(&conf->fe_cfg)) {
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_te_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg = card->hw_iface.fe_write;
		card->fe.read_fe_reg	 = card->hw_iface.fe_read;
		card->wandev.fe_enable_timer = fr_enable_timer;
		card->wandev.te_link_state = fr_handle_front_end_state;
		conf->electrical_interface = 
			(IS_T1_FEMEDIA(&card->fe)) ? WANOPT_V35 : WANOPT_RS232;
		conf->clocking = WANOPT_EXTERNAL;
        }else if (IS_56K_MEDIA(&conf->fe_cfg)) {
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_56k_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg = card->hw_iface.fe_write;
		card->fe.read_fe_reg	 = card->hw_iface.fe_read;
		card->fe.fe_status = FE_CONNECTED;
		 * this for S508 and S514 1-2-3 cards */
		card->wandev.ignore_front_end_status = WANOPT_YES;
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
		return -EIO;
		card->devname, u.str);
		return -EIO;
	conf->mtu += FR_HEADER_LEN;
	conf->mtu = (conf->mtu >= MIN_LGTH_FR_DATA_CFG) ?
			wp_min(conf->mtu, FR_MAX_NO_DATA_BYTES_IN_FRAME) :
	conf->bps = wp_min(conf->bps, 2048000);
	memset(card->u.f.dlci_to_dev_map, 0, sizeof(card->u.f.dlci_to_dev_map));
	u.cfg.mtu	= conf->mtu;
	u.cfg.kbps	= conf->bps / 1000;
	printk(KERN_INFO "%s: Global CIR enabled by Default\n", card->devname);
	switch (conf->u.fr.signalling) {
					card->wandev.name);
			return -EINVAL;
	card->wandev.signalling = conf->u.fr.signalling;
	if (conf->u.fr.station == WANOPT_CPE) {
		if (conf->u.fr.signalling == WANOPT_NO){
				"%s: ERROR - For NO signalling, station must be set to Node!",
				 	 card->devname);
			return -EINVAL;
		card->u.f.dlci_num  = 0;
		card->u.f.dlci_num  = wp_min(wp_max(conf->u.fr.dlci_num, 1), 100);
		for ( i = 0; i < card->u.f.dlci_num; i++) {
			card->u.f.node_dlci[i] = (unsigned short) 
				conf->u.fr.dlci[i] ? conf->u.fr.dlci[i] : 16;
	if (conf->clocking == WANOPT_INTERNAL)
	if (conf->electrical_interface == WANOPT_RS232)
	if (conf->u.fr.t391)
		u.cfg.t391 = wp_min(conf->u.fr.t391, 30);
	card->u.f.t391 = u.cfg.t391;
	if (conf->u.fr.t392)
		u.cfg.t392 = wp_min(conf->u.fr.t392, 30);
	card->u.f.t392 = u.cfg.t392;
	if (conf->u.fr.n391)
		u.cfg.n391 = wp_min(conf->u.fr.n391, 255);
	card->u.f.n391 = u.cfg.n391;
	if (conf->u.fr.n392)
		u.cfg.n392 = wp_min(conf->u.fr.n392, 10);
	card->u.f.n392 = u.cfg.n392;
	if (conf->u.fr.n393)
		u.cfg.n393 = wp_min(conf->u.fr.n393, 10);
	card->u.f.n393 = u.cfg.n393;
		return -EIO;
	card->hw_iface.peek(card->hw, buf_info_off, (unsigned char*)&buf_info, sizeof(buf_info));
        card->rxmb_off = buf_info.rse_next;
        card->u.f.rxmb_base_off = buf_info.rse_base; 
	card->u.f.rxmb_last_off =
			(buf_info.rse_num - 1) * sizeof(fr_rx_buf_ctl_t);
	card->u.f.rx_base_off = buf_info.buf_base;
	card->u.f.rx_top_off  = buf_info.buf_top;
	atomic_set(&card->u.f.tx_interrupts_pending,0);
	card->wandev.mtu	= conf->mtu;
	card->wandev.bps	= conf->bps;
	card->wandev.electrical_interface	= conf->electrical_interface;
	card->wandev.clocking	= conf->clocking;
	card->wandev.station	= conf->u.fr.station;
	card->poll		= NULL; 
	card->exec		= NULL;
	card->wandev.update	= &update;
	card->wandev.new_if	= &new_if;
	card->wandev.del_if	= &del_if;
	card->wandev.get_config_info 	= &fr_get_config_info;
	card->wandev.get_status_info 	= &fr_get_status_info;
	card->wandev.set_dev_config    	= &fr_set_dev_config;
	card->wandev.set_if_info     	= &fr_set_if_info;
	card->wan_debugging	= &fr_debugging;
	card->get_crc_frames	= &fr_crc_frames;
	card->get_abort_frames	= &fr_abort_frames;
	card->get_tx_underun_frames	= &fr_tx_underun_frames;
    	card->wandev.state	= WAN_DISCONNECTED;
	card->wandev.ttl	= conf->ttl;
        card->wandev.udp_port 	= conf->udp_port;       
	card->disable_comm	= &disable_comm;	
	card->u.f.arp_dev 	= NULL;
	card->get_snmp_data	= &fr_snmp_data;
        card->TracingEnabled          = 0;
	card->timer_int_enabled = 0;
	card->intr_mode = INTR_TEST_MODE;
			card->devname,err,card->timer_int_enabled); 
	if (err || (card->timer_int_enabled < MAX_INTR_TEST_COUNTER)) {
			card->devname, card->timer_int_enabled);
				card->devname);
		return -EIO;
			card->devname, card->timer_int_enabled);
	card->u.f.issue_fs_on_startup = conf->u.fr.issue_fs_on_startup;
	if (card->u.f.issue_fs_on_startup){
				card->devname);
				card->devname);
		int	err = -EINVAL;
			card->devname, 
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
					card->devname,
			return -EIO;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
		int	err = -EINVAL;
			card->devname);
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
				card->devname);
			return -EIO;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
		card->wandev.mtu, 0)) {
		return -EIO;
	/* Mask - Disable all interrupts */
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, 
		return -EIO;
	spin_lock_init(&card->u.f.if_send_lock);
		card->wandev.fe_iface.read_alarm(&card->fe, 1);
	/* Unmask - Enable all interrupts */
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, 
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	atomic_set(&card->wandev.if_cnt,0);
	atomic_set(&card->wandev.if_up_cnt,0);
 * update - Update wanpipe device status & statistics
	if ((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if (wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	card = wandev->priv;
	if (test_and_set_bit(0,&card->update_comms_stats)){
		return -EBUSY;	
	spin_lock_irqsave(&card->wandev.lock, smp_flags);
	fr_get_stats(card, card->u.f.update_dlci);
	if (card->u.f.update_dlci == NULL){
			card->wandev.fe_iface.read_alarm(&card->fe, 0); 
			card->wandev.fe_iface.read_pmon(&card->fe, 0); 
			card->wandev.fe_iface.read_alarm(&card->fe, 1); 
	card->u.f.update_dlci = NULL;
	card->update_comms_stats = 0;
	spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
 * new_if - Create new logical channel.
 * to dev->priv pointer.  
 * Also the dev->init pointer should also be initialized
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
	if (atomic_read(&wandev->if_cnt) > 0 && card->u.f.auto_dlci_cfg){
			    card->devname,conf->name);
				card->devname,card->devname);
		return -EINVAL;
		WAN_MEM_ASSERT(card->devname);
		return -ENOMEM;
	strcpy(chan->name, conf->name);
	chan->card = card;
	WAN_TASKLET_INIT((&chan->common.bh_task),0,fr_bh,(unsigned long)chan);
	chan->common.state = WAN_CONNECTING;
	if (strcmp(conf->addr,"auto")){
		if (is_digit(conf->addr[0])) {
			dlci = dec_to_uint(conf->addr, 0);
				chan->dlci = dlci;
				chan->common.lcn = dlci;
					wandev->name, dlci, chan->name);
				err = -EINVAL;
				wandev->name, chan->name);
			err = -EINVAL;
		if (card->wandev.station == WANOPT_NODE){
					card->devname);
				card->devname,card->devname);
			err = -EINVAL;
		if (atomic_read(&wandev->if_cnt) != 0){
			    card->devname,chan->name);
				card->devname,card->devname);
			err = -EINVAL;
		card->u.f.auto_dlci_cfg=1;
		chan->dlci=0xFFFF;
	if (find_channel (card, chan->dlci) != NULL){
				card->devname, chan->name, dlci);
		err = -EEXIST;
	if (card->u.f.auto_dlci_cfg){
			card->devname,conf->name);
			card->devname,conf->name,dlci);
	if ((chan->true_if_encoding = conf->true_if_encoding) == WANOPT_YES){
			card->devname,chan->name);
        if (strcmp(conf->usedby, "WANPIPE")  == 0  || 
	    strcmp(conf->usedby, "BRIDGE")   == 0  ||
	    strcmp(conf->usedby, "BRIDGE_N") == 0){
		if(strcmp(conf->usedby, "WANPIPE") == 0){
			chan->common.usedby = WANPIPE;
					card->devname,chan->name);
		}else if(strcmp(conf->usedby, "BRIDGE") == 0){
			chan->common.usedby = BRIDGE;
					card->devname,chan->name);
		}else if(strcmp(conf->usedby, "BRIDGE_N") == 0 ){
			chan->common.usedby = BRIDGE_NODE;
					card->devname,chan->name);
			if (conf->if_down == WANOPT_YES){ 
				set_bit(DYN_OPT_ON,&chan->interface_down);
					card->devname,chan->name);
        } else if(strcmp(conf->usedby, "API") == 0){
                chan->common.usedby = API;
			wandev->name,chan->name);
		wan_reg_api(chan, dev, card->devname);
	if (conf->cir) {
		chan->cir = wp_max( 1, wp_min( conf->cir, 512 ) );
		chan->cir_status = CIR_ENABLED; 
		chan->bc = chan->cir;
		if (conf->be){
			chan->be = wp_max( 0, wp_min( conf->be, 511) ); 
			conf->be = 0;
				wandev->name,chan->name);
				wandev->name,chan->cir,chan->bc,chan->be);
		chan->cir_status = CIR_DISABLED;
				wandev->name,chan->name);
	chan->mc = conf->mc;
	chan->inarp_rx = conf->inarp_rx;
	if (conf->inarp == WANOPT_YES){
		printk(KERN_INFO "%s:%s: Inv. ARP Support Enabled\n",card->devname,chan->name);
		chan->inarp = conf->inarp ? INARP_REQUEST : INARP_NONE;
		chan->inarp_interval = conf->inarp_interval ? conf->inarp_interval : 10;
		chan->inarp_rx = WANOPT_YES;
		printk(KERN_INFO "%s:%s: Inv. ARP Support Disabled\n",card->devname,chan->name);
		chan->inarp = INARP_NONE;
		chan->inarp_interval = 10;
	if (chan->inarp_rx == WANOPT_YES){
		printk(KERN_INFO "%s:%s: Inv. ARP Reception Enabled!\n",card->devname,chan->name);
		printk(KERN_INFO "%s:%s: Inv. ARP Reception Disabled!\n",card->devname,chan->name);
	chan->dlci_configured = DLCI_NOT_CONFIGURED;	
	if (conf->enable_IPX == WANOPT_YES){
		chan->enable_IPX = WANOPT_YES;
		printk(KERN_INFO "%s:%s: IPX Support Enabled!\n",card->devname,chan->name);
		printk(KERN_INFO "%s:%s: IPX Support Disabled!\n",card->devname,chan->name);
		chan->enable_IPX = WANOPT_NO;
	if (conf->network_number && chan->enable_IPX == WANOPT_YES){
				card->devname,chan->name,conf->network_number);
		chan->network_number = conf->network_number;
		chan->network_number = 0xDEADBEEF;
	chan->route_flag = NO_ROUTE;
	chan->transmit_length = 0;
	WAN_TASKQ_INIT((&chan->fr_poll_task),0,fr_poll,dev);
	init_timer(&chan->fr_arp_timer);
	chan->fr_arp_timer.data=(unsigned long)dev;
	chan->fr_arp_timer.function = fr_arp;
	if ((chan->gateway = conf->gateway) == WANOPT_YES){
			card->devname,dev->name);
	chan->fr_encap_0 = Q922_UI;
	chan->fr_encap_1 = NLPID_IP;
	err = wanrouter_proc_add_interface(wandev, &chan->dent, chan->name, dev);
			card->devname, chan->name);
	chan->dlci_type = SNMP_FR_STATIC;
	chan->trap_state = SNMP_FR_DISABLED;
	chan->trap_max_rate = 0;
	dev->init = &if_init;
	dev->priv = chan;
	chan->common.dev = dev;
	set_bit(0,&chan->config_dlci);
	atomic_inc(&wandev->if_cnt);
	WAN_TASKLET_KILL(&chan->common.bh_task);
	wan_unreg_api(chan, card->devname);
	dev->priv=NULL;
 * del_if - Delete logical channel.
	fr_channel_t* chan = dev->priv;
	sdla_t *card=wandev->priv;
	wanrouter_proc_delete_interface(wandev, chan->name);
	del_timer(&chan->fr_arp_timer);
	WAN_TASKLET_KILL(&chan->common.bh_task);
	wan_unreg_api(chan, card->devname);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	if (card->u.f.arp_dev == dev){
		card->u.f.arp_dev=NULL;
	if (chan->delay_skb){
		wan_skb_free(chan->delay_skb);
		chan->delay_skb=NULL;	
	if (chan->tx_arp){
		wan_skb_free(chan->tx_arp);
		chan->tx_arp=NULL;
	if (chan->tx_ipx){
		wan_skb_free(chan->tx_ipx);
		chan->tx_ipx=NULL;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);	
	atomic_dec(&wandev->if_cnt);
 * disable_comm - Main shutdown function
			card->devname);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
	fr_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= TX_TIMEOUT;
	if (chan->common.usedby == WANPIPE || chan->common.usedby == API){
		/* Initialize media-specific parameters */
		if (chan->true_if_encoding){
			dev->type 		= ARPHRD_DLCI;  /* This breaks tcpdump */
			dev->type		= ARPHRD_PPP; 	/* ARP h/w type */
		dev->flags		|= IFF_POINTOPOINT;
		dev->flags		|= IFF_NOARP;
		if (chan->mc == WANOPT_YES){
			dev->flags 	|= IFF_MULTICAST;
		dev->mtu		= wandev->mtu - FR_HEADER_LEN;
		   to the driver is (dev->mtu + dev->hard_header_len). So, adjust the
		if(chan->common.usedby == API) {
			dev->mtu += (sizeof(api_tx_hdr_t) - FR_HEADER_LEN);
		dev->hard_header_len	= 0;            /* media header length */
		dev->addr_len		= 2; 		/* hardware address length */
		*(unsigned short*)dev->dev_addr = chan->dlci;
        	dev->tx_queue_len = 100;
		memcpy(dev->dev_addr, "\xFE\xFC\x00\x00\x00\x00", 6);
		*(int *)(dev->dev_addr + 2) += hw_addr;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start); //ALEX_TODAY wandev->maddr;
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end); //ALEX_TODAY wandev->maddr + wandev->msize - 1;
	dev->do_ioctl	= if_do_ioctl;
 * if_open - Open network interface.
	fr_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
		return -EBUSY;
	chan->router_start_time = tv.tv_sec;
	atomic_inc(&card->wandev.if_up_cnt);
	if (test_bit(0,&chan->config_dlci)){
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		clear_bit(0,&chan->config_dlci);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		dev1 = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		if (dev1 == dev && card->wandev.station == WANOPT_CPE){
					card->devname);
	}else if (chan->inarp == INARP_REQUEST){
 * if_close - Close network interface.
	fr_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	if (chan->inarp == INARP_CONFIGURED) {
		chan->inarp = INARP_REQUEST;
	dev->start=0;
	atomic_dec(&card->wandev.if_up_cnt);
    	fr_channel_t* chan = dev->priv;
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	chan->drvstats_if_send.if_send_tbusy++;
	++chan->ifstats.collisions;
			card->devname, dev->name);
	atomic_inc(&card->u.f.tx_interrupts_pending);
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, FR_INTR_TXRDY);
	dev->trans_start = jiffies;
	chan->drvstats_if_send.if_send_tbusy_timeout++;
 * if_send - Send a packet on a network interface.
 *   block a timer-based transmit from overlapping.
 *		non-0	packet may be re-transmitted (tbusy must be set)
    	fr_channel_t* chan = dev->priv;
    	sdla_t* card = chan->card;
	chan->drvstats_if_send.if_send_entry++;
		 * tx-done interrupt.
			card->devname, dev->name);
		chan->drvstats_if_send.if_send_skb_null ++;
	DEBUG_ADD_MEM(skb->truesize);
	if (test_bit(PERI_CRIT, &card->wandev.critical)){
				card->devname);
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	set_bit(SEND_TXIRQ_CRIT, (void*)&card->wandev.critical);
        if(chan->transmit_length || chan->tx_ipx || chan->tx_arp) {
		if (card->wandev.state != WAN_CONNECTED ||
		    chan->common.state != WAN_CONNECTED){
			chan->drvstats_if_send.if_send_dlci_disconnected ++;
        		++chan->ifstats.tx_dropped;
        		++card->wandev.stats.tx_dropped;
			++chan->ifstats.tx_carrier_errors;
        		++card->wandev.stats.tx_carrier_errors;
			DEBUG_SUB_MEM(skb->truesize);
			chan->tick_counter = jiffies;
 		clear_bit(SEND_TXIRQ_CRIT, (void*)&card->wandev.critical);
		wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
       	clear_bit(SEND_TXIRQ_CRIT, (void*)&card->wandev.critical);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
    	if (dev->tbusy) {
		chan->drvstats_if_send.if_send_tbusy++;
		++chan->ifstats.collisions;
		if ((jiffies - chan->tick_counter) < (5 * HZ)) {
	chan->fr_header_len = setup_fr_header(&skb,dev,chan->common.usedby);
	if (chan->fr_header_len < 0 ){
		++chan->ifstats.tx_dropped;
		++card->wandev.stats.tx_dropped;
		++chan->ifstats.tx_errors;
		++card->wandev.stats.tx_errors;
	sendpacket = skb->data;
                        chan->dlci)) {
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, FR_INTR_TIMER);
                                chan->drvstats_if_send.
  	if ((chan->common.usedby == WANPIPE) && (sendpacket[0] == 0x45)) {
            		++chan->ifstats.tx_dropped;
			++card->wandev.stats.tx_dropped;
	if (test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
		chan->drvstats_if_send.if_send_critical_non_ISR ++;
		chan->ifstats.tx_errors ++;
				card->devname);
	if((chan->common.usedby == API) && (skb->len <= sizeof(api_tx_hdr_t))) {
		++chan->ifstats.tx_errors;
		++card->wandev.stats.tx_errors;
		if (chan->common.usedby == API) {
			api_tx_hdr = (api_tx_hdr_t*)&skb->data[0x00];
			attr = api_tx_hdr->wp_api_tx_hdr_fr_attr;
	if (card->wandev.state != WAN_CONNECTED) {
		chan->drvstats_if_send.if_send_wan_disconnected ++;
		++chan->ifstats.tx_dropped;
        	++card->wandev.stats.tx_dropped;
		++chan->ifstats.tx_carrier_errors;
        	++card->wandev.stats.tx_carrier_errors;
	} else if (chan->common.state != WAN_CONNECTED) {
		chan->drvstats_if_send.if_send_dlci_disconnected ++;
		card->u.f.timer_int_enabled |= TMR_INT_ENABLED_UPDATE_STATE;	
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, FR_INTR_TIMER);
        	++chan->ifstats.tx_dropped;
        	++card->wandev.stats.tx_dropped;
		++chan->ifstats.tx_carrier_errors;
        	++card->wandev.stats.tx_carrier_errors;
		chan->drvstats_if_send.if_send_no_bfrs++;
	} else if (!skb->protocol) {
				card->devname,dev->name);
		chan->drvstats_if_send.if_send_protocol_error ++;
		++card->wandev.stats.tx_errors;
	} else if (test_bit(ARP_CRIT,&card->wandev.critical)){
				card->devname,dev->name);
		++chan->ifstats.tx_dropped;
        	++card->wandev.stats.tx_dropped;
		if(chan->common.usedby == WANPIPE &&
		   htons(skb->protocol) == ETH_P_IPX){ 
			if( chan->enable_IPX ) {
						chan->network_number, 0);
					card->devname);
				++chan->ifstats.tx_dropped;
		        	++card->wandev.stats.tx_dropped;
					  chan->dlci, 
					  skb->len, 
					  skb->data, 
					  chan->fr_header_len,
				chan->drvstats_if_send.
					 card->devname, (unsigned int)skb->len);
				chan->drvstats_if_send.
				++chan->ifstats.tx_dropped;
				++card->wandev.stats.tx_dropped;
				++chan->ifstats.tx_carrier_errors;
				++card->wandev.stats.tx_carrier_errors;
			chan->drvstats_if_send.
			++chan->ifstats.tx_packets;
			++card->wandev.stats.tx_packets;
			chan->ifstats.tx_bytes += skb->len;
			card->wandev.stats.tx_bytes += skb->len;
			dev->trans_start = jiffies;
		atomic_inc(&card->u.f.tx_interrupts_pending);
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, FR_INTR_TXRDY);
        clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
 * if_do_ioctl - Ioctl handler for fr
	fr_channel_t* chan = dev->priv;
		return -ENODEV;
	card = chan->card;
				err= -EINVAL;
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			err=wan_bind_api_to_svc(chan,ifr->ifr_data);
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
				err= -EINVAL;
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			err=wan_unbind_api_from_svc(chan,ifr->ifr_data);
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
			err = chan->common.state;
			if (atomic_read(&card->u.f.udp_pkt_len) != 0){
				return -EBUSY;
			atomic_set(&card->u.f.udp_pkt_len,sizeof(wan_udp_hdr_t));
			wan_udp_pkt=(wan_udp_pkt_t*)&card->u.f.udp_pkt_data;
			if (copy_from_user(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				atomic_set(&card->u.f.udp_pkt_len,0);
				return -EFAULT;
			spin_lock_irqsave(&card->wandev.lock, smp_flags);
			if (test_bit(0,&card->in_isr)){
						card->devname,dev->name);
				atomic_set(&card->u.f.udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
				return -EBUSY;
				atomic_set(&card->u.f.udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
				return -EINVAL;
			spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
			if (atomic_read(&card->u.f.udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						card->devname,atomic_read(&card->u.f.udp_pkt_len));
				atomic_set(&card->u.f.udp_pkt_len,0);
				return -EINVAL;
			if (copy_to_user(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				atomic_set(&card->u.f.udp_pkt_len,0);
				return -EFAULT;
			atomic_set(&card->u.f.udp_pkt_len,0);
			return -EOPNOTSUPP;
        fr_channel_t* chan = dev->priv;
        sdla_t* card = chan->card;
	int len = skb->len;
	if (!chan->dlci_int_interface_off){
					card->devname, chan->dlci);
					card->devname);
	card->hw_iface.peek(card->hw, chan->dlci_int_interface_off, &dlci_interface, sizeof(dlci_interface));
        if(chan->transmit_length) {
				card->devname);
				card->devname,len,FR_MAX_NO_DATA_BYTES_IN_FRAME);
        chan->transmit_length = len;
	chan->delay_skb = skb;
	card->hw_iface.poke(card->hw, chan->dlci_int_interface_off, &dlci_interface, sizeof(dlci_interface));
        fr_channel_t* chan = dev->priv;
	iphdr_t *iphdr = (iphdr_t *)skb->data;
	if (skb->len < sizeof(iphdr_t)){
                        card->devname,skb->len);
        src_ip_addr = iphdr->w_ip_src;
        in_dev = dev->ip_ptr;
                struct in_ifaddr *ifa= in_dev->ifa_list;
                        broadcast_ip_addr = ifa->ifa_broadcast;
        if((dev->flags & IFF_BROADCAST) && (src_ip_addr == broadcast_ip_addr)) {
                        card->devname);
        if((chan->mc == WANOPT_NO) && (ntohl(src_ip_addr) >= 0xE0000001) &&
                        card->devname);
	wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	wan_udp_pkt->wan_udp_len = temp;
	temp = wan_udp_pkt->wan_udp_sport;
	wan_udp_pkt->wan_udp_sport = 
			wan_udp_pkt->wan_udp_dport; 
	wan_udp_pkt->wan_udp_dport = temp;
		(wan_udp_pkt->wan_udp_data+mbox_len+even_bound)) = temp;	
		(wan_udp_pkt->wan_udp_data+mbox_len+even_bound+2)) = temp;
	wan_udp_pkt->wan_udp_sum = 0;
	wan_udp_pkt->wan_udp_sum = 
	wan_udp_pkt->wan_ip_len = temp;
	ip_temp = wan_udp_pkt->wan_ip_src;
	wan_udp_pkt->wan_ip_src = 
				wan_udp_pkt->wan_ip_dst;
	wan_udp_pkt->wan_ip_dst = ip_temp;
	wan_udp_pkt->wan_ip_sum = 0;
	wan_udp_pkt->wan_ip_sum = 
   If incoming is 0 (outgoing)- if the net numbers is ours make it 0
   if incoming is 1 - if the net number is 0 make it ours 
 * Get ethernet-style interface statistics.
	fr_channel_t* chan = dev->priv;
	return &chan->ifstats;
	wan_mbox_t*	mb = &card->wan_mbox;
	if (!card->hw){
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	set_bit(0,&card->in_isr);
	++card->statistics.isr_entry;
	/* All peripheral (configuraiton, re-configuration) events
	if (test_bit(PERI_CRIT, (void*)&card->wandev.critical)) {
		++card->statistics.isr_already_critical;
        if(card->type != SDLA_S514) {
		if (test_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
                                card->devname);
			++card->statistics.isr_already_critical;
	    		++card->statistics.isr_rx;
	    		++ card->statistics.isr_tx; 
	    		card->timer_int_enabled++;
			++card->statistics.isr_intr_test;
			mb->wan_command = FR_READ_STATUS;
			mb->wan_data_len = 0;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			mb->wan_command = FR_READ_STATUS;
			mb->wan_data_len = 0;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	    		++card->statistics.isr_spurious;
			card->hw_iface.peek(card->hw, card->intr_type_off, &intr_type, 1);
				card->devname, intr_type); 
			printk(KERN_INFO "%s: ID Bytes = ",card->devname);
				card->hw_iface.peek(card->hw, card->intr_type_off+0x28, str, 8);
	clear_bit(0,&card->in_isr);
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.peek(card->hw, card->rxmb_off, &frbuf, sizeof(frbuf));
			card->devname, (unsigned)card->rxmb_off, frbuf.flag);
		card->hw_iface.peek(card->hw, card->intr_type_off+0x28, str, 8);
		printk(KERN_INFO "%s: ID Bytes = ",card->devname);
		++card->statistics.rx_intr_corrupt_rx_bfr;
		printk(KERN_INFO "%s: Critical router failure ...!!!\n", card->devname);
                                                card->devname, dlci);
		++card->statistics.rx_intr_on_orphaned_DLCI; 
		++card->wandev.stats.rx_dropped;
	if ((chan = dev->priv) == NULL){
                                                card->devname, dlci);
		++card->statistics.rx_intr_on_orphaned_DLCI; 
		++card->wandev.stats.rx_dropped;
		++chan->ifstats.rx_dropped;
					card->devname);
		chan->drvstats_rx_intr.
		++chan->ifstats.rx_dropped;
					card->devname);
		chan->drvstats_rx_intr.rx_intr_no_socket ++;
	if ((offs + len) > card->u.f.rx_top_off + 1) {
		unsigned tmp = card->u.f.rx_top_off - offs + 1;
		card->hw_iface.peek(card->hw, offs, buf, tmp);
		offs = card->u.f.rx_base_off;
		len -= tmp;
	card->hw_iface.peek(card->hw, offs, buf, len);
				card->hw_iface.set_bit(card->hw, card->intr_perm_off, FR_INTR_TIMER); 
					++chan->drvstats_rx_intr.rx_intr_PIPE_request;
	}else if (chan->common.usedby == API) {
		api_rx_hdr = (api_rx_hdr_t*)&skb->data[0x00];
		api_rx_hdr->wp_api_rx_hdr_fr_attr = frbuf.attr;
		api_rx_hdr->wp_api_rx_hdr_fr_time_stamp = frbuf.tmstamp;
		skb->protocol = htons(WP_PVC_PROT);
		skb->dev      = dev;
		skb->pkt_type = WAN_PACKET_DATA;
			++card->wandev.stats.rx_dropped;
		WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
	}else if (handle_IPXWAN(skb->data,chan->name,chan->enable_IPX, chan->network_number)){
		if (chan->enable_IPX) {
			if (chan->tx_ipx){
						card->devname,dev->name);
				chan->tx_ipx=skb;	
			atomic_inc(&card->u.f.tx_interrupts_pending);
			card->hw_iface.set_bit(card->hw, chan->dlci_int_off, FR_INTR_TXRDY);
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, FR_INTR_TXRDY);
	} else if (is_arp(skb->data)) {
		if (chan->inarp_rx == WANOPT_YES){
			err=process_ARP((arphdr_1490_t *)skb->data, card, dev);
				if (chan->tx_arp){
					chan->tx_arp=skb;	
				atomic_inc(&card->u.f.tx_interrupts_pending);
				card->hw_iface.set_bit(card->hw, chan->dlci_int_off, FR_INTR_TXRDY);
				card->hw_iface.set_bit(card->hw, card->intr_perm_off, FR_INTR_TXRDY);
				if (err == -1 && net_ratelimit()){  
						card->devname);
	} else if (skb->data[0] != chan->fr_encap_0) {
		switch (skb->data[0]){
				printk(KERN_INFO "%s-%s: Changing data encapsulation to CISCO\n",
						card->devname,dev->name);
				chan->fr_encap_0 = CISCO_UI;
				chan->fr_encap_1 = CISCO_IP;
				printk(KERN_INFO "%s-%s: Changing data encapsulation to IETF\n",
						card->devname,dev->name);
				chan->fr_encap_0 = Q922_UI;
				chan->fr_encap_1 = NLPID_IP;
				if (skb->data[0] != CISCO_INV && net_ratelimit()) { 
					card->devname,skb->data[0],skb->data[1]);
				++chan->drvstats_rx_intr.rx_intr_bfr_not_passed_to_stack;
				++chan->ifstats.rx_errors;
				++card->wandev.stats.rx_errors;
		len_incl_hdr = skb->len;
		skb->dev = dev;
		if (chan->common.usedby == BRIDGE || chan->common.usedby == BRIDGE_NODE){
			if (!memcmp(skb->data, "\x03\x00\x80\x00\x80\xC2\x00\x07", 8)) {
				skb->protocol=eth_type_trans(skb,dev);
				++chan->drvstats_rx_intr.rx_intr_bfr_not_passed_to_stack;
				++chan->ifstats.rx_errors;
				++card->wandev.stats.rx_errors;
			skb->protocol=htons(ETH_P_IP);
			if (chan->fr_encap_0 == CISCO_UI && skb->data[0] == CISCO_IP){
				++chan->drvstats_rx_intr.rx_intr_bfr_not_passed_to_stack;
				++chan->ifstats.rx_errors;
				++card->wandev.stats.rx_errors;
		DEBUG_SUB_MEM(skb->truesize);
			++chan->ifstats.rx_dropped;
			++chan->drvstats_rx_intr.rx_intr_bfr_passed_to_stack;
			++chan->ifstats.rx_packets;
			++card->wandev.stats.rx_packets;
			chan->ifstats.rx_bytes += len_incl_hdr;
			card->wandev.stats.rx_bytes += len_incl_hdr;
		++chan->drvstats_rx_intr.rx_intr_bfr_passed_to_stack;
		++chan->ifstats.rx_packets;
		++card->wandev.stats.rx_packets;	
		chan->ifstats.rx_bytes += len_incl_hdr;
		card->wandev.stats.rx_bytes += len_incl_hdr;
	card->hw_iface.poke(card->hw, card->rxmb_off, &frbuf, sizeof(frbuf));
	card->rxmb_off += sizeof(frbuf);
	if (card->rxmb_off > card->u.f.rxmb_last_off){
		card->rxmb_off = card->u.f.rxmb_base_off;
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	card->hw_iface.peek(card->hw, bctl_off, &bctl, sizeof(bctl));
				card->devname);	
        if ((chan = dev->priv) == NULL){
				card->devname);	
        if((!chan->transmit_length || !chan->delay_skb) && 
	    !chan->tx_ipx && !chan->tx_arp) {
                printk(KERN_INFO "%s: tx int error - transmit length zero\n",
				card->wandev.name);
		chan->transmit_length=0;
		if (chan->delay_skb){
			wan_skb_free(chan->delay_skb);
			chan->delay_skb=NULL;	
		if (chan->tx_arp){
			wan_skb_free(chan->tx_arp);
			chan->tx_arp=NULL;
		if (chan->tx_ipx){
			wan_skb_free(chan->tx_ipx);
			chan->tx_ipx=NULL;
	if (!(dev->flags&IFF_UP) || 
	    chan->common.state != WAN_CONNECTED || 
	    card->wandev.state != WAN_CONNECTED){
		chan->transmit_length=0;
		if (chan->delay_skb){
			wan_skb_free(chan->delay_skb);
			chan->delay_skb=NULL;	
		if (chan->tx_arp){
			wan_skb_free(chan->tx_arp);
			chan->tx_arp=NULL;
		if (chan->tx_ipx){
			wan_skb_free(chan->tx_ipx);
			chan->tx_ipx=NULL;
		card->hw_iface.poke(card->hw, bctl_off, &bctl, sizeof(bctl));
	   so as to re-issue this transmit interrupt at a later stage. 
	if (test_bit(SEND_TXIRQ_CRIT, (void*)&card->wandev.critical)) {
		card->hw_iface.poke(card->hw, bctl_off, &bctl, sizeof(bctl));
		card->hw_iface.set_bit(card->hw, chan->dlci_int_off, FR_INTR_TXRDY);
	}else if (chan->tx_arp){
		bctl.length = chan->tx_arp->len;
		card->hw_iface.poke(card->hw, 
			  chan->tx_arp->data,
 	              	  chan->tx_arp->len);
		card->hw_iface.poke(card->hw, bctl_off, &bctl, sizeof(bctl));
		++chan->ifstats.tx_packets;
		++card->wandev.stats.tx_packets;
		chan->ifstats.tx_bytes += chan->tx_arp->len;
		card->wandev.stats.tx_bytes += chan->tx_arp->len;
		wan_skb_free(chan->tx_arp);
		chan->tx_arp=NULL;
		chan->route_flag = ADD_ROUTE;
		if (!chan->transmit_length && !chan->tx_ipx){
			card->hw_iface.set_bit(card->hw, chan->dlci_int_off, FR_INTR_TXRDY);
 	}else if (chan->tx_ipx){
		bctl.length = chan->tx_ipx->len+chan->fr_header_len;
		card->hw_iface.poke(card->hw, 
			  chan->tx_ipx->data,
 	              	  chan->tx_ipx->len);
		card->hw_iface.poke(card->hw, bctl_off, &bctl, sizeof(bctl));
		++chan->ifstats.tx_packets;
		++card->wandev.stats.tx_packets;
		chan->ifstats.tx_bytes += chan->tx_ipx->len;
		card->wandev.stats.tx_bytes += chan->tx_ipx->len;
		wan_skb_free(chan->tx_ipx);
		chan->tx_ipx=NULL;
		if (!chan->transmit_length){
			card->hw_iface.set_bit(card->hw, chan->dlci_int_off, FR_INTR_TXRDY);
			//bctl->flag = 0xA0;
	        bctl.length = chan->transmit_length+chan->fr_header_len;
        	card->hw_iface.poke(card->hw, 
			  chan->delay_skb->data,
 	              	  chan->delay_skb->len);
		card->hw_iface.poke(card->hw, bctl_off, &bctl, sizeof(bctl));
		++chan->ifstats.tx_packets;
		++card->wandev.stats.tx_packets;
		chan->ifstats.tx_bytes += chan->transmit_length;
		card->wandev.stats.tx_bytes += chan->transmit_length;
                wan_skb_free(chan->delay_skb);
		chan->delay_skb = NULL;				
        	chan->transmit_length = 0;
		dev->trans_start = jiffies;
			if (chan->common.usedby == API){
	if (!chan->transmit_length){
			if (chan->common.usedby == API){
	atomic_dec(&card->u.f.tx_interrupts_pending);
	if(atomic_read(&card->u.f.tx_interrupts_pending)<=0){
		atomic_set(&card->u.f.tx_interrupts_pending,0);
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, FR_INTR_TXRDY);
 *   	3. Reading board-level statistics for 
        if (card->u.f.timer_int_enabled & TMR_INT_ENABLED_UDP) {
		if(card->u.f.udp_type == UDP_FPIPE_TYPE) {
		         card->u.f.timer_int_enabled &=
	if (card->u.f.timer_int_enabled & TMR_INT_ENABLED_UPDATE) {
			card->wandev.fe_iface.read_alarm(&card->fe, 0); 
			card->wandev.fe_iface.read_pmon(&card->fe, 0); 
			card->wandev.fe_iface.read_alarm(&card->fe, 1); 
		card->update_comms_stats = 0;
		card->u.f.timer_int_enabled &= ~TMR_INT_ENABLED_UPDATE;
	if (card->u.f.timer_int_enabled & TMR_INT_ENABLED_TE){
		card->wandev.fe_iface.polling(&card->fe);
		card->u.f.timer_int_enabled &= ~TMR_INT_ENABLED_TE;
	if (card->u.f.timer_int_enabled & TMR_INT_ENABLED_UPDATE_DLCI){
		fr_get_stats(card, card->u.f.update_dlci);
		card->update_comms_stats = 0;
		card->u.f.update_dlci = NULL;
		card->u.f.timer_int_enabled &= ~TMR_INT_ENABLED_UPDATE_DLCI;
	if (card->u.f.timer_int_enabled & TMR_INT_ENABLED_UPDATE_STATE){
		if (card->wandev.state == WAN_CONNECTED){
			WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
				if (chan->common.state != WAN_CONNECTED){
		card->u.f.timer_int_enabled &= ~TMR_INT_ENABLED_UPDATE_STATE;
	if (card->u.f.timer_int_enabled & TMR_INT_ENABLED_ARP){
		if (card->u.f.arp_dev == NULL){
			card->u.f.arp_dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		dev = card->u.f.arp_dev;
			fr_channel_t *chan = dev->priv;
			/* If the interface is brought down cancel sending In-ARPs */
			if (!(dev->flags&IFF_UP)){
				clear_bit(0,&chan->inarp_ready);	
			if (test_bit(0,&chan->inarp_ready)){
					set_bit(ARP_CRIT,&card->wandev.critical);
					clear_bit(0,&chan->inarp_ready);
				}else if(arp_err ==  -EINVAL){
					clear_bit(0,&chan->inarp_ready);
					chan->inarp = INARP_NONE;
							card->devname,dev->name);
			if (++i == atomic_read(&card->wandev.if_cnt)){
				card->u.f.timer_int_enabled &= ~TMR_INT_ENABLED_ARP;
				clear_bit(ARP_CRIT,&card->wandev.critical);
		card->u.f.arp_dev = dev;
        if (!card->u.f.timer_int_enabled){
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, FR_INTR_TIMER);
		printk(KERN_INFO "%s: spurious interrupt!\n", card->devname);
 *  Return 0 for non-IPXWAN packet
			sendpacket[64] = '-';
	/* If we get here, its an IPX-data packet so it'll get passed up the 
	fr_channel_t *chan = dev->priv;
	sdla_t *card = chan->card;
	switch(chan->route_flag){
		strcpy(if_info.ifr_name, dev->name);
		if_data->sin_addr.s_addr = chan->ip_remote;
		if_data->sin_family = AF_INET;
					card->devname,err);
				chan->name, NIPQUAD(chan->ip_remote));
				card->devname,NIPQUAD(chan->ip_remote));
			chan->route_flag = ROUTE_ADDED;
		strcpy(if_info.ifr_name, dev->name);
		if_data->sin_addr.s_addr = 0;
		if_data->sin_family = AF_INET;
					card->devname,err);
				dev->name,NIPQUAD(chan->ip_remote) );
				card->devname,NIPQUAD(ip_tmp));
			chan->route_flag = NO_ROUTE;
/****** Frame Relay Firmware-Specific Functions *****************************/
	wan_mbox_t* mbox = &card->wan_mbox;
		mbox->wan_command = FR_READ_CODE_VERSION;
		mbox->wan_data_len = 0;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	} while (err && retry-- && fr_event(card, err, mbox));
		int len = mbox->wan_data_len;
		memcpy(str, mbox->wan_data, len);
	wan_mbox_t* mb = &card->wan_mbox;
	int dlci_num = card->u.f.dlci_num;
		memcpy(mb->wan_data, conf, sizeof(fr_conf_t));
				((fr_conf_t*)mb->wan_data)->dlci[i] = 
						card->u.f.node_dlci[i]; 
		mb->wan_command = FR_SET_CONFIG;
		mb->wan_data_len =
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry-- && fr_event(card, err, mb));
				card->devname,err);
	wan_mbox_t* mb = &card->wan_mbox;
	unsigned char *buf=mb->wan_data;
		mb->wan_fr_dlci = (unsigned short) dlci; 
		mb->wan_command = FR_SET_CONFIG;
		mb->wan_data_len = sizeof(fr_dlc_conf_t);
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry--);
	wan_mbox_t* mb = &card->wan_mbox;
	fr508_intr_ctl_t* ictl = (void*)mb->wan_data;
		ictl->mode   = mode;
		ictl->tx_len = mtu;
		ictl->irq    = card->wandev.irq; // ALEX_TODAY card->hw.irq;
		if (mode & 0x20) ictl->timeout = timeout; 
		mb->wan_data_len = sizeof(fr508_intr_ctl_t);
		mb->wan_command = FR_SET_INTR_MODE;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry-- && fr_event(card, err, mb));
	wan_mbox_t*	mb = &card->wan_mbox;
		mb->wan_command = FR_COMM_ENABLE;
		mb->wan_data_len = 0;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry-- && fr_event(card, err, mb));
 *          since dev->priv are has already been deallocated and no
	wan_mbox_t*	mb = &card->wan_mbox;
		mb->wan_command = FR_SET_MODEM_STATUS;
		mb->wan_data_len = 1;
		mb->wan_data[0] = 0;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry--);
		mb->wan_command = FR_COMM_DISABLE;
		mb->wan_data_len = 0;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry--);
	wan_mbox_t*	mb = &card->wan_mbox;
		mb->wan_command = FR_READ_ERROR_STATS;
		mb->wan_data_len = 0;
		mb->wan_fr_dlci = 0;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry-- && fr_event(card, err, mb));
		fr_comm_stat_t* stats = (void*)mb->wan_data;
		card->wandev.stats.rx_over_errors    = stats->rx_overruns;
		card->wandev.stats.rx_crc_errors     = stats->rx_bad_crc;
		card->wandev.stats.rx_missed_errors  = stats->rx_aborts;
		card->wandev.stats.rx_length_errors  = stats->rx_too_long;
		card->wandev.stats.tx_aborted_errors = stats->tx_aborts;
	wan_mbox_t*	mb = &card->wan_mbox;
	if (chan && chan->common.state == WAN_CONNECTED){
		dlci = chan->dlci;
		mb->wan_command = FR_READ_STATISTICS;
		mb->wan_data_len = 0;
		mb->wan_fr_dlci = dlci;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry-- && fr_event(card, err, mb));
			fr_link_stat_t* stats = (void*)mb->wan_data;
			card->wandev.stats.rx_frame_errors = 
					stats->rx_bad_format;
			card->wandev.stats.rx_dropped =
					stats->rx_dropped + 
					stats->rx_dropped2;
			fr_dlci_stat_t* stats = (void*)mb->wan_data;
			chan->rx_DE_set = stats->rx_DE_set;
	wan_mbox_t*	mb = &card->wan_mbox;
		unsigned short* dlci_list = (void*)mb->wan_data;
		mb->wan_data_len  = sizeof(short);
		mb->wan_command = FR_ADD_DLCI;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry-- && fr_event(card, err, mb));
	wan_mbox_t* mb = &card->wan_mbox;
		unsigned short* dlci_list = (void*)mb->wan_data;
		mb->wan_data_len  = sizeof(short);
		mb->wan_command = FR_ACTIVATE_DLCI;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry-- && fr_event(card, err, mb));
	wan_mbox_t* mb = &card->wan_mbox;
		unsigned short* dlci_list = (void*)mb->wan_data;
		mb->wan_data_len  = sizeof(short);
		mb->wan_command = FR_DELETE_DLCI;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry-- && fr_event(card, err, mb));
 * Issue in-channel signalling frame. 
	wan_mbox_t* mb = &card->wan_mbox;
		mb->wan_data[0] = isf;
		mb->wan_data_len  = 1;
		mb->wan_command = FR_ISSUE_IS_FRAME;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry-- && fr_event(card, err, mb));
 * Issue in-channel signalling frame. 
	if (!dev || !(chan=dev->priv))
	if (chan->fr_header_len){
		card->hw_iface.poke(card->hw, offset, chan->fr_header, chan->fr_header_len);
	return offset+chan->fr_header_len;
	wan_mbox_t*	mb = &card->wan_mbox;
		mb->wan_fr_dlci    = dlci;
		mb->wan_fr_attr    = attr;
		mb->wan_data_len  = len+hdr_len;
		mb->wan_command = FR_WRITE;
		err = card->hw_iface.cmd(card->hw, card->mbox_off + 0x800, mb);
	} while (err && retry-- && event_err);
		unsigned long 	frbuf_off = *(unsigned long*)mb->wan_data;
		card->hw_iface.peek(card->hw, frbuf_off, &frbuf, sizeof(frbuf));
		card->hw_iface.poke(card->hw, fr_send_hdr(card,dlci,frbuf.offset), buf, len);
		card->hw_iface.poke(card->hw, frbuf_off, &frbuf, sizeof(frbuf));
	wan_mbox_t* mb = &card->wan_mbox;
		mb->wan_fr_dlci    = dlci;
		mb->wan_fr_attr    = attr;
		mb->wan_data_len  = len;
		mb->wan_command = FR_WRITE;
		err = card->hw_iface.cmd(card->hw, card->mbox_off + 0x800, mb);
	} while (err && retry-- && fr_event(card, err, mb));
		unsigned long 	frbuf_off = *(unsigned long*)mb->wan_data;
		card->hw_iface.peek(card->hw, frbuf_off, &frbuf, sizeof(frbuf));
		card->hw_iface.poke(card->hw, frbuf.offset, buf, len);
		card->hw_iface.poke(card->hw, frbuf_off, &frbuf, sizeof(frbuf));
	card->u.f.timer_int_enabled |= TMR_INT_ENABLED_TE;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, FR_INTR_TIMER); 
 *	This routine is called whenever firmware command returns non-zero
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
			printk(KERN_INFO "%s: FR Event: Channel Down!\n",card->devname);
			WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
				if (chan->route_flag == ROUTE_ADDED) {
					chan->route_flag = REMOVE_ROUTE;
				if (chan->inarp == INARP_CONFIGURED) {
					chan->inarp = INARP_REQUEST;
			printk(KERN_INFO "%s: FR Event: Channel Up!\n",card->devname);
				WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
					if (chan->dlci_stat & FR_DLCI_ACTIVE){
						if (card->wandev.ignore_front_end_status == WANOPT_YES ||
					    	    card->fe.fe_status == FE_CONNECTED){
				card->devname);
				card->devname, mb->wan_command);
			printk(KERN_INFO "%s: ID Bytes = ",card->devname);
				card->hw_iface.peek(card->hw, card->intr_type_off+0x18+i, &tmp, 1);
				, card->devname, mb->wan_command, event);
		card->hw_iface.peek(card->hw, FE_status_off, &FE_status, sizeof(FE_status));
		card->fe.fe_param.k56_param.RR8_reg_56k = 
		card->fe.fe_param.k56_param.RRA_reg_56k = 
		card->fe.fe_param.k56_param.RRC_reg_56k = 
		card->wandev.fe_iface.read_alarm(&card->fe, 0);
		card->hw_iface.poke(card->hw, FE_status_off, &FE_status, sizeof(FE_status));
		card->hw_iface.peek(card->hw, FE_status_off, &FE_status, sizeof(FE_status));
		card->wandev.fe_iface.isr(&card->fe);
		card->hw_iface.poke(card->hw, FE_status_off, &FE_status, sizeof(FE_status));
			card->devname, mb->wan_data[0]);
		if (mb->wan_data[0] == 0x28){
			card->fe.fe_status = FE_CONNECTED;	
			card->fe.fe_status = FE_DISCONNECTED;
	switch (mb->wan_command){
	dlci_status_t* status = (void*)((unsigned char*)mb->wan_data+mbox_offset);
	int cnt = mb->wan_data_len / sizeof(dlci_status_t);
	if (cnt > 1 && card->u.f.auto_dlci_cfg){
				card->devname,cnt);
		dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
			if (chan->dlci == 0xFFFF){
						card->devname);
						card->devname);
						card->devname,card->devname);
	for (; cnt; --cnt, ++status) {
		unsigned short dlci= status->dlci;
				card->devname, dlci,
				(status->state & FR_DLCI_DELETED) ? "Deleted" : "Included",
				(status->state & FR_DLCI_ACTIVE) ? "Active" : "Inactive");
			fr_channel_t *chan = dev->priv;
			if (card->u.f.auto_dlci_cfg && chan->dlci == 0xFFFF){
				chan->dlci=dlci;
				chan->common.lcn=dlci;
			chan->dlci_stat = status->state;
			if ((status->state & ~FR_DLCI_NEW) == FR_DLCI_INOPER) {
					card->devname, dlci, 
					(status->state&FR_DLCI_NEW)?", New":"");
					card->devname);
				if (chan->common.state != WAN_DISCONNECTED){
					if (chan->route_flag == ROUTE_ADDED) {
						chan->route_flag = REMOVE_ROUTE;
					if (chan->inarp == INARP_CONFIGURED) {
						chan->inarp = INARP_REQUEST;
			if (status->state & FR_DLCI_DELETED) {
					card->devname, dlci);
					card->devname);
				if (chan->common.state != WAN_DISCONNECTED){
					if (chan->route_flag == ROUTE_ADDED) {
						chan->route_flag = REMOVE_ROUTE;
					if (chan->inarp == INARP_CONFIGURED) {
						chan->inarp = INARP_REQUEST;
			} else if (status->state & FR_DLCI_ACTIVE) {
				chan = dev->priv;
					card->devname, dlci,
					(status->state&FR_DLCI_NEW)?", New":"");
				chan->dlci_configured = DLCI_CONFIG_PENDING;
				if (card->wandev.state == WAN_CONNECTED){
					if (card->wandev.ignore_front_end_status == WANOPT_YES ||	
				    	    card->fe.fe_status == FE_CONNECTED){
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		chan = dev2->priv;
		if (chan->dlci_configured == DLCI_CONFIG_PENDING) {
	if ( chan->cir_status == CIR_DISABLED) {
	}else if (chan->cir_status == CIR_ENABLED) {
		cfg.cir_fwd = cfg.cir_bwd = chan->cir;
		cfg.bc_fwd  = cfg.bc_bwd  = chan->bc;
		cfg.be_fwd  = cfg.be_bwd  = chan->be;
	if (fr_dlci_configure( card, &cfg , chan->dlci)){
				card->devname, chan->dlci);
	chan->dlci_configured = DLCI_CONFIGURED;
	fr_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	wan_mbox_t* mb = &card->wan_mbox;
		mb->wan_command = FR_LIST_ACTIVE_DLCI;
		mb->wan_data_len = 0;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry-- && fr_event(card, err, mb));
		unsigned short* list = (void*)mb->wan_data;
		int cnt = mb->wan_data_len / sizeof(short);
		for (; cnt; --cnt, ++list) {
			if (*list == chan->dlci) {
				chan->dlci_stat=0x02;
				if (card->wandev.state == WAN_CONNECTED){
					if (card->wandev.ignore_front_end_status == WANOPT_YES ||
				    	    card->fe.fe_status == FE_CONNECTED){
				if (!chan->dlci_int_interface_off){
	chan->dlci_stat=0x00;
	fr_channel_t* chan = dev->priv;
	sdla_t* card = chan->card;
	if (chan->common.state != state) {
					card->devname, dev->name, 
					chan->dlci > HIGHEST_VALID_DLCI?0:chan->dlci);
					card->devname, dev->name, 
					chan->dlci > HIGHEST_VALID_DLCI?0:chan->dlci);
					card->devname, dev->name, 
					chan->dlci > HIGHEST_VALID_DLCI?0:chan->dlci);
		chan->common.state = state;
		chan->router_last_change = tv.tv_sec;
		if (chan->common.usedby == API){
	chan->state_tick = jiffies;
	if (card->u.f.auto_dlci_cfg){
		dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
			if (chan->dlci != 0xFFFF && chan->dlci != dlci){
	return(card->u.f.dlci_to_dev_map[dlci]);
 * Return:	1 - Tx buffer(s) available
 *		0 - no buffers available
        if(card->type == SDLA_S514)
	card->hw_iface.isa_read_1(card->hw, 0x00, &sb);
	for (val = 0; len && is_digit(*str); ++str, --len)
		val = (val * 10) + (*str - (unsigned)'0');
	if (!dev || !(chan=dev->priv))
        if(!atomic_read(&card->u.f.udp_pkt_len) && (skb->len <= MAX_LGTH_UDP_MGNT_PKT)){
		atomic_set(&card->u.f.udp_pkt_len,skb->len + chan->fr_header_len);
                card->u.f.udp_type = udp_type;
                card->u.f.udp_pkt_src = udp_pkt_src;
                card->u.f.udp_dlci = dlci;
                memcpy((u8*)&card->u.f.udp_pkt_data, skb->data, skb->len);
                card->u.f.timer_int_enabled |= TMR_INT_ENABLED_UDP;
	wan_mbox_t* mb = &card->wan_mbox;
	char udp_pkt_src = card->u.f.udp_pkt_src; 
	int dlci = card->u.f.udp_dlci;
			atomic_set(&card->u.f.udp_pkt_len,0);
			return -ENODEV;
		if ((chan = dev->priv) == NULL){
			atomic_set(&card->u.f.udp_pkt_len,0);
			return -ENODEV;
				atomic_set(&card->u.f.udp_pkt_len,0);
				return -EBUSY;
		wan_udp_pkt = (wan_udp_pkt_t *)&card->u.f.udp_pkt_data;
			switch(wan_udp_pkt->wan_udp_command) {
		if ((chan = dev->priv) == NULL){
			return -ENODEV;
		dlci=chan->dlci;	
		if (atomic_read(&card->u.f.udp_pkt_len) == 0){
			return -ENODEV;
		wan_udp_pkt = (wan_udp_pkt_t *)&card->u.f.udp_pkt_data;
	wan_udp_pkt->wan_udp_opp_flag = 0x0; 
		wan_udp_pkt->wan_udp_data_len = 0;
		wan_udp_pkt->wan_udp_return_code = 0xCD; 
		chan->drvstats_gen.UDP_PIPE_mgmt_direction_err ++;
			card->devname,wan_udp_pkt->wan_udp_command);
		switch(wan_udp_pkt->wan_udp_command) {
			if(!card->TracingEnabled) {
                       			mb->wan_command = FR_SET_TRACE_CONFIG;
                       			mb->wan_data_len = 1;
                     			mb->wan_fr_dlci = 0x00;
                   			mb->wan_data[0] = wan_udp_pkt->wan_udp_data[0] | 
                    			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
                       		} while (err && c_retry-- && fr_event(card, err, mb));
					card->TracingEnabled = 0;
					wan_udp_pkt->wan_udp_return_code =
  						mb->wan_return_code;
					mb->wan_data_len = 0;
				card->hw_iface.peek(card->hw, NO_TRC_ELEMENTS_OFF,
				card->hw_iface.peek(card->hw, BASE_TRC_ELEMENTS_OFF,
						&card->u.f.trc_el_base, 4);
				card->u.f.curr_trc_el = card->u.f.trc_el_base;
             			card->u.f.trc_el_last = card->u.f.curr_trc_el +
							((num_trc_els - 1) * 
				card->u.f.trc_bfr_space=
					MAX_LGTH_UDP_MGNT_PKT-
					sizeof(struct iphdr)-
					sizeof(struct udphdr) - 
					sizeof(wan_mgmt_t)-
				wan_udp_pkt->wan_udp_return_code = 0;
				wan_udp_pkt->wan_udp_return_code = 1;
			mb->wan_data_len = 0;
			card->TracingEnabled = 1;
			if(card->TracingEnabled) {
					mb->wan_command = FR_SET_TRACE_CONFIG;
					mb->wan_data_len = 1;
					mb->wan_fr_dlci = 0x00;
					mb->wan_data[0] = ~ACTIVATE_TRC;
					err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
				} while (err && c_retry-- && fr_event(card, err, mb));
			wan_udp_pkt->wan_udp_return_code = 0;
			mb->wan_data_len = 0;
			card->TracingEnabled = 0;
                        if(!card->TracingEnabled) {
                                wan_udp_pkt->wan_udp_return_code = 1;
                                mb->wan_data_len = 0;
			ptr_trc_el = (fr_trc_el_t*) card->u.f.curr_trc_el;
			wan_udp_pkt->wan_udp_data[0x00] = 0x00;
                                card->hw_iface.peek(card->hw, (unsigned long)ptr_trc_el,
                                if((card->u.f.trc_bfr_space - buffer_length)
                                        wan_udp_pkt->wan_udp_data[0x00] |= MORE_TRC_DATA;
					(fpipemon_trc_t *)&wan_udp_pkt->wan_udp_data[buffer_length]; 
				fpipemon_trc->fpipemon_trc_hdr.status =
                            	fpipemon_trc->fpipemon_trc_hdr.tmstamp =
                            	fpipemon_trc->fpipemon_trc_hdr.length = 
                                     	fpipemon_trc->fpipemon_trc_hdr.data_passed = 0x00;
					(card->u.f.trc_bfr_space - buffer_length)){
                                        fpipemon_trc->fpipemon_trc_hdr.data_passed = 0x00;
                                    	wan_udp_pkt->wan_udp_data[0x00] |= MORE_TRC_DATA;
                                        fpipemon_trc->fpipemon_trc_hdr.data_passed = 0x01;
                                        card->hw_iface.peek(card->hw, trc_el.offset,
                           			  fpipemon_trc->data,
                                card->hw_iface.poke_byte(card->hw, (unsigned long)ptr_trc_el, 0x00);
				if((void *)ptr_trc_el > card->u.f.trc_el_last)
					ptr_trc_el = (fr_trc_el_t*)card->u.f.trc_el_base;
                               	if(fpipemon_trc->fpipemon_trc_hdr.data_passed) {
				if(wan_udp_pkt->wan_udp_data[0x00] & MORE_TRC_DATA) {
                        	wan_udp_pkt->wan_udp_data[0x00] |= MORE_TRC_DATA;
			card->u.f.curr_trc_el = (void *)ptr_trc_el;
			wan_udp_pkt->wan_udp_data[0x00] |=
			wan_udp_pkt->wan_udp_data_len = mb->wan_data_len = buffer_length;
                        wan_udp_pkt->wan_udp_return_code = 0;
			card->hw_iface.peek(card->hw, 0xF020,
				&wan_udp_pkt->wan_udp_data[0x00] , 2);
			wan_udp_pkt->wan_udp_data_len = mb->wan_data_len = 2;
			wan_udp_pkt->wan_udp_return_code = 0;
			mb->wan_data_len = 0;
			chan->router_up_time = tv.tv_sec - 
						chan->router_start_time;
    	                *(unsigned long *)&wan_udp_pkt->wan_udp_data =
    				chan->router_up_time;	
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 4;
			wan_udp_pkt->wan_udp_return_code = 0;
			memcpy(wan_udp_pkt->wan_udp_data,
				&chan->drvstats_if_send.if_send_entry,
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len =sizeof(if_send_stat_t);	
			wan_udp_pkt->wan_udp_return_code = 0;
			memcpy(wan_udp_pkt->wan_udp_data,
                                &card->statistics.isr_entry,
                        memcpy(&wan_udp_pkt->wan_udp_data[sizeof(global_stats_t)],
                                &chan->drvstats_rx_intr.rx_intr_no_socket,
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 
			wan_udp_pkt->wan_udp_return_code = 0;
                        memcpy(wan_udp_pkt->wan_udp_data,
                                &chan->drvstats_gen.UDP_PIPE_mgmt_kmalloc_err,
                        memcpy(&wan_udp_pkt->wan_udp_data[sizeof(pipe_mgmt_stat_t)],
                               &card->statistics, sizeof(global_stats_t));
                        mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = sizeof(global_stats_t)+
			wan_udp_pkt->wan_udp_return_code = 0;
			if(wan_udp_pkt->wan_udp_data[0] == 1) {
				if(card->rCount++ != 0 ){
					wan_udp_pkt->wan_udp_return_code = 0;
					mb->wan_data_len = 1;
                        if(wan_udp_pkt->wan_udp_data[0] == 0) {
				if( --card->rCount != 0) {
                                        wan_udp_pkt->wan_udp_return_code = 0;
					mb->wan_data_len = 1;
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				if (wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE){
		    			wan_udp_pkt->wan_udp_data_len = sizeof(wan_femedia_t); 
					wan_udp_pkt->wan_udp_return_code = CMD_OK;
					wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
			err = card->wandev.fe_iface.set_fe_lbmode(
						&card->fe, 
						wan_udp_pkt->wan_udp_data[0], 
						wan_udp_pkt->wan_udp_data[1]);
			wan_udp_pkt->wan_udp_return_code = 
			wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
		    wan_udp_pkt->wan_udp_data_len = 0x00;
	 		wan_udp_pkt->wan_udp_data[0] = 
		    	wan_udp_pkt->wan_udp_data_len = sizeof(unsigned char); 
			wan_udp_pkt->wan_udp_return_code = 0;
			mb->wan_data_len = sizeof(unsigned char);
			  	*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
					card->wandev.fe_iface.read_alarm(
							&card->fe, 0);
    				card->wandev.fe_iface.read_pmon(&card->fe); 
	        		memcpy(&wan_udp_pkt->wan_udp_data[sizeof(unsigned long)],
					&card->wandev.te_pmon,
		        	wan_udp_pkt->wan_udp_return_code = 0;
		    		wan_udp_pkt->wan_udp_data_len = 
				mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
				card->wandev.k56_alarm = sdla_56k_alarm(card, 1); 
			 	*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
			                        card->wandev.k56_alarm;
				wan_udp_pkt->wan_udp_return_code = 0;
	    			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
				mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
				card->wandev.fe_iface.flush_pmon(&card->fe);
	        		wan_udp_pkt->wan_udp_return_code = 0;
        			memcpy(&wan_udp_pkt->wan_udp_data[0],
					&card->wandev.te_cfg,
		        	wan_udp_pkt->wan_udp_return_code = 0;
	    			wan_udp_pkt->wan_udp_data_len = sizeof(sdla_te_cfg_t);
				mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
		   	wan_udp_pkt->wan_udp_data[0] = card->wandev.config_id;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_LINUX_PLATFORM;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len  = wan_udp_pkt->wan_udp_data_len = 1;
				memcpy(&mb->wan_command,
					&wan_udp_pkt->wan_udp_command,
				if(mb->wan_data_len) {
					memcpy(&mb->wan_data,
						(char *)wan_udp_pkt->wan_udp_data,
						mb->wan_data_len);
				err = card->hw_iface.cmd(card->hw, card->mbox_off, mb); 
			} while (err && c_retry-- && fr_event(card, err, mb));
				chan->drvstats_gen.
                                chan->drvstats_gen.
			memcpy(&wan_udp_pkt->wan_udp_hdr.wan_cmd, mb, sizeof(wan_cmd_t)); 
                       	if(mb->wan_data_len) {
                               	memcpy(&wan_udp_pkt->wan_udp_data,
					&mb->wan_data, mb->wan_data_len);
        wan_udp_pkt->wan_ip_ttl = card->wandev.ttl;
		wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
       	len = reply_udp((u8*)&card->u.f.udp_pkt_data, mb->wan_data_len);
		chan->fr_header_len=2;
		chan->fr_header[0]=chan->fr_encap_0;
		chan->fr_header[1]=chan->fr_encap_1;
			(u8*)&card->u.f.udp_pkt_data,chan->fr_header_len,0);
			chan->drvstats_gen.UDP_PIPE_mgmt_adptr_send_passed ++;
			chan->drvstats_gen.UDP_PIPE_mgmt_adptr_send_failed ++;
			memcpy(buf, (u8*)&card->u.f.udp_pkt_data, len);
			chan->drvstats_gen.
			new_skb->dev = dev;
			new_skb->protocol = htons(ETH_P_IP);
			DEBUG_SUB_MEM(new_skb->truesize);
			chan->drvstats_gen.UDP_PIPE_mgmt_no_socket ++;
			card->devname);
	atomic_set(&card->u.f.udp_pkt_len,0);
	fr_channel_t *chan = dev->priv;
	in_dev = dev->ip_ptr;
		ArpPacket->control	= 0x03;
		ArpPacket->pad		= 0x00;
		ArpPacket->NLPID	= 0x80;
		ArpPacket->OUI[0]	= 0;
		ArpPacket->OUI[1]	= 0;
		ArpPacket->OUI[2]	= 0;
		ArpPacket->PID		= 0x0608;
		arphdr->ar_hrd = 0x0F00;	/* Frame Relay HW type */
		arphdr->ar_pro = 0x0008;	/* IP Protocol	       */
		arphdr->ar_hln = 2;		/* HW addr length      */
		arphdr->ar_pln = 4;		/* IP addr length      */
		arphdr->ar_op = htons(0x08);	/* InARP Request       */
		arphdr->ar_sha = 0; 		/* src HW DLCI - Doesn't matter */
		if(in_dev->ifa_list != NULL)
			arphdr->ar_sip = in_dev->ifa_list->ifa_local;  /* Local Address       */else
			arphdr->ar_sip = 0;
		arphdr->ar_tha = 0; 		/* dst HW DLCI - Doesn't matter */
		arphdr->ar_tip = 0;		/* Remote Address -- what we want */
		err = fr_send(card, chan->dlci, 0, sizeof(arphdr_1490_t) + sizeof(arphdr_fr_t),
				card->devname, chan->dlci);
				card->devname,dev->name);
		return -EINVAL;
	if (arphdr->pad   == 0x00  &&
	    arphdr->NLPID == 0x80  &&
	    arphdr->PID   == 0x0608) 
	fr_channel_t *chan = dev->priv;		
	in_dev = dev->ip_ptr;
	if (in_dev == NULL || in_dev->ifa_list == NULL){ 
		err = -1;
	switch (ntohs(arphdr->ar_op)) {
	case 0x08:  // Inverse ARP request  -- Send Reply, add route.
		printk(KERN_INFO "%s: Recvd PtP addr -InArp Req: %u.%u.%u.%u\n", 
			card->devname, NIPQUAD(arphdr->ar_sip));
		if (in_dev->ifa_list->ifa_mask != 0xFFFFFFFF && 
		    (in_dev->ifa_list->ifa_mask & arphdr->ar_sip) != 
		    (in_dev->ifa_list->ifa_mask & in_dev->ifa_list->ifa_local)){
					card->devname,NIPQUAD(arphdr->ar_sip));
				card->devname, NIPQUAD(in_dev->ifa_list->ifa_mask));
				card->devname,NIPQUAD(in_dev->ifa_list->ifa_local));
			err = -1;
		if (in_dev->ifa_list->ifa_local == arphdr->ar_sip){
					card->devname);
			err = -1;
		arphdr->ar_op = htons(0x09);	/* InARP Reply */
		arphdr->ar_tip = arphdr->ar_sip;
		arphdr->ar_sip = in_dev->ifa_list->ifa_local;
		chan->ip_local = in_dev->ifa_list->ifa_local;
		chan->ip_remote = arphdr->ar_sip;
		printk(KERN_INFO "%s: Recvd PtP addr %u.%u.%u.%u -InArp Reply\n", 
				card->devname, NIPQUAD(arphdr->ar_sip));
		if (in_dev->ifa_list->ifa_mask != 0xffffffff &&
		    (in_dev->ifa_list->ifa_mask & arphdr->ar_sip) != 
			(in_dev->ifa_list->ifa_mask & in_dev->ifa_list->ifa_local)) {
					card->devname);
			err = -1;
		if (in_dev->ifa_list->ifa_local == arphdr->ar_sip) {
				card->devname);
			err = -1;
		chan->ip_local  = in_dev->ifa_list->ifa_local;
		chan->ip_remote = arphdr->ar_sip;
		chan->route_flag = ADD_ROUTE;
		chan->inarp = INARP_CONFIGURED;
	default:  // ARP's and RARP's -- Shouldn't happen.
				card->devname, ntohs(arphdr->ar_op));
	fr_channel_t* chan = dev->priv;
	del_timer(&chan->fr_arp_timer);
	chan->fr_arp_timer.expires = jiffies + (chan->inarp_interval * HZ);
	add_timer(&chan->fr_arp_timer);
	fr_channel_t *chan = dev->priv;
	sdla_t *card = chan->card;
	if (chan->inarp == INARP_REQUEST &&
	    chan->common.state == WAN_CONNECTED && 
	    card->wandev.state == WAN_CONNECTED){
		set_bit(0,&chan->inarp_ready);
		card->u.f.timer_int_enabled |= TMR_INT_ENABLED_ARP;
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, FR_INTR_TIMER);
	wan_mbox_t* mb = &card->wan_mbox;
        err = fr_set_intr_mode(card, FR_INTR_READY, card->wandev.mtu, 0 );
			mb->wan_data_len  = 0;
			mb->wan_command = FR_READ_CODE_VERSION;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	err = fr_set_intr_mode( card, 0, card->wandev.mtu, 0 );
	wan_udp_pkt_t *wan_udp_pkt = (wan_udp_pkt_t *)skb->data;
	if (skb->len < sizeof(wan_udp_pkt_t)){
		wan_udp_pkt = (wan_udp_pkt_t *)&skb->data[2];
        if((wan_udp_pkt->wan_ip_p == UDPMGMT_UDP_PROTOCOL) &&
		(wan_udp_pkt->wan_udp_dport == ntohs(card->wandev.udp_port)) &&
		(wan_udp_pkt->wan_udp_request_reply == UDPMGMT_REQUEST)) {
                        if(!strncmp(wan_udp_pkt->wan_udp_signature,
			if(!strncmp(wan_udp_pkt->wan_udp_signature,
        memset(&chan->drvstats_if_send.if_send_entry, 0,
        memset(&chan->drvstats_rx_intr.rx_intr_no_socket, 0,
        memset(&chan->drvstats_gen.UDP_PIPE_mgmt_kmalloc_err, 0,
        memset(&card->statistics.isr_entry, 0, sizeof(global_stats_t));
	wan_mbox_t* mb = &card->wan_mbox;
		mb->wan_command = FR_READ_DLCI_IB_MAPPING;
		mb->wan_data_len = 0;	
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	} while (err && retry-- && fr_event(card, err, mb));
	if( mb->wan_return_code != 0){
			chan->name);
	counter = mb->wan_data_len / sizeof(dlci_IB_mapping_t);
	result = (void *)mb->wan_data;
	for (; counter; --counter, ++result) {
		if ( result->dlci == chan->dlci ) {
			chan->IB_addr = result->addr_value;
	             	chan->dlci_int_interface_off = chan->IB_addr;
	             	chan->dlci_int_off = 
				chan->IB_addr + offsetof(fr_dlci_interface_t, gen_interrupt);
		card->devname, chan->dlci);
	if (card->type != SDLA_S514){
		spin_lock_irqsave(&card->wandev.lock, *smp_flags);
		spin_lock(&card->u.f.if_send_lock);
	if (card->type != SDLA_S514){
		spin_unlock_irqrestore (&card->wandev.lock, *smp_flags);
		spin_unlock(&card->u.f.if_send_lock);
	if (card->type == SDLA_S514){
		spin_lock_irqsave(&card->wandev.lock, *smp_flags);		
	if (card->type == SDLA_S514){
		spin_unlock_irqrestore(&card->wandev.lock, *smp_flags);		
/*----------------------------------------------------------------------
 ----------------------------------------------------------------------*/
	sdla_t *card = chan->card;
		len=skb->len;
			card->wandev.stats.rx_packets++;
			card->wandev.stats.rx_bytes += len;
			chan->ifstats.rx_packets++;
			chan->ifstats.rx_bytes += len;
			chan->drvstats_rx_intr.rx_intr_bfr_passed_to_stack ++;
			++card->wandev.stats.rx_dropped;
			++chan->ifstats.rx_dropped;
	WAN_TASKLET_END((&chan->common.bh_task));
/*----------------------------------------------------------------------
 ----------------------------------------------------------------------*/
	fr_channel_t* chan = dev->priv;
	WAN_TASKQ_SCHEDULE((&chan->fr_poll_task));
	dev=chan->common.dev;
	if (!dev || (chan = dev->priv) == NULL) {
	card = chan->card;
	if (test_bit(PERI_CRIT,&card->wandev.critical)){
	switch (chan->common.state){
		if (test_bit(DYN_OPT_ON,&chan->interface_down) &&
		    !test_bit(DEV_DOWN, &chan->interface_down) &&
		    dev->flags&IFF_UP){
				card->devname,dev->name);
			change_dev_flags(dev,dev->flags&~IFF_UP);
			set_bit(DEV_DOWN, &chan->interface_down);
			chan->route_flag = NO_ROUTE;
			if (chan->inarp != INARP_NONE)
		if (test_bit(DYN_OPT_ON,&chan->interface_down) &&
		    test_bit(DEV_DOWN, &chan->interface_down) &&
		    !(dev->flags&IFF_UP)){
					card->devname,dev->name);
			change_dev_flags(dev,dev->flags|IFF_UP);
			clear_bit(DEV_DOWN, &chan->interface_down);
		if (chan->inarp != INARP_NONE){
		if (chan->gateway && check_gateway)
	if (card->type == SDLA_S514){
		if (test_bit(SEND_CRIT, (void*)&card->wandev.critical) ||
			test_bit(SEND_TXIRQ_CRIT, (void*)&card->wandev.critical)) {
	if (is_queue_stopped(dev) || (atomic_read(&card->u.f.tx_interrupts_pending)))
	if (atomic_read(&card->wandev.if_cnt) == 1){
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (devle->dev == dev){
				dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	fr_channel_t *chan=dev->priv;
	if (card->wandev.signalling == WANOPT_NO){
				card->wandev.name);
				card->devname, chan->dlci);
	if (card->wandev.station == WANOPT_CPE) {
		if (card->u.f.issue_fs_on_startup && 
		    (atomic_read(&card->wandev.if_cnt) == atomic_read(&card->wandev.if_up_cnt))){
			card->u.f.issue_fs_on_startup=0;
			fr_add_dlci(card, chan->dlci);
			fr_activate_dlci(card, chan->dlci);
	if (!card->u.f.auto_dlci_cfg){
		card->u.f.dlci_to_dev_map[chan->dlci] = dev;
	fr_channel_t *chan=dev->priv;
	if (card->wandev.station == WANOPT_NODE){
				card->devname,chan->dlci);
		fr_delete_dlci(card,chan->dlci);
	if (!card->u.f.auto_dlci_cfg){
		card->u.f.dlci_to_dev_map[chan->dlci] = NULL;
	fr_channel_t *chan=dev->priv;
		switch (htons(skb->protocol)){
			chan->fr_header[0]=chan->fr_encap_0;
			chan->fr_header[1]=chan->fr_encap_1;
			chan->fr_header[0]=Q922_UI;
			chan->fr_header[1]=0;
			chan->fr_header[2]=NLPID_SNAP;
			chan->fr_header[3]=0;
			chan->fr_header[4]=0;
			chan->fr_header[5]=0;
			*((unsigned short*)&chan->fr_header[6]) = skb->protocol;
			return -EINVAL;
			dev->name);
		chan->fr_header[0] = 0x03;
		chan->fr_header[1] = 0x00;
		chan->fr_header[2] = 0x80;
		chan->fr_header[3] = 0x00;
		chan->fr_header[4] = 0x80;
		chan->fr_header[5] = 0xC2;
		chan->fr_header[6] = 0x00;
		chan->fr_header[7] = 0x07;
		skb->protocol = ETH_P_802_3;
	wan_mbox_t* mb = &card->wan_mbox;
	unsigned short dlci_num = chan->dlci;
	mb->wan_command = FR_READ_CONFIG;
	mb->wan_data_len = 0;
	mb->wan_fr_dlci = dlci_num; 	
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
			card->devname,dlci_num);
	mb->wan_command = FR_COMM_DISABLE;
	mb->wan_data_len = 0;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			card->devname);
	mb->wan_command = FR_READ_CONFIG;
	mb->wan_data_len = 0;
	mb->wan_fr_dlci = 0; 	
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	conf = (fr_conf_t *)mb->wan_data;
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		conf->dlci[dlci_offset] = chan_tmp->dlci;		
	mb->wan_data_len = 0x20 + dlci_offset*2;
	mb->wan_command = FR_SET_CONFIG;
	mb->wan_fr_dlci = 0; 
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			card->devname,dlci_num);
			card->devname);
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		fr_add_dlci(card, chan_tmp->dlci);
		fr_activate_dlci(card, chan_tmp->dlci);
	card->hw_iface.peek(card->hw, buf_info_off, &buf_info, sizeof(buf_info));
	card->rxmb_off = buf_info.rse_next;
	card->u.f.rxmb_base_off = buf_info.rse_base; 
	card->u.f.rxmb_last_off =
			(buf_info.rse_num - 1) * sizeof(fr_rx_buf_ctl_t) +
	card->u.f.rx_base_off = buf_info.buf_base;
	card->u.f.rx_top_off  = buf_info.buf_top;
	atomic_set(&card->u.f.tx_interrupts_pending,0);
	wan_mbox_t* mb = &card->wan_mbox;
	ADAPTER_CONFIGURATION_STRUCT* cfg = (ADAPTER_CONFIGURATION_STRUCT*)mb->wan_data;
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &cfg->adapter_type); 
	cfg->adapter_config = 0x00; 
	cfg->operating_frequency = 00; 
	mb->wan_data_len = sizeof(ADAPTER_CONFIGURATION_STRUCT);
	mb->wan_command = SET_ADAPTER_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
#define PROC_CFG_FRM	"%-15s| %-12s| %-5u|\n"
#define PROC_STAT_FRM	"%-15s| %-12s| %-14s|\n"
	sdla_t*		card = chan->card;
		return m->count;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		PROC_CFG_FRM, chan->name, card->devname, chan->dlci);
	return m->count;
	sdla_t*		card = chan->card;
		return m->count;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		PROC_STAT_FRM, chan->name, card->devname, STATE_DECODE(chan->common.state));
	return m->count;
#define PROC_DEV_FR_S_FRM	"%-20s| %-14s|\n"
#define PROC_DEV_FR_D_FRM	"%-20s| %-14d|\n"
	card = (sdla_t*)wandev->priv;
			wandev->name, buffer);
#define PROC_IF_FR_S_FRM	"%-30s\t%-14s\n"
#define PROC_IF_FR_D_FRM	"%-30s\t%-14d\n"
#define PROC_IF_FR_L_FRM	"%-30s\t%-14ld\n"
	fr_channel_t* 	chan = (fr_channel_t*)dev->priv;
	sdla_t*		card = chan->card;
	if (dev == NULL || dev->priv == NULL)
	chan = (fr_channel_t*)dev->priv;
	if (chan->card == NULL)
	card = chan->card;
			chan->name, buffer);
	if (card->wandev.ignore_front_end_status == WANOPT_YES){
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (card->fe.fe_status == FE_CONNECTED){ 
			if (chan->dlci_stat & FR_DLCI_ACTIVE &&
			    card->wandev.state == WAN_CONNECTED &&
			    chan->common.state != WAN_CONNECTED){
			if (chan->common.state != WAN_DISCONNECTED){
				if (chan->route_flag == ROUTE_ADDED) {
					chan->route_flag = REMOVE_ROUTE;
				if (chan->inarp == INARP_CONFIGURED) {
					chan->inarp = INARP_REQUEST;
	if (dev == NULL || dev->priv == NULL)
		return -EFAULT;
	chan = (fr_channel_t*)dev->priv;
	if (card->wandev.update) {
		card->u.f.update_dlci = chan;
		rslt = card->wandev.update(&card->wandev);
			return (rslt) ? (-EBUSY) : (-EINVAL);
	switch(snmp->snmp_magic){
		 snmp->snmp_val = 
		 (card->wandev.signalling == WANOPT_FR_ANSI) ? SNMP_FR_ANSIT1617D :
		 (card->wandev.signalling == WANOPT_FR_Q933) ? SNMP_FR_ITUT933A :
		 (card->wandev.signalling == WANOPT_FR_LMI) ? SNMP_FR_LMIREV:
		snmp->snmp_val = SNMP_FR_Q922;
		snmp->snmp_val = SNMP_FR_4BYTE_ADDR;
		snmp->snmp_val = card->u.f.t391;
		snmp->snmp_val = card->u.f.n391;
		snmp->snmp_val = card->u.f.n392;
		snmp->snmp_val = card->u.f.n393;
		snmp->snmp_val = HIGHEST_VALID_DLCI;
		snmp->snmp_val = SNMP_FR_NONBROADCAST;
		snmp->snmp_val = SNMP_FR_RUNNING;
		snmp->snmp_val = 0;
		snmp->snmp_val = chan->dlci;
		snmp->snmp_val = (chan->common.state == WAN_CONNECTED) ? SNMP_FR_ACTIVE : SNMP_FR_INACTIVE;
		snmp->snmp_val = chan->rx_FECN;
		snmp->snmp_val = chan->rx_BECN;
		snmp->snmp_val = chan->ifstats.tx_packets;
		snmp->snmp_val = chan->ifstats.tx_bytes;
		snmp->snmp_val = chan->ifstats.rx_packets;
		snmp->snmp_val = chan->ifstats.rx_bytes;
		snmp->snmp_val = tv.tv_sec - chan->router_start_time;
		snmp->snmp_val = tv.tv_sec - chan->router_last_change;
		snmp->snmp_val = (unsigned long)chan->bc;
		snmp->snmp_val = (unsigned long)chan->be;
		snmp->snmp_val = (unsigned long)0;
		snmp->snmp_val = (chan->mc) ? SNMP_FR_ONEWAY : SNMP_FR_UNICAST;
		snmp->snmp_val = chan->dlci_type;
		snmp->snmp_val = chan->ifstats.rx_errors;
		snmp->snmp_val = chan->rx_DE_set;
		snmp->snmp_val = chan->tx_DE_set;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = chan->err_type;
		strcpy((void*)snmp->snmp_data, chan->err_data);
		snmp->snmp_val = chan->err_time;
		snmp->snmp_val = chan->err_faults;
		snmp->snmp_val = (unsigned long)0;
		snmp->snmp_val = chan->trap_state;
		snmp->snmp_val = chan->trap_max_rate;
            	return -EAFNOSUPPORT;
	if (card->wan_debugging_state == WAN_DEBUGGING_CONT && 
	    card->wandev.station == WANOPT_CPE){
		card->wan_debugging_state = WAN_DEBUGGING_PROTOCOL;
	if (card->wandev.station == WANOPT_CPE){
		if (card->wan_debug_last_msg != WAN_DEBUG_FR_CPE_MSG){
						card->devname);
						card->devname);
		card->wan_debug_last_msg = WAN_DEBUG_FR_CPE_MSG;
		if (card->wan_debug_last_msg != WAN_DEBUG_FR_NODE_MSG){
						card->devname);
		card->wan_debug_last_msg = WAN_DEBUG_FR_NODE_MSG;
	wan_mbox_t*	mb = &card->wan_mbox;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		fr_comm_stat_t* err_stats = (void*)mb->wan_data;
		rx_bad_crc = err_stats->rx_bad_crc;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	wan_mbox_t*	mb = &card->wan_mbox;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		fr_comm_stat_t* err_stats = (void*)mb->wan_data;
		rx_aborts = err_stats->rx_aborts;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	wan_mbox_t*	mb = &card->wan_mbox;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		fr_comm_stat_t* err_stats = (void*)mb->wan_data;
		tx_missed_undr = err_stats->tx_missed_undr;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
./sdla_fr.c
	((type) == WP_RM_POLL_EVENT) ? "RM-Event":				\
	((type) == WP_RM_POLL_TXSIG_OFFHOOK) ? "TX Sig Off-hook":		\
	((type) == WP_RM_POLL_TXSIG_ONHOOK) ? "TX Sig On-hook":			\
	((type) == WP_RM_POLL_ONHOOKTRANSFER) ? "On-hook transfer":		\
	((type) == WP_RM_POLL_RXSIG_OFFHOOK) ? "RX Sig Off-hook":		\
	((type) == WP_RM_POLL_RXSIG_ONHOOK) ? "RX Sig On-hook":			\
** OSC1= 350 Hz OSC2= 440 Hz .0975 Volts -18 dBm */
** OSC1= 480  OSC2 = 620 .0975 Voltz -18 dBm 8 */
** OSC1 = 440 Hz OSC2 = 480 .0975 Volts -18 dBm */
** OSC1= 480 Hz OSC2 = 620 .0975 Volts -18 dBM */
#define DEFAULT_OH_THRESH     	10      /* Anything under this is "off-hook" */
				fe->name, address, data);
				fe->name, mod_no, address);
		return -EINVAL;
	int res = -1;
				fe->name, mod_no);
		return -EINVAL;
	DEBUG_CFG("%s: Initializing Indirect Registers...\n", fe->name);
			return -1;
	DEBUG_CFG("%s: Initializing Indirect Registers...Done!\n", fe->name);
	DEBUG_CFG("%s: Verifing Indirect Registers...\n", fe->name);
						fe->name, mod_no+1,
			return -1;
						fe->name, mod_no+1,
						fe->name, mod_no+1);
		return -1;
	DEBUG_CFG("%s: Verifing Indirect Registers...Done!\n", fe->name);
** wp_remora_chain_enable() - 
	WAN_ASSERT_RC(fe->reset_fe == NULL,0);
			fe->rm_param.mod[mod_no].type = MOD_TYPE_FXO;
		fe->rm_param.mod[4].type = MOD_TYPE_FXS;
	for(mod_no = 0;mod_no < fe->rm_param.max_fe_channels; mod_no ++){
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_NONE){
					fe->name, mod_no+1);
				fe->rm_param.mod[mod_no].type	=
					fe->name, mod_no+1);
				fe->rm_param.mod[mod_no].type	=
	fe->reset_fe(fe);
	for(mod_no = 0;mod_no < fe->rm_param.max_fe_channels; mod_no ++){
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_NONE){
						fe->name, mod_no+1);
				fe->rm_param.mod[mod_no].type	=
	fe->reset_fe(fe);
	for(mod_no = 0;mod_no < fe->rm_param.max_fe_channels; mod_no ++){
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS && mod_no % 2 == 0){
						fe->name, mod_no+1, byte);
				return -EINVAL;
		}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
				fe->rm_param.mod[mod_no].type	= MOD_TYPE_NONE;
		}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_TEST){
			fe->name, mod_no+1,
			WP_REMORA_DECODE_TYPE(fe->rm_param.mod[mod_no].type));	
		fe->rm_param.mod[mod_no].chain	= MOD_CHAIN_ENABLED;
					fe->name,
		return -1;
					fe->name);
		return -1;
					fe->name,
		return -1;
					fe->name, mod_no+1, value);
		return -1;
					fe->name, mod_no+1, value);
		return -1;
					fe->name, mod_no+1, value);
		return -1;
	DEBUG_CFG("%s: PowerUp SLIC initialization...\n", fe->name);
	fxs = &fe->rm_param.mod[mod_no].u.fxs;
	/* set the period of the DC-DC converter to 1/64 kHz  START OUT SLOW*/
		if ((SYSTEM_TICKS - start_ticks) > HZ/2){
		if (fxs->proslic_power == PROSLIC_POWER_UNKNOWN){
					fe->name,
					(u_int32_t)(((SYSTEM_TICKS - start_ticks) * 1000 / HZ)),
					fe->name,
		fxs->proslic_power = PROSLIC_POWER_WARNED;
		return -1;
	fxs->proslic_power = PROSLIC_POWER_ON;
					fe->name, mod_no+1,
        lim = (loopcurrent - 20) / 3;
					fe->name, mod_no+1);
					fe->name,
	WRITE_RM_REG(mod_no, 93, 0x99);  /* DC-DC Calibration  */
	/* Wait for DC-DC Calibration to complete */
		if ((SYSTEM_TICKS - start_ticks) > 2*HZ){
			"%s: Module %d: Timeout waiting for DC-DC calibration (%02X)\n",
						fe->name, mod_no+1,
			return -EINVAL;
	DEBUG_CFG("%s: PowerUp SLIC initialization...Done!\n", fe->name);
	DEBUG_CFG("%s: PowerLeak ProSLIC testing...\n", fe->name);
					fe->name, mod_no+1,
					(u_int32_t)((SYSTEM_TICKS - start_ticks) * 1000 / HZ));
		return -1;
	DEBUG_RM("%s: Module %d: Post-leakage voltage: %d volts\n",
					fe->name,
	DEBUG_CFG("%s: PowerLeak ProSLIC testing...Done!\n", fe->name);
	DEBUG_CFG("%s: ProSLIC calibration...\n", fe->name);
		if ((SYSTEM_TICKS - start_ticks) > 2*HZ){
					fe->name, mod_no+1);
			return -1;
	DEBUG_CFG("%s: ProSLIC calibration...Done!\n", fe->name);
	DEBUG_CFG("%s: ProSLIC manual calibration...\n", fe->name);
		if ((SYSTEM_TICKS - start_ticks) > 800){
					fe->name, mod_no+1);
			return -1;
	for (i = 0x1f; i > 0; i--){
	for (i = 0x1f; i > 0; i--){
		if ((SYSTEM_TICKS - start_ticks) > 400){
				fe->name, mod_no+1,
			return -1;
				fe->name, mod_no+1);
	DEBUG_CFG("%s: ProSLIC manual calibration...Done!\n", fe->name);
	if (fe->fe_cfg.cfg.remora.reversepolarity){
		fe->rm_param.mod[mod_no].u.fxs.idletxhookstate = 5;
		fe->rm_param.mod[mod_no].u.fxs.idletxhookstate = 1;
	DEBUG_CFG("%s: Start ProSLIC configuration...\n", fe->name);
		return -2;
		fe->rm_param.mod[mod_no].u.fxs.proslic_power = PROSLIC_POWER_UNKNOWN;
							fe->name,
		return -1;
	/* Power up the DC-DC converter */
					fe->name,
		return -1;
						fe->name,
						fe->name,
			return -1;
			return -1;
			return -1;
		/* Perform DC-DC calibration */
			"%s: Module %d: DC-DC calibration has a surprising direct 107 of 0x%02x!\n",
						fe->name,
			fe->rm_param.mod[mod_no].u.fxs.callregs.vals[x] =
				fe->rm_param.mod[mod_no].u.fxs.callregs.vals[x]);
					fe->name,
		return -1;
	if (fe->fe_cfg.tdmv_law == WAN_TDMV_ALAW){
	}else if (fe->fe_cfg.tdmv_law == WAN_TDMV_MULAW){
	/* U-Law 8-bit interface */
	if (!strcmp(fxo_modes[fe->fe_cfg.cfg.remora.opermode].name, "AUSTRALIA") ||
	    !strcmp(fxo_modes[fe->fe_cfg.cfg.remora.opermode].name, "TBR21")) {
		value = (unsigned char)acim2tiss[fxo_modes[fe->fe_cfg.cfg.remora.opermode].acim];
		if (fxo_modes[fe->fe_cfg.cfg.remora.opermode].ring_osc){
				(unsigned short)fxo_modes[fe->fe_cfg.cfg.remora.opermode].ring_osc);
		if (fxo_modes[fe->fe_cfg.cfg.remora.opermode].ring_x){
				(unsigned short)fxo_modes[fe->fe_cfg.cfg.remora.opermode].ring_x);
	if (fe->fe_cfg.cfg.remora.fxs_lowpower == WANOPT_YES){
	if (fe->fe_cfg.cfg.remora.fxs_fastringer == WANOPT_YES){
		if (!strcmp(fxo_modes[fe->fe_cfg.cfg.remora.opermode].name, "AUSTRALIA")) {
				return -1;
					fe->name, mod_no + 1);
		} else if (fe->fe_cfg.cfg.remora.fxs_lowpower == WANOPT_YES){
				return -1;
					fe->name, mod_no + 1);
					fe->name, mod_no + 1);
		if (!strcmp(fxo_modes[fe->fe_cfg.cfg.remora.opermode].name, "AUSTRALIA")) {
			if (fe->fe_cfg.cfg.remora.fxs_ringampl){
				switch(fe->fe_cfg.cfg.remora.fxs_ringampl){
							fe->name,mod_no+1, fe->fe_cfg.cfg.remora.fxs_ringampl, ringx, vbath);
							fe->name, mod_no+1); 
							fe->name, mod_no+1, fe->fe_cfg.cfg.remora.fxs_ringampl); 
					return -1;
						fe->name, mod_no+1);
		} else if (fe->fe_cfg.cfg.remora.fxs_lowpower == WANOPT_YES){
				return -1;
						fe->name, mod_no+1);
	if (fe->fe_cfg.cfg.remora.fxs_txgain || fe->fe_cfg.cfg.remora.fxs_rxgain) {
					fe->name, mod_no+1,
					(fe->fe_cfg.cfg.remora.fxs_txgain == 35) ? "3.5dB":
					(fe->fe_cfg.cfg.remora.fxs_txgain == -35) ? "-3.5dB":"0dB");
		switch (fe->fe_cfg.cfg.remora.fxs_txgain) {
		case -35:
					fe->name, mod_no+1,
					(fe->fe_cfg.cfg.remora.fxs_rxgain == 35) ? "3.5dB":
					(fe->fe_cfg.cfg.remora.fxs_rxgain == -35) ? "-3.5dB":"0dB");
		switch (fe->fe_cfg.cfg.remora.fxs_rxgain) {
		case -35:
		fe->rm_param.mod[mod_no].u.fxs.imask1 = 0x00;
		fe->rm_param.mod[mod_no].u.fxs.imask2 = 0x03;
		fe->rm_param.mod[mod_no].u.fxs.imask3 = 0x01;
		fe->rm_param.mod[mod_no].u.fxs.imask1 = 0x00;
		fe->rm_param.mod[mod_no].u.fxs.imask2 = 0xFC;
		fe->rm_param.mod[mod_no].u.fxs.imask3 = 0x00;
					fe->name, mod_no+1,
			if ((SYSTEM_TICKS - start_ticks) > HZ*10){
						fe->name,
			return -1;
				fe->name,
		return -1;
					fe->name, mod_no+1,
	DEBUG_CFG("%s: Start ProSLIC configuration...Done!\n", fe->name);
		return -2;
				fe->name,
		return -2;
	if (fe->fe_cfg.tdmv_law == WAN_TDMV_ALAW){
	}else if (fe->fe_cfg.tdmv_law == WAN_TDMV_MULAW){
	/* Set On-hook speed, Ringer impedence, and ringer threshold */
	reg16 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].ohs << 6);
	reg16 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].rz << 1);
	reg16 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].rt);
	reg26 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].dcv << 6);
	reg26 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].mini << 4);
	reg26 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].ilim << 1);
	reg30 = (unsigned char)(fxo_modes[fe->fe_cfg.cfg.remora.opermode].acim);
	reg31 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].ohs2 << 3);
	/* Enable ISO-Cap */
		/* Wait 1000ms for ISO-cap to come up */
						fe->name,
			return -1;
		DEBUG_TEST("%s: Module %d: ISO-Cap is now up, line side: %02x rev %02x\n", 
				fe->name,
	/* Enable on-hook line monitor */
	fe->rm_param.mod[mod_no].u.fxo.imask = 0xFF;
	fe->rm_param.mod[mod_no].u.fxo.imask = 0x00;
	if (fe->fe_cfg.cfg.remora.fxo_txgain) {
		if (fe->fe_cfg.cfg.remora.fxo_txgain >= -150 && fe->fe_cfg.cfg.remora.fxo_txgain < 0) {
					fe->name, mod_no+1,
					fe->fe_cfg.cfg.remora.fxo_txgain / 10,
					fe->fe_cfg.cfg.remora.fxo_txgain % -10);
			WRITE_RM_REG(mod_no, 38, 16 + (fe->fe_cfg.cfg.remora.fxo_txgain/-10));
			if(fe->fe_cfg.cfg.remora.fxo_txgain % 10) {
				WRITE_RM_REG(mod_no, 40, 16 + (-fe->fe_cfg.cfg.remora.fxo_txgain%10));
		else if (fe->fe_cfg.cfg.remora.fxo_txgain <= 120 && fe->fe_cfg.cfg.remora.fxo_txgain > 0) {
					fe->name, mod_no+1,
					fe->fe_cfg.cfg.remora.fxo_txgain / 10,
					fe->fe_cfg.cfg.remora.fxo_txgain % 10);
			WRITE_RM_REG(mod_no, 38, fe->fe_cfg.cfg.remora.fxo_txgain/10);
			if (fe->fe_cfg.cfg.remora.fxo_txgain % 10){
				WRITE_RM_REG(mod_no, 40, (fe->fe_cfg.cfg.remora.fxo_txgain % 10));
	if (fe->fe_cfg.cfg.remora.fxo_rxgain) {
		if (fe->fe_cfg.cfg.remora.fxo_rxgain >= -150 && fe->fe_cfg.cfg.remora.fxo_rxgain < 0) {
					fe->name, mod_no+1,
					fe->fe_cfg.cfg.remora.fxo_rxgain / 10,
					(-1) * (fe->fe_cfg.cfg.remora.fxo_rxgain % 10));
			WRITE_RM_REG(mod_no, 39, 16 + (fe->fe_cfg.cfg.remora.fxo_rxgain/-10));
			if(fe->fe_cfg.cfg.remora.fxo_rxgain%10) {
				WRITE_RM_REG(mod_no, 41, 16 + (-fe->fe_cfg.cfg.remora.fxo_rxgain%10));
		}else if (fe->fe_cfg.cfg.remora.fxo_rxgain <= 120 && fe->fe_cfg.cfg.remora.fxo_rxgain > 0) {
					fe->name, mod_no+1,
					fe->fe_cfg.cfg.remora.fxo_rxgain / 10,
					fe->fe_cfg.cfg.remora.fxo_rxgain % 10);
			WRITE_RM_REG(mod_no, 39, fe->fe_cfg.cfg.remora.fxo_rxgain/10);
			if(fe->fe_cfg.cfg.remora.fxo_rxgain % 10) {
				WRITE_RM_REG(mod_no, 41, (fe->fe_cfg.cfg.remora.fxo_rxgain%10));
	/* NZ -- crank the tx gain up by 7 dB */
	if (!strcmp(fxo_modes[fe->fe_cfg.cfg.remora.opermode].name, "NEWZEALAND")) {
					fe->name,
	if (fe->fe_cfg.cfg.remora.rm_mode == WAN_RM_TAPPING) {
		DEBUG_EVENT("%s: Module %d: FXO Tapping enabled.\n", fe->name, mod_no+1);
	if (fe->fe_cfg.cfg.remora.rm_mode == WAN_RM_TAPPING) {
		 if (!fe->fe_cfg.cfg.remora.ohthresh) {
			 fe->fe_cfg.cfg.remora.ohthresh = DEFAULT_OH_THRESH;
		 DEBUG_EVENT("%s: Module:%d: Off-hook threshold: %dv\n", fe->name, mod_no+1, fe->fe_cfg.cfg.remora.ohthresh);
	fe->rm_param.mod[mod_no].u.fxo.going_offhook = 0;
** wp_remora_iface_init) - 
	fe_iface->config	= &wp_remora_config;
	fe_iface->unconfig	= &wp_remora_unconfig;
	fe_iface->post_init	= &wp_remora_post_init;
	fe_iface->if_config	= &wp_remora_if_config;
	fe_iface->if_unconfig	= &wp_remora_if_unconfig;
	fe_iface->pre_release	= &wp_remora_pre_release;
	fe_iface->active_map	= &wp_remora_active_map;
	fe_iface->isr		= &wp_remora_intr;
	fe_iface->disable_irq	= &wp_remora_disable_irq;
	fe_iface->check_isr	= &wp_remora_check_intr;
	fe_iface->polling	= &wp_remora_polling;
	fe_iface->process_udp	= &wp_remora_udp;
	fe_iface->get_fe_media	= &wp_remora_fe_media;
	fe_iface->set_dtmf	= &wp_remora_set_dtmf;
	fe_iface->intr_ctrl	= &wp_remora_intr_ctrl;
	fe_iface->event_ctrl	= &wp_remora_event_ctrl;
	fe_iface->watchdog	= &wp_remora_watchdog;
	fe_iface->get_fe_status = &wp_remora_get_link_status;
	WAN_LIST_INIT(&fe->event);
	wan_spin_lock_irq_init(&fe->lockirq, "wan_rm_lock");
** wp_remora_opermode() - 
	sdla_fe_cfg_t	*fe_cfg = &fe->fe_cfg;
	if (!strlen(fe_cfg->cfg.remora.opermode_name)){
		memcpy(fe_cfg->cfg.remora.opermode_name, "FCC", 3);
		fe_cfg->cfg.remora.opermode = 0;
			if (!strcmp(fxo_modes[x].name, fe_cfg->cfg.remora.opermode_name))
			fe_cfg->cfg.remora.opermode = x;
						fe->name,
						fe_cfg->cfg.remora.opermode_name);
						fe->name);
					fe->name, fxo_modes[x].name);
			return -ENODEV;
** wp_remora_config() - 
	WAN_ASSERT_RC(fe->reset_fe == NULL,0);
        		     	fe->name);
		fe->rm_param.max_fe_channels 	= NUM_A600_ANALOG_PORTS;
		fe->rm_param.max_fe_channels 	= NUM_A700_ANALOG_PORTS;
		fe->rm_param.max_fe_channels 	= MAX_REMORA_MODULES;
	fe->rm_param.module_map 	= 0;
	fe->rm_param.intcount		= 0;
	fe->rm_param.last_watchdog 	= SYSTEM_TICKS;
		return -EINVAL;
	fe->reset_fe(fe);
			    fe->name);
		return -EINVAL;
	for(mod_no = 0; mod_no < fe->rm_param.max_fe_channels; mod_no++) {
		switch(fe->rm_param.mod[mod_no].type) {
				"%s: Module %d: Installed -- Auto FXS!\n",
					fe->name, mod_no+1);	
				wan_set_bit(mod_no, &fe->rm_param.module_map);
				fe->rm_param.mod[mod_no].u.fxs.oldrxhook = 1;	/* default (off-hook) */
				"%s: Module %d: Installed -- Auto FXO (%s mode)!\n",
					fe->name, mod_no+1,
					fxo_modes[fe->fe_cfg.cfg.remora.opermode].name);
				wan_set_bit(mod_no, &fe->rm_param.module_map);
			"%s: Module %d: Installed -- FXS/FXO tester!\n",
					fe->name, mod_no+1);
			wan_set_bit(mod_no, &fe->rm_param.module_map);
			((sdla_t*)fe->card)->fe_no_intr = 0x1;
						fe->name, mod_no+1);	
					fe->name, mod_no+1);
				fe->name, mod_no+1,
				WP_REMORA_DECODE_TYPE(fe->rm_param.mod[mod_no].type));
	if (err_cnt && fe->fe_cfg.cfg.remora.relaxcfg != WANOPT_YES){
					fe->name, err_cnt);
		return -EINVAL;
	fe->remora_modules_counter = mod_cnt;
					fe->name);
					fe->name);
		return -EINVAL;
	wan_set_bit(WP_RM_TIMER_KILL,(void*)&fe->rm_param.critical);
		&fe->timer, 
	wan_clear_bit(WP_RM_TIMER_KILL,(void*)&fe->rm_param.critical);
	wan_clear_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical);
	wan_set_bit(WP_RM_CONFIGURED,(void*)&fe->rm_param.critical);
** wp_remora_unconfig() - 
	if (!wan_test_bit(WP_RM_CONFIGURED,(void*)&fe->rm_param.critical)){
		return -EINVAL;
        		     	fe->name);
	wan_clear_bit(WP_RM_CONFIGURED,(void*)&fe->rm_param.critical);
	for(mod_no = 0; mod_no < fe->rm_param.max_fe_channels; mod_no++){
		if (wan_test_bit(mod_no, &fe->rm_param.module_map)) {
			wan_clear_bit(mod_no, &fe->rm_param.module_map);
	wan_set_bit(WP_RM_TIMER_KILL,(void*)&fe->rm_param.critical);
	if (wan_test_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical)){
		wan_del_timer(&fe->timer);
	wan_clear_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical);
		wan_spin_lock_irq(&fe->lockirq,&smp_flags);
		if (!WAN_LIST_EMPTY(&fe->event)){
			fe_event = WAN_LIST_FIRST(&fe->event);
		wan_spin_unlock_irq(&fe->lockirq,&smp_flags);
** wp_remora_post_init() - 
	DEBUG_EVENT("%s: Running post initialization...\n", fe->name);
** wp_remora_if_config() - 
	if (!wan_test_bit(WP_RM_CONFIGURED,(void*)&fe->rm_param.critical)){
		return -EINVAL;
		for(mod_no = 0; mod_no < fe->rm_param.max_fe_channels; mod_no++){
			if (!wan_test_bit(mod_no, &fe->rm_param.module_map) ||
** wp_remora_if_unconfig() - 
	if (!wan_test_bit(WP_RM_CONFIGURED,(void*)&fe->rm_param.critical)){
		return -EINVAL;
		for(mod_no = 0; mod_no < fe->rm_param.max_fe_channels; mod_no++){
			if (!wan_test_bit(mod_no, &fe->rm_param.module_map) ||
** wp_remora_disable_irq() - 
	if (!wan_test_bit(WP_RM_CONFIGURED,(void*)&fe->rm_param.critical)){
		return -EINVAL;
	for(mod_no = 0; mod_no < fe->rm_param.max_fe_channels; mod_no++){
		if (wan_test_bit(mod_no, &fe->rm_param.module_map)) {
	return fe->rm_param.module_map;
	return fe->fe_cfg.media;
	if (mod_no > fe->rm_param.max_fe_channels){
					fe->name, mod_no+1);
		return -EINVAL;
	if (!wan_test_bit(mod_no-1, &fe->rm_param.module_map)){
					fe->name, mod_no+1);
		return -EINVAL;
	return -EINVAL;
	sdla_t 		*card = (sdla_t*)fe->card;
	wan_device_t	*wandev = &card->wandev;
	DEBUG_TEST("%s: RM timer!\n", fe->name);
	if (wan_test_bit(WP_RM_TIMER_KILL,(void*)&fe->rm_param.critical)){
		wan_clear_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical);
	if (!wan_test_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical)){
					fe->name);
	wan_clear_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical);
	wan_spin_lock_irq(&fe->lockirq,&smp_flags);	
	empty = WAN_LIST_EMPTY(&fe->event);
	wan_spin_unlock_irq(&fe->lockirq,&smp_flags);	
		if (wan_test_and_set_bit(WP_RM_TIMER_EVENT_PENDING,(void*)&fe->rm_param.critical)){
			DEBUG_EVENT("%s: RM timer event is pending!\n", fe->name);
		if (wandev->fe_enable_timer){
			wandev->fe_enable_timer(fe->card);
	DEBUG_TEST("%s: Add new RM timer!\n", fe->name);
	err = wan_add_timer(&fe->timer, delay * HZ / 1000);
		return -EINVAL;
	wan_set_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical);
	sdla_t			*card = (sdla_t*)fe->card;
	WAN_ASSERT_RC(fe->write_fe_reg == NULL,0);
	WAN_ASSERT_RC(fe->read_fe_reg == NULL, 0);
	DEBUG_EVENT("%s: %s:%d: ---------------START ----------------------\n",
				fe->name, __FUNCTION__,__LINE__);
	DEBUG_EVENT("%s: %s:%d: ---------------STOP ----------------------\n",
				fe->name, __FUNCTION__,__LINE__);
	wan_spin_lock_irq(&fe->lockirq,&smp_flags);			
	if (WAN_LIST_EMPTY(&fe->event)){
		wan_clear_bit(WP_RM_TIMER_EVENT_PENDING,(void*)&fe->rm_param.critical);
		wan_spin_unlock_irq(&fe->lockirq,&smp_flags);	
					fe->name);
	fe_event = WAN_LIST_FIRST(&fe->event);
	wan_spin_unlock_irq(&fe->lockirq,&smp_flags);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	mod_no = fe_event->rm_event.mod_no;
			fe->name, mod_no+1,
			fe->fe_status==FE_CONNECTED?"Con":"Disconn",
			WP_RM_POLL_DECODE(fe_event->type), fe_event->type,
			WAN_EVENT_MODE_DECODE(fe_event->mode));
	switch(fe_event->type){
		if (fe_event->mode == WAN_EVENT_ENABLE){
				&fe->rm_param.mod[mod_no].events);
				&fe->rm_param.mod[mod_no].events);
		if (fe_event->mode == WAN_EVENT_ENABLE){
				&fe->rm_param.mod[mod_no].events);
				&fe->rm_param.mod[mod_no].events);
		if (fe_event->mode == WAN_EVENT_ENABLE){
				&fe->rm_param.mod[mod_no].events);
				&fe->rm_param.mod[mod_no].events);
		if (fe_event->mode == WAN_EVENT_ENABLE){
				&fe->rm_param.mod[mod_no].events);
				&fe->rm_param.mod[mod_no].events);
		if (fe_event->mode == WAN_EVENT_ENABLE){
				&fe->rm_param.mod[mod_no].events);
				&fe->rm_param.mod[mod_no].events);
		if (fe_event->mode == WAN_EVENT_ENABLE){
					fe->name, mod_no+1,
					WAN_EVENT_MODE_DECODE(fe_event->mode),
					WP_RM_POLL_DECODE(fe_event->type),
					fe_event->rm_event.tone);
			switch(fe_event->rm_event.tone){
				&fe->rm_param.mod[mod_no].events);
				&fe->rm_param.mod[mod_no].events);
		fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 0;
		WRITE_RM_REG(mod_no, 64, fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
					fe->name, mod_no+1);
			fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 4;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
			DEBUG_RM("%s: Module %d: goes off-hook.\n", 
					fe->name, mod_no+1);
			fe->rm_param.mod[mod_no].u.fxo.offhook = 1;
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
			DEBUG_RM("%s: Module %d: goes off-hook.\n",
						fe->name, mod_no+1);
			switch(fe->rm_param.mod[mod_no].sig) {
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 5;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook =
					fe->rm_param.mod[mod_no].u.fxs.idletxhookstate;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
			DEBUG_TDMV("%s: Module %d: goes off-hook.\n", 
					fe->name, mod_no+1);
			fe->rm_param.mod[mod_no].u.fxo.offhook = 1;
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
			DEBUG_RM("%s: Module %d: goes on-hook.\n",
						fe->name, mod_no+1);
			switch(fe->rm_param.mod[mod_no].sig) {
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook =
					fe->rm_param.mod[mod_no].u.fxs.idletxhookstate;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 3;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
			DEBUG_RM("%s: Module %d: goes on-hook.\n", 
					fe->name, mod_no+1);
			fe->rm_param.mod[mod_no].u.fxo.offhook = 0;
		fe->rm_param.mod[mod_no].u.fxs.ohttimer = 
				fe_event->rm_event.ohttimer << 3;
		if (fe->fe_cfg.cfg.remora.reversepolarity){
			fe->rm_param.mod[mod_no].u.fxs.idletxhookstate  = 0x6;
			fe->rm_param.mod[mod_no].u.fxs.idletxhookstate  = 0x2;
		if (fe->rm_param.mod[mod_no].u.fxs.lasttxhook == 0x1) {
			if (fe->fe_cfg.cfg.remora.reversepolarity){
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 0x6;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 0x2;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		if ((fe->rm_param.mod[mod_no].u.fxs.lasttxhook == 0x04) ||
		    (fe->rm_param.mod[mod_no].u.fxs.lasttxhook == 0x00)){
		if ((fe_event->mode && !fe->fe_cfg.cfg.remora.reversepolarity) ||
		    (!fe_event->mode && fe->fe_cfg.cfg.remora.reversepolarity)){
			fe->rm_param.mod[mod_no].u.fxs.lasttxhook |= 0x04;
			fe->rm_param.mod[mod_no].u.fxs.lasttxhook &= ~0x04;
		WRITE_RM_REG(mod_no, 64, fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
			if (fe_event->mode == WAN_EVENT_ENABLE){
					&fe->rm_param.mod[mod_no].events);
					&fe->rm_param.mod[mod_no].events);
		wp_init_proslic(fe, fe_event->rm_event.mod_no, 1, 1);
		fe->rm_param.reg_dbg_value = READ_RM_REG(mod_no,fe_event->rm_event.reg);
		fe->rm_param.reg_dbg_ready = 1;
					fe->name, mod_no+1,
					fe_event->rm_event.reg,
					fe->rm_param.reg_dbg_value); 
		WRITE_RM_REG(mod_no, fe_event->rm_event.reg, fe_event->rm_event.value);
		if (card->wandev.event_callback.hook){
			card->wandev.event_callback.hook(card, &event);
		if (card->wandev.event_callback.hook){
			card->wandev.event_callback.hook(card, &event);
				fe->name, fe_event->type);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	wan_clear_bit(WP_RM_TIMER_EVENT_PENDING,(void*)&fe->rm_param.critical);
	fe_event = WAN_LIST_FIRST(&fe->event);
		wp_remora_add_timer(fe, fe_event->delay);	
	sdla_t			*card = (sdla_t*)fe->card;
	WAN_ASSERT_RC(card == NULL, -EINVAL);
			fe->name,fe_event->type);
					fe->name);
		return -EINVAL;
	DEBUG_EVENT("%s: %s:%d: ---------------START ----------------------\n",
				fe->name, __FUNCTION__,__LINE__);
	DEBUG_EVENT("%s: %s:%d: ---------------STOP ----------------------\n",
				fe->name, __FUNCTION__,__LINE__);
	wan_spin_lock_irq(&fe->lockirq,&smp_flags);	
	if (WAN_LIST_EMPTY(&fe->event)){
		WAN_LIST_INSERT_HEAD(&fe->event, event, next);
			fe->name);
		wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
		WAN_LIST_FOREACH(tmp, &fe->event, next){
			DEBUG_EVENT("%s: Internal Error!!!\n", fe->name);
			wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
			return -EINVAL;
	wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
* Arguments: mod_no -  Module number (1,2,3,... fe->rm_param.max_fe_channels)
	int	mod_no = ectrl->mod_no-1;
	if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
		switch(ectrl->type){
					fe->name,mod_no+1,
					ectrl->type);
			return -EINVAL;
	}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
		switch(ectrl->type){
					fe->name,mod_no+1,
					ectrl->type);
			return -EINVAL;
				fe->name,mod_no+1,
				fe->rm_param.mod[mod_no].type);
		return -EINVAL;	
* Arguments: mod_no -  Module number (1,2,3,... fe->rm_param.max_fe_channels)
	int			mod_no = ectrl->mod_no-1, err = 0;
	if (mod_no+1 > fe->rm_param.max_fe_channels){
					fe->name, mod_no+1);
		return -EINVAL;
	if (!wan_test_bit(mod_no, &fe->rm_param.module_map)) {
					fe->name, mod_no);
		return -EINVAL;
		return -EINVAL;
				fe->name, mod_no+1,
				WAN_EVENT_TYPE_DECODE(ectrl->type),
				WAN_EVENT_MODE_DECODE(ectrl->mode), ectrl->mode);
	fe_event.mode		= ectrl->mode;
	switch(ectrl->type){
		fe_event.rm_event.tone	= ectrl->tone;
		fe_event.rm_event.ohttimer= ectrl->ohttimer;
				fe->name, mod_no+1);
				fe->name, mod_no+1);
				fe->name, mod_no+1);
				fe->name, mod_no+1);
	mod_no = rm_udp->mod_no;
	if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
		rm_udp->type = MOD_TYPE_FXS;
		regs_fxs = &rm_udp->u.regs_fxs;
			regs_fxs->direct[reg] = READ_RM_REG(mod_no, reg);
			regs_fxs->indirect[reg] =
	}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
		rm_udp->type = MOD_TYPE_FXO;
		regs_fxo = &rm_udp->u.regs_fxo;
			regs_fxo->direct[reg] = READ_RM_REG(mod_no, reg);
	mod_no = rm_udp->mod_no;
	if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
		rm_udp->type = MOD_TYPE_FXS;
		rm_udp->u.stats.tip_volt = READ_RM_REG(mod_no, 80);
		rm_udp->u.stats.ring_volt = READ_RM_REG(mod_no, 81);
		rm_udp->u.stats.bat_volt = READ_RM_REG(mod_no, 82);
	} else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
		rm_udp->type = MOD_TYPE_FXO;
		rm_udp->u.stats.volt = READ_RM_REG(mod_no, 29);
		rm_udp->u.stats.status = fe->rm_param.mod[mod_no].u.fxo.status; 
	int			err = -EINVAL;
	switch(udp_cmd->wan_cmd_command){
                fe_media->media         = fe->fe_cfg.media;
                fe_media->sub_media     = fe->fe_cfg.sub_media;
                fe_media->chip_id       = 0x00;
                fe_media->max_ports     = 1;
                udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
                udp_cmd->wan_cmd_data_len = sizeof(wan_femedia_t);
		udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
		udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_data_len = (unsigned short)err; 
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_data_len = (unsigned short)err; 
		switch(fe_debug->type){
			if (fe->rm_param.reg_dbg_busy){
				if (fe_debug->fe_debug_reg.read == 2 && fe->rm_param.reg_dbg_ready){
					fe_debug->fe_debug_reg.value = fe->rm_param.reg_dbg_value;
					udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
					fe->rm_param.reg_dbg_busy = 0;
			event.type		= (fe_debug->fe_debug_reg.read) ? 
			event.rm_event.mod_no	= fe_debug->mod_no;
			event.rm_event.reg	= (u_int16_t)fe_debug->fe_debug_reg.reg;
			event.rm_event.value	= fe_debug->fe_debug_reg.value;
			if (fe_debug->fe_debug_reg.read){
				fe->rm_param.reg_dbg_busy = 1;
				fe->rm_param.reg_dbg_ready = 0;
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			event.type		= (fe_debug->fe_debug_hook.offhook) ? 
			event.rm_event.mod_no	= fe_debug->mod_no;
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
		    	udp_cmd->wan_cmd_data_len = 0;
		udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
	    	udp_cmd->wan_cmd_data_len = 0;
	if (!res && (res != fe->rm_param.mod[mod_no].u.fxs.lasttxhook)) {
					fe->name, mod_no+1);
			if (fe->rm_param.mod[mod_no].u.fxs.palarms++ < MAX_ALARMS) {
					fe->name, mod_no + 1);
				if (fe->rm_param.mod[mod_no].u.fxs.lasttxhook == 4){
					fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 1;
				WRITE_RM_REG(mod_no, 64, fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
				if (fe->rm_param.mod[mod_no].u.fxs.palarms == MAX_ALARMS){
						fe->name, mod_no + 1);
	WAN_ASSERT1(fe->card == NULL);
	card	= (sdla_t*)fe->card;
		/* Not good -- don't look at anything else */
			 fe->name, mod_no + 1, b); 
	if (!fe->rm_param.mod[mod_no].u.fxo.offhook) {
			fe->rm_param.mod[mod_no].u.fxo.ringdebounce += (WP_RM_CHUNKSIZE * 4);
			if (fe->rm_param.mod[mod_no].u.fxo.ringdebounce >= WP_RM_CHUNKSIZE * 128) {	
				if (!fe->rm_param.mod[mod_no].u.fxo.wasringing) {
					fe->rm_param.mod[mod_no].u.fxo.wasringing = 1;
						fe->name,
					if (card->wandev.event_callback.ringdetect){
						card->wandev.event_callback.ringdetect(card, &event);
				fe->rm_param.mod[mod_no].u.fxo.ringdebounce = WP_RM_CHUNKSIZE * 128;
			fe->rm_param.mod[mod_no].u.fxo.ringdebounce -= WP_RM_CHUNKSIZE * 1;
			if (fe->rm_param.mod[mod_no].u.fxo.ringdebounce <= 0) {
				if (fe->rm_param.mod[mod_no].u.fxo.wasringing) {
					fe->rm_param.mod[mod_no].u.fxo.wasringing = 0;
						fe->name,
					if (card->wandev.event_callback.ringdetect){
						card->wandev.event_callback.ringdetect(card, &event);
				fe->rm_param.mod[mod_no].u.fxo.ringdebounce = 0;
		fe->rm_param.mod[mod_no].u.fxo.statusdebounce ++;
		if (fe->rm_param.mod[mod_no].u.fxo.statusdebounce >= FXO_LINK_DEBOUNCE) {
			if (fe->rm_param.mod[mod_no].u.fxo.status != FE_DISCONNECTED) {
								fe->name,
				fe->rm_param.mod[mod_no].u.fxo.status = FE_DISCONNECTED;
				if (card->wandev.event_callback.linkstatus) {
					card->wandev.event_callback.linkstatus(card, &event);
			fe->rm_param.mod[mod_no].u.fxo.statusdebounce = FXO_LINK_DEBOUNCE;
		fe->rm_param.mod[mod_no].u.fxo.statusdebounce--;
		if (fe->rm_param.mod[mod_no].u.fxo.statusdebounce <= 0) {
			if (fe->rm_param.mod[mod_no].u.fxo.status != FE_CONNECTED) {
								fe->name,
				fe->rm_param.mod[mod_no].u.fxo.status = FE_CONNECTED;
				if (card->wandev.event_callback.linkstatus) {					
					card->wandev.event_callback.linkstatus(card, &event);				
			fe->rm_param.mod[mod_no].u.fxo.statusdebounce = 0;
	if (abs(b) < fe->fe_cfg.cfg.remora.ohthresh) {
		if (!fe->rm_param.mod[mod_no].u.fxo.going_offhook) {
			fe->rm_param.mod[mod_no].u.fxo.going_offhook = 1;
			fe->rm_param.mod[mod_no].u.fxo.ohdebounce = ohdebounce;	
		if (!fe->rm_param.mod[mod_no].u.fxo.offhook) {
			fe->rm_param.mod[mod_no].u.fxo.ohdebounce--;
			if (!fe->rm_param.mod[mod_no].u.fxo.ohdebounce) {
				DEBUG_RM("%s: Module %d: OFF-HOOK!\n",
						fe->name,
				if (card->wandev.event_callback.hook) {
					card->wandev.event_callback.hook(card, &event);
				fe->rm_param.mod[mod_no].u.fxo.offhook = 1;
				fe->rm_param.mod[mod_no].u.fxo.ohdebounce = ohdebounce;
		if (fe->rm_param.mod[mod_no].u.fxo.going_offhook) {
			fe->rm_param.mod[mod_no].u.fxo.going_offhook = 0;
			fe->rm_param.mod[mod_no].u.fxo.ohdebounce = ohdebounce;	
		if (fe->rm_param.mod[mod_no].u.fxo.offhook) {
			fe->rm_param.mod[mod_no].u.fxo.ohdebounce--;
			if (!fe->rm_param.mod[mod_no].u.fxo.ohdebounce) {
			/*For the first On-hook event after line connected, pass connected event before ON-hook !*/
				if (fe->rm_param.mod[mod_no].u.fxo.status != FE_CONNECTED) {
									fe->name,
					fe->rm_param.mod[mod_no].u.fxo.status = FE_CONNECTED;
					if (card->wandev.event_callback.linkstatus) {					
						card->wandev.event_callback.linkstatus(card, &event);				
				DEBUG_RM("%s: Module %d: ON-HOOK!\n",
					    	fe->name,
				if (card->wandev.event_callback.hook){
					card->wandev.event_callback.hook(
				fe->rm_param.mod[mod_no].u.fxo.offhook = 0;
				fe->rm_param.mod[mod_no].u.fxo.ohdebounce = ohdebounce;
			    fe->name,
	      		  fe->rm_param.mod[mod_no].u.fxo.tapper_ohdebounce,
      				fe->rm_param.mod[mod_no].u.fxo.ringdebounce);
	WAN_ASSERT1(fe->card == NULL);
	card	= (sdla_t*)fe->card;
		/* Not good -- don't look at anything else */
				fe->name, mod_no + 1, b); 
	if (fe->rm_param.mod[mod_no].u.fxo.offhook) {
	if (!fe->rm_param.mod[mod_no].u.fxo.offhook) {
		if ((res & 0x60) && fe->rm_param.mod[mod_no].u.fxo.battery) {
			fe->rm_param.mod[mod_no].u.fxo.ringdebounce += (WP_RM_CHUNKSIZE * 4);
			if (fe->rm_param.mod[mod_no].u.fxo.ringdebounce >= WP_RM_CHUNKSIZE * 64) {
				if (!fe->rm_param.mod[mod_no].u.fxo.wasringing) {
					fe->rm_param.mod[mod_no].u.fxo.wasringing = 1;
							fe->name,
					if (card->wandev.event_callback.ringdetect){
						card->wandev.event_callback.ringdetect(card, &event);
				fe->rm_param.mod[mod_no].u.fxo.ringdebounce = WP_RM_CHUNKSIZE * 64;
			fe->rm_param.mod[mod_no].u.fxo.ringdebounce -= WP_RM_CHUNKSIZE * 2;
			if (fe->rm_param.mod[mod_no].u.fxo.ringdebounce <= 0) {
				if (fe->rm_param.mod[mod_no].u.fxo.wasringing) {
					fe->rm_param.mod[mod_no].u.fxo.wasringing = 0;
							fe->name,
					if (card->wandev.event_callback.ringdetect){
						card->wandev.event_callback.ringdetect(card, &event);
				fe->rm_param.mod[mod_no].u.fxo.ringdebounce = 0;
			fe->rm_param.mod[mod_no].u.fxo.statusdebounce ++;
			if (fe->rm_param.mod[mod_no].u.fxo.statusdebounce >= FXO_LINK_DEBOUNCE){
				if (fe->rm_param.mod[mod_no].u.fxo.status != FE_DISCONNECTED){
									fe->name,
					fe->rm_param.mod[mod_no].u.fxo.status = FE_DISCONNECTED;
					if (card->wandev.event_callback.linkstatus){
						card->wandev.event_callback.linkstatus(card, &event);
				fe->rm_param.mod[mod_no].u.fxo.statusdebounce = FXO_LINK_DEBOUNCE;
		fe->rm_param.mod[mod_no].u.fxo.statusdebounce--;
		if (fe->rm_param.mod[mod_no].u.fxo.statusdebounce <= 0) {
			if (fe->rm_param.mod[mod_no].u.fxo.status != FE_CONNECTED){
								fe->name,
				fe->rm_param.mod[mod_no].u.fxo.status = FE_CONNECTED;
				if (card->wandev.event_callback.linkstatus){
					card->wandev.event_callback.linkstatus(card, &event);
			fe->rm_param.mod[mod_no].u.fxo.statusdebounce = 0;
		fe->rm_param.mod[mod_no].u.fxo.nobatttimer++;
		if (wr->mod[mod_no].fxo.battery)
			printk("Battery loss: %d (%d debounce)\n", b, wr->mod[mod_no].fxo.battdebounce);
		if (fe->rm_param.mod[mod_no].u.fxo.battery &&
		    !fe->rm_param.mod[mod_no].u.fxo.battdebounce) {
						fe->name,
			fe->rm_param.mod[mod_no].u.fxo.battery =  0;
			if ((!fe->rm_param.mod[mod_no].u.fxo.ohdebounce) &&
			     fe->rm_param.mod[mod_no].u.fxo.offhook) {
				DEBUG_RM("%s: Module %d: On-Hook status!\n",
							fe->name,
				if (card->wandev.event_callback.hook){
					card->wandev.event_callback.hook(
				fe->rm_param.mod[mod_no].u.fxo.onhook++;
			DEBUG_RM("%s: Module %d: On-Hook status!\n",
							fe->name,
			if (card->wandev.event_callback.hook){
				card->wandev.event_callback.hook(card, &event);
			fe->rm_param.mod[mod_no].u.fxo.battdebounce = battdebounce;
		} else if (!fe->rm_param.mod[mod_no].u.fxo.battery)
			fe->rm_param.mod[mod_no].u.fxo.battdebounce = battdebounce;
		if (!fe->rm_param.mod[mod_no].u.fxo.battery &&
		    !fe->rm_param.mod[mod_no].u.fxo.battdebounce) {
						fe->name,
						(b < 0) ? "-" : "+");			    
			if (fe->rm_param.mod[mod_no].u.fxo.onhook) {
				fe->rm_param.mod[mod_no].u.fxo.onhook = 0;
				DEBUG_RM("%s: Module %d: Off-Hook status!\n",
							fe->name,
				if (card->wandev.event_callback.hook){
					card->wandev.event_callback.hook(card, &event);
			DEBUG_RM("%s: Module %d: Off-Hook status!\n",
						fe->name,
			if (card->wandev.event_callback.hook){
				card->wandev.event_callback.hook(card, &event);
			fe->rm_param.mod[mod_no].u.fxo.battery = 1;
			fe->rm_param.mod[mod_no].u.fxo.nobatttimer = 0;
			fe->rm_param.mod[mod_no].u.fxo.battdebounce = battdebounce;
		} else if (fe->rm_param.mod[mod_no].u.fxo.battery)
			fe->rm_param.mod[mod_no].u.fxo.battdebounce = battdebounce;
		if (fe->rm_param.mod[mod_no].u.fxo.lastpol >= 0) {
			fe->rm_param.mod[mod_no].u.fxo.lastpol = -1;
			fe->rm_param.mod[mod_no].u.fxo.polaritydebounce = POLARITY_DEBOUNCE;
		if (fe->rm_param.mod[mod_no].u.fxo.lastpol <= 0) {
			fe->rm_param.mod[mod_no].u.fxo.lastpol = 1;
			fe->rm_param.mod[mod_no].u.fxo.polaritydebounce = POLARITY_DEBOUNCE;
		fe->rm_param.mod[mod_no].u.fxo.battdebounce = battdebounce;
	if (fe->rm_param.mod[mod_no].u.fxo.battdebounce)
		fe->rm_param.mod[mod_no].u.fxo.battdebounce--;
	if (fe->rm_param.mod[mod_no].u.fxo.polaritydebounce) {
	        fe->rm_param.mod[mod_no].u.fxo.polaritydebounce--;
		if (fe->rm_param.mod[mod_no].u.fxo.polaritydebounce < 1) {
			if (fe->rm_param.mod[mod_no].u.fxo.lastpol !=
					fe->rm_param.mod[mod_no].u.fxo.polarity) {
				"%s: Module %d: Polarity reversed (%d -> %d) (%ul)\n",
						fe->name, mod_no + 1,
						fe->rm_param.mod[mod_no].u.fxo.polarity, 
						fe->rm_param.mod[mod_no].u.fxo.lastpol,
				if (fe->rm_param.mod[mod_no].u.fxo.polarity){
				fe->rm_param.mod[mod_no].u.fxo.polarity =
						fe->rm_param.mod[mod_no].u.fxo.lastpol;
	WAN_ASSERT1(fe->card == NULL);
	card	= fe->card;
	if (hook != fe->rm_param.mod[mod_no].u.fxs.lastrxhook) {
		fe->rm_param.mod[mod_no].u.fxs.debounce = 4 * (4 * 8);
				fe->name, mod_no + 1, hook,
				fe->rm_param.mod[mod_no].u.fxs.debounce);
		if (fe->rm_param.mod[mod_no].u.fxs.debounce > 0) {
			fe->rm_param.mod[mod_no].u.fxs.debounce-= 16 * WP_RM_CHUNKSIZE;
					fe->name, mod_no + 1,
					hook, fe->rm_param.mod[mod_no].u.fxs.debounce);
			if (!fe->rm_param.mod[mod_no].u.fxs.debounce) {
							fe->name,
				fe->rm_param.mod[mod_no].u.fxs.debouncehook = hook;
			if (!fe->rm_param.mod[mod_no].u.fxs.oldrxhook &&
			    fe->rm_param.mod[mod_no].u.fxs.debouncehook) {
							fe->name, mod_no + 1);
				if (card->wandev.event_callback.hook){
					card->wandev.event_callback.hook(card, &event);
				//zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_OFFHOOK);
				fe->rm_param.mod[mod_no].u.fxs.oldrxhook = 1;
			} else if (fe->rm_param.mod[mod_no].u.fxs.oldrxhook &&
				   !fe->rm_param.mod[mod_no].u.fxs.debouncehook) {
							fe->name, mod_no + 1);
				if (card->wandev.event_callback.hook){
					card->wandev.event_callback.hook(card, &event);
				//zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_ONHOOK);
				fe->rm_param.mod[mod_no].u.fxs.oldrxhook = 0;
	fe->rm_param.mod[mod_no].u.fxs.lastrxhook = hook;
* Arguments: mod_no -  Module number (1,2,3,... fe->rm_param.max_fe_channels)
	for (mod_no = 0; mod_no < fe->rm_param.max_fe_channels; mod_no++) {
		if (!wan_test_bit(mod_no, &fe->rm_param.module_map)) {
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
			if (fe->rm_param.mod[mod_no].u.fxs.lasttxhook == 0x4) {
				fe->rm_param.mod[mod_no].u.fxs.ohttimer = OHT_TIMER << 3;
				if (fe->fe_cfg.cfg.remora.reversepolarity){
					fe->rm_param.mod[mod_no].u.fxs.idletxhookstate = 0x6;
					fe->rm_param.mod[mod_no].u.fxs.idletxhookstate = 0x2; 
				if (fe->rm_param.mod[mod_no].u.fxs.ohttimer) {
					fe->rm_param.mod[mod_no].u.fxs.ohttimer-= WP_RM_CHUNKSIZE;
					if (!fe->rm_param.mod[mod_no].u.fxs.ohttimer) {
						if (fe->fe_cfg.cfg.remora.reversepolarity){
							fe->rm_param.mod[mod_no].u.fxs.idletxhookstate = 0x5;
							fe->rm_param.mod[mod_no].u.fxs.idletxhookstate = 0x1;
						if ((fe->rm_param.mod[mod_no].u.fxs.lasttxhook == 0x2) ||
						    (fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 0x6)) {
							if (fe->fe_cfg.cfg.remora.reversepolarity){ 
								fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 0x5;
								fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 0x1;
							WRITE_RM_REG(mod_no, 64, fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		} else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO) {
			if (wr->mod[x].fxo.echotune){
							fe->name, x);
				WRITE_RM_REG(x, 30, wr->mod[x].fxo.echoregs.acim);
				WRITE_RM_REG(x, 45, wr->mod[x].fxo.echoregs.coef1);
				WRITE_RM_REG(x, 46, wr->mod[x].fxo.echoregs.coef2);
				WRITE_RM_REG(x, 47, wr->mod[x].fxo.echoregs.coef3);
				WRITE_RM_REG(x, 48, wr->mod[x].fxo.echoregs.coef4);
				WRITE_RM_REG(x, 49, wr->mod[x].fxo.echoregs.coef5);
				WRITE_RM_REG(x, 50, wr->mod[x].fxo.echoregs.coef6);
				WRITE_RM_REG(x, 51, wr->mod[x].fxo.echoregs.coef7);
				WRITE_RM_REG(x, 52, wr->mod[x].fxo.echoregs.coef8);
						fe->name, x);
				wr->mod[x].fxo.echotune = 0;
			if (fe->fe_cfg.cfg.remora.rm_mode == WAN_RM_TAPPING) {
	if (SYSTEM_TICKS - fe->rm_param.last_watchdog  > WP_RM_WATCHDOG_TIMEOUT) {
		fe->rm_param.last_watchdog = SYSTEM_TICKS;
* Arguments: mod_no -  Module number (1,2,3,... fe->rm_param.max_fe_channels)
	if (mod_no >= fe->rm_param.max_fe_channels){
					fe->name, mod_no+1);
		return -EINVAL;
	if (!wan_test_bit(mod_no, &fe->rm_param.module_map)) {
					fe->name, mod_no+1);
		return -EINVAL;
	if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
				WRITE_RM_REG(mod_no, 21, fe->rm_param.mod[mod_no].u.fxs.imask1);
				WRITE_RM_REG(mod_no, 22, fe->rm_param.mod[mod_no].u.fxs.imask2);
				WRITE_RM_REG(mod_no, 23, fe->rm_param.mod[mod_no].u.fxs.imask3);
					fe->name, mod_no+1, type);
			err = -EINVAL;
	}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
				WRITE_RM_REG(mod_no, 3, fe->rm_param.mod[mod_no].u.fxo.imask);
					fe->name, mod_no+1, type);
			err = -EINVAL;
				fe->name, mod_no+1);
	WAN_ASSERT(fe->card == NULL);
	if (((sdla_t*)fe->card)->fe_ignore_intr) {
	fe->rm_param.intcount++;
	for(mod_no = 0; mod_no < fe->rm_param.max_fe_channels; mod_no++){
		if (wan_test_bit(mod_no, &fe->rm_param.module_map)) {
			if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
			}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
	if (card->wan_tdmv.sc && fe->rm_param.intcount % 100 == 0){
	WAN_ASSERT(fe->card == NULL);
	card		= fe->card;
				fe->name,
		if (card->wandev.event_callback.dtmf){
			card->wandev.event_callback.dtmf(card, &event);
	WAN_ASSERT(fe->card == NULL);
	card		= fe->card;
				fe->name, mod_no+1);
			if (card->wandev.fe_notify_iface.hook_state){
				card->wandev.fe_notify_iface.hook_state(
				"RM: %s: Module %d: Off-hook status!\n",
						fe->name, mod_no+1);
				fe->rm_param.mod[mod_no].u.fxs.oldrxhook = 1;
			}else/* if (fe->rm_param.mod[mod_no].u.fxs.oldrxhook)*/{
				"RM: %s: Module %d: On-hook status!\n",
						fe->name, mod_no+1);
				fe->rm_param.mod[mod_no].u.fxs.oldrxhook = 0;
			if (card->wandev.event_callback.hook){
				card->wandev.event_callback.hook(
				fe->name, mod_no+1);
			if (card->wandev.fe_notify_iface.hook_state){
				card->wandev.fe_notify_iface.hook_state(
			off-hook during the ringing state.
						fe->name, mod_no+1);
						fe->name, mod_no+1);
			if (card->wandev.event_callback.ringtrip){
				card->wandev.event_callback.ringtrip(card, &event);
					fe->name, mod_no+1);
					fe->name, mod_no+1);
					fe->name, mod_no+1);
					fe->name, mod_no+1);
					fe->name, mod_no+1);
					fe->name, mod_no+1);
			fe->name, mod_no+1,
	WAN_ASSERT(fe->card == NULL);
	card		= fe->card;
			if (fe->rm_param.mod[mod_no].u.fxo.ring_detect){
					fe->name, mod_no+1);
				fe->rm_param.mod[mod_no].u.fxo.ring_detect = 0;			
					fe->name, mod_no+1);
				fe->rm_param.mod[mod_no].u.fxo.ring_detect = 1;
				fe->name, mod_no+1);
			fe->rm_param.mod[mod_no].u.fxo.ring_detect = 1;
		if (card->wandev.event_callback.ringdetect){
			card->wandev.event_callback.ringdetect(card, &event);
					fe->name, mod_no+1);
	for(mod_no = 0; mod_no < fe->rm_param.max_fe_channels; mod_no++){
		if (!wan_test_bit(mod_no, &fe->rm_param.module_map)) {
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
		}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
	/*mod_no = chan -1 */
	if (fe->rm_param.mod[mod_no-1].type == MOD_TYPE_FXO) {
		*status = fe->rm_param.mod[mod_no -1].u.fxo.status;
					fe->name, mod_no);
		return -EINVAL;
./sdla_remora.c
* Copyright:	(c) 1995-2003 Sangoma Technologies Inc.
#error   "-> INCLUDE PROTOCOL SPECIFIC HEADER HERE"
 * wpc_init - Cisco HDLC protocol initialization routine.
 *  o initialize protocol-specific fields of the adapter data space.
#error "->CHANGE THE INITIALIZATION NAME TO SUTE YOUR PROTOCOL"
	if (conf->config_id != WANCONFIG_FRMW) {
				  card->devname, conf->config_id);
		return -EINVAL;
	if (!card->configured){
		while (mb->wan_return_code != 'I')	/* Wait 1s for board to initialize */
			if ((jiffies - timeout) > 1*HZ) break;
		if (mb->wan_return_code != 'I') {
				card->devname);
			return -EIO;
	card->wandev.clocking 			= conf->clocking;
	card->wandev.ignore_front_end_status 	= conf->ignore_front_end_status;
	card->wandev.ttl 			= conf->ttl;
	card->wandev.electrical_interface 			= conf->electrical_interface; 
	card->wandev.comm_port 			= conf->comm_port;
	card->wandev.udp_port   		= conf->udp_port;
	card->wandev.new_if_cnt 		= 0;
	atomic_set(&card->wandev.if_cnt,0);
	port_num = card->wandev.comm_port;
	err = (card->hw_iface.check_mismatch) ? 
			card->hw_iface.check_mismatch(card->hw,conf->te_cfg.media) : -EINVAL;
	if (IS_TE1(conf->te_cfg)){
		memcpy(&card->wandev.te_cfg, &conf->te_cfg, sizeof(sdla_te_cfg_t));
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg	= write_front_end_reg;
		card->fe.read_fe_reg	= read_front_end_reg;
		card->wandev.write_front_end_reg = write_front_end_reg;
		card->wandev.read_front_end_reg = read_front_end_reg;
		card->wandev.fe_enable_timer = enable_timer;
		conf->electrical_interface = 
			(card->wandev.te_cfg.media == WAN_MEDIA_T1) ? WANOPT_V35 : WANOPT_RS232;
		if (card->wandev.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
	}else if (IS_56K(conf->te_cfg)){
		memcpy(&card->wandev.te_cfg, &conf->te_cfg, sizeof(sdla_te_cfg_t));
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg	= write_front_end_reg;
		card->fe.read_fe_reg	= read_front_end_reg;
		card->wandev.write_front_end_reg = write_front_end_reg;
		card->wandev.read_front_end_reg = read_front_end_reg;
		if (card->wandev.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
		card->wandev.front_end_status = FE_CONNECTED;
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
		return -EIO;
		card->devname, u.str); 
		return -EIO;
	card->isr			= &wpc_isr;
	card->wandev.update		= &update;
 	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= &del_if;
	card->disable_comm		= &disable_comm;
	card->wandev.get_config_info 	= &get_config_info;
	card->wandev.get_status_info 	= &get_status_info;
	card->wandev.get_dev_config_info= &get_dev_config_info;
	card->wandev.get_if_info     	= &get_if_info;
	card->wandev.set_dev_config    	= &set_dev_config;
	card->wandev.set_if_info     	= &set_if_info;
	if(card->wandev.clocking) {
		card->wandev.bps = conf->bps;
        	card->wandev.bps = 0;
#error "->USE YOUR OWN MIN AND MAX VALUES FOR PRI/SEC MTU"
	if((card->wandev.comm_port == WANOPT_PRI)) {
		card->wandev.mtu =
			(conf->mtu >= MIN_WP_PRI_MTU) ? 
			 wp_min(conf->mtu, MAX_WP_PRI_MTU) : DEFAULT_WP_PRI_MTU;
		card->wandev.mtu =
			(conf->mtu >= MIN_WP_SEC_MTU) ?
			wp_min(conf->mtu, MAX_WP_SEC_MTU) :
	if (!card->wandev.piggyback){	
					card->devname, Intr_test_counter);
					card->devname);
			return -EIO;
				card->devname, Intr_test_counter);
		card->configured = 1;
			card->devname);
		return -EIO;	
	flags->interrupt_info_struct.interrupt_permission &= 
	card->backup = conf->backup;
	card->wandev.state = WAN_DISCONNECTED;
 * update - Update wanpipe device status & statistics
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
                return -ENODEV;
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical))
                return -EAGAIN;
	if((dev=card->wandev.dev) == NULL)
		return -ENODEV;
	if((priv_area=dev->priv) == NULL)
		return -ENODEV;
       	if(card->update_comms_stats){
		return -EAGAIN;
	card->update_comms_stats = (IS_TE1_CARD(card) || IS_56K_CARD(card)) ? 3 : 2;
       	flags->interrupt_info_struct.interrupt_permission |= APP_INT_ON_TIMER;
	card->timer_int_enabled = TMR_INT_ENABLED_UPDATE;
		if(card->update_comms_stats == 0)
                if ((jiffies - timeout) > (1 * HZ)){
    			card->update_comms_stats = 0;
 			card->timer_int_enabled &=
 			return -EAGAIN;
 * new_if - Create new logical channel.
 * to dev->priv pointer.  
 * Also the dev->init pointer should also be initialized
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
			card->devname, conf->name);
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
	 * If developing a multi-interface protocol, one should
	if (atomic_read(&card->wandev.if_cnt) > 0){
		return -EEXIST;
		WAN_MEM_ASSERT(card->devname);
		return -ENOMEM;
	strncpy(priv_area->if_name, conf->name, WAN_IFNAME_SZ);
	priv_area->card = card; 
	priv_area->common.sk = NULL;
	priv_area->common.func = NULL;	
	priv_area->common.state = WAN_CONNECTING;
	priv_area->TracingEnabled = 0;
	priv_area->route_status = NO_ROUTE;
	priv_area->route_removed = 0;
	if(strcmp(conf->usedby, "WANPIPE") == 0) {
			wandev->name);
		priv_area->common.usedby = WANPIPE;
		if (conf->if_down){
			set_bit(DYN_OPT_ON,&priv_area->interface_down);
			   card->devname,priv_area->if_name);
	} else if( strcmp(conf->usedby, "API") == 0) {
		priv_area->common.usedby = API;
			wandev->name,priv_area->if_name);
	}else if (strcmp(conf->usedby, "BRIDGE") == 0) {
		priv_area->common.usedby = BRIDGE;
				card->devname,priv_area->if_name);
	}else if (strcmp(conf->usedby, "BRIDGE_N") == 0) {
		priv_area->common.usedby = BRIDGE_NODE;
				card->devname,priv_area->if_name);
				card->devname,priv_area->if_name);
		err=-EINVAL;
	 * test with (MAX_BH_BUFF-1) 
	priv_area->bh_head = wan_malloc((sizeof(bh_data_t)*(MAX_BH_BUFF+1)));
	if (!priv_area->bh_head){
		WAN_MEM_ASSERT(card->devname);
		err=-ENOMEM;
	memset(priv_area->bh_head,0,(sizeof(bh_data_t)*(MAX_BH_BUFF+1)));
	atomic_set(&priv_area->bh_buff_used, 0);
	 *      is brought back up, we must know to re-astablish the
	if ((priv_area->gateway = conf->gateway) == WANOPT_YES){
			card->devname,priv_area->if_name);
	priv_area->mc = conf->mc;
	 * 	dev->if_init : function that will be called
	 * 	dev->priv    : private structure allocated above
	strcpy(dev->name,priv_area->if_name);
	dev->name = (char *)wan_malloc(strlen(priv_area->if_name) + 2); 
	if (!dev->name){
		err=-ENOMEM;
	sprintf(dev->name, "%s", priv_area->if_name);
	priv_area->poll_task.next = NULL;
	priv_area->poll_task.sync=0;
	priv_area->poll_task.routine = (void*)(void*)frmw_poll;
	priv_area->poll_task.data = dev;
	init_timer(&priv_area->poll_delay_timer);
	priv_area->poll_delay_timer.data = (unsigned long)dev;
	priv_area->poll_delay_timer.function = frmw_poll_delay;
					   &priv_area->dent, 
					   priv_area->if_name, 
			card->devname, priv_area->if_name);
	dev->init = &if_init;
	dev->priv = priv_area;
	set_bit(0,&priv_area->config_frmw);
	atomic_inc(&card->wandev.if_cnt);
	if (priv_area->bh_head){
		wan_free(priv_area->bh_head);
	if (dev->name){
		wan_free(dev->name);
		dev->name=NULL;
	dev->priv=NULL;
 * del_if - Delete logical channel.
 * NOTE: DO NOT deallocate dev->priv here! It will be
	private_area_t* 	priv_area = dev->priv;
	sdla_t*			card = priv_area->card;
	wanrouter_proc_delete_interface(wandev, priv_area->if_name);
	if (priv_area->bh_head){
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);		
			skb = ((bh_data_t *)&priv_area->bh_head[i])->skb;
		wan_free(priv_area->bh_head);
		priv_area->bh_head=NULL;
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);	
	atomic_dec(&card->wandev.if_cnt);
 * if_init - Initialize Linux network interface.
	private_area_t* priv_area = dev->priv;
	sdla_t* card = priv_area->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= TX_TIMEOUT;
	dev->do_ioctl		= if_do_ioctl;
	if (priv_area->common.usedby == BRIDGE || 
            priv_area->common.usedby == BRIDGE_NODE){
		memcpy(dev->dev_addr, "\xFE\xFC\x00\x00\x00\x00", 6);
		*(int *)(dev->dev_addr + 2) += hw_addr;
		/* Initialize media-specific parameters */
		dev->flags		|= IFF_POINTOPOINT;
		dev->flags		|= IFF_NOARP;
		if (priv_area->mc == WANOPT_YES){
			dev->flags 	|= IFF_MULTICAST;
		if (priv_area->true_if_encoding){
			dev->type	= ARPHRD_HDLC; /* This breaks the tcpdump */
			dev->type	= ARPHRD_PPP;
		dev->mtu		= card->wandev.mtu;
		if(priv_area->common.usedby == API) {
			dev->mtu += sizeof(api_tx_hdr_t);
		dev->hard_header_len	= 0;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start);
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end);
        dev->tx_queue_len = 100;
 * if_open - Open network interface.
	private_area_t* priv_area = dev->priv;
	sdla_t* card = priv_area->card;
		return -EBUSY;
	priv_area->tq_working=0;
	priv_area->common.wanpipe_task.next = NULL;
	priv_area->common.wanpipe_task.sync = 0;
	priv_area->common.wanpipe_task.routine = (void *)(void *)wp_bh;
	priv_area->common.wanpipe_task.data = dev;
	priv_area->router_start_time = tv.tv_sec;
	dev->interrupt = 0;
	dev->tbusy = 0;
	dev->start = 1;
	set_bit(0,&priv_area->config_frmw);
	priv_area->config_frmw_timeout=jiffies;
	del_timer(&priv_area->poll_delay_timer);
	priv_area->poll_delay_timer.expires=jiffies+HZ;
	add_timer(&priv_area->poll_delay_timer);
 * if_close - Close network interface.
	private_area_t* priv_area = dev->priv;
	sdla_t* card = priv_area->card;
	dev->start=0;
	del_timer(&priv_area->poll_delay_timer);
 * disable_comm - Main shutdown function
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	if (card->comm_enabled){
		flags->interrupt_info_struct.interrupt_permission = 0;	
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	/* TE1 - Unconfiging, only on shutdown */
		sdla_te_unconfig(&card->fe);
    	private_area_t* chan = dev->priv;
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++chan->if_stats.collisions;
	DEBUG_EVENT( "%s: Transmit timed out on %s\n", card->devname,dev->name);
 * if_send - Send a packet on a network interface.
 * 	Return a non-zero value to tell the stack
 *		non-0	packet may be re-transmitted 
	private_area_t *priv_area = dev->priv;
	sdla_t *card = priv_area->card;
	INTERRUPT_INFORMATION_STRUCT *frmw_int = &flags->interrupt_info_struct;
			card->devname, dev->name);
	if (dev->tbusy){
		 * kick start the device by making dev->tbusy = 0.  We expect 
                ++chan->if_stats.collisions;
		if((jiffies - priv_area->tick_counter) < (5 * HZ)) {
			card->devname);
		clear_bit(0,&dev->tbusy);
   	if (ntohs(skb->protocol) != htons(PVC_PROT)){
	                	frmw_int->interrupt_permission |=
                if(priv_area->common.usedby == WANPIPE && chk_bcast_mcast_addr(card, dev, skb)){
			++chan->if_stats.tx_dropped;
      	if(card->type != SDLA_S514){
	 * re-entrant.  The kernel will never do this to us
    	if(test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
					card->wandev.name,card->wandev.critical);
                ++chan->if_stats.tx_dropped;
	if(card->wandev.state != WAN_CONNECTED){
       		++chan->if_stats.tx_dropped;
	}else if(!skb->protocol){
        	++chan->if_stats.tx_errors;
		void* data = skb->data;
		unsigned len = skb->len;
		if (priv_area->common.usedby == API){
				++chan->if_stats.tx_dropped;
			attr = api_tx_hdr->attr;
			misc_Tx_bits = api_tx_hdr->misc_Tx_bits;
			len -= sizeof(api_tx_hdr_t);
			++chan->if_stats.tx_packets;
                        chan->if_stats.tx_bytes += len;
		 	dev->trans_start = jiffies;
	 * exiting with non-zero value.  
		priv_area->tick_counter = jiffies;
		frmw_int->interrupt_permission |= APP_INT_ON_TX_FRAME;
	/* End of critical area for re-entry and for S508 card */
	clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
	if(card->type != SDLA_S514){
 * chk_bcast_mcast_addr - Check for source broadcast addresses
	private_area_t *priv_area=dev->priv;
        src_ip_addr = *(u32 *)(skb->data + 12);
	if (priv_area->common.usedby != WANPIPE){
        in_dev = dev->ip_ptr;
                struct in_ifaddr *ifa= in_dev->ifa_list;
                        broadcast_ip_addr = ifa->ifa_broadcast;
        if((dev->flags & IFF_BROADCAST) && (src_ip_addr == broadcast_ip_addr)) {
				card->devname);
				card->devname);
	if ((priv_area=dev->priv) == NULL)
	return &priv_area->if_stats;
 * if_do_ioctl - Ioctl handler for fr
	private_area_t* chan= (private_area_t*)dev->priv;
		return -ENODEV;
	card=chan->card;
			if (atomic_read(&chan->udp_pkt_len) != 0){
				return -EBUSY;
			atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
			if (test_bit(0,&card->in_isr)){
				atomic_set(&chan->udp_pkt_len,0);
				return -EBUSY;
			wan_udp_pkt=(wan_udp_pkt_t*)chan->udp_pkt_data;
			if (copy_from_user(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			spin_lock_irqsave(&card->wandev.lock, smp_flags);
			if (test_bit(0,&card->in_isr)) {
						card->devname,dev->name);
				atomic_set(&chan->udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
				return -EBUSY;
			spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
			if (atomic_read(&chan->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						card->devname,atomic_read(&chan->udp_pkt_len));
				atomic_set(&chan->udp_pkt_len,0);
				return -EINVAL;
			if (copy_to_user(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			atomic_set(&chan->udp_pkt_len,0);
			return -EOPNOTSUPP;
	mb1->wan_data_len = 0;
	mb1->wan_command = READ_CONFIGURATION;
	err = sdla_exec(mb1) ? mb1->wan_return_code : CMD_TIMEOUT;
		return -EIO;
			(void *)(card->hw.dpmbase +
             			         (((CONFIGURATION_STRUCT *)mb1->wan_data)->
	char* data = mb->wan_data;
	((ADAPTER_CONFIGURATION_STRUCT *)data)->adapter_type = 
			sdla_get(&card->hw, SDLA_ADAPTERTYPE); 
	((ADAPTER_CONFIGURATION_STRUCT *)data)->adapter_config = 0x00; 
	((ADAPTER_CONFIGURATION_STRUCT *)data)->operating_frequency = 00; 
	mb->wan_data_len = sizeof(ADAPTER_CONFIGURATION_STRUCT);
	mb->wan_command = SET_ADAPTER_CONFIGURATION;
	err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CODE_VERSION;
	err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
		len = mb->wan_data_len;
		memcpy(str, mb->wan_data, len);
/*-----------------------------------------------------------------------------
	mb->wan_data_len = data_length;  
	memcpy(mb->wan_data, data, data_length);
	mb->wan_command = SET_CONFIGURATION;
	err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
 * Set interrupt mode -- HDLC Version.
		 (INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->interrupt_triggers 	= mode;
	int_data->IRQ				= card->hw.irq;
	int_data->interrupt_timer               = 1;
	mb->wan_data_len = sizeof(INT_TRIGGERS_STRUCT);
	mb->wan_command = SET_INTERRUPT_TRIGGERS;
	err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
		 (INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->interrupt_triggers 		= 0;
	int_data->IRQ				= card->hw.irq;
	int_data->interrupt_timer               = 1;
	mb->wan_data_len = sizeof(INT_TRIGGERS_STRUCT);
	mb->wan_command = SET_INTERRUPT_TRIGGERS;
	err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
	mb->wan_command = DISABLE_COMMUNICATIONS;
	mb->wan_data_len = 0;
	err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
	card->comm_enabled = 0;
	/* TE1 - Unconfiging, only on shutdown */
		sdla_te_unconfig(&card->fe);
	mb->wan_data_len = 0;
	mb->wan_command = ENABLE_COMMUNICATIONS;
	err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
		card->comm_enabled = 1;
        mb->wan_data_len = 0;
        mb->wan_command = READ_COMMS_ERROR_STATS;
        err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
        mb->wan_data_len = 0;
        mb->wan_command = READ_OPERATIONAL_STATS;
        err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
	if(card->update_comms_stats == 3) {
			card->wandev.fe_iface.read_alarm(&card->fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE); 
			card->wandev.k56_alarm = sdla_56k_alarm(card,1);
		if(card->update_comms_stats == 2) {
			err_stats = (COMMS_ERROR_STATS_STRUCT *)mb->wan_data;
			card->wandev.stats.rx_over_errors = 
				err_stats->Rx_overrun_err_count;
			card->wandev.stats.rx_crc_errors = 
				err_stats->CRC_err_count;
			card->wandev.stats.rx_frame_errors = 
				err_stats->Rx_abort_count;
			card->wandev.stats.rx_fifo_errors = 
				err_stats->Rx_dis_pri_bfrs_full_count; 
			card->wandev.stats.rx_missed_errors =
				card->wandev.stats.rx_fifo_errors;
			card->wandev.stats.tx_aborted_errors =
				err_stats->sec_Tx_abort_count;
			op_stats = (OPERATIONAL_STATS_STRUCT *)mb->wan_data;
			card->wandev.stats.rx_length_errors =
				(op_stats->Rx_Data_discard_short_count +
				op_stats->Rx_Data_discard_long_count);
 *	Return:	0 - o.k.
 *		1 - no transmit buffers available
	if (txbuf->opp_flag)
	sdla_poke(&card->hw, txbuf->ptr_data_bfr, data, len);
	txbuf->frame_length = len;
	txbuf->misc_Tx_bits = tx_bits;
	txbuf->opp_flag = 1;		/* start transmission */
	char* data = mb->wan_data;
	((FRONT_END_REG_STRUCT *)data)->register_number = (unsigned short)reg;
	mb->wan_data_len = sizeof(FRONT_END_REG_STRUCT);
        mb->wan_command = READ_FRONT_END_REGISTER;
        err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
	return(((FRONT_END_REG_STRUCT *)data)->register_value);
	char* data = mb->wan_data;
		((FRONT_END_REG_STRUCT *)data)->register_number = (unsigned short)reg;
		((FRONT_END_REG_STRUCT *)data)->register_value = value;
		mb->wan_data_len = sizeof(FRONT_END_REG_STRUCT);
		mb->wan_command = WRITE_FRONT_END_REGISTER;
		err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
	}while(err && --retry);
	DEBUG_EVENT( "%s: enabling timer %s\n",card->devname,
			card->wandev.dev?card->wandev.dev->name:"No DEV");
	card->timer_int_enabled |= TMR_INT_ENABLED_TE;
	flags->interrupt_info_struct.interrupt_permission |= APP_INT_ON_TIMER;
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_command;
			card->devname, cmd, err);
	if(card->wandev.clocking){
		cfg.baud_rate = card->wandev.bps;
#error  "->PROTOCOL SPECIFIC CONFIGURATION"
	mb->wan_data_len = 0;
	mb->wan_command = START_BAUD_CALIBRATION;
	err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
	mb->wan_data_len = 0;
	mb->wan_command = READ_BAUD_CALIBRATION_RESULT;
	err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
			mb->wan_data_len = 0;
			mb->wan_command = READ_CONFIGURATION;
			err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
				card->wandev.bps = ((CONFIGURATION_STRUCT*)mb->wan_data)->baud_rate;
					card->devname,card->wandev.bps);
					card->devname);
			return -EINVAL;
					card->devname);
			return -EINVAL;
					card->devname);
			return -EINVAL;
			return -EINVAL;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CONFIGURATION;
	err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
		if (card->wandev.dev){
		(TX_STATUS_EL_CFG_STRUCT *)(card->hw.dpmbase +
                (((CONFIGURATION_STRUCT *)mb->wan_data)->
		(RX_STATUS_EL_CFG_STRUCT *)(card->hw.dpmbase +
                (((CONFIGURATION_STRUCT *)mb->wan_data)->
       	card->u.c.txbuf_base = 
		(void *)(card->hw.dpmbase +
                tx_config->base_addr_Tx_status_elements);
       	card->u.c.txbuf_last = 
		(DATA_TX_STATUS_EL_STRUCT *)card->u.c.txbuf_base +
		(tx_config->number_Tx_status_elements - 1);
       	card->u.c.rxbuf_base = 
		(void *)(card->hw.dpmbase +
                rx_config->base_addr_Rx_status_elements);
        card->u.c.rxbuf_last =
		(DATA_RX_STATUS_EL_STRUCT *)card->u.c.rxbuf_base +
		(rx_config->number_Rx_status_elements - 1);
        card->u.c.txbuf = 
		(void *)(card->hw.dpmbase +
                tx_config->next_Tx_status_element_to_use);
        card->u.c.rxmb = 
		(void *)(card->hw.dpmbase +
                rx_config->next_Rx_status_element_to_use);
        card->u.c.rx_base = rx_config->base_addr_Rx_buffer;
        card->u.c.rx_top  = rx_config->end_addr_Rx_buffer;
			mb->wan_data_len  = 0;
			mb->wan_command = READ_CODE_VERSION;
			err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
	flags->interrupt_info_struct.interrupt_type = 0;
	private_area_t* chan = dev->priv;
	sdla_t *card = chan->card;
	if (!chan->bh_head || atomic_read(&chan->bh_buff_used) == 0){
		clear_bit(0, &chan->tq_working);
	while (atomic_read(&chan->bh_buff_used)){
		skb  = ((bh_data_t *)&chan->bh_head[chan->bh_read])->skb;
			if (chan->common.sk == NULL || chan->common.func == NULL){
				++chan->if_stats.rx_dropped;
			if (chan->common.func(skb,dev,chan->common.sk) != 0){
				++chan->if_stats.rx_dropped;
	clear_bit(0, &chan->tq_working);
	private_area_t* chan = dev->priv;
	((bh_data_t *)&chan->bh_head[chan->bh_read])->skb = NULL;
	if (chan->bh_read == MAX_BH_BUFF){
		chan->bh_read=0;
		++chan->bh_read;	
	atomic_dec(&chan->bh_buff_used);
	private_area_t* chan = dev->priv;
	sdla_t *card = chan->card;
	if (!chan->bh_head || atomic_read(&chan->bh_buff_used) == (MAX_BH_BUFF+1)){
		++chan->if_stats.rx_dropped;
	((bh_data_t *)&chan->bh_head[chan->bh_write])->skb = skb;
	if (chan->bh_write == MAX_BH_BUFF){
		chan->bh_write=0;
		++chan->bh_write;
	atomic_inc(&chan->bh_buff_used);
	private_area_t *chan = dev->priv;
	if (test_bit(0,&chan->common.common_critical)){
	if (!chan->common.sk || !chan->common.func){
	chan->common.func(NULL,dev,chan->common.sk);
#error "->CHANGE THE ISR NAME "
	if (!flags->interrupt_info_struct.interrupt_type){
		if ((my_card = card->next) != NULL){
			if (flags->interrupt_info_struct.interrupt_type){
				card->isr(card);
	card->in_isr = 1;
	dev = card->wandev.dev;
	if (!dev && flags->interrupt_info_struct.interrupt_type != 
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical)) {
				card->devname);
	if(card->type != SDLA_S514) {
		if(test_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
				card->devname);
			card->in_isr = 0;
			flags->interrupt_info_struct.interrupt_type = 0;
	switch(flags->interrupt_info_struct.interrupt_type) {
		flags->interrupt_info_struct.interrupt_permission &=
			private_area_t* priv_area=dev->priv;
			if (priv_area->common.usedby == API){
				(FRONT_END_STATUS_STRUCT *)&flags->FT1_info_struct.parallel_port_A_input;
			FE_status->opp_flag = 0x01;	
			card->devname,
			flags->interrupt_info_struct.interrupt_type);
				flags->global_info_struct.codename[i]); 
				flags->global_info_struct.codeversion[i]); 
	card->in_isr = 0;
	flags->interrupt_info_struct.interrupt_type = 0;
	unsigned addr = rxbuf->ptr_data_bfr;
	if (rxbuf->opp_flag != 0x01) {
			card->devname, (unsigned)rxbuf, rxbuf->opp_flag);
                                flags->global_info_struct.codename[i]);
                                flags->global_info_struct.codeversion[i]);
		DEBUG_EVENT( "%s: Critical router failure ...!!!\n", card->devname);
	len  = rxbuf->frame_length;
	dev = card->wandev.dev;
	priv_area = dev->priv;
					card->devname);
		++chan->if_stats.rx_dropped;
		unsigned tmp = rx_top_buf - addr + 1;
		sdla_peek(&card->hw, addr, buf, tmp);
		len -= tmp;
	sdla_peek(&card->hw, addr, buf, len);
	skb->protocol = htons(ETH_P_IP);
	chan->if_stats.rx_packets ++;
	chan->if_stats.rx_bytes += skb->len;
     		        flags->interrupt_info_struct.
	} else if(priv_area->common.usedby == API) {
                api_rx_hdr = (api_rx_hdr_t*)&skb->data[0x00];
		api_rx_hdr->error_flag = rxbuf->error_flag;
     		api_rx_hdr->time_stamp = rxbuf->time_stamp;
                skb->protocol = htons(PVC_PROT);
     		skb->mac.raw  = skb->data;
		skb->dev      = dev;
               	skb->pkt_type = WAN_PACKET_DATA;
		if (!test_and_set_bit(0,&priv_area->tq_working)){
			if (wanpipe_queue_tq(&priv_area->common.wanpipe_task) != 0){
				clear_bit(0,&priv_area->tq_working);
				clear_bit(0,&priv_area->tq_working);
	}else if (priv_area->common.usedby == BRIDGE ||
		  priv_area->common.usedby == BRIDGE_NODE){
		if (skb->len <= ETH_ALEN) {
			++chan->if_stats.rx_errors;
		skb->dev = dev;
		skb->protocol=eth_type_trans(skb,dev);
                          ++ priv_area->if_stats.multicast;
		skb->protocol = htons(ETH_P_IP);
                skb->dev = dev;
                skb->mac.raw  = skb->data;
	rxbuf->opp_flag = 0x00;
 *    2) Reading board-level statistics for updating the proc file system.
	if (card->timer_int_enabled & TMR_INT_ENABLED_TE) {
		card->wandev.fe_iface.polling(&card->fe);
		card->timer_int_enabled &= ~TMR_INT_ENABLED_TE;
        if ((dev = card->wandev.dev)==NULL){
		card->timer_int_enabled=0;
        priv_area = dev->priv;
	if (card->timer_int_enabled & TMR_INT_ENABLED_CONFIG) {
		card->timer_int_enabled &= ~TMR_INT_ENABLED_CONFIG;
       	if(card->timer_int_enabled & TMR_INT_ENABLED_UDP) {
		card->timer_int_enabled &= ~TMR_INT_ENABLED_UDP;
	if(card->timer_int_enabled & TMR_INT_ENABLED_UPDATE) {
                if(!(-- card->update_comms_stats)) {
			card->timer_int_enabled &= 
        if(!card->timer_int_enabled) {
                flags->interrupt_info_struct.interrupt_permission &=
	mb->wan_data_len = 0;
	mb->wan_command = READ_GLOBAL_EXCEPTION_CONDITION;
	err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
		switch(mb->wan_return_code) {
				(FRONT_END_STATUS_STRUCT *)&flags->FT1_info_struct.parallel_port_A_input;
				card->wandev.RR8_reg_56k = 
					FE_status->FE_U.stat_56k.RR8_56k;	
				card->wandev.RRA_reg_56k = 
					FE_status->FE_U.stat_56k.RRA_56k;	
				card->wandev.RRC_reg_56k = 
					FE_status->FE_U.stat_56k.RRC_56k;	
				card->wandev.fe_iface.isr(&card->fe);
			if ((mb->wan_data[0] & (DCD_HIGH | CTS_HIGH)) == (DCD_HIGH | CTS_HIGH)){
				card->wandev.front_end_status = FE_CONNECTED;
				card->wandev.front_end_status = FE_DISCONNECTED;
				card->devname);
			switch(mb->wan_data[0] & (DCD_HIGH | CTS_HIGH)) {
                                        DEBUG_EVENT( "%s: DCD high, CTS high\n",card->devname);
					DEBUG_EVENT( "%s: DCD high, CTS low\n",card->devname);
                                        DEBUG_EVENT( "%s: DCD low, CTS high\n",card->devname); 
                                        DEBUG_EVENT( "%s: DCD low, CTS low\n",card->devname);
				card->devname);
				card->devname); 
				card->devname, mb->wan_return_code);
	mb->wan_data_len = 0;
	mb->wan_command = READ_EXCEPTION_CONDITION;
	err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
			card->u.c.state = WAN_CONNECTED;
			if (card->wandev.ignore_front_end_status == WANOPT_YES ||
			    card->wandev.front_end_status == FE_CONNECTED){
				trigger_poll(card->wandev.dev);
			card->u.c.state = WAN_DISCONNECTED;
			trigger_poll(card->wandev.dev);
			card->u.c.state = WAN_DISCONNECTED;
				 		card->devname);
			trigger_poll(card->wandev.dev);
				return -1;
						card->devname);
						card->devname);
	if(!atomic_read(&priv_area->udp_pkt_len) &&
	  (skb->len <= MAX_LGTH_UDP_MGNT_PKT)) {
		atomic_set(&priv_area->udp_pkt_len, skb->len);
		priv_area->udp_pkt_src = udp_pkt_src;
       		memcpy(priv_area->udp_pkt_data, skb->data, skb->len);
		card->timer_int_enabled = TMR_INT_ENABLED_UDP;
 * "wanpipemon" utility is a user-space program that 
	wan_udp_pkt = (wan_udp_pkt_t *) priv_area->udp_pkt_data;
		if(priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK){
			switch(wan_udp_pkt->wan_udp_command) {
		wan_udp_pkt->wan_udp_data_len = 0;
		wan_udp_pkt->wan_udp_return_code = 0xCD;
			card->devname,wan_udp_pkt->wan_udp_command);
		wan_udp_pkt->wan_udp_opp_flag = 0;
		switch(wan_udp_pkt->wan_udp_command) {
		     if (!priv_area->TracingEnabled) {
			mb->wan_data_len = sizeof(LINE_TRACE_CONFIG_STRUCT);
			mb->wan_command = SET_TRACE_CONFIGURATION;
    			((LINE_TRACE_CONFIG_STRUCT *)mb->wan_data)->
			((LINE_TRACE_CONFIG_STRUCT *)mb->wan_data)->trace_config |= 
					wan_udp_pkt->wan_udp_data[0];
			((LINE_TRACE_CONFIG_STRUCT *)mb->wan_data)->
			err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
				card->TracingEnabled = 0;
				wan_udp_pkt->wan_udp_return_code = err;
				mb->wan_data_len = 0;
			mb->wan_data_len = 0;
			mb->wan_command = READ_TRACE_CONFIGURATION;
			err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
				priv_area->TracingEnabled = 0;
				wan_udp_pkt->wan_udp_return_code = err;
				mb->wan_data_len = 0;
				mb->wan_data) -> ptr_trace_stat_el_cfg_struct;
			sdla_peek(&card->hw, trace_status_cfg_addr,
			priv_area->start_trace_addr = trace_cfg_struct.
			priv_area->number_trace_elements = 
			priv_area->end_trace_addr = (unsigned long)
					 priv_area->start_trace_addr + 
					 (priv_area->number_trace_elements - 1));
			priv_area->base_addr_trace_buffer = 
			priv_area->end_addr_trace_buffer = 
		    	priv_area->curr_trace_addr = 
	    		priv_area->available_buffer_space = 2000 - 
								  sizeof(struct iphdr) -
								  sizeof(struct udphdr) -
							      	  sizeof(wan_mgmt_t)-
								  sizeof(wan_cmd_t)-
		     wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
		     mb->wan_data_len = 0;
	       	     priv_area->TracingEnabled = 1;
		     if (priv_area->TracingEnabled) {
			mb->wan_data_len = sizeof(LINE_TRACE_CONFIG_STRUCT);
			mb->wan_command = SET_TRACE_CONFIGURATION;
    			((LINE_TRACE_CONFIG_STRUCT *)mb->wan_data)->
			err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
		     priv_area->TracingEnabled = 0;
		     wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
		     mb->wan_data_len = 0;
		     if (!priv_area->TracingEnabled) {
			wan_udp_pkt->wan_udp_return_code = 1;
			mb->wan_data_len = 0;
  		     wan_udp_pkt->wan_udp_ismoredata = 0x00;
		     for (frames=0; frames < priv_area->number_trace_elements; frames++){
				&wan_udp_pkt->wan_udp_data[buffer_length];
			sdla_peek(&card->hw, priv_area->curr_trace_addr,
				wan_udp_pkt->wan_udp_ismoredata = 0x01;
   			if( (priv_area->available_buffer_space - buffer_length)
				wan_udp_pkt->wan_udp_ismoredata = 0x01;
			trace_pkt->status = trace_element_struct.trace_type;
			trace_pkt->time_stamp =
			trace_pkt->real_length =
			real_len = trace_pkt->real_length;
			     	trace_pkt->data_avail = 0x00;
			        trace_pkt->data_avail = 0x01;
					     priv_area->end_addr_trace_buffer + 1){
				    	tmp = priv_area->end_addr_trace_buffer - data_ptr + 1;
				    	sdla_peek(&card->hw, data_ptr,
					       	  trace_pkt->data,tmp);
				    	data_ptr = priv_area->base_addr_trace_buffer;
		        	sdla_peek(&card->hw, data_ptr,
					  &trace_pkt->data[tmp], real_len - tmp);
			sdla_poke(&card->hw, priv_area->curr_trace_addr, &ut_char, 1);
       			priv_area->curr_trace_addr += sizeof(TRACE_STATUS_ELEMENT_STRUCT);
			if ( priv_area->curr_trace_addr > priv_area->end_trace_addr ) {
				priv_area->curr_trace_addr = priv_area->start_trace_addr;
            		if(trace_pkt->data_avail == 0x01) {
				buffer_length += real_len - 1;
		     if (frames == priv_area->number_trace_elements){
			wan_udp_pkt->wan_udp_ismoredata = 0x01;
 		     wan_udp_pkt->wan_udp_num_frames = frames;
    		     mb->wan_data_len = buffer_length;
		     wan_udp_pkt->wan_udp_data_len = buffer_length; 
		     wan_udp_pkt->wan_udp_return_code = COMMAND_OK; 
			((unsigned char *)wan_udp_pkt->wan_udp_data )[0] =
				flags->FT1_info_struct.parallel_port_A_input;
			((unsigned char *)wan_udp_pkt->wan_udp_data )[1] =
				flags->FT1_info_struct.parallel_port_B_input;
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
			wan_udp_pkt->wan_udp_data_len = 2;
			mb->wan_data_len = 2;
			priv_area->router_up_time = tv.tv_sec - 
					priv_area->router_start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
					priv_area->router_up_time;	
			mb->wan_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
	        	if ((wan_udp_pkt->wan_udp_data[0] & ENABLE_READ_FT1_STATUS) ||  
				(wan_udp_pkt->wan_udp_data[0] & ENABLE_READ_FT1_OP_STATS)) {
					wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
					mb->wan_data_len = 1;
	      		if( wan_udp_pkt->wan_udp_data[0] == 0) {
	      	   	     	if( --rCount != 0) {
		  			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
					mb->wan_data_len = 1;
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				if (wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE){
		    			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned char); 
					wan_udp_pkt->wan_udp_return_code = CMD_OK;
					wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
					&card->fe, 
					wan_udp_pkt->wan_udp_data[0], 
					wan_udp_pkt->wan_udp_data[1]);
			wan_udp_pkt->wan_udp_return_code = 
			wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
		    wan_udp_pkt->wan_udp_data_len = 0x00;
	 		wan_udp_pkt->wan_udp_data[0] = 
		    	wan_udp_pkt->wan_udp_data_len = sizeof(unsigned char); 
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
			mb->wan_data_len = sizeof(unsigned char);
			  	*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
	        		memcpy(&wan_udp_pkt->wan_udp_data[sizeof(unsigned long)],
					&card->wandev.te_pmon,
		        	wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
		    		wan_udp_pkt->wan_udp_data_len = 
				mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
				card->wandev.k56_alarm = sdla_56k_alarm(card, 1); 
			 	*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
			                        card->wandev.k56_alarm;
				wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
	    			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
				mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
				card->wandev.fe_iface.flush_pmon(&card->fe);
	        		wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
        			memcpy(&wan_udp_pkt->wan_udp_data[0],
					&card->wandev.te_cfg,
		        	wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
	    			wan_udp_pkt->wan_udp_data_len = sizeof(sdla_te_cfg_t);
				mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
		   	wan_udp_pkt->wan_udp_num_frames = card->wandev.config_id;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_LINUX_PLATFORM;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
			mb->wan_command = wan_udp_pkt->wan_udp_command;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
			if (mb->wan_data_len) {
				memcpy(&mb->wan_data, (unsigned char *) wan_udp_pkt->
							wan_udp_data, mb->wan_data_len);
			err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
				wan_udp_pkt->wan_udp_return_code = mb->wan_return_code;
	         	memcpy(&wan_udp_pkt->wan_udp_hdr.wan_cmd, &mb->wan_command, sizeof(wan_cmd_t)); 
			if (mb->wan_data_len) {
	         		memcpy(&wan_udp_pkt->wan_udp_data, &mb->wan_data, 
								mb->wan_data_len); 
	wan_udp_pkt->wan_ip_ttl= card->wandev.ttl; 
		wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	len = reply_udp(priv_area->udp_pkt_data, mb->wan_data_len);
     	if(priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK){
	   	if (!test_bit(SEND_CRIT,&card->wandev.critical)) {
			if(!frmw_send(card, priv_area->udp_pkt_data, len, 0)) {
				++ chan->if_stats.tx_packets;
				chan->if_stats.tx_bytes += len;
  	    		memcpy(buf, priv_area->udp_pkt_data, len);
	    		new_skb->protocol = htons(ETH_P_IP);
            		new_skb->dev = dev;
	    		new_skb->mac.raw  = new_skb->data;
					card->devname);
	atomic_set(&priv_area->udp_pkt_len,0);
	 wan_udp_pkt_t *wan_udp_pkt = (wan_udp_pkt_t *)skb->data;
				  wan_udp_pkt->wan_udp_signature,
				  wan_udp_pkt->wan_udp_dport,
				  ntohs(card->wandev.udp_port),
				  wan_udp_pkt->wan_ip_p,
				  wan_udp_pkt->wan_udp_request_reply,
				  skb->data[36], skb->data[37]);
	if ((wan_udp_pkt->wan_udp_dport == ntohs(card->wandev.udp_port)) &&
	   (wan_udp_pkt->wan_ip_p == UDPMGMT_UDP_PROTOCOL) &&
	   (wan_udp_pkt->wan_udp_request_reply == UDPMGMT_REQUEST)) {
		if (!strncmp(wan_udp_pkt->wan_udp_signature,UDPMGMT_SIGNATURE,8)){
		if (!strncmp(wan_udp_pkt->wan_udp_signature,GLOBAL_UDP_SIGNATURE,8)){
        if (card->wandev.state != state)
                                card->devname);
                                card->devname);
                                card->devname);
                card->wandev.state = state;
		if (card->wandev.dev){
			struct net_device *dev = card->wandev.dev;
			private_area_t *priv_area = dev->priv;
			priv_area->common.state = state;
			if (priv_area->common.usedby == API){
	struct net_device *dev = card->wandev.dev;
	private_area_t *priv_area = dev->priv;
	if (card->comm_enabled){
		if ((priv_area->ip_local_tmp != priv_area->ip_local ||
		     priv_area->ip_remote_tmp != priv_area->ip_remote) && 
		     priv_area->common.usedby == WANPIPE) {
			card->u.c.state = WAN_DISCONNECTED;
					card->devname);
					card->devname);
	priv_area->ip_local = priv_area->ip_local_tmp;
	priv_area->ip_remote = priv_area->ip_remote_tmp;
			card->devname);
	flags->interrupt_info_struct.interrupt_type = 0;
	flags->interrupt_info_struct.interrupt_permission=0;
			card->devname, 
			(card->wandev.te_cfg.media==WAN_MEDIA_T1)?"T1":"E1");
		if (sdla_te_config(&card->fe, &card->wandev.fe_iface)){
					card->devname,
					(card->wandev.te_cfg.media==WAN_MEDIA_T1)?"T1":"E1");
			return -EINVAL;
			card->devname);
		if(sdla_56k_config(&card->fe, &card->wandev.fe_iface)){
				card->devname);
			return -EINVAL;
				card->devname);
		return -EINVAL;	
	flags->interrupt_info_struct.interrupt_permission &= 
				card->devname);
		flags->interrupt_info_struct.interrupt_permission = 0;
		card->comm_enabled=0;
		return -EINVAL;
	card->u.c.state = WAN_CONNECTING;
	flags->interrupt_info_struct.interrupt_permission |= 
	flags->interrupt_info_struct.interrupt_type = 0;
	if (!dev || (priv_area=dev->priv) == NULL){
	card = priv_area->card;
	if (test_bit(PERI_CRIT,&card->wandev.critical)){
		clear_bit(POLL_CRIT,&card->wandev.critical);
	if (test_bit(0,&priv_area->config_frmw)){
		priv_area->ip_local_tmp  = get_ip_address(dev,WAN_LOCAL_IP);
		priv_area->ip_remote_tmp = get_ip_address(dev,WAN_POINTOPOINT_IP);
		if (priv_area->ip_local_tmp == priv_area->ip_remote_tmp && 
		    !card->backup && 
		    priv_area->common.usedby == WANPIPE){
			if (++priv_area->ip_error > MAX_IP_ERRORS){
				DEBUG_EVENT( "%s: --- WARNING ---\n",
						card->devname);
						card->devname);
				"%s: Point-to-Point IP address.\n",
						card->devname);
				DEBUG_EVENT( "%s: --- WARNING ---\n\n",
						card->devname);
				clear_bit(POLL_CRIT,&card->wandev.critical);
				priv_area->poll_delay_timer.expires = jiffies+HZ;
				add_timer(&priv_area->poll_delay_timer);
		clear_bit(0,&priv_area->config_frmw);
		clear_bit(POLL_CRIT,&card->wandev.critical);
		card->timer_int_enabled |= TMR_INT_ENABLED_CONFIG;
		flags->interrupt_info_struct.interrupt_permission |= APP_INT_ON_TIMER;
	switch (card->wandev.state){
		if (test_bit(DYN_OPT_ON,&priv_area->interface_down) && 
		    !test_bit(DEV_DOWN,  &priv_area->interface_down) &&		
		    card->wandev.dev->flags & IFF_UP){	
				card->devname,card->wandev.dev->name);
			change_dev_flags(card->wandev.dev,(card->wandev.dev->flags&~IFF_UP));
			set_bit(DEV_DOWN,&priv_area->interface_down);
			priv_area->route_status = NO_ROUTE;
			if (card->wandev.dev->flags & IFF_UP && 
		    	    get_ip_address(card->wandev.dev,WAN_LOCAL_IP) && 
		    	    priv_area->route_status != NO_ROUTE){
		if (test_bit(DYN_OPT_ON,&priv_area->interface_down) &&
		    test_bit(DEV_DOWN,  &priv_area->interface_down) &&
		    !(card->wandev.dev->flags & IFF_UP)){
				card->devname,card->wandev.dev->name);
			change_dev_flags(card->wandev.dev,(card->wandev.dev->flags|IFF_UP));
			clear_bit(DEV_DOWN,&priv_area->interface_down);
		if (chdlc_priv_area->route_status == ADD_ROUTE && 
		    card->u.c.slarp_timer){ 
		if (priv_area->gateway && check_gateway)
	clear_bit(POLL_CRIT,&card->wandev.critical);
	if ((priv_area = dev->priv)==NULL)
	card = priv_area->card;
	if (test_and_set_bit(POLL_CRIT,&card->wandev.critical)){
	if (test_bit(PERI_CRIT,&card->wandev.critical)){
	schedule_task(&priv_area->poll_task);
	queue_task(&priv_area->poll_task, &tq_scheduler);
 * S514-1/2/3:		V32/RS232/FT1 Front End
 * S514-4/5/7/8:	56K/T1/E1 Front End
 * 1. Front End State (card->wandev.front_end_status)
 * 2. Protocol State  (card->wandev.state)
 * 3. Interface State (dev->flags & IFF_UP)
	if (card->wandev.ignore_front_end_status == WANOPT_YES){
	if (card->wandev.front_end_status == FE_CONNECTED){
		if (card->u.c.state == WAN_CONNECTED){
			trigger_poll(card->wandev.dev);
		trigger_poll(card->wandev.dev);
 * board commands.  If the non-interrupt process
 * the interrupt and non-interrupt kernel 
	spin_lock_irqsave(&card->wandev.lock, *smp_flags);
        if (card->next){
        	spin_lock(&card->next->wandev.lock);
        disable_irq(card->hw.irq);
        if (card->next){
        	spin_unlock(&card->next->wandev.lock);
        spin_unlock_irqrestore(&card->wandev.lock, *smp_flags);
        enable_irq(card->hw.irq);
	struct net_device *dev = card->wandev.dev;
	priv_area = dev->priv;
        if(card->u.c.slarp_timer != 0x00) {
     		mb->wan_data_len = 0;
		mb->wan_command = READ_CONFIGURATION;
		err = sdla_exec(mb) ? mb->wan_return_code : CMD_TIMEOUT;
			return -1;
		cfg = (CONFIGURATION_STRUCT *)mb->wan_data;
                priv_area->IP_address = cfg->IP_address;
                priv_area->IP_netmask = cfg->IP_netmask;
		priv_area->route_status = ADD_ROUTE;
 * Un-Configure IP negotiated by SLARP
	struct net_device *dev = card->wandev.dev;
	priv_area= dev->priv;
	if (priv_area->route_status == ROUTE_ADDED) {
		priv_area->route_status = REMOVE_ROUTE;
        struct net_device *dev = card->wandev.dev;
        priv_area = dev->priv;
        port_num = card->wandev.comm_port;
	if((priv_area->route_status == ADD_ROUTE) &&
		((priv_area->IP_address & ~priv_area->IP_netmask) > 2)) {
		DEBUG_EVENT( "%s: Dynamic route failure.\n",card->devname);
		tmp_ip=ntohl(priv_area->IP_address);
		if(card->u.c.slarp_timer) {
				card->devname,
				card->devname);
				card->devname,
				card->devname);
				card->devname);
			DEBUG_EVENT( "%s: or A.B.C.2.\n",card->devname);
		priv_area->route_status = REMOVE_ROUTE;
        if((priv_area->route_status == REMOVE_ROUTE) && err) {
        	if(priv_area->route_removed) {
                in_dev = dev->ip_ptr;
                        struct in_ifaddr *ifa = in_dev->ifa_list;
                                local_IP_addr = ifa->ifa_local;
                                IP_netmask  = ifa->ifa_mask;
       		/* According to Cisco HDLC, if the point-to-point address is
		   A.B.C.1, then we are the opposite (A.B.C.2), and vice-versa.
		IP_netmask = ntohl(priv_area->IP_netmask);
	        remote_IP_addr = ntohl(priv_area->IP_address);
	        if(!card->u.c.slarp_timer) {
        strcpy(if_info.ifr_name, dev->name);
	switch (priv_area->route_status) {
		if(!card->u.c.slarp_timer) {
			if_data2->sin_addr.s_addr = remote_IP_addr;
			if_data2->sin_family = AF_INET;
			if_data1->sin_addr.s_addr = local_IP_addr;
			if_data1->sin_family = AF_INET;
				if_data2->sin_addr.s_addr = remote_IP_addr;
				if_data2->sin_family = AF_INET;
				card->devname, NIPQUAD(remote_IP_addr), err);
			((private_area_t *)dev->priv)->route_status = ROUTE_ADDED;
				card->devname);
				card->devname, NIPQUAD(local_IP_addr));
				card->devname, NIPQUAD(remote_IP_addr));
			priv_area->route_removed = 0;
		if(!card->u.c.slarp_timer) {
			if_data2->sin_addr.s_addr = 0;
			if_data2->sin_family = AF_INET;
			if_data1->sin_addr.s_addr = 0;
			if_data1->sin_family = AF_INET;
					card->devname, NIPQUAD(remote_IP_addr),
			((private_area_t *)dev->priv)->route_status =
                                        card->devname, NIPQUAD(local_IP_addr)); 
			priv_area->route_removed = 1;
#define PROC_CFG_FRM	"%-15s| %-12s|\n"
#define PROC_STAT_FRM	"%-15s| %-12s| %-14s|\n"
	card = priv_area->card;
			    PROC_CFG_FRM, priv_area->if_name, card->devname));
	card = priv_area->card;
			    priv_area->if_name, card->devname, STATE_DECODE(priv_area->common.state)));
#define PROC_DEV_FR_S_FRM	"%-20s| %-14s|\n"
#define PROC_DEV_FR_D_FRM	"%-20s| %-14d|\n"
	card = (sdla_t*)wandev->priv;
		 wandev->name));
		 "Comm Port", COMPORT_DECODE(card->wandev.comm_port)));
		 "Interface", INT_DECODE(wandev->interface)));
		 "Clocking", CLK_DECODE(wandev->clocking)));
		 "BaudRate",wandev->bps));
		 "MTU", wandev->mtu));
		 "UDP Port",  wandev->udp_port));
		 "TTL", wandev->ttl));
	card = (sdla_t*)wandev->priv;
			wandev->name, buffer);
#define PROC_IF_FR_S_FRM	"%-30s\t%-14s\n"
#define PROC_IF_FR_D_FRM	"%-30s\t%-14d\n"
#define PROC_IF_FR_L_FRM	"%-30s\t%-14ld\n"
	private_area_t* 	priv_area = dev->priv;
	sdla_t*			card = priv_area->card;
	if (!offs && card->wandev.update) {
		rslt = card->wandev.update(&card->wandev);
			case -EAGAIN:
	if (dev == NULL || dev->priv == NULL)
	priv_area = (private_area_t*)dev->priv;
			priv_area->if_name, buffer);
./sdla_template.c
* 		WANPIPE(tm) AFT CORE Hardware Support - Protocol/API
* Copyright:	(c) 2003-2008 Sangoma Technologies Inc.
		return -1;
	return -1;
	card->wandev.rtp_len=0;
	card->rtp_conf.rtp_ip=0;
	card->rtp_conf.rtp_sample=0;
	if (card->wandev.rtp_dev) {
              	dev_put(card->wandev.rtp_dev);
		card->wandev.rtp_dev=NULL;
		rtp_chan=&card->wandev.rtp_chan[i];
		if (rtp_chan->rx_skb) {
			wan_skb_free(rtp_chan->rx_skb);
			rtp_chan->rx_skb=NULL;
		if (rtp_chan->tx_skb) {
			wan_skb_free(rtp_chan->tx_skb);
			rtp_chan->rx_skb=NULL;
	while ((skb=wan_skb_dequeue(&card->u.aft.rtp_tap_list))) {
	card->wandev.rtp_tap=NULL;
	if (!card->rtp_conf.rtp_ip || !card->rtp_conf.rtp_sample) {
	if (card->rtp_conf.rtp_sample < 10 || card->rtp_conf.rtp_sample > 150) {
				card->devname,card->rtp_conf.rtp_sample);
			card->devname,
			NIPQUAD(card->rtp_conf.rtp_ip),
			card->rtp_conf.rtp_port,
			card->rtp_conf.rtp_sample,
			card->rtp_conf.rtp_devname,
			card->rtp_conf.rtp_mac[0],
			card->rtp_conf.rtp_mac[1],
			card->rtp_conf.rtp_mac[2],
			card->rtp_conf.rtp_mac[3],
			card->rtp_conf.rtp_mac[4],
			card->rtp_conf.rtp_mac[5]);
	card->wandev.rtp_len = (card->rtp_conf.rtp_sample * 8) + sizeof(wan_rtp_pkt_t);
	if ((card->wandev.rtp_dev=wan_dev_get_by_name(card->rtp_conf.rtp_devname)) == NULL){
				card->devname,
				card->rtp_conf.rtp_devname);
	dev=(netdevice_t*)card->wandev.rtp_dev;
	memcpy(card->rtp_conf.rtp_local_mac,dev->dev_addr,dev->addr_len);
	card->rtp_conf.rtp_local_ip=wan_get_ip_address(card->wandev.rtp_dev,WAN_LOCAL_IP);
	if (card->rtp_conf.rtp_local_ip == 0) {
	card->wandev.rtp_tap=&aft_rtp_tap;
	memset(card->wandev.rtp_chan,0,sizeof(card->wandev.rtp_chan));
	DEBUG_EVENT("%s: Failed to configure rtp tap!\n",card->devname);
	return -1;
		*skb_q=wan_skb_alloc(card->wandev.rtp_len+128);
		pkt->rtp_hdr.version=2;
                	pkt->rtp_hdr.pt=0;
                        pkt->rtp_hdr.pt=1;
				card->devname,chan,card->wandev.rtp_len);
        	pkt->rtp_hdr.seq=0;
		pkt->rtp_hdr.ts=0;
	ts=htonl(pkt->rtp_hdr.ts);
	pkt->rtp_hdr.ts = htonl(ts);
        if (wan_skb_len(skb) >= card->wandev.rtp_len ||
		pkt->rtp_hdr.ts = *timestamp;
				 &card->rtp_conf,
				 wan_skb_len(skb)-sizeof(wan_rtp_pkt_t));
                	nskb->next = nskb->prev = NULL;
			nskb->dev = card->wandev.rtp_dev;
			nskb->protocol = htons(ETH_P_802_2);
			wan_skb_queue_tail(&card->u.aft.rtp_tap_list,nskb);
			wan_set_bit(AFT_RTP_TAP_Q,&card->u.aft.port_task_cmd);
			WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
				card->devname,chan,nskb->dev->name);
		seq=htons(pkt->rtp_hdr.seq);
		pkt->rtp_hdr.seq=htons(seq);
		pkt->rtp_hdr.ts = htonl(ts);
	if (!card->rtp_conf.rtp_ip ||
	    !card->rtp_conf.rtp_sample ||
	    !card->wandev.rtp_len ||
	    !card->wandev.rtp_dev) {
					card->devname,chan);
					card->devname,chan);
	span = card->tdmv_conf.span_no-1;
	rtp_chan = &card->wandev.rtp_chan[chan];
	if (wan_test_bit(chan,&card->wandev.rtp_tap_call_map)) {
		if (!wan_test_and_set_bit(chan,&card->wandev.rtp_tap_call_status)) {
					card->devname,chan);
               	if (!wan_test_bit(chan,&card->wandev.rtp_tap_call_status)) {
               	wan_clear_bit(chan,&card->wandev.rtp_tap_call_status);
	       		card->devname,chan);
	aft_rtp_tap_chan(card, rx, len, &rtp_chan->rx_skb, &rtp_chan->rx_ts,
	aft_rtp_tap_chan(card, tx, len, &rtp_chan->tx_skb, &rtp_chan->tx_ts,
	chan->common.protocol = conf->protocol;
			wan_netif_name(dev), chan->common.protocol,
			chan->if_name);
	return -1;
	if (chan->common.protocol == WANCONFIG_PPP ||
	    chan->common.protocol == WANCONFIG_CHDLC){
		chan->common.prot_ptr = dev;
		if (chan->common.protocol == WANCONFIG_CHDLC){
					chan->if_name);
					chan->if_name);
			return -EINVAL;
	}else if (chan->common.protocol == WANCONFIG_GENERIC){
		chan->common.prot_ptr = dev;
				card->devname,chan->if_name,chan->common.protocol);
		return -EPROTONOSUPPORT;
	if (chan->common.protocol == WANCONFIG_PPP ||
	    chan->common.protocol == WANCONFIG_CHDLC){
		chan->common.prot_ptr = NULL;
	}else if (chan->common.protocol == WANCONFIG_GENERIC){
				card->devname, chan->if_name);
	if (chan->common.protocol == WANCONFIG_PPP ||
	    chan->common.protocol == WANCONFIG_CHDLC){
		wanpipe_generic_input(chan->common.dev, skb);
	if (chan->common.protocol == WANCONFIG_GENERIC){
		skb->protocol = htons(ETH_P_HDLC);
		skb->dev = chan->common.dev;
	skb->protocol = htons(ETH_P_IP);
	skb->dev = chan->common.dev;
	if (wan_iface.input && wan_iface.input(chan->common.dev, skb) != 0){
		WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common);	//++chan->if_stats.rx_dropped;
				card->devname);
	sdla_t *card = chan->card;
		return -EINVAL;
	if (chan->common.usedby != ANNEXG)
		return -EPROTONOSUPPORT;
	if (chan->annexg_dev)
		return -EBUSY;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	chan->annexg_dev = annexg_dev;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	sdla_t *card = wandev->priv;
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (!chan->annexg_dev || chan->common.usedby != ANNEXG)
		if (chan->annexg_dev == annexg_dev){
			wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
			chan->annexg_dev = NULL;
			wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	if (chan->common.usedby == ANNEXG && chan->annexg_dev){
			lapb_protocol.lapb_get_active_inactive(chan->annexg_dev,wp_stats);
	if (chan->common.state == WAN_CONNECTED){
		wp_stats->fr_active++;
		wp_stats->fr_inactive++;
	if (!(dev->flags&IFF_UP)){
		return m->count;
	if (chan->common.usedby == ANNEXG && chan->annexg_dev){
			return lapb_protocol.lapb_get_map(chan->annexg_dev,
		chan->label,
		wandev->name,(wandev->state == WAN_CONNECTED) ? '*' : ' ',
		dev->name,(chan->common.state == WAN_CONNECTED) ? '*' : ' ');
	return m->count;
	if (chan->common.usedby != TDM_VOICE_API &&
	    chan->common.usedby != TDM_VOICE_DCHAN &&
		!chan->tdm_span_voice_api) {
	if (chan->tdmv_zaptel_cfg) {
	chan->wp_tdm_api_dev.chan = chan;
	chan->wp_tdm_api_dev.card = card;
	wan_spin_lock_init(&chan->wp_tdm_api_dev.lock,"wp_aft_tdmapi_lock");
	strncpy(chan->wp_tdm_api_dev.name,chan->if_name,WAN_IFNAME_SZ);
	if (conf->hdlc_streaming) {
		chan->wp_tdm_api_dev.hdlc_framing=1;
	chan->wp_tdm_api_dev.cfg.rx_disable = 0;
	chan->wp_tdm_api_dev.cfg.tx_disable = 0;
	chan->wp_tdm_api_dev.tx_q_len = MAX_AFT_DMA_CHAINS;
			chan->wp_tdm_api_dev.cfg.hw_tdm_coding=WP_MULAW;
			chan->wp_tdm_api_dev.tdm_chan = chan->first_time_slot+1;
			chan->wp_tdm_api_dev.cfg.hw_tdm_coding=WP_ALAW;
			chan->wp_tdm_api_dev.tdm_chan = chan->first_time_slot;
		if (chan->dchan_time_slot >= 0) {
			chan->wp_tdm_api_dev.tdm_chan = 3;
			chan->wp_tdm_api_dev.tdm_chan = (chan->first_time_slot % 2)+1;
		if (card->fe.fe_cfg.tdmv_law == WAN_TDMV_MULAW){
		       	chan->wp_tdm_api_dev.cfg.hw_tdm_coding=WP_MULAW;
                        chan->wp_tdm_api_dev.cfg.hw_tdm_coding=WP_ALAW;
		chan->wp_tdm_api_dev.tx_q_len = 0;
		if (card->fe.fe_cfg.tdmv_law == WAN_TDMV_MULAW){
		       	chan->wp_tdm_api_dev.cfg.hw_tdm_coding=WP_MULAW;
			chan->wp_tdm_api_dev.tdm_chan = chan->first_time_slot+1;
                        chan->wp_tdm_api_dev.cfg.hw_tdm_coding=WP_ALAW;
			chan->wp_tdm_api_dev.tdm_chan = chan->first_time_slot+1;
		chan->wp_tdm_api_dev.active_ch = conf->active_ch;
		chan->wp_tdm_api_dev.active_ch = conf->active_ch << 1;
		chan->if_name, chan->wp_tdm_api_dev.active_ch,chan->wp_tdm_api_dev.tdm_chan);
	chan->wp_tdm_api_dev.cfg.idle_flag = conf->u.aft.idle_flag;
	chan->wp_tdm_api_dev.cfg.rbs_tx_bits = conf->u.aft.rbs_cas_idle;
	chan->wp_tdm_api_dev.tdm_span = card->tdmv_conf.span_no;
	chan->wp_tdm_api_dev.dtmfsupport = card->u.aft.tdmv_hw_dtmf;
	chan->wp_tdm_api_dev.span_mode=0;
	if (chan->tdm_span_voice_api) {
		chan->wp_tdm_api_dev.span_mode	= 1;
		chan->wp_tdm_api_dev.cfg.hw_mtu_mru = chan->tdm_api_chunk;
		chan->wp_tdm_api_dev.cfg.usr_period = chan->tdm_api_period;
		chan->wp_tdm_api_dev.cfg.usr_mtu_mru = chan->mtu;
	err=wanpipe_tdm_api_reg(&chan->wp_tdm_api_dev);
	wan_set_bit(0,&chan->wp_tdm_api_dev.init);
	if (wan_test_bit(0,&chan->wp_tdm_api_dev.init)){
		wan_clear_bit(0,&chan->wp_tdm_api_dev.init);
		err=wanpipe_tdm_api_unreg(&chan->wp_tdm_api_dev);
			wan_set_bit(0,&chan->wp_tdm_api_dev.init);
./aft_core_prot.c
 * Copyright:	(c) 1995-2007 Sangoma Technologies Inc.
 *				1. Added support for AFT-56k card, at the same time,
 *				made sure S514-56k card is working too.
	fe->write_fe_reg(						\
		((sdla_t*)fe->card)->hw, 				\
		(int)(((sdla_t*)fe->card)->wandev.state==WAN_CONNECTED),\
	fe->read_fe_reg(						\
		((sdla_t*)fe->card)->hw, 				\
		(int)(((sdla_t*)fe->card)->wandev.state==WAN_CONNECTED),\
	return fe->fe_cfg.media;
* Description	: Get current FE line state - is it Connected or Disconnected
* Arguments	: fe - pointer to Front End structure.	
*		  status - pointer to location where the FE line state will
*		  notused - ignored 
	*status = fe->fe_status;
	sdla_t		*card = (sdla_t *)fe->card;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	/* set to manually read the front-end registers */
		fe->fe_param.k56_param.RR8_reg_56k = 0;
		fe->fe_param.k56_param.RR8_reg_56k = READ_REG(REG_INT_EN_STAT);
		fe->fe_param.k56_param.RRA_reg_56k = READ_REG(REG_DEV_STAT);
		fe->fe_param.k56_param.RRC_reg_56k = READ_REG(REG_RX_CODES);
		status |= fe->fe_param.k56_param.RRA_reg_56k;
		status |= fe->fe_param.k56_param.RRC_reg_56k;
	DEBUG_56K("56K registers: 8-%02X,C-%02X,A-%02X\n", 
			fe->fe_param.k56_param.RR8_reg_56k,
			fe->fe_param.k56_param.RRC_reg_56k, 
			fe->fe_param.k56_param.RRA_reg_56k);
	if((fe->fe_param.k56_param.RR8_reg_56k & BIT_INT_EN_STAT_RX_CODE) && 
		(!fe->fe_param.k56_param.RRC_reg_56k)) {
	if(fe->fe_param.k56_param.RRA_reg_56k & BIT_DEV_STAT_RLOS) {
		fe->fe_param.k56_param.RLOS_56k = 1;
	if(!((fe->fe_param.k56_param.RRC_reg_56k ^ fe->fe_param.k56_param.prev_RRC_reg_56k) & 
		fe->fe_param.k56_param.delta_RRC_reg_56k) ||
		(fe->fe_status == FE_CONNECTED)) {
	fe->fe_param.k56_param.delta_RRC_reg_56k |= 
		(fe->fe_param.k56_param.RRC_reg_56k ^ fe->fe_param.k56_param.prev_RRC_reg_56k);
	if(manual_read || (fe->fe_param.k56_param.RR8_reg_56k & BIT_INT_EN_STAT_ACTIVE)) {
		if ((fe->fe_param.k56_param.RRA_reg_56k & 0x0F) > BIT_DEV_STAT_IL_44_dB) {
			if((fe->fe_status == FE_DISCONNECTED) ||
			 (fe->fe_status == FE_UNITIALIZED)) {
				fe->fe_status = FE_CONNECTED;
				fe->fe_param.k56_param.delta_RRC_reg_56k = 0;
				if(fe->fe_param.k56_param.RLOS_56k == 1) {
					fe->fe_param.k56_param.RLOS_56k = 0;
							fe->name);
							fe->name);
				if (card->wandev.te_link_state){
					card->wandev.te_link_state(card);
			if((fe->fe_status == FE_CONNECTED) || 
			 (fe->fe_status == FE_UNITIALIZED)) {
				fe->fe_status = FE_DISCONNECTED;
				fe->fe_param.k56_param.delta_RRC_reg_56k = 0;
				if(fe->fe_param.k56_param.RLOS_56k == 1) {
							fe->name);
						fe->name);
				if (card->wandev.te_link_state){
					card->wandev.te_link_state(card);
	fe->fe_param.k56_param.prev_RRC_reg_56k = 
				fe->fe_param.k56_param.RRC_reg_56k;
	fe->fe_alarm = status;
	fe_iface->global_config		= &sdla_56k_global_config;
	fe_iface->global_unconfig	= &sdla_56k_global_unconfig;
	fe_iface->config		= &sdla_56k_config;
	fe_iface->unconfig		= &sdla_56k_unconfig;
	fe_iface->polling		= &sdla_56k_polling;
	fe_iface->get_fe_status		= &sdla_56k_get_fe_status;
	fe_iface->get_fe_media		= &sdla_56k_get_fe_media;
	fe_iface->get_fe_media_string	= &sdla_56k_get_fe_media_string;
	fe_iface->print_fe_alarm	= &sdla_56k_print_alarm;
	fe_iface->read_alarm		= &sdla_56k_alarm;
	fe_iface->update_alarm_info	= &sdla_56k_update_alarm_info;
	fe_iface->process_udp		= &sdla_56k_udp;
	fe_iface->isr			= &sdla_56k_intr;
	fe_iface->check_isr		= &sdla_56k_check_intr;
	fe->fe_status = FE_UNITIALIZED;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
			fe->name, FE_MEDIA_DECODE(fe));
				fe->name,
	sdla_t		*card = (sdla_t *)fe->card;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	fe->fe_status = FE_UNITIALIZED;
	fe->fe_param.k56_param.prev_RRC_reg_56k = 0;
	fe->fe_param.k56_param.delta_RRC_reg_56k = 0;
	if (card->wandev.clocking == WANOPT_EXTERNAL){
				card->devname);
				fe->name);
	fe->fe_status = FE_CONNECTED;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	fe->fe_status = FE_UNITIALIZED;
	sdla_56k_param_t	*k56_param = &fe->fe_param.k56_param;
	/* check for a DLP (DSU Non-latching loopback) code condition */
	if((k56_param->RRC_reg_56k ^ k56_param->prev_RRC_reg_56k) &
		if(k56_param->RRC_reg_56k & BIT_RX_CODES_DLP) {
					fe->name);
					fe->name);
	if((k56_param->RRC_reg_56k ^ k56_param->prev_RRC_reg_56k) &
		if(k56_param->RRC_reg_56k & BIT_RX_CODES_OOF) {
					fe->name);
					fe->name);
	if((k56_param->RRC_reg_56k ^ k56_param->prev_RRC_reg_56k) &
		if(k56_param->RRC_reg_56k & BIT_RX_CODES_OOS) {
					fe->name);
					fe->name);
	if((k56_param->RRC_reg_56k ^ k56_param->prev_RRC_reg_56k) &
		if(k56_param->RRC_reg_56k & BIT_RX_CODES_CMI) {
					fe->name);
					fe->name);
	if((k56_param->RRC_reg_56k ^ k56_param->prev_RRC_reg_56k) &
		if(k56_param->RRC_reg_56k & BIT_RX_CODES_ZSC) {
					fe->name);
					fe->name);
	if((k56_param->RRC_reg_56k ^ k56_param->prev_RRC_reg_56k) &
		if(k56_param->RRC_reg_56k & BIT_RX_CODES_DMI) {
				fe->name);
				fe->name);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
			fe->name,
			fe->name,
	if (lb->cmd != WAN_FE_LBMODE_CMD_SET){
		return -EINVAL;
	return sdla_56k_set_lbmode(fe, lb->type, lb->mode);
	switch(udp_cmd->wan_cmd_command){
		fe_media->media		= WAN_MEDIA_56K;
		udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
		udp_cmd->wan_cmd_data_len = sizeof(wan_femedia_t); 
		fe->fe_alarm = sdla_56k_alarm(fe, 1); 
		memcpy(&data[0], &fe->fe_stats, sizeof(sdla_fe_stats_t));
		udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
	    	udp_cmd->wan_cmd_data_len = sizeof(sdla_fe_stats_t);
	    	udp_cmd->wan_cmd_return_code = 
	    	udp_cmd->wan_cmd_data_len = 0x00;
		udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
	    	udp_cmd->wan_cmd_data_len = 0;
	DEBUG_EVENT("%s: 56K Alarms:\n", fe->name);
				fe->name,
				fe->name,
				fe->name,
				fe->name,
				fe->name,
		"In service", INS_ALARM_56K(fe->fe_alarm), 
		"Data mode idle", DMI_ALARM_56K(fe->fe_alarm));
		"Zero supp. code", ZCS_ALARM_56K(fe->fe_alarm), 
		"Ctrl mode idle", CMI_ALARM_56K(fe->fe_alarm));
		"Out of service code", OOS_ALARM_56K(fe->fe_alarm), 
		"Out of frame code", OOF_ALARM_56K(fe->fe_alarm));
		"Valid DSU NL loopback", DLP_ALARM_56K(fe->fe_alarm), 
		"Unsigned mux code", UMC_ALARM_56K(fe->fe_alarm));
		"Rx loss of signal", RLOS_ALARM_56K(fe->fe_alarm), 
	return m->count;	
./sdla_56k.c
* Copyright:	(c) 1995-2004 Sangoma Technologies Inc.
* Dec 12, 2001  Nenad Corbic	Re-wrote the tty receive algorithm, using
* Dec 03, 2001  Gideon Hack	Updated for S514-5 56K adapter.
 * wp_asyhdlc_init - Cisco HDLC protocol initialization routine.
 *  o initialize protocol-specific fields of the adapter data space.
	if (conf->config_id != WANCONFIG_ASYHDLC) {
				  card->devname, conf->config_id);
		return -EINVAL;
	if ((conf->comm_port == WANOPT_PRI) || (conf->comm_port == WANOPT_SEC)){
		if (card->next){
			if (conf->comm_port != card->next->u.c.comm_port){
				card->u.c.comm_port = conf->comm_port;
				printk(KERN_INFO "%s: ERROR - %s port used!\n",
        		        	card->wandev.name, PORT(conf->comm_port));
				return -EINVAL;
			card->u.c.comm_port = conf->comm_port;
		printk(KERN_INFO "%s: ERROR - Invalid Port Selected!\n",
                			card->wandev.name);
		return -EINVAL;
	/* Initialize protocol-specific fields */
	if (card->u.c.comm_port == WANOPT_PRI){
		card->mbox_off = PRI_BASE_ADDR_MB_STRUCT;
		card->mbox_off = SEC_BASE_ADDR_MB_STRUCT;
	mb = &card->wan_mbox;
	mb1 = &card->wan_mbox;
	if (!card->configured){
			card->hw_iface.peek(card->hw, 
				card->mbox_off+offsetof(wan_mbox_t, wan_return_code),
			if ((jiffies - timeout) > 1*HZ) break;
				card->devname);
			return -EIO;
	card->wandev.clocking = conf->clocking;
	card->wandev.ignore_front_end_status = conf->ignore_front_end_status;
	card->wandev.line_idle = conf->line_idle;
	card->wandev.line_coding = conf->line_coding;
	card->wandev.connection = conf->connection;
	err = (card->hw_iface.check_mismatch) ? 
			card->hw_iface.check_mismatch(card->hw,conf->fe_cfg.media) : -EINVAL;
	if (IS_TE1_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_te_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg = card->hw_iface.fe_write;
		card->fe.read_fe_reg	 = card->hw_iface.fe_read;
		card->wandev.fe_enable_timer = chdlc_enable_timer;
		card->wandev.te_link_state = chdlc_handle_front_end_state;
		conf->electrical_interface = 
		if (card->u.c.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
	}else if (IS_56K_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_56k_iface_init(&card->fe,&card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg = card->hw_iface.fe_write;
		card->fe.read_fe_reg	 = card->hw_iface.fe_read;
		if (card->u.c.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
		card->fe.fe_status = FE_CONNECTED;
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
		return -EIO;
		card->devname, str); 
		return -EIO;
	card->isr			= &wpc_isr;
	card->poll			= NULL;
	card->exec			= NULL;
	card->wandev.update		= &update;
 	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= &del_if;
	card->wandev.udp_port   	= conf->udp_port;
	card->wandev.new_if_cnt = 0;
	atomic_set(&card->wandev.if_cnt,0);
	card->wandev.get_config_info 	= &chdlc_get_config_info;
	card->wandev.get_status_info 	= &chdlc_get_status_info;
	card->wandev.set_dev_config    	= &chdlc_set_dev_config;
	card->wandev.set_if_info     	= &chdlc_set_if_info;
	card->u.c.update_call_count = 0;
	card->wandev.ttl = conf->ttl;
	card->wandev.electrical_interface = conf->electrical_interface; 
	if ((card->u.c.comm_port == WANOPT_SEC && conf->electrical_interface == WANOPT_V35)&&
	    card->type != SDLA_S514){
		printk(KERN_INFO "%s: ERROR - V35 Interface not supported on S508 %s port \n",
			card->devname, PORT(card->u.c.comm_port));
		return -EIO;
	port_num = card->u.c.comm_port;
	if(card->type == SDLA_S514) {
		card->u.c.receive_only = conf->receive_only;
		if(conf->receive_only) {
                                card->devname);
	if(card->wandev.clocking) {
		if(conf->bps > max_permitted_baud) {
			conf->bps = max_permitted_baud;
				card->wandev.name);
				card->wandev.name, max_permitted_baud);
		card->wandev.bps = conf->bps;
        	card->wandev.bps = 0;
	card->wandev.mtu = conf->mtu;
         * Use this pointer to calculate the value of card->u.c.flags !
	mb1->wan_data_len = 0;
	mb1->wan_command = READ_ASY_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb1);
				card->devname,err);
                if(card->type != SDLA_S514)
                	enable_irq(card->wandev.irq);
		return -EIO;
	card->flags_off = 
		((ASY_CONFIGURATION_STRUCT *)mb1->wan_data)->
    	card->intr_type_off = 
		card->flags_off +
	card->intr_perm_off = 
		card->flags_off +
	card->fe_status_off = 
		card->flags_off + 
	card->wandev.state = WAN_DUALPORT;
	if (!card->wandev.piggyback){	
		if(err || (card->timer_int_enabled < 1)) { 
					card->devname, card->timer_int_enabled);
					card->devname);
			return -EIO;
				card->devname, card->timer_int_enabled);
		card->configured = 1;
			card->devname);
		return -EIO;	
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	card->u.c.backup = conf->backup;
	card->disable_comm = &disable_comm;
 * update - Update wanpipe device status & statistics
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical))
                return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
		return -ENODEV;
      	flags = card->u.c.flags;
	if(test_and_set_bit(0,&chdlc_priv_area->update_comms_stats)){
		return -EAGAIN;
	chdlc_priv_area->update_comms_stats = 
       	flags->interrupt_info_struct.interrupt_permission |= APP_INT_ON_TIMER;
	card->u.c.timer_int_enabled = TMR_INT_ENABLED_UPDATE;
		if(chdlc_priv_area->update_comms_stats == 0)
                if ((jiffies - timeout) > (1 * HZ)){
    			chdlc_priv_area->update_comms_stats = 0;
 			card->u.c.timer_int_enabled &=
 			return -EAGAIN;
	spin_lock_irqsave(&card->wandev.lock, smp_flags);
	chdlc_priv_area->update_comms_stats=0;
	spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
 * new_if - Create new logical channel.
 * to dev->priv pointer.  
 * Also the dev->init pointer should also be initialized
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
			card->devname, conf->name);
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
		WAN_MEM_ASSERT(card->devname);
		return -ENOMEM;
	chdlc_priv_area->card = card; 
	strcpy(chdlc_priv_area->if_name, conf->name);
	WAN_TASKLET_INIT((&chdlc_priv_area->common.bh_task),0,chdlc_bh,(unsigned long)chdlc_priv_area);
	if (atomic_read(&card->wandev.if_cnt) > 0){
		err=-EEXIST;
	chdlc_priv_area->TracingEnabled = 0;
	chdlc_priv_area->route_status = NO_ROUTE;
	chdlc_priv_area->route_removed = 0;
	card->u.c.async_mode = 1; //conf->async_mode;
	if(card->u.c.async_mode) {
			wandev->name);
	       	if(strcmp(conf->usedby, "WANPIPE") == 0) {
						wandev->name);
			chdlc_priv_area->common.usedby = WANPIPE;
						wandev->name);
			chdlc_priv_area->common.usedby = API;
			wan_reg_api(chdlc_priv_area, dev, card->devname);
		if(!card->wandev.clocking) {
				wandev->name);
			err=-EINVAL;
		if((card->wandev.bps < MIN_ASY_BAUD_RATE) ||
			(card->wandev.bps > MAX_ASY_BAUD_RATE)) {
				wandev->name);
			err=-EINVAL;
		card->u.c.api_options = 0;
		card->u.c.protocol_options = conf->u.chdlc.protocol_options;
				card->devname,card->u.c.protocol_options);
		card->u.c.tx_bits_per_char = conf->tx_bits_per_char;
                card->u.c.rx_bits_per_char = conf->rx_bits_per_char;
                card->u.c.stop_bits = conf->stop_bits;
		card->u.c.parity = conf->parity;
		card->u.c.break_timer = conf->break_timer;
		card->u.c.inter_char_timer = conf->inter_char_timer;
		card->u.c.rx_complete_length = conf->rx_complete_length;
		card->u.c.xon_char = conf->xon_char;
	if ((chdlc_priv_area->gateway = conf->gateway) == WANOPT_YES){
			card->devname,chdlc_priv_area->if_name);
	chdlc_priv_area->mc = conf->mc;
					   &chdlc_priv_area->dent, 
					   chdlc_priv_area->if_name, 
			card->devname, chdlc_priv_area->if_name);
	dev->init = &if_init;
	dev->priv = chdlc_priv_area;
	set_bit(0,&chdlc_priv_area->config_chdlc);
	atomic_inc(&card->wandev.if_cnt);
	WAN_TASKLET_KILL(&chdlc_priv_area->common.bh_task);
	wan_unreg_api(chdlc_priv_area, card->devname);
	dev->priv=NULL;
 * del_if - Delete logical channel.
	chdlc_private_area_t* 	chdlc_priv_area = dev->priv;
	sdla_t*			card = chdlc_priv_area->card;
	WAN_TASKLET_KILL(&chdlc_priv_area->common.bh_task);
	wan_unreg_api(chdlc_priv_area, card->devname);
	wanrouter_proc_delete_interface(wandev, chdlc_priv_area->if_name);
	atomic_dec(&card->wandev.if_cnt);
 * if_init - Initialize Linux network interface.
	chdlc_private_area_t* chdlc_priv_area = dev->priv;
	sdla_t* card = chdlc_priv_area->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= TX_TIMEOUT;
	dev->do_ioctl		= if_do_ioctl;
	if (chdlc_priv_area->common.usedby == BRIDGE || 
            chdlc_priv_area->common.usedby == BRIDGE_NODE){
		memcpy(dev->dev_addr, "\xFE\xFC\x00\x00\x00\x00", 6);
		*(int *)(dev->dev_addr + 2) += hw_addr;
		/* Initialize media-specific parameters */
		dev->flags		|= IFF_POINTOPOINT;
		dev->flags		|= IFF_NOARP;
		if (chdlc_priv_area->mc == WANOPT_YES){
			dev->flags 	|= (IFF_MULTICAST|IFF_ALLMULTI);
		if (chdlc_priv_area->true_if_encoding){
			dev->type	= ARPHRD_HDLC; /* This breaks the tcpdump */
			dev->type	= ARPHRD_PPP;
		dev->mtu		= card->wandev.mtu;
		if(chdlc_priv_area->common.usedby == API) {
			dev->mtu += sizeof(api_tx_hdr_t);
		dev->hard_header_len	= 0;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start); 
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end); 
        dev->tx_queue_len = 100;
 * if_open - Open network interface.
	chdlc_private_area_t* chdlc_priv_area = dev->priv;
	sdla_t* card = chdlc_priv_area->card;
		return -EBUSY;
	chdlc_priv_area->router_start_time = tv.tv_sec;
	chdlc_priv_area->config_chdlc_timeout=jiffies;
	if (wan_test_bit(0,&chdlc_priv_area->config_chdlc)){
		card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
		wan_clear_bit(0,&chdlc_priv_area->config_chdlc);
		card->u.c.timer_int_enabled |= TMR_INT_ENABLED_CONFIG;
		card->hw_iface.poke(card->hw, card->flags_off, &flags, sizeof(flags));
 * if_close - Close network interface.
	chdlc_private_area_t* chdlc_priv_area = dev->priv;
	sdla_t* card = chdlc_priv_area->card;
	dev->start=0;
	del_timer(&chdlc_priv_area->poll_delay_timer);
	if (chdlc_priv_area->common.usedby == API){	
		spin_lock_irqsave(&card->wandev.lock,smp_flags);
				chdlc_priv_area->common.sk);
		spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
 * disable_comm - Main shutdown function
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	if (card->u.c.comm_enabled){
		card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	/* TE1 - Unconfiging, only on shutdown */
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
    	chdlc_private_area_t* chan = dev->priv;
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++card->wandev.stats.collisions;
	printk (KERN_INFO "%s: Transmit timed out on %s\n", card->devname,dev->name);
 * if_send - Send a packet on a network interface.
 *   block a timer-based transmit from overlapping.
 *		non-0	packet may be re-transmitted (tbusy must be set)
	chdlc_private_area_t *chdlc_priv_area = dev->priv;
	sdla_t *card = chdlc_priv_area->card;
		 * tx-done interrupt.
			card->devname, dev->name);
	if (dev->tbusy){
		 ++card->wandev.stats.collisions;
		if((jiffies - chdlc_priv_area->tick_counter) < (5 * HZ)) {
   	if (chdlc_priv_area->common.usedby != ANNEXG && 
	    skb->protocol != htons(PVC_PROT)){
				card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
                if(chdlc_priv_area->common.usedby == WANPIPE && chk_bcast_mcast_addr(card, dev, skb)){
			++card->wandev.stats.tx_dropped;
      	if(card->type != SDLA_S514){
    	if(test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
					card->wandev.name,card->wandev.critical);
                ++card->wandev.stats.tx_dropped;
	if(card->wandev.state != WAN_CONNECTED){
       		++card->wandev.stats.tx_dropped;
	}else if(!skb->protocol){
        	++card->wandev.stats.tx_errors;
		void* data = skb->data;
		unsigned len = skb->len;
		if (chdlc_priv_area->common.usedby == API){
			if (card->u.c.receive_only ||
				++card->wandev.stats.tx_dropped;
			attr = api_tx_hdr->attr;
			misc_Tx_bits = api_tx_hdr->misc_Tx_bits;
			len -= sizeof(api_tx_hdr_t);
			err=-1;
			++card->wandev.stats.tx_packets;
                        card->wandev.stats.tx_bytes += len;
		 	dev->trans_start = jiffies;
		chdlc_priv_area->tick_counter = jiffies;
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX);
	clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
	if(card->type != SDLA_S514){
 * chk_bcast_mcast_addr - Check for source broadcast addresses
	chdlc_private_area_t *chdlc_priv_area=dev->priv;
        src_ip_addr = *(u32 *)(skb->data + 12);
	if (chdlc_priv_area->common.usedby != WANPIPE){
        in_dev = dev->ip_ptr;
                struct in_ifaddr *ifa= in_dev->ifa_list;
                        broadcast_ip_addr = ifa->ifa_broadcast;
        if((dev->flags & IFF_BROADCAST) && (src_ip_addr == broadcast_ip_addr)) {
				card->devname);
				card->devname);
	c_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	c_udp_pkt->wan_udp_len = temp;
	temp = c_udp_pkt->wan_udp_sport;
	c_udp_pkt->wan_udp_sport = 
			c_udp_pkt->wan_udp_dport; 
	c_udp_pkt->wan_udp_dport = temp;
	*((unsigned short *)(c_udp_pkt->wan_udp_data+mbox_len+even_bound)) = temp;	
	*((unsigned short *)(c_udp_pkt->wan_udp_data+mbox_len+even_bound+2)) = temp;
	c_udp_pkt->wan_udp_sum = 0;
	c_udp_pkt->wan_udp_sum = calc_checksum(&data[UDP_OFFSET],udp_length+UDP_OFFSET);
	c_udp_pkt->wan_ip_len = temp;
	ip_temp = c_udp_pkt->wan_ip_src;
	c_udp_pkt->wan_ip_src = c_udp_pkt->wan_ip_dst;
	c_udp_pkt->wan_ip_dst = ip_temp;
	c_udp_pkt->wan_ip_sum = 0;
	c_udp_pkt->wan_ip_sum = calc_checksum(data,sizeof(struct iphdr));
 * Get ethernet-style interface statistics.
	if ((chdlc_priv_area=dev->priv) == NULL)
	my_card = chdlc_priv_area->card;
	return &my_card->wandev.stats; 
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_ASY_CODE_VERSION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		len = mb->wan_data_len;
			memcpy(str, mb->wan_data, len);
					card->devname,len,str_size);
 * Set interrupt mode -- HDLC Version.
	wan_mbox_t* mb = &card->wan_mbox;
		 (ASY_INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->interrupt_triggers 	= mode;
	int_data->IRQ				= card->wandev.irq;
	int_data->interrupt_timer               = 1;
	mb->wan_data_len = sizeof(ASY_INT_TRIGGERS_STRUCT);
	mb->wan_command = SET_ASY_INTERRUPT_TRIGGERS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t* mb = &card->wan_mbox;
		 (ASY_INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->interrupt_triggers 	= 0;
	int_data->IRQ				= card->wandev.irq;	
	int_data->interrupt_timer               = 1;
	mb->wan_data_len = sizeof(ASY_INT_TRIGGERS_STRUCT);
	mb->wan_command = SET_ASY_INTERRUPT_TRIGGERS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	if (card->u.c.async_mode) {
		mb->wan_command = DISABLE_ASY_COMMUNICATIONS;
		mb->wan_command = DISABLE_ASY_COMMUNICATIONS;
	mb->wan_data_len = 0;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card->u.c.comm_enabled = 0;
	/* TE1 - Unconfiging, only on shutdown */
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = ENABLE_ASY_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->u.c.comm_enabled = 1;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = DISABLE_ASY_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->u.c.comm_enabled = 0;
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_COMMS_ERROR_STATS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
		card->wandev.fe_iface.read_alarm(&card->fe, 0); 
		card->wandev.fe_iface.read_pmon(&card->fe,0); 
		card->wandev.fe_iface.read_alarm(&card->fe, 1); 
	err_stats = (COMMS_ERROR_STATS_STRUCT *)mb->wan_data;
	card->wandev.stats.rx_over_errors = 
		err_stats->Rx_overrun_err_count;
	card->wandev.stats.rx_crc_errors = 
		err_stats->Rx_parity_err_count;
	card->wandev.stats.rx_frame_errors = 
		err_stats->Rx_framing_err_count;
 *	Return:	0 - o.k.
 *		1 - no transmit buffers available
	card->hw_iface.peek(card->hw, card->u.c.txbuf_off, &txbuf, sizeof(txbuf));
	card->hw_iface.poke(card->hw, txbuf.ptr_data_bfr, data, len);
	card->hw_iface.poke(card->hw,
		       		card->u.c.txbuf_off,
	card->hw_iface.poke_byte(card->hw,
		       		card->u.c.txbuf_off+
	card->u.c.txbuf_off += sizeof(txbuf);
	if (card->u.c.txbuf_off > card->u.c.txbuf_last_off){
		card->u.c.txbuf_off = card->u.c.txbuf_base_off;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	DEBUG_TEST("%s: Chdlc enabling timer %s\n",card->devname,
	card->u.c.timer_int_enabled |= TMR_INT_ENABLED_TE;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_command;
			card->devname, cmd);
			card->devname, cmd, err);
	sdla_t *card = chan->card;
		len=skb->len;
		if (chan->common.usedby == API){
				card->wandev.stats.rx_packets++;
				card->wandev.stats.rx_bytes += len;
				++card->wandev.stats.rx_dropped;
			++card->wandev.stats.rx_dropped;
	WAN_TASKLET_END((&chan->common.bh_task));
	if (!card->hw){
	card->hw_iface.peek(card->hw, card->flags_off,
	set_bit(0,&card->in_isr);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (!card->tty_opt && !dev && 
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical)) {
				card->devname);
	if(card->type != SDLA_S514) {
		if(test_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
				card->devname);
			card->in_isr = 0;
			card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX);
			chdlc_private_area_t* chdlc_priv_area=dev->priv;
			if (chdlc_priv_area->common.usedby == API){
		++ card->timer_int_enabled;
			card->hw_iface.peek(card->hw, 
					    card->fe_status_off,
			card->hw_iface.poke(card->hw, 
					    card->fe_status_off,
		if (card->next){
			set_bit(0,&card->spurious);
				card->devname,
	card->in_isr = 0;
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	card->hw_iface.peek(card->hw, card->u.c.rxmb_off, &rxbuf, sizeof(rxbuf));
			card->devname, (unsigned)card->u.c.rxmb_off, rxbuf.opp_flag);
		printk(KERN_INFO "%s: Critical router failure ...!!!\n", card->devname);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (chdlc_priv_area->common.usedby == ANNEXG){
		len = rxbuf.data_length - CRC_LENGTH;
					card->devname);
		++card->wandev.stats.rx_dropped;
	if((addr + len) > card->u.c.rx_top_off + 1) {
		unsigned tmp = card->u.c.rx_top_off - addr + 1;
		card->hw_iface.peek(card->hw, addr, buf, tmp);
		addr = card->u.c.rx_base_off;
		len -= tmp;
	card->hw_iface.peek(card->hw, addr, buf, len);
	skb->protocol = htons(ETH_P_IP);
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	} else if(chdlc_priv_area->common.usedby == API) {
                api_rx_hdr = (api_rx_hdr_t*)&skb->data[0x00];
		api_rx_hdr->error_flag=0;
     		api_rx_hdr->time_stamp = rxbuf.time_stamp;
                skb->protocol = htons(WP_PVC_PROT);
		skb->dev      = dev;
               	skb->pkt_type = WAN_PACKET_DATA;
			++card->wandev.stats.rx_dropped;
		WAN_TASKLET_SCHEDULE(&chdlc_priv_area->common.bh_task);
	} else if (chdlc_priv_area->common.usedby == ANNEXG){
		if (chdlc_priv_area->annexg_dev){
			skb->protocol = htons(ETH_P_X25);
			skb->dev = chdlc_priv_area->annexg_dev;
				++card->wandev.stats.rx_dropped;
			WAN_TASKLET_SCHEDULE(&chdlc_priv_area->common.bh_task);
			++card->wandev.stats.rx_errors;
	}else if (chdlc_priv_area->common.usedby == BRIDGE ||
		  chdlc_priv_area->common.usedby == BRIDGE_NODE){
		if (skb->len <= ETH_ALEN) {
			++card->wandev.stats.rx_errors;
		card->wandev.stats.rx_packets ++;
		card->wandev.stats.rx_bytes += skb->len;
		skb->dev = dev;
		skb->protocol=eth_type_trans(skb,dev);
                          ++ chdlc_priv_area->if_stats.multicast;
		card->wandev.stats.rx_packets ++;
		card->wandev.stats.rx_bytes += skb->len;
		skb->protocol = htons(ETH_P_IP);
                skb->dev = dev;
	card->hw_iface.poke_byte(card->hw, 
			card->u.c.rxmb_off+offsetof(ASY_DATA_RX_STATUS_EL_STRUCT, opp_flag),
	card->u.c.rxmb_off += sizeof(rxbuf);
	if (card->u.c.rxmb_off > card->u.c.rxbuf_last_off){
		card->u.c.rxmb_off = card->u.c.rxbuf_base_off;
 *    2) Reading board-level statistics for updating the proc file system.
	if (card->u.c.timer_int_enabled & TMR_INT_ENABLED_TE) {
		card->wandev.fe_iface.polling(&card->fe);
		card->u.c.timer_int_enabled &= ~TMR_INT_ENABLED_TE;
   	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
        chdlc_priv_area = dev->priv;
	if (card->u.c.timer_int_enabled & TMR_INT_ENABLED_CONFIG) {
		card->u.c.timer_int_enabled &= ~TMR_INT_ENABLED_CONFIG;
       	if(card->u.c.timer_int_enabled & TMR_INT_ENABLED_UDP) {
		card->u.c.timer_int_enabled &= ~TMR_INT_ENABLED_UDP;
	if(card->u.c.timer_int_enabled & TMR_INT_ENABLED_UPDATE) {
                if(!(-- chdlc_priv_area->update_comms_stats)) {
			card->u.c.timer_int_enabled &= 
        if(!card->u.c.timer_int_enabled) {
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
/*-----------------------------------------------------------------------------
------------------------------------------------------------------------------*/
 	wan_mbox_t *mb = &card->wan_mbox;
	if(card->wandev.clocking)
		cfg.baud_rate = card->wandev.bps;
	cfg.line_config_options = (card->wandev.electrical_interface == WANOPT_RS232) ?
	cfg.API_options 		= card->u.c.api_options;
	cfg.protocol_options		= card->u.c.protocol_options;
	cfg.Tx_bits_per_char		= card->u.c.tx_bits_per_char;
	cfg.Rx_bits_per_char		= card->u.c.rx_bits_per_char;
	cfg.stop_bits			= card->u.c.stop_bits;
	cfg.parity			= card->u.c.parity;
	cfg.break_timer			= card->u.c.break_timer;
	cfg.Rx_inter_char_timer		= card->u.c.inter_char_timer; 
	cfg.Rx_complete_length		= card->u.c.rx_complete_length; 
	cfg.XON_char			= card->u.c.xon_char;
	cfg.XOFF_char			= card->u.c.xoff_char;
	mb->wan_data_len = sizeof(ASY_CONFIGURATION_STRUCT);
	memcpy(mb->wan_data, &cfg, mb->wan_data_len);
	mb->wan_command = SET_ASY_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t		*mb = &card->wan_mbox;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -EINVAL;
	mb->wan_data_len = 0;
	mb->wan_command = ENABLE_ASY_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->u.c.comm_enabled = 1;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_GLOBAL_EXCEPTION_CONDITION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		switch(mb->wan_return_code) {
				card->hw_iface.peek(card->hw, 
					    	    card->fe_status_off,
				card->fe.fe_param.k56_param.RR8_reg_56k = 
				card->fe.fe_param.k56_param.RRA_reg_56k = 
				card->fe.fe_param.k56_param.RRC_reg_56k = 
				card->wandev.fe_iface.read_alarm(&card->fe, 0); 
				card->wandev.fe_iface.isr(&card->fe);
			if ((mb->wan_data[0] & (DCD_HIGH | CTS_HIGH)) == (DCD_HIGH | CTS_HIGH)){
				card->fe.fe_status = FE_CONNECTED;
				card->fe.fe_status = FE_DISCONNECTED;
				card->devname);
			switch(mb->wan_data[0] & (DCD_HIGH | CTS_HIGH)) {
                                        printk(KERN_INFO "%s: DCD high, CTS high\n",card->devname);
					printk(KERN_INFO "%s: DCD high, CTS low\n",card->devname);
                                        printk(KERN_INFO "%s: DCD low, CTS high\n",card->devname); 
                                        printk(KERN_INFO "%s: DCD low, CTS low\n",card->devname);
				card->devname, mb->wan_return_code);
 *	if_do_ioctl - Ioctl handler for fr
	chdlc_private_area_t* chan= (chdlc_private_area_t*)dev->priv;
		return -ENODEV;
	card=chan->card;
				err= -EINVAL;
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			err=wan_bind_api_to_svc(chan,ifr->ifr_data);
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
				err= -EINVAL;
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			err=wan_unbind_api_from_svc(chan,ifr->ifr_data);
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
			err = chan->common.state;
			card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
			if (atomic_read(&chan->udp_pkt_len) != 0){
				return -EBUSY;
			atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
			if (test_bit(0,&card->in_isr)){
				atomic_set(&chan->udp_pkt_len,0);
				return -EBUSY;
			wan_udp_pkt=(wan_udp_pkt_t*)chan->udp_pkt_data;
			if (copy_from_user(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			spin_lock_irqsave(&card->wandev.lock, smp_flags);
			if (test_bit(0,&card->in_isr)) {
						card->devname,dev->name);
				atomic_set(&chan->udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
				return -EBUSY;
			spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
			if (atomic_read(&chan->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						card->devname,atomic_read(&chan->udp_pkt_len));
				atomic_set(&chan->udp_pkt_len,0);
				return -EINVAL;
			if (copy_to_user(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			atomic_set(&chan->udp_pkt_len,0);
			return -EOPNOTSUPP;
	if(!atomic_read(&chdlc_priv_area->udp_pkt_len) &&
	  (skb->len <= MAX_LGTH_UDP_MGNT_PKT)) {
		atomic_set(&chdlc_priv_area->udp_pkt_len, skb->len);
		chdlc_priv_area->udp_pkt_src = udp_pkt_src;
       		memcpy(chdlc_priv_area->udp_pkt_data, skb->data, skb->len);
		card->u.c.timer_int_enabled = TMR_INT_ENABLED_UDP;
	wan_mbox_t *mb = &card->wan_mbox;
	wan_udp_pkt = (wan_udp_pkt_t *) chdlc_priv_area->udp_pkt_data;
		if(chdlc_priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK){
			switch(wan_udp_pkt->wan_udp_command) {
		wan_udp_pkt->wan_udp_data_len = 0;
		wan_udp_pkt->wan_udp_return_code = 0xCD;
			card->devname,wan_udp_pkt->wan_udp_command);
		wan_udp_pkt->wan_udp_opp_flag = 0;
		switch(wan_udp_pkt->wan_udp_command) {
			card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
			((unsigned char *)wan_udp_pkt->wan_udp_data )[0] =
			((unsigned char *)wan_udp_pkt->wan_udp_data )[1] =
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
			wan_udp_pkt->wan_udp_data_len = 2;
			mb->wan_data_len = 2;
			chdlc_priv_area->router_up_time = tv.tv_sec - 
					chdlc_priv_area->router_start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
					chdlc_priv_area->router_up_time;	
			mb->wan_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				if (wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE){
		    			wan_udp_pkt->wan_udp_data_len = sizeof(wan_femedia_t); 
					wan_udp_pkt->wan_udp_return_code = CMD_OK;
					wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
		   	wan_udp_pkt->wan_udp_chdlc_num_frames = card->wandev.config_id;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_LINUX_PLATFORM;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
			mb->wan_command = wan_udp_pkt->wan_udp_command;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
			if (mb->wan_data_len) {
				memcpy(&mb->wan_data, (unsigned char *) wan_udp_pkt->
							wan_udp_data, mb->wan_data_len);
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
				wan_udp_pkt->wan_udp_return_code = mb->wan_return_code;
	         	memcpy(&wan_udp_pkt->wan_udp_hdr.wan_cmd, mb, sizeof(wan_cmd_t)); 
			if (mb->wan_data_len) {
	         		memcpy(&wan_udp_pkt->wan_udp_data, &mb->wan_data, 
								mb->wan_data_len); 
	wan_udp_pkt->wan_ip_ttl= card->wandev.ttl; 
		wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	len = reply_udp(chdlc_priv_area->udp_pkt_data, mb->wan_data_len);
     	if(chdlc_priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK){
	   	if (!test_bit(SEND_CRIT,&card->wandev.critical)) {
			if(!chdlc_send(card, chdlc_priv_area->udp_pkt_data, len, 0)) {
				++ card->wandev.stats.tx_packets;
				card->wandev.stats.tx_bytes += len;
  	    		memcpy(buf, chdlc_priv_area->udp_pkt_data, len);
	    		new_skb->protocol = htons(ETH_P_IP);
            		new_skb->dev = dev;
					card->devname);
	atomic_set(&chdlc_priv_area->udp_pkt_len,0);
	wan_mbox_t			*mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_ASY_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		((ASY_CONFIGURATION_STRUCT *)mb->wan_data)->
		((ASY_CONFIGURATION_STRUCT *)mb->wan_data)->
	card->hw_iface.peek(card->hw, tx_config_off, &tx_config, sizeof(tx_config));
       	card->u.c.txbuf_base_off = tx_config.base_addr_Tx_status_elements;
       	card->u.c.txbuf_last_off = 
               	card->u.c.txbuf_base_off +
		(tx_config.number_Tx_status_elements - 1) * 
	card->hw_iface.peek(card->hw, rx_config_off, &rx_config, sizeof(rx_config));
       	card->u.c.rxbuf_base_off =
       	card->u.c.rxbuf_last_off =
		card->u.c.rxbuf_base_off +
		(rx_config.number_Rx_status_elements - 1) * 
       	card->u.c.txbuf_off = tx_config.next_Tx_status_element_to_use;
       	card->u.c.rxmb_off =
        card->u.c.rx_base_off = rx_config.base_addr_Rx_buffer;
        card->u.c.rx_top_off  = rx_config.end_addr_Rx_buffer;
	wan_mbox_t* 	mb = &card->wan_mbox;
	card->timer_int_enabled = 0;
			mb->wan_data_len  = 0;
			mb->wan_command = READ_ASY_CODE_VERSION;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	 wan_udp_pkt_t *wan_udp_pkt = (wan_udp_pkt_t *)skb->data;
	 if (skb->len < sizeof(wan_udp_pkt_t)){
				  wan_udp_pkt->wan_udp_signature,
				  wan_udp_pkt->wan_udp_dport,
				  ntohs(card->wandev.udp_port),
				  wan_udp_pkt->wan_ip_p,
				  wan_udp_pkt->wan_udp_request_reply,
				  skb->data[36], skb->data[37]);
	if ((wan_udp_pkt->wan_udp_dport == ntohs(card->wandev.udp_port)) &&
	   (wan_udp_pkt->wan_ip_p == UDPMGMT_UDP_PROTOCOL) &&
	   (wan_udp_pkt->wan_udp_request_reply == UDPMGMT_REQUEST)) {
		if (!strncmp(wan_udp_pkt->wan_udp_signature,UDPMGMT_SIGNATURE,8)){
		if (!strncmp(wan_udp_pkt->wan_udp_signature,GLOBAL_UDP_SIGNATURE,8)){
   	if (card->wandev.state != state)
                                card->devname);
                                card->devname);
                                card->devname);
                card->wandev.state = state;
		dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
			chdlc_priv_area->common.state = state;
			if (chdlc_priv_area->common.usedby == API){
	if (card->u.c.comm_enabled){
			card->devname);
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
		int	err = -EINVAL;
			card->devname, 
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
					card->devname,
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
		int	err = -EINVAL;
			card->devname);
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
				card->devname);
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
				card->devname);
		return -EINVAL;	
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off,
				card->devname);
		card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
		card->u.c.comm_enabled=0;
		return -EINVAL;
					card->devname);
		card->wandev.fe_iface.read_alarm(&card->fe, 1); 
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, 
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);		
	wan_mbox_t* mb = &card->wan_mbox;
	ADAPTER_CONFIGURATION_STRUCT* cfg = (ADAPTER_CONFIGURATION_STRUCT*)mb->wan_data;
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &cfg->adapter_type);
	cfg->adapter_config = 0x00; 
	cfg->operating_frequency = 00; 
	mb->wan_data_len = sizeof(ADAPTER_CONFIGURATION_STRUCT);
	mb->wan_command = SET_ADAPTER_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	spin_lock_irqsave(&card->wandev.lock, *smp_flags);
        if (card->next){
        	spin_lock(&card->next->wandev.lock);
        if (card->next){
        	spin_unlock(&card->next->wandev.lock);
        spin_unlock_irqrestore(&card->wandev.lock, *smp_flags);
#define PROC_CFG_FRM	"%-15s| %-12s|\n"
#define PROC_STAT_FRM	"%-15s| %-12s| %-14s|\n"
		return m->count;
	card = chdlc_priv_area->card;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		PROC_CFG_FRM, chdlc_priv_area->if_name, card->devname);
	return m->count;
		return m->count;
	card = chdlc_priv_area->card;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		chdlc_priv_area->if_name,
		card->devname,
		STATE_DECODE(chdlc_priv_area->common.state));
	return m->count;
#define PROC_DEV_FR_S_FRM	"%-20s| %-14s|\n"
#define PROC_DEV_FR_D_FRM	"%-20s| %-14d|\n"
	card = (sdla_t*)wandev->priv;
			wandev->name, buffer);
#define PROC_IF_FR_S_FRM	"%-30s\t%-14s\n"
#define PROC_IF_FR_D_FRM	"%-30s\t%-14d\n"
#define PROC_IF_FR_L_FRM	"%-30s\t%-14ld\n"
	if (dev == NULL || dev->priv == NULL)
	chdlc_priv_area = (chdlc_private_area_t*)dev->priv;
			chdlc_priv_area->if_name, buffer);
	if (card->wandev.ignore_front_end_status == WANOPT_YES){
		if (card->fe.fe_status == FE_CONNECTED) {
			if(card->u.c.comm_enabled == 0) {
							card->devname);
							card->devname,rc);
			if (card->u.c.comm_enabled){
							card->devname);
		if (card->fe.fe_status == FE_CONNECTED){
			if (card->u.c.state == WAN_CONNECTED){
./sdla_asyhdlc.c
 *		ISDN-BRI support module for "Cologne XHFC-2SU" chip.
 * Copyright:	(c) 1984 - 2007 Sangoma Technologies Inc.
 *				Re-implemented T3 and T4 timers.
			caller_name, fe->name, WAN_FE_LINENO(fe)+1, MAX_BRI_LINES);
			caller_name, mod_no, MAX_BRI_LINES - 1);
/* Read/Write to front-end register */
		DEBUG_EVENT("%s: %s() time out!\n", fe->name, __FUNCTION__);		
	pcm_slot += (4*mod_no);		/* mod_no is 0,2,4.... -->0+0, 0+8, 0+16 */
	sdla_bri_param_t	*bri = &fe->bri_param;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	bri_module = &bri->mod[mod_no];
	fe->fe_chip_id = READ_REG(R_CHIP_ID);
	switch (fe->fe_chip_id)
		bri_module->num_ports = 2;
		bri_module->max_fifo = 8;
		bri_module->max_z = 0x7F;
		       fe->name, __FUNCTION__, fe->fe_chip_id);
* Arguments	:  pfe - pointer to Front End structure.
*		   mod_no - module number.
*		   master_mode - Yes or No
* Returns	:  0 - configred successfully, otherwise non-zero value.
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	if (fe->bri_param.mod[mod_no].type != MOD_TYPE_TE && master_mode) {
			fe->name, mod_no);
		fe->name, WP_BRI_DECODE_MOD_TYPE(fe->bri_param.mod[mod_no].type), 
		/* select 1-st function of pin 16 - SYNC_O. page 315. */
		/* enable output on pin 16 - page 314.*/
		so there is only one clock source - the master. */
		/* select 2-nd function of pin 16 - GPIO6. page 315.*/
		/* DISABLE output on pin 16 - page 314. */
		if(fe->bri_param.use_512khz_recovery_clock == 1){
				fe->name, REPORT_MOD_NO(mod_no), fe_line_no_to_port_no(fe)+1);
			DEBUG_EVENT("%s: Module=%d Port=%d: SYNC_O -> SYNC_I / Sync Pulse.\n",
				fe->name, REPORT_MOD_NO(mod_no), fe_line_no_to_port_no(fe)+1);
*		  time per-module.
* Arguments	:  pfe - pointer to Front End structure.
*		   mod_no - module number.
* Returns	:  0 - configred successfully, otherwise non-zero value.
	sdla_bri_param_t	*bri = &fe->bri_param;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	bri_module = &bri->mod[mod_no];
	fe->fe_chip_id = READ_REG(R_CHIP_ID);
	switch (fe->fe_chip_id)
		DEBUG_EVENT("%s: Detected XHFC-2SU chip.\n", fe->name);
		bri_module->num_ports = 2;
		bri_module->max_fifo = 8;
		bri_module->max_z = 0x7F;
		       fe->name, __FUNCTION__, fe->fe_chip_id);
		timeout--;
			       fe->name, __FUNCTION__);
	bri_module->pcm_md1.bit.v_pll_adj = 3;
	bri_module->pcm_md1.bit.v_pcm_dr = 1; /* dr stands for 'data rate' (64) */ 
	WRITE_REG(R_PCM_MD0, bri_module->pcm_md0.reg + 0x90); /* get access to R_PCM_MD1 */
	WRITE_REG(R_PCM_MD1, bri_module->pcm_md1.reg);
	DEBUG_HFC_INIT("\n%s: configuring B-channels FIFOs...\n", fe->name);
	/* configure B channel fifos for ST<->PCM data flow */
	for (port_no = 0; port_no < bri_module->num_ports; port_no++) {/* 2 ports */
			/* B chan - Tx of port_no */
			/* ST-->PCM, channel enabled */
			WRITE_REG(A_CON_HDLC, 0xde);/* page 83: Tx, Transparent, ST/U-->PCM */
			/* B chan - Rx of port_no */
			/* ST<--PCM, channel enabled */
			WRITE_REG(A_CON_HDLC, 0xde);/* page 83: Rx, Transparent, ST/U<--PCM */
	DEBUG_HFC_INIT("\nconfiguring D-channel FIFOs...\n");
	for (port_no = 0; port_no < bri_module->num_ports; port_no++) {
		/* D - Tx of port_no */
		/* FIFO-->ST, channel enabled, IFF=ones */
		/* D - Rx of port_no */
		/* ST--> FIFO, channel enabled */
		B-chan data will use PCM64 bus. D-chan data will use SPI. 
	for (port_no = 0; port_no < bri_module->num_ports; port_no++) {
				pcm_slot = (u8)calculate_pcm_timeslot(mod_no - MAX_BRI_MODULES, port_no, bchan);
			/*	transmit slot - select direction TX */
				0x80+0x40==0xC0==11000000 -> v_rout==0x3 -> "output buffer for STIO2 enabled" page 257.
				0*8 + 0*2 = 0 --> HFC channel 0.
			/* receive slot - select direction RX */
	}/* for (port_no = 0; port_no < bri_module->num_ports; port_no++) */
	for (port_no = 0; port_no < bri_module->num_ports; port_no++) {
		switch(bri_module->type)
		switch(bri_module->type)
			/* enables automatic transition G2->G3 */
		switch(bri_module->type)
			DBG_MODULE_TESTER("wait for 10ms - f0cl should be incremented by 80 (+- 10 is ok)\n");
			/* wait for 10ms - f0cl should be incremented by 80 (+- 10 is ok) */
			fe->name, REPORT_MOD_NO(mod_no) + port_no, f0cl_diff);	
	}/* for (port_no = 0; port_no < bri_module->num_ports; port_no++) */
	for (port_no = 0; port_no < bri_module->num_ports; port_no++) {
		bri_module->port[port_no].idx = port_no;
		bri_module->port[port_no].hw = bri_module;
		/*wan_set_bit(HFC_L1_ACTIVATING, &bri_module->port[port_no].l1_flags);*/
	}/* for (port_no = 0; port_no < bri_module->num_ports; port_no++) */
	/* for debugging only - read line status */
	DBG_MODULE_TESTER("read line status - Connected/Disconnected\n");
	/* read line status - Connected/Disconnected */
	for (port_no = 0; port_no < bri_module->num_ports; port_no++) {
			if(bri_module->type == MOD_TYPE_TE){
				DEBUG_HFC_S0_STATES("%d: TE: force F7 - pt:%d line status: 0x%02x, v_su_fr_sync: %d\n",
				DEBUG_HFC_S0_STATES("%d: NT: force G3 - pt:%d line status: 0x%02x, v_su_fr_sync: %d\n", 
			DBG_MODULE_TESTER("a_su_rd_sta.bit.v_su_fr_sync: %d (0-Disconnected, 1-Connected)\n", a_su_rd_sta.bit.v_su_fr_sync);
	*diff = new_f0cl - old_f0cl;
		*diff = 255 - old_f0cl;
			fe->name, *diff);	
			fe->name, *diff);	
	sdla_t	*card = (sdla_t*)fe->card;
	buf = port->dtxbuf;		/* data buffer */
	len = &port->bytes2transmit;	/* hdlc packet len */
	idx = &port->dtx_indx;		/* already transmitted */
	/* select the D-channel TX fifo */
	xhfc_select_fifo(fe, mod_no, (port->idx*8+4));
	free = (bri_module->max_z - (READ_REG( A_USAGE)));
	tcnt = ((free >= (*len - *idx)) ? (*len - *idx) : free);
	fcnt = 0x07 - ((f1 - f2) & 0x07);	/* free frame count in tx fifo */
			chan=(private_area_t*)card->u.aft.dev_to_ch_map[BRI_DCHAN_LOGIC_CHAN];
			xhfc_select_fifo(fe, mod_no, (port->idx*8+4));/* addition ?? */
	chan=(private_area_t*)card->u.aft.dev_to_ch_map[BRI_DCHAN_LOGIC_CHAN];
	sdla_bri_param_t	*bri = &fe->bri_param;
	DEBUG_TX_DATA("%lu: %s(): Module: %d, port_no: %d. fe->name: %s blen=%i\n",
		jiffies, __FUNCTION__, mod_no, port_no, fe->name, buffer_len);
	bri_module = &bri->mod[mod_no];
	port_ptr = &bri_module->port[port_no];
		return port_ptr->bytes2transmit;
			fe->name, __FUNCTION__, buffer_len, MAX_DFRAME_LEN_L1);
		return -EINVAL;
	if(port_ptr->bytes2transmit){
		return -EBUSY;
	memcpy(port_ptr->dtxbuf, src_data_buffer, buffer_len);
	port_ptr->bytes2transmit = buffer_len;
		if (i == (data_len - 4)){
			printk (" -");
	u8	*buf = port->drxbuf;
	int	*idx = &port->drx_indx;
	/* select D-RX fifo */
	xhfc_select_fifo(fe, mod_no, (port->idx * 8) + 5);
	rcnt = (z1 - z2) & bri_module->max_z;
					fe->name, __FUNCTION__, mod_no, port->idx, MAX_DFRAME_LEN_L1);
							  fe->name, __FUNCTION__, mod_no, port->idx);
			if (buf[(*idx) - 1]) {
					DEBUG_EVENT("%s: %s(): CRC-error in frame in mod_no %d, port_no %d!\n",
							  fe->name, __FUNCTION__, mod_no, port->idx);
			/* D-Channel debug to syslog */
			DBG_RX_DATA("%lu:D-RX len(%02i):\n", jiffies, (*idx));
				if (i == (*idx - 3)){
					printk ("- ");
			*rx_data_len = *idx - 3;/* discard CRC and STATUS - 3 bytes */
				After the ending flag of a frame the XHFC-2SU checks the HDLC CRC checksum.
			if(check_data(port->drxbuf, *rx_data_len)){
				dump_chip_SRAM(fe, mod_no, port->idx);
				dump_chip_SRAM(fe, mod_no, port->idx);
				dump_data(port->drxbuf, *idx);
	sdla_bri_param_t	*bri = &fe->bri_param;
	bri_module = &bri->mod[mod_no];
	port_ptr = &bri_module->port[port_no];
		memcpy(skb_data_area, port_ptr->drxbuf, rx_data_len);
** wp_bri_iface_init) - 
	fe_iface->global_config		= &bri_global_config;	/* not used in remora */
	fe_iface->global_unconfig	= &bri_global_unconfig;	/* not used in remora */
	fe_iface->config		= &wp_bri_config;
	fe_iface->unconfig		= &wp_bri_unconfig;
	fe_iface->pre_release		= &wp_bri_pre_release;
	fe_iface->post_init		= &wp_bri_post_init;
	fe_iface->if_config		= &wp_bri_if_config;
	fe_iface->if_unconfig		= &wp_bri_if_unconfig;
	fe_iface->active_map		= &wp_bri_active_map;
	fe_iface->set_fe_status		= &wp_bri_set_fe_status;
	fe_iface->get_fe_status		= &wp_bri_get_fe_status;
	fe_iface->isr			= &wp_bri_intr;
	fe_iface->disable_irq		= &wp_bri_disable_fe_irq; 
	fe_iface->check_isr		= &wp_bri_check_intr;
	fe_iface->polling		= &wp_bri_polling;
	fe_iface->process_udp		= &wp_bri_udp;
	fe_iface->get_fe_media		= &wp_bri_fe_media;
	fe_iface->set_dtmf		= &wp_bri_set_dtmf;
	fe_iface->intr_ctrl		= &wp_bri_intr_ctrl;
	fe_iface->event_ctrl		= &wp_bri_event_ctrl;
	fe_iface->isdn_bri_dchan_tx	= &wp_bri_dchan_tx;
	fe_iface->watchdog		= &wp_bri_watchdog;
	fe_iface->clock_ctrl		= &config_clock_routing;
	sdla_t	*card = (sdla_t*)fe->card;
	DEBUG_EVENT("%s: Executing SPI bus reset....\n", fe->name);
	card->hw_iface.bus_write_4(	card->hw,
	card->hw_iface.bus_write_4(	card->hw,
* Arguments	: pfe - pointer to Front End structure.	
		bit 0 == 1	- module 1 active (exist)
		bit 1		- type of module 1 (0 - NT, 1 - TE)
		bit 2 == 1	- module 2 active (exist)
		bit 3		- type of module 1 (0 - NT, 1 - TE)
  		bit 4 == 1	- module 3 active (exist)
		bit 5		- type of module 1 (0 - NT, 1 - TE)
		bit 6,7		- has to be zeros for active remora. if non-zero, remora does not exist.
	value = fe->read_fe_reg(fe->card, 
		DEBUG_EVENT("%s: Remora number %d: Found 512khz Recovery clock remora.\n", fe->name, rm_no);
		fe->bri_param.use_512khz_recovery_clock = 1;
			DEBUG_EVENT("%s: Remora number %d does not exist.\n", fe->name, rm_no);
			DEBUG_EVENT("%s: Remora number %d exist.\n", fe->name, rm_no);
			DEBUG_BRI_INIT("module Number on REMORA (0-2): %d\n", ind / 2);
			/* 0-11, all (even and odd) numbers */
			DEBUG_BRI_INIT("mod_no_index on CARD (should be 0-11): %d\n", mod_no_index);
			/* 0-23, only even numbers */
			DEBUG_BRI_INIT("mod_no_index (line number) on CARD (should be 0-23): %d\n", mod_no_index);
						fe->name, mod_no_index, mod_no_index, MAX_BRI_LINES);
						fe->name, mod_no_index);
					fe->bri_param.mod[mod_no_index].type = MOD_TYPE_TE;
					fe->bri_param.mod[mod_no_index].port[PORT_0].mode |= PORT_MODE_TE;
					fe->bri_param.mod[mod_no_index].port[PORT_1].mode |= PORT_MODE_TE;
						fe->name, mod_no_index);
					fe->bri_param.mod[mod_no_index].type = MOD_TYPE_NT;
					fe->bri_param.mod[mod_no_index].port[PORT_0].mode |= PORT_MODE_NT;
					fe->bri_param.mod[mod_no_index].port[PORT_1].mode |= PORT_MODE_NT;
				memcpy(&fe->bri_param.mod[mod_no_index + 1], &fe->bri_param.mod[mod_no_index], 
						fe->name, mod_no_index);
* Arguments	: pfe - pointer to Front End structure.	
* Returns	: 0 - configred successfully, otherwise non-zero value.
		DEBUG_EVENT("%s: Error: modules counter is zero!\n", fe->name);
		DEBUG_EVENT("%s: Total number of modules: %d.\n", fe->name, modules_counter);
* Arguments	: pfe - pointer to Front End structure.	
* Returns	: 0 - configred successfully, otherwise non-zero value.
			fe->name, FE_MEDIA_DECODE(fe));
* Description	: Global un-configuration for Sangoma BRI board.
				fe->name, FE_MEDIA_DECODE(fe));
	sdla_bri_param_t	*bri = &fe->bri_param;
	DEBUG_EVENT("%s: Running pre-release...\n", fe->name);
	if(fe->fe_status == FE_UNITIALIZED){
			fe->name, __FUNCTION__);
	bri_module = &bri->mod[mod_no];
	for (port_no = 0; port_no < bri_module->num_ports; port_no++) {
		port_ptr = &bri_module->port[port_no];
		wan_del_timer(&port_ptr->t3_timer);
		wan_del_timer(&port_ptr->t4_timer);
	}/* for (port_no = 0; port_no < bri_module->num_ports; port_no++) */
*			wp_bri_config() - initialise the XHFC ISDN Chip.
* Arguments	:  pfe - pointer to Front End structure.
* Returns	:  0 - configred successfully, otherwise non-zero value.
	sdla_t 			*card = (sdla_t*)fe->card;
	/*sdlahw_t* 		hw = (sdlahw_t*)card->hw;*/
	sdla_bri_param_t	*bri = &fe->bri_param;
	fe->fe_status = FE_UNITIALIZED;
			fe->name, FE_MEDIA_DECODE(fe), WAN_FE_LINENO(fe)+1);
			fe->name, FE_MEDIA_DECODE(fe), WAN_FE_LINENO(fe) + 1, mod_no);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	fe->bri_param.max_fe_channels 	= MAX_TIMESLOTS;
	fe->bri_param.module_map[0]	= fe->bri_param.module_map[1] = 0;
	bri_module = &bri->mod[mod_no];
	card->hw_iface.getcfg(card->hw, SDLA_HWTYPE_USEDCNT, &physical_card_config_counter);
		/* Per-card initialization. Important to do only ONCE.*/
	fe->bri_param.use_512khz_recovery_clock = 0;
	WAN_LIST_INIT(&fe->event);
	/* wan_spin_lock_init(&fe->lock, "wp_bri_lock"); FIXME: 'lock' is not there, but what is there? */
	card->hw_iface.getcfg(card->hw, SDLA_HWLINEREG, &physical_module_config_counter);
	bri_module->fe = fe;
	switch(fe->bri_param.mod[mod_no].type)
			bri_module->num_ports = BRI_MAX_PORTS_PER_CHIP;
			bri_module->max_fifo = 8;
			bri_module->max_z = 0x7F;
			for (port_no = 0; port_no < bri_module->num_ports; port_no++) {
				bri_module->port[port_no].idx = port_no;
				bri_module->port[port_no].hw = bri_module;
			}/* for (port_no = 0; port_no < bri_module->num_ports; port_no++) */
			__FUNCTION__, fe->name, REPORT_MOD_NO(mod_no), aft_line_no);
#define BCHAN_BITMAP	0x3 /* each BRI line has 2 b-channels --> 2 bits */
		/* 1-st aft line has timeslots 0-23 */
		/* 2-nd aft line has timeslots 24-47 */
	fe->bri_param.mod[mod_no].mod_no = mod_no;
	switch(fe->bri_param.mod[mod_no].type)
		fe->bri_param.module_map[aft_line_no] |= (BCHAN_BITMAP << (mod_no*2));
		DEBUG_EVENT("%s: Module %d (AFT Line: %d): Installed -- %s. Timeslots map: 0x%08X\n",
				fe->name, REPORT_MOD_NO(mod_no), aft_line_no,
				WP_BRI_DECODE_MOD_TYPE(fe->bri_param.mod[mod_no].type),
			__FUNCTION__, fe->name, REPORT_MOD_NO(mod_no), aft_line_no);	
	switch(fe->bri_param.mod[mod_no].type)
/* DAVIDR-consider moving call bri_enable_interrupts() to wp_bri_post_init() */
			__FUNCTION__, fe->name, REPORT_MOD_NO(mod_no), aft_line_no);	
	/*------------------ CLOCK RECOVERY ------------------*/
		/* Per-card initialization. Important to do only ONCE.*/
			switch(fe->bri_param.mod[i].type)
	/*----------- END OF CLOCK RECOVERY ------------------*/
	fe->fe_status = FE_DISCONNECTED;
** wp_bri_unconfig() - 
	sdla_t		*card = (sdla_t*)fe->card;
	sdla_bri_param_t *bri = &fe->bri_param;
	DEBUG_EVENT("%s: Unconfiguring BRI Front End...\n", fe->name);
	if(fe->fe_status == FE_UNITIALIZED){
			fe->name, __FUNCTION__);
	bri_module = &bri->mod[mod_no];
	port_ptr   = &bri_module->port[port_no];
	card->hw_iface.getcfg(card->hw, SDLA_HWLINEREG, &physical_module_config_counter);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	switch(fe->bri_param.mod[mod_no].type)
		/* for missing (not installed) modules - do nothing  */
			__FUNCTION__, fe->name);
	DEBUG_HFC_INIT("%s(): port_no: %i, port_ptr: 0x%p, port_ptr->mode: %i\n", __FUNCTION__, port_no, port_ptr, port_ptr->mode);
	if (port_ptr->mode & PORT_MODE_TE) {
	/* Immediatly after that we get SU state interrupt - clear it! (for all ports) */
	fe->fe_status = FE_UNITIALIZED;
** wp_bri_post_init() - 
	sdla_bri_param_t	*bri = &fe->bri_param;
	DEBUG_EVENT("%s: Running post initialization...\n", fe->name);
	bri_module = &bri->mod[mod_no];
	for (port_no = 0; port_no < bri_module->num_ports; port_no++) {
		port_ptr = &bri_module->port[port_no];
		wan_init_timer(&port_ptr->t3_timer, l1_timer_expire_t3, (wan_timer_arg_t)port_ptr);
		wan_init_timer(&port_ptr->t4_timer, l1_timer_expire_t4, (wan_timer_arg_t)port_ptr);
	}/* for (port_no = 0; port_no < bri_module->num_ports; port_no++) */
		sdla_t		*card = (sdla_t*)fe->card;
		/* Try to activate the port_no - if cable is in, line will get activated.
		card->hw_iface.hw_lock(card->hw,&smp_flags1);   
		card->hw_iface.hw_unlock(card->hw,&smp_flags1);   
	WAN_ASSERT_VOID(port_ptr->hw == NULL);
	bri_module = port_ptr->hw;
	WAN_ASSERT_VOID(bri_module->fe == NULL);
	fe = (sdla_fe_t*)bri_module->fe;
	mod_no = (u8)bri_module->mod_no;
	DEBUG_HFC_S0_STATES("%s(): mod_no: %i, port number: %i\n", __FUNCTION__, mod_no, port_ptr->idx);
	if(fe->fe_status == FE_UNITIALIZED){
	if(!wan_test_and_set_bit(T3_TIMER_ACTIVE, &port_ptr->timer_flags)){
		wan_add_timer(&port_ptr->t3_timer, XHFC_TIMER_T3);
		wan_add_timer(&port_ptr->t3_timer, (XHFC_TIMER_T3 * HZ) / 1000);
	wp_bri_module_t	*bri_module = port_ptr->hw;
	u8		mod_no = (u8)bri_module->mod_no;
	DEBUG_HFC_S0_STATES("%s(): mod_no: %i, port number: %i\n", __FUNCTION__, mod_no, port_ptr->idx);
	wan_clear_bit(T3_TIMER_ACTIVE, &port_ptr->timer_flags);
        wan_clear_bit(HFC_L1_ACTIVATING, &port_ptr->l1_flags);
        wan_del_timer(&port_ptr->t3_timer);
	wp_bri_module_t	*bri_module = port_ptr->hw;
	sdla_fe_t	*fe = (sdla_fe_t*)bri_module->fe;
	sdla_t 		*card = (sdla_t*)fe->card;
	wan_device_t	*wandev = &card->wandev;
	if (wandev->fe_enable_timer){
		wandev->fe_enable_timer(fe->card);
	sdla_bri_param_t *bri = &fe->bri_param;
	bri_module = &bri->mod[mod_no];
	port_ptr   = &bri_module->port[port_no];
	DEBUG_HFC_S0_STATES("%s(): mod_no: %i, port number: %i\n", __FUNCTION__, mod_no, port_ptr->idx);
	wan_clear_bit(T3_TIMER_ACTIVE, &port_ptr->timer_flags);
	wan_clear_bit(HFC_L1_ACTIVATING, &port_ptr->l1_flags);
	WAN_ASSERT_VOID(port_ptr->hw == NULL);
	bri_module = port_ptr->hw;
	WAN_ASSERT_VOID(bri_module->fe == NULL);
	fe = (sdla_fe_t*)bri_module->fe;
	mod_no = (u8)bri_module->mod_no;
	DEBUG_HFC_S0_STATES("%s(): mod_no: %i, port number: %i\n", __FUNCTION__, mod_no, port_ptr->idx);
	if(fe->fe_status == FE_UNITIALIZED){
	if(!wan_test_and_set_bit(T4_TIMER_ACTIVE, &port_ptr->timer_flags)){
		wan_set_bit(HFC_L1_DEACTTIMER, &port_ptr->l1_flags);
		wan_add_timer(&port_ptr->t4_timer, XHFC_TIMER_T4);
		wan_add_timer(&port_ptr->t4_timer, (XHFC_TIMER_T4 * HZ) / 1000);
	wp_bri_module_t	*bri_module = port_ptr->hw;
	u8		mod_no = (u8)bri_module->mod_no;
	DEBUG_HFC_S0_STATES("%s(): mod_no: %i, port number: %i\n", __FUNCTION__, mod_no, port_ptr->idx);
	wan_clear_bit(T4_TIMER_ACTIVE, &port_ptr->timer_flags);
	wan_clear_bit(HFC_L1_DEACTTIMER, &port_ptr->l1_flags);
        wan_del_timer(&port_ptr->t4_timer);
 * Description: l1_timer_expire_t4 - called when timer t4 expires.
	wp_bri_module_t	*bri_module = port_ptr->hw;
	sdla_fe_t	*fe = bri_module->fe;
	DEBUG_HFC_S0_STATES("%s(): mod_no: %i, port number: %i\n", __FUNCTION__, mod_no, port_ptr->idx);
	wan_clear_bit(T4_TIMER_ACTIVE, &port_ptr->timer_flags);
	wan_clear_bit(HFC_L1_DEACTTIMER, &port_ptr->l1_flags);
** wp_bri_if_config() - 
** wp_bri_if_unconfig() - 
* Description: Enable BRI interrupts - start interrupt and set interrupt mask.
	sdla_bri_param_t 	*bri = &fe->bri_param;
				fe->name, REPORT_MOD_NO(mod_no),
	bri_module = &bri->mod[mod_no];
	/* Configure Timer Interrupt - every 2.048 seconds (page 289, 297).
** wp_bri_disable_fe_irq() - disable all interrupts by disabling M_GLOB_IRQ_EN
** wp_bri_disable_irq() - disable all interrupts by disabling M_GLOB_IRQ_EN
	sdla_bri_param_t 	*bri = &fe->bri_param;
					fe->name, REPORT_MOD_NO(mod_no),
	bri_module = &bri->mod[mod_no];
	if (!wan_test_bit(WP_RM_CONFIGURED,(void*)&fe->bri_param.critical)){
		return -EINVAL;
					fe->name, __FUNCTION__, line_no);
			fe->name,  
	return fe->fe_cfg.media;
					fe->name, mod_no);
		return -EINVAL;
	if (!wan_test_bit(mod_no-1, &fe->bri_param.module_map)){
					fe->name, mod_no);
		return -EINVAL;
	return -EINVAL;
	sdla_bri_param_t *bri = &fe->bri_param;
	bri_module = &bri->mod[mod_no];
	port_ptr   = &bri_module->port[port_no];
	if(wan_test_bit(T3_TIMER_ACTIVE, &port_ptr->timer_flags)){
	int32_t		err = -EINVAL;
	switch(udp_cmd->wan_cmd_command){
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_data_len = (u16)err; 
		udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
	    	udp_cmd->wan_cmd_data_len = 0;
* Description	: Get current FE line state - is it Connected or Disconnected
* Arguments	: fe - pointer to Front End structure.	
*		  status - pointer to location where the FE line state will
*		  notused - ignored
	*status = fe->fe_status;
	sdla_bri_param_t	*bri = &fe->bri_param;
	bri_module = &bri->mod[mod_no];
	port_ptr = &bri_module->port[port_no];
                       fe->name, __FUNCTION__, port_no, bchan_no);
		fe->name, __FUNCTION__,
		pcm_slot = (u8)calculate_pcm_timeslot(mod_no - MAX_BRI_MODULES, port_no, bchan_no);
	/* transmit slot - select direction TX */
	/* receive slot - select direction RX */
	sdla_bri_param_t	*bri = &fe->bri_param;
	DEBUG_LOOPB("%s(): Module: %d, port_no: %d. fe->name: %s, command: %i\n",
		__FUNCTION__, mod_no, port_no, fe->name, command);
	bri_module = &bri->mod[mod_no];
	port_ptr = &bri_module->port[port_no];
			__FUNCTION__, fe->name, command);
* Arguments	: fe - pointer to Front End structure.	
*		  new_status - the new FE line state.
* Returns	: 0 - success.
*		  1 - failure.
	sdla_bri_param_t	*bri = &fe->bri_param;
	DEBUG_FE_STATUS("%s(): Module: %d, port_no: %d. fe->name: %s, new status: %d (%s)\n",
		__FUNCTION__, mod_no, port_no, fe->name, new_status, FE_STATUS_DECODE(new_status));
	bri_module = &bri->mod[mod_no];
	port_ptr = &bri_module->port[port_no];
		DEBUG_HFC_S0_STATES("l2->l1 -- ACTIVATE REQUEST\n");
		if (port_ptr->mode & PORT_MODE_TE) {
			if (wan_test_bit(HFC_L1_ACTIVATED, &port_ptr->l1_flags)) {
				DEBUG_HFC_S0_STATES("l1->l2 -- ACTIVATE CONFIRM\n");
				wan_test_and_set_bit(HFC_L1_ACTIVATING, &port_ptr->l1_flags);
		DEBUG_HFC_S0_STATES("l2->l1 -- DEACTIVATE REQUEST\n");
		if (port_ptr->mode & PORT_MODE_TE) {
				__FUNCTION__, fe->name);
			__FUNCTION__, fe->name, new_status, FE_STATUS_DECODE(new_status));
* Arguments: mod_no -  Module number (1,2,3,... MAX_REMORA_MODULES)
		fe->name, WAN_EVENT_TYPE_DECODE(ectrl->type),
		WAN_EVENT_MODE_DECODE(ectrl->mode));
	switch(ectrl->type)
		switch(ectrl->channel)
			err = wp_bri_control(fe, (ectrl->mode == WAN_EVENT_ENABLE ? HFC_L1_ENABLE_LOOP_B1:HFC_L1_DISABLE_LOOP_B1));
			err = wp_bri_control(fe, (ectrl->mode == WAN_EVENT_ENABLE ? HFC_L1_ENABLE_LOOP_B2:HFC_L1_DISABLE_LOOP_B2));
* Arguments: mod_no -  Module number (1,2,3,... MAX_REMORA_MODULES)
* Arguments: mod_no -  Module number (1,2,3,... MAX_REMORA_MODULES)
	wp_bri_module_t	*bri_module = port->hw;
	u8		mod_no = (u8)bri_module->mod_no;
		DEBUG_HFC_S0_STATES("HFC_L1_ACTIVATE_TE port(%i)\n", port->idx);
		WRITE_REG(R_SU_SEL, port->idx);
		DEBUG_HFC_S0_STATES("HFC_L1_FORCE_DEACTIVATE_TE port(%i)\n", port->idx);
		WRITE_REG(R_SU_SEL, port->idx);
		DEBUG_HFC_S0_STATES("HFC_L1_ACTIVATE_NT port(%i)\n", port->idx);
		WRITE_REG(R_SU_SEL, port->idx);
		DEBUG_HFC_S0_STATES("HFC_L1_DEACTIVATE_NT port(%i)\n", port->idx);
		WRITE_REG(R_SU_SEL, port->idx);
	sdla_t	*card = (sdla_t*)fe->card;
		__FUNCTION__, new_status, fe->fe_status);
	if (new_status == fe->fe_status){
	fe->fe_status = new_status;
			fe->name,
		if (card->wandev.te_report_alarms){
			card->wandev.te_report_alarms(card, 0);
			fe->name,
		if (card->wandev.te_report_alarms){
			card->wandev.te_report_alarms(card, 1);
	if (card->wandev.te_link_state){
		card->wandev.te_link_state(card);
	sdla_bri_param_t 	*bri = &fe->bri_param;
	bri_module	= &bri->mod[mod_no];
	port		= &bri_module->port[port_no];
	sdla_bri_param_t 	*bri = &fe->bri_param;
	bri_module	= &bri->mod[mod_no];
	port_ptr	= &bri_module->port[port_no];
	DEBUG_HFC_S0_STATES("%s(): mod_no: %i, port number: %i\n", __FUNCTION__, mod_no, port_ptr->idx);
	if (port_ptr->mode & PORT_MODE_TE) {
		DEBUG_HFC_S0_STATES("TE F%d\n", port_ptr->l1_state);
		if ((port_ptr->l1_state <= 3) || (port_ptr->l1_state >= 7)){
		switch (port_ptr->l1_state) 
			if (wan_test_and_clear_bit(HFC_L1_ACTIVATED, &port_ptr->l1_flags)){
				if (fe->fe_status == FE_CONNECTED){
			if (wan_test_and_clear_bit(HFC_L1_ACTIVATING, &port_ptr->l1_flags)) {
				DEBUG_HFC_S0_STATES("l1->l2 -- ACTIVATE CONFIRM\n");
				wan_set_bit(HFC_L1_ACTIVATED, &port_ptr->l1_flags);
				if (!(wan_test_and_set_bit(HFC_L1_ACTIVATED, &port_ptr->l1_flags))) {
					DEBUG_HFC_S0_STATES("l1->l2 -- ACTIVATE INDICATION\n");
					/* L1 was already activated (e.g. F8->F7) */
	} else if (port_ptr->mode & PORT_MODE_NT) {
		DEBUG_HFC_S0_STATES("NT G%d\n", port_ptr->l1_state);
		switch (port_ptr->l1_state) 
			port_ptr->nt_timer = 0;
			port_ptr->mode &= ~NT_TIMER;
			DEBUG_HFC_S0_STATES("l1->l2 (PH_DEACTIVATE | INDICATION)\n");
			if (port_ptr->nt_timer < 0) {
				port_ptr->nt_timer = 0;
				port_ptr->mode &= ~NT_TIMER;
				port_ptr->nt_timer = NT_T1_COUNT;
				port_ptr->mode |= NT_TIMER;
				WRITE_REG(R_SU_SEL, port_ptr->idx);
			port_ptr->nt_timer = 0;
			port_ptr->mode &= ~NT_TIMER;
			DEBUG_HFC_S0_STATES("l1->l2 -- ACTIVATE INDICATION\n");
			port_ptr->nt_timer = 0;
			port_ptr->mode &= ~NT_TIMER;
*			in 'wp_bri_module_t->fe' because this function returns
* Returns	: fe pointer - found FE for the 'port_no'.
*		  NULL	     - FE for the 'port_no' not found (it means port_no
	sdla_t	*card = (sdla_t*)original_fe->card;
	if(!card || !card->hw){
	card_list=__sdla_get_ptr_isr_array(card->hw);
	return &tmp_card->fe;
* Returns	: 1 - interrupt recognized and handled
*		  0 - interrupt not recognized (not generated by this module)
	sdla_bri_param_t 	*bri = &fe->bri_param;
	bri_module = &bri->mod[mod_no];
	//DEBUG_HFC_SU_IRQ("%s(%lu): %s: mod_no: %d\n", __FUNCTION__, jiffies, fe->name, mod_no);
	for (port_no = 0; port_no < bri_module->num_ports; port_no++) {
	for (i = 0; i < bri_module->num_ports; i++) {
			/*sdla_bri_param_t	*su_bri = &fe->bri_param;
			wp_bri_module_t		*su_bri_module = &su_bri->mod[mod_no];
			bri_xhfc_port_t		*port_ptr = &su_bri_module->port[port_no];*/
			sdla_bri_param_t 	*su_bri = &fe->bri_param;
			wp_bri_module_t		*su_bri_module = &su_bri->mod[mod_no];
			bri_xhfc_port_t		*port_ptr = &su_bri_module->port[port_no];
				(port_ptr->mode & PORT_MODE_NT) ? "NT: G" : "TE: F",
			if (new_su_state.bit.v_su_sta != port_ptr->l1_state) {
 				port_ptr->l1_state = new_su_state.bit.v_su_sta;
		if(bri_module->port[port_no].bytes2transmit){
				__FUNCTION__, port_no,	bri_module->port[port_no].bytes2transmit,
							bri_module->port[port_no].dtx_indx);
			xhfc_write_fifo_dchan(fe, mod_no, bri_module, &bri_module->port[port_no], &free_space);
		/* receive D-Channel Data */
			DBG_MODULE_TESTER("There is receive D-Channel Data for port_no %d\n", port_no);
				sdla_t	*card = (sdla_t*)fe->card;
				chan=(private_area_t*)card->u.aft.dev_to_ch_map[BRI_DCHAN_LOGIC_CHAN];
							card->devname, BRI_DCHAN_LOGIC_CHAN);
				wan_skb_queue_tail(&chan->wp_rx_bri_dchan_complete_list, skb);
				WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
	}/* for (port_no = 0; port_no < bri_module->num_ports; port_no++) */
	if(fe->fe_status == FE_UNITIALIZED){
	switch(fe->bri_param.mod[mod_no].type)
		/* for missing (not installed) modules - do nothing  */
./sdla_bri.c
 * Copyright:	(c) 1995-2005 Sangoma Technologies Inc.
		return -ENOMEM;
	wp_codec_ops->init = 1;
	wp_codec_ops->encode = wanpipe_codec_convert_ulaw_2_s;
	wp_codec_ops->decode = wanpipe_codec_convert_s_2_ulaw;
		return -ENOMEM;
	wp_codec_ops->init = 1;
	wp_codec_ops->encode = wanpipe_codec_convert_alaw_2_s;
	wp_codec_ops->decode = wanpipe_codec_convert_s_2_alaw;
./wanpipe_codec.c
 * Copyright:	(c) 1995-2005 Sangoma Technologies Inc.
			num = num + (ptr[i]-'0') * base;
		WAN_LIST_FOREACH(ec_dev, &ec->ec_dev, next){
			if (ec_dev->card == NULL || ec_dev->card == card){
						card->devname,
		WAN_LIST_FOREACH(ec_dev, &ec->ec_dev, next){
			if (card->hw_iface.hw_same(ec_dev->card->hw, card->hw)){
					card->devname,
						card->devname,
		ec->chip_no		= ++wan_ec_no;
		ec->state		= WAN_OCT6100_STATE_RESET;
		ec->ec_channels_no	= 0;
		ec->max_channels	= max_channels;
		sprintf(ec->name, "wp_ec%d", ec->chip_no);
		WAN_LIST_INIT(&ec->ec_dev);
		ec = ec_dev->ec;
	ec->usage++;
	ec_dev_new->ecdev_no = wan_ec_devnum(card->devname);
	ec_dev_new->ec		= ec;
	ec_dev_new->name	= ec->name;
	ec_dev_new->card	= card;
	card->wandev.ec_action	= wan_ec_action;
	card->wandev.ec_map		= 0;
	memcpy(ec_dev_new->devname, card->devname, sizeof(card->devname));
	sprintf(ec_dev_new->ecdev_name, "wp%dec", ec_dev_new->ecdev_no);
	err=wanpipe_ecdev_reg(ec, ec_dev_new->ecdev_name, ec_dev_new->ecdev_no);
					card->devname,
	err=wp_cdev_reg(ec, ec_dev_new->ecdev_name, wan_ec_dev_ioctl);
					card->devname,
	WAN_LIST_INSERT_HEAD(&ec->ec_dev, ec_dev_new, next);
					ec_dev_new->devname,
					ec->name,
					ec->usage,
					ec->max_channels);
	ec = ec_dev->ec;
					card->devname,
					ec->name,
					ec->chip_no,
					ec->usage);
	ec_dev->card = NULL;
	ec->usage--;
	if (WAN_LIST_FIRST(&ec->ec_dev) == ec_dev){
		WAN_LIST_FIRST(&ec->ec_dev) =
	wanpipe_ecdev_unreg(ec_dev->ecdev_no);
	wp_cdev_unreg(ec_dev->ecdev_name);
	if (!ec->usage){
		ec_dev->ec = NULL;
		ec_dev->ec = NULL;
		WAN_LIST_FOREACH(ec_dev, &ec->ec_dev, next){
			if (strcmp(ec_dev->devname, devname) == 0){
	int		err = -EINVAL;
	ec = ec_dev->ec;
	if (card->wandev.hwec_reset){
		err = card->wandev.hwec_reset(
				ec->state = WAN_OCT6100_STATE_RESET;
				ec->state = WAN_OCT6100_STATE_READY;
	int		err = -ENODEV;
	ec_dev = wan_ec_search(card->devname);
	WAN_ASSERT(ec_dev->ec == NULL);
	ec = ec_dev->ec;	
			card->devname,
	if (card->wandev.hwec_enable){
			if (ec->ec_channels_no >= ec->max_channels){
						ec->name,
						ec->max_channels);
				return -ENODEV;
		err = card->wandev.hwec_enable(card, enable, channel);
				ec->ec_channels_no++;
				ec->ec_channels_no--;
		DEBUG_HWEC("[HWEC]: %s: %s(): card->wandev.hwec_enable == NULL!\n",
			card->devname, __FUNCTION__);
			card->devname,
			ec_api->u_tone.fe_chan,
			WAN_EC_DECODE_TONE_TYPE(ec_api->u_tone.type),
			WAN_EC_DECODE_DTMF_ID(ec_api->u_tone.id));
	sdla_t	*card = ec_dev->card;
				card->devname,
		return -EINVAL;
	err = card->hw_iface.bus_read_4(card->hw, addr, data);
	sdla_t	*card = ec_dev->card;
				card->devname,
		return -EINVAL;
	err = card->hw_iface.bus_write_4(card->hw, addr, data);	
	/* 16-bit indirect access. */
				ec_dev->name);
				ec_dev->ec->name, write_addr, write_data);
						ec_dev->name,
						ec_dev->name,
						ec_dev->name,
				ec_dev->name);
			ec_dev->ec->name, addr);
					ec_dev->name,
			ec_dev->ec->name,
						ec_dev->name,
	u32	len = ec_api->u_oct6100_write_burst.ulWriteLength;
	u16	*user_space = (u16*)ec_api->u_oct6100_write_burst.pWriteData,
				ec_dev->name,
				ec_dev->ec->name,
				ec_api->u_oct6100_write_burst.ulWriteAddress,
				ec_api->u_oct6100_write_burst.ulWriteLength);
	u32	len = ec_api->u_oct6100_read_burst.ulReadLength;
	u16	*user_space = (u16*)ec_api->u_oct6100_read_burst.pReadData,
				ec_dev->name,
				ec_api->u_oct6100_read_burst.ulReadAddress,
				ec_api->u_oct6100_read_burst.ulReadLength);	
				ec_dev->ec->name,
	sdla_t		*card = ec_dev->card;
	if (strcmp(card->devname, ec_api->devname)){
				card->devname, ec_api->if_name,
				ec_api->devname);
		return -EINVAL;
	ec = ec_dev->ec;
	memcpy(ec_api->name, ec->name, strlen(ec->name));
	ec_api->u_ecd.state		= ec->state;
	ec_api->u_ecd.chip_no		= ec->chip_no;
	ec_api->u_ecd.fe_media		= WAN_FE_MEDIA(&card->fe);
	ec_api->u_ecd.fe_lineno		= WAN_FE_LINENO(&card->fe);
	ec_api->u_ecd.fe_max_channels	= WAN_FE_MAX_CHANNELS(&card->fe);
	ec_api->u_ecd.fe_tdmv_law	= WAN_FE_TDMV_LAW(&card->fe);
	ec_api->u_ecd.max_channels	= ec->max_channels;
	ec_api->u_ecd.max_ec_channels	= ec->max_ec_channels;
	ec_api->u_ecd.ulApiInstanceSize = ec->ulApiInstanceSize;
	ec_dev = WAN_LIST_FIRST(&ec->ec_dev);
					ec->name,
		return -EINVAL;
	card = ec_dev->card;
				ec->name,
		return -EINVAL;
				ec->name,
		return -EINVAL;
				ec->name,
			WAN_OCT6100_CMD_DECODE(ec_api->cmd)); 
	switch(ec_api->cmd){
		err = wan_ec_reset(ec_dev, card, ec_api->cmd);
		err = wan_ec_action(card, 1, ec_api->u_ecd.channel);
		err = wan_ec_action(card, 0, ec_api->u_ecd.channel);
		ec_api->ulResult = 
				ec_api->u_oct6100_write.ulWriteAddress,
				ec_api->u_oct6100_write.usWriteData);
		ec_api->ulResult = 
				ec_api->u_oct6100_write_swear.ulWriteAddress,
				ec_api->u_oct6100_write_swear.usWriteData,
				ec_api->u_oct6100_write_swear.ulWriteLength);
		ec_api->ulResult =
		ec_api->ulResult =
				ec_api->u_oct6100_read.ulReadAddress,
				&ec_api->u_oct6100_read.usReadData);
		ec_api->ulResult =
				card->devname, ec->name, ec_api->cmd);
		err = -EINVAL;
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
				ec->name,
		return -EINVAL;
./sdla_ec.c
* sdla_mp_fr.c  Multi-Port Frame Relay driver module.
* Copyright:	(c) 1995-2002 Sangoma Technologies Inc.
* 				Based on raw-hdlc fimrware
#define MAX_TRACE_BUFFER (MAX_LGTH_UDP_MGNT_PKT-  \
			  sizeof(struct iphdr)-   \
			  sizeof(struct udphdr) - \
			  sizeof(wan_mgmt_t)-     \
#define FR_PROT_AREA(a) ((fr_prot_t*)a->u.c.prot)
#define IS_TE1_CARD(card)	IS_TE1(card->wandev.te_cfg)
#define IS_56K_CARD(card)	IS_56K(card->wandev.te_cfg)
 *  o initialize protocol-specific fields of the adapter data space.
	if (conf->config_id != WANCONFIG_MFR) {
				  card->devname, conf->config_id, WANCONFIG_MFR);
		return -EINVAL;
	if ((conf->comm_port == WANOPT_PRI) || (conf->comm_port == WANOPT_SEC)){
		if (card->next){
			if (conf->comm_port != card->next->u.c.comm_port){
				card->u.c.comm_port = conf->comm_port;
				printk(KERN_INFO "%s: ERROR - %s port used!\n",
        		        	card->wandev.name, PORT(conf->comm_port));
				return -EINVAL;
			card->u.c.comm_port = conf->comm_port;
		printk(KERN_INFO "%s: ERROR - Invalid Port Selected!\n",
                			card->wandev.name);
		return -EINVAL;
	if (!card->u.c.prot){
		card->u.c.prot=kmalloc(sizeof(fr_prot_t), GFP_KERNEL);
		if (!card->u.c.prot){
			return -ENOMEM;
		memset(card->u.c.prot,0,sizeof(fr_prot_t));
	fr_prot->station = conf->u.fr.station;
	memcpy(&fr_prot->cfg, &conf->u.fr, sizeof(wan_fr_conf_t));
	if (card->u.c.comm_port == WANOPT_PRI){
		card->mbox_off = PRI_BASE_ADDR_MB_STRUCT;
		card->mbox_off = SEC_BASE_ADDR_MB_STRUCT;
	mb = &card->wan_mbox;
	mb1 = &card->wan_mbox;
	if (!card->configured){
			card->hw_iface.peek(card->hw, 
				card->mbox_off+offsetof(wan_mbox_t, wan_return_code),
			if ((jiffies - timeout) > 1*HZ) break;
				card->devname);
			return -EIO;
	card->wandev.ignore_front_end_status=WANOPT_NO;
	//err=check_conf_hw_mismatch(card,conf->te_cfg.media);
	err = (card->hw_iface.check_mismatch) ? 
			card->hw_iface.check_mismatch(card->hw,conf->fe_cfg.media) : -EINVAL;
        if (IS_TE1_MEDIA(&conf->fe_cfg)) {
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_te_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg = card->hw_iface.fe_write;
		card->fe.read_fe_reg	 = card->hw_iface.fe_read;
		card->wandev.fe_enable_timer = hdlc_enable_timer;
		card->wandev.te_link_state = fr_handle_front_end_state;
		conf->electrical_interface = 
		if (card->u.c.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
		return -EINVAL;
        }else if (IS_56K_MEDIA(&conf->fe_cfg)) {
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_56k_iface_init(&card->fe,&card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg = card->hw_iface.fe_write;
		card->fe.read_fe_reg	 = card->hw_iface.fe_read;
		if (card->u.c.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
		return -EINVAL;
		card->fe.fe_status = FE_CONNECTED;
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
		return -EIO;
	printk(KERN_INFO "%s: Running Frame Relay AnnexG over Raw-HDLC firmware v%s\n",
			card->devname,u.str); 
	printk(KERN_INFO "%s: Running Frame Relay over Raw-HDLC firmware v%s\n",
			card->devname,u.str);
		return -EIO;
	card->isr			= &wp_hdlc_fr_isr;
	card->poll			= NULL;
	card->exec			= NULL;
	card->wandev.update		= &update;
 	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= &del_if;
	card->wandev.udp_port   	= conf->udp_port;
	card->disable_comm		= &disable_comm;
	card->wandev.new_if_cnt = 0;
	card->wandev.bind_annexg	= &bind_annexg;
	card->wandev.un_bind_annexg	= &un_bind_annexg;
	card->wandev.get_map		= &get_map;
	card->wandev.get_active_inactive= &get_active_inactive;
	card->wandev.get_config_info 	= &fr_get_config_info;
	card->wandev.get_status_info 	= &fr_get_status_info;
	card->wandev.set_dev_config    	= &fr_set_dev_config;
	card->wandev.set_if_info     	= &fr_set_if_info;
	card->get_snmp_data	= &fr_snmp_data;
	card->u.c.update_call_count = 0;
	card->wandev.ttl = conf->ttl;
	card->wandev.electrical_interface = conf->electrical_interface; 
	if ((card->u.c.comm_port == WANOPT_SEC && conf->electrical_interface == WANOPT_V35)&&
	    card->type != SDLA_S514){
		printk(KERN_INFO "%s: ERROR - V35 Interface not supported on S508 %s port \n",
			card->devname, PORT(card->u.c.comm_port));
		return -EIO;
	card->wandev.clocking = conf->clocking;
	port_num = card->u.c.comm_port;
	if(card->wandev.clocking) {
		if((port_num == WANOPT_PRI) || card->u.c.receive_only) {
				(card->type == SDLA_S514) ?
                               (card->type == SDLA_S514) ?
			if(conf->bps > max_permitted_baud) {
				conf->bps = max_permitted_baud;
					card->wandev.name);
					card->wandev.name, max_permitted_baud);
			card->wandev.bps = conf->bps;
        	card->wandev.bps = 0;
	if((port_num == WANOPT_PRI) || card->u.c.receive_only) {
		card->wandev.mtu =
			(conf->mtu >= MIN_LGTH_CHDLC_DATA_CFG) ?
			wp_min(conf->mtu, PRI_MAX_NO_DATA_BYTES_IN_FRAME) :
		card->wandev.mtu =
			(conf->mtu >= MIN_LGTH_CHDLC_DATA_CFG) ?
			wp_min(conf->mtu, SEC_MAX_NO_DATA_BYTES_IN_FRAME) :
         * Use this pointer to calculate the value of card->u.c.flags !
	mb1->wan_data_len = 0;
	mb1->wan_command = READ_CHDLC_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb1);
		clear_bit(1, (void*)&card->wandev.critical);
                if(card->type != SDLA_S514)
                	enable_irq(card->wandev.irq/*ALEX_TODAY card->hw.irq*/);
		return -EIO;
	card->flags_off =
			((CHDLC_CONFIGURATION_STRUCT *)mb1->wan_data)->
    	card->intr_type_off = 
			card->flags_off +
	card->intr_perm_off = 
			card->flags_off +
	card->fe_status_off = 
			card->flags_off + 
	skb_queue_head_init(&fr_prot->rx_free);
	skb_queue_head_init(&fr_prot->rx_used);
	skb_queue_head_init(&fr_prot->lmi_queue);
	skb_queue_head_init(&fr_prot->trace_queue);
	fr_prot->max_rx_queue = MAX_FR_RX_BUF;
	if (conf->max_rx_queue && conf->max_rx_queue<FR_RX_BUF_LIMIT){
		fr_prot->max_rx_queue = conf->max_rx_queue;
			card->devname,fr_prot->max_rx_queue);
	for (i=0;i<fr_prot->max_rx_queue;i++){
		skb=dev_alloc_skb(card->wandev.mtu+10);
			printk(KERN_INFO "%s: Failed to allocate rx queues! No Memory!\n",card->devname);
			skb_queue_purge(&fr_prot->rx_free);
			return -ENOMEM;
		skb_queue_tail(&fr_prot->rx_free,skb);
	card->wandev.state = WAN_DUALPORT;
	card->u.c.state = WAN_DISCONNECTED;
	tasklet_init(&fr_prot->wanpipe_task,fr_bh,(u32)card);
	fr_prot->max_trace_queue = MAX_TRACE_QUEUE;
	if (conf->max_trace_queue && conf->max_trace_queue<TRACE_QUEUE_LIMIT){
		fr_prot->max_trace_queue=conf->max_trace_queue;
				card->devname,fr_prot->max_trace_queue);
	if (!card->wandev.piggyback){
		if(err || (card->timer_int_enabled < MAX_INTR_TEST_COUNTER)) { 
					card->devname, card->timer_int_enabled);
					card->devname);
			return  -EIO;
				card->devname, card->timer_int_enabled);
	wan_spin_lock_irq(&card->wandev.lock,&smp_lock);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_lock);
		return -EINVAL;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_lock);
	spin_lock_init(&card->u.c.if_send_lock);
			card->devname,
			fr_prot->station == WANOPT_NODE ? "NODE" : "CPE",
			fr_prot->cfg.signalling == WANOPT_FR_ANSI ? "ANSI":"LMI");
	card->u.c.router_start_time = tv.tv_sec;
	fr_prot->state = LINK_STATE_CHANGED;
	fr_prot->txseq = fr_prot->rxseq = 0;
	fr_prot->last_errors = 0xFFFFFFFF;
	fr_prot->n391cnt = 0;
	init_timer(&fr_prot->timer);
	fr_prot->timer.function = fr_timer;
	fr_prot->timer.data = (unsigned long)card;
	fr_prot->timer.expires = (jiffies+HZ);
	add_timer(&fr_prot->timer);
	if (fr_prot->station == WANOPT_CPE){
				card->devname);
	fr_prot->state |= LINK_STATE_RELIABLE;
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
        if(!card->u.c.flags)
                return -ENODEV;
      	flags = card->u.c.flags;
	if(test_and_set_bit(0,&card->update_comms_stats)){
		return -EAGAIN;
	card->update_comms_stats = 
	card->update_comms_stats = 2;
       	flags->interrupt_info_struct.interrupt_permission |= APP_INT_ON_TIMER;
	card->u.c.timer_int_enabled = TMR_INT_ENABLED_UPDATE;
		if(card->update_comms_stats == 0)
                if ((jiffies - timeout) > (1 * HZ)){
    			card->update_comms_stats = 0;
 			card->u.c.timer_int_enabled &=
 			return -EAGAIN;
	spin_lock_irqsave(&card->wandev.lock, smp_flags);
	card->update_comms_stats=0;
	spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
		return -ENOMEM;
	strncpy(chan->if_name,conf->name,WAN_IFNAME_SZ);
	chan->card = card; 
	if (is_digit(conf->addr[0])) {
		dlci = dec_to_uint(conf->addr, 0);
			chan->dlci = dlci;
			chan->common.lcn=dlci;
				wandev->name, dlci, chan->if_name,HIGHEST_VALID_DLCI);
			err = -EINVAL;
			wandev->name, chan->if_name);
		err = -EINVAL;
			card->devname,conf->name,chan->dlci);
	if (fr_prot->dlci_to_dev_map[chan->dlci] != NULL){
				card->devname,chan->if_name,chan->dlci);
		return -EEXIST;
	chan->route_status = NO_ROUTE;
	chan->route_removed = 0;
	if( strcmp(conf->usedby, "WANPIPE") == 0) {
			wandev->name,chan->if_name);
		card->u.c.usedby = WANPIPE;
	}else if (strcmp(conf->usedby, "ANNEXG") == 0){
		chan->common.usedby = ANNEXG;
				card->devname,chan->if_name);
			wandev->name,chan->if_name);
		return -EINVAL;
	chan->mc = conf->mc;
	if (strlen(conf->label)){
		strncpy(chan->label,conf->label,WAN_IF_LABEL_SZ);
					   &chan->dent, 
					   conf->name, 
			card->devname, conf->name);
		dev->priv=NULL;
	dev->init = NULL;
	dev->priv = chan;
	chan->dlci_state=0;
	chan->newstate=0;
	chan->max_trace_queue = MAX_TRACE_QUEUE;
	if (conf->max_trace_queue){
		chan->max_trace_queue = conf->max_trace_queue;
			card->devname,chan->if_name,chan->dlci,chan->max_trace_queue);
	skb_queue_head_init(&chan->trace_queue);
	card->wandev.new_if_cnt++;
	chan->common.state = WAN_DISCONNECTED;
	wan_spin_lock_irq(&card->wandev.lock,&smp_lock);
	fr_prot->dlci_to_dev_map[chan->dlci] = dev;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_lock);
	fr_private_area_t *chan = dev->priv;
	sdla_t *card = wandev->priv;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	if (fr_prot->tx_dev==dev){
		fr_prot->tx_dev=NULL;
	if (chan->dlci && fr_prot->dlci_to_dev_map[chan->dlci]){
		fr_prot->dlci_to_dev_map[chan->dlci] = NULL;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	if (chan->common.usedby == ANNEXG && chan->annexg_dev){
		printk(KERN_INFO "%s: Unregistering Lapb Protocol\n",wandev->name);
			wan_spin_lock_irq(&wandev->lock, &smp_flags);
			chan->annexg_dev = NULL;
			wan_spin_unlock_irq(&wandev->lock, &smp_flags);
		wan_spin_lock_irq(&wandev->lock, &smp_flags);
		tmp_dev=chan->annexg_dev;
		chan->annexg_dev=NULL;
		wan_spin_unlock_irq(&wandev->lock, &smp_flags);
			wan_spin_lock_irq(&wandev->lock, &smp_flags);
			chan->annexg_dev=tmp_dev;
			wan_spin_unlock_irq(&wandev->lock, &smp_flags);
	wanrouter_proc_delete_interface(wandev, chan->if_name);
	skb_queue_purge(&chan->trace_queue);
	card->wandev.new_if_cnt--;
	tasklet_kill(&fr_prot->wanpipe_task);
	wan_spin_lock_irq(&card->wandev.lock,&smp_lock);
	if (card->u.c.comm_enabled){
	wan_spin_unlock_irq(&card->wandev.lock,&smp_lock);
		del_timer(&fr_prot->timer);
		wan_spin_lock_irq(&card->wandev.lock,&smp_lock);
		skb_queue_purge(&fr_prot->rx_free);	
		skb_queue_purge(&fr_prot->rx_used);
		skb_queue_purge(&fr_prot->lmi_queue);
		skb_queue_purge(&fr_prot->trace_queue);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_lock);
		card->u.c.prot=NULL;
	/* TE1 - Unconfiging */
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
	fr_private_area_t* chan = dev->priv;
	sdla_t* card = chan->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= TX_TIMEOUT;
	dev->do_ioctl		= if_do_ioctl;
	dev->hard_header_len = 0;
	dev->addr_len = 2;
	*(u16*)dev->dev_addr = htons(chan->dlci);
	dlci_to_q922(dev->broadcast, fr_prot->lmi_dlci);
	dev->flags		|= IFF_POINTOPOINT;
	dev->flags		|= IFF_NOARP;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start); //ALEX_TODAY wandev->maddr;
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end); //ALEX_TODAY wandev->maddr + wandev->msize - 1;
	dev->type	= ARPHRD_DLCI;
	dev->mtu	= card->wandev.mtu;
        dev->tx_queue_len = 100;
    	fr_private_area_t* chan = dev->priv;
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++card->wandev.stats.collisions;
	printk (KERN_INFO "%s: Transmit timed out on %s\n", card->devname,dev->name);
	fr_private_area_t* chan = dev->priv;
	sdla_t* card = chan->card;
		return -EBUSY;
	if (fr_prot->station == WANOPT_NODE){
		chan->dlci_state = 0;
		fr_prot->state |= LINK_STATE_CHANGED;
		if (chan->dlci_state & PVC_STATE_ACTIVE){
			chan->dlci_state=0;
	fr_private_area_t* chan = dev->priv;
	sdla_t* card = chan->card;
	dev->start=0;
	if (fr_prot->station == WANOPT_NODE){
		chan->dlci_state &= ~(PVC_STATE_ACTIVE|PVC_STATE_NEW);
		fr_prot->state |= LINK_STATE_CHANGED;
 *	if_do_ioctl - Ioctl handler for fr
	fr_private_area_t* chan = dev->priv;
		return -ENODEV;
	card = chan->card;
		return -EPERM;
			if (atomic_read(&chan->udp_pkt_len) != 0){
				return -EBUSY;
			atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
			wan_udp_pkt=(wan_udp_pkt_t*)&chan->udp_pkt_data;
			if (copy_from_user(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			spin_lock_irqsave(&card->wandev.lock, smp_flags);
			if (test_bit(0,&card->in_isr)){
						card->devname,dev->name);
				atomic_set(&chan->udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
				return -EBUSY;
				atomic_set(&chan->udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
				return -EINVAL;
			spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
			if (atomic_read(&chan->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						card->devname,atomic_read(&chan->udp_pkt_len));
				atomic_set(&chan->udp_pkt_len,0);
				return -EINVAL;
			if (copy_to_user(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			atomic_set(&chan->udp_pkt_len,0);
			return -EOPNOTSUPP;
 * o set tbusy flag (marks start of the transmission) to block a timer-based
 *		non-0	packet may be re-transmitted (tbusy must be set)
	fr_private_area_t *chan = dev->priv;
	sdla_t *card = chan->card;
	dev->trans_start = jiffies;
		 * tx-done interrupt.
			card->devname, dev->name);
	if (dev->tbusy){
		 * kick start the device by making dev->tbusy = 0.  We expect 
		if((jiffies - chan->tick_counter) < (5 * HZ)) {
	if (test_bit(SEND_TXIRQ_CRIT,&card->wandev.critical)){
		chan->tick_counter = jiffies;
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
		//printk(KERN_INFO "%s: (Debug): IF send busy: on TXIRQ CRIT \n",dev->name);
    	if (test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)){
					card->wandev.name,card->wandev.critical);
                ++card->wandev.stats.tx_dropped;
		++chan->stats.tx_carrier_errors;
	if (card->wandev.state != WAN_CONNECTED){
		++card->wandev.stats.tx_dropped;
		++chan->stats.tx_carrier_errors;
	if (chan->common.state != WAN_CONNECTED){
		++card->wandev.stats.tx_dropped;
		++chan->stats.tx_carrier_errors;
	if (fr_hard_header(card, dev, htons(skb->protocol)) <= 0){
		++card->wandev.stats.tx_errors;
	err=hdlc_send_hdr_data(card, dev, skb->data, skb->len);
		err=-1;
		//printk(KERN_INFO "%s: (Debug): IF send failed\n",dev->name);
			chan->stats.tx_fifo_errors++;
		++card->wandev.stats.tx_packets;
       		card->wandev.stats.tx_bytes += skb->len;
		++chan->stats.tx_packets;
		chan->stats.tx_bytes += skb->len;
		dev->trans_start = jiffies;
		chan->tick_counter = jiffies;
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
	clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
	wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	wan_udp_pkt->wan_udp_len = temp;
	temp = wan_udp_pkt->wan_udp_sport;
	wan_udp_pkt->wan_udp_sport = 
			wan_udp_pkt->wan_udp_dport; 
	wan_udp_pkt->wan_udp_dport = temp;
		(wan_udp_pkt->wan_udp_data+mbox_len+even_bound)) = temp;	
		(wan_udp_pkt->wan_udp_data+mbox_len+even_bound+2)) = temp;
	wan_udp_pkt->wan_udp_sum = 0;
	wan_udp_pkt->wan_udp_sum = 
	wan_udp_pkt->wan_ip_len = temp;
	ip_temp = wan_udp_pkt->wan_ip_src;
	wan_udp_pkt->wan_ip_src = 
				wan_udp_pkt->wan_ip_dst;
	wan_udp_pkt->wan_ip_dst = ip_temp;
	wan_udp_pkt->wan_ip_sum = 0;
	wan_udp_pkt->wan_ip_sum = 
 * Get ethernet-style interface statistics.
	if (!dev || !(dev->flags&IFF_UP))
         * dev->priv pointer. This function, gets
	if ((chan=dev->priv) == NULL)
	return &chan->stats;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CHDLC_CODE_VERSION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		len = mb->wan_data_len;
		memcpy(str, mb->wan_data, len);
/*-----------------------------------------------------------------------------
	wan_mbox_t *mbox = &card->wan_mbox;
	mbox->wan_data_len = data_length;  
	memcpy(mbox->wan_data, data, data_length);
	mbox->wan_command = SET_CHDLC_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
 * Set interrupt mode -- HDLC Version.
	wan_mbox_t* mb = &card->wan_mbox;
		 (CHDLC_INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->CHDLC_interrupt_triggers 	= mode;
	int_data->IRQ				= card->wandev.irq; //ALEX_TODAY card->hw.irq;
	int_data->interrupt_timer               = 1;
	mb->wan_data_len = sizeof(CHDLC_INT_TRIGGERS_STRUCT);
	mb->wan_command = SET_CHDLC_INTERRUPT_TRIGGERS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = ENABLE_CHDLC_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->u.c.comm_enabled=1;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = DISABLE_CHDLC_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_COMMS_ERROR_STATS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_CHDLC_OPERATIONAL_STATS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
		card->wandev.fe_iface.read_alarm(&card->fe, 0); 
		card->wandev.fe_iface.read_pmon(&card->fe, 0); 
		card->wandev.fe_iface.read_alarm(&card->fe, 1); 
	err_stats = (COMMS_ERROR_STATS_STRUCT *)mb->wan_data;
	card->wandev.stats.rx_over_errors = 
			err_stats->Rx_overrun_err_count;
	card->wandev.stats.rx_crc_errors = 
				err_stats->CRC_err_count;
	card->wandev.stats.rx_frame_errors = 
				err_stats->Rx_abort_count;
	card->wandev.stats.rx_fifo_errors = 
			err_stats->Rx_dis_pri_bfrs_full_count; 
	card->wandev.stats.rx_missed_errors =
			card->wandev.stats.rx_fifo_errors;
	card->wandev.stats.tx_aborted_errors =
			err_stats->sec_Tx_abort_count;
	op_stats = (CHDLC_OPERATIONAL_STATS_STRUCT *)mb->wan_data;
	card->wandev.stats.rx_length_errors =
		(op_stats->Rx_Data_discard_short_count +
		op_stats->Rx_Data_discard_long_count);
	fr_private_area_t *chan = dev->priv;
	card->hw_iface.peek(card->hw, card->u.c.txbuf_off, &txbuf, sizeof(txbuf));
	txbuf.frame_length = (len+chan->hdr_len);
	card->hw_iface.poke(card->hw,txbuf.ptr_data_bfr,chan->header,chan->hdr_len);
	card->hw_iface.poke(card->hw,(txbuf.ptr_data_bfr+chan->hdr_len),data,len);
	card->hw_iface.peek(card->hw, card->u.c.txbuf_off, &txbuf, sizeof(txbuf));
	card->u.c.txbuf_off += sizeof(txbuf);
	if (card->u.c.txbuf_off > card->u.c.txbuf_last_off)
		card->u.c.txbuf_off = card->u.c.txbuf_base_off;
 *	Return:	0 - o.k.
 *		1 - no transmit buffers available
	card->hw_iface.peek(card->hw, card->u.c.txbuf_off, &txbuf, sizeof(txbuf));
	card->hw_iface.poke(card->hw, txbuf.ptr_data_bfr, data, len);
	card->hw_iface.poke(card->hw, card->u.c.txbuf_off, &txbuf, sizeof(txbuf));
	card->u.c.txbuf_off += sizeof(txbuf);
	if (card->u.c.txbuf_off > card->u.c.txbuf_last_off)
		card->u.c.txbuf_off = card->u.c.txbuf_base_off;
	wan_mbox_t* mb = &card->wan_mbox;
	ADAPTER_CONFIGURATION_STRUCT* cfg = (ADAPTER_CONFIGURATION_STRUCT*)mb->wan_data;
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &cfg->adapter_type); 
	cfg->adapter_config = 0x00; 
	cfg->operating_frequency = 00; 
	mb->wan_data_len = sizeof(ADAPTER_CONFIGURATION_STRUCT);
	mb->wan_command = SET_ADAPTER_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card->u.c.timer_int_enabled |= TMR_INT_ENABLED_TE;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_command;
			card->devname, cmd);
				card->devname);
			card->devname, cmd, err);
	set_bit(0,&card->in_isr);
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical)) {
				card->devname);
		card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	if(card->type != SDLA_S514) {
		if(test_bit(0, (void*)&card->wandev.critical)) {
				card->devname, card->wandev.critical);
			++ card->timer_int_enabled;
				card->hw_iface.peek(card->hw, card->fe_status_off,
				card->hw_iface.poke(card->hw, card->fe_status_off,
			if (card->next){
				set_bit(0,&card->spurious);
				card->devname,
	card->in_isr = 0;
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
				card->devname);
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	card->hw_iface.peek(card->hw, card->u.c.rxmb_off, &rxbuf, sizeof(rxbuf));
			card->devname, card->u.c.rxmb_off, rxbuf.opp_flag);
				card->devname);
				card->devname,rxbuf.error_flag, rxbuf.frame_length);
	    (rxbuf.frame_length > (card->wandev.mtu+CRC_LENGTH))){
				card->devname,rxbuf.frame_length);
	len = rxbuf.frame_length - CRC_LENGTH;
	skb = skb_dequeue(&fr_prot->rx_free);
						card->devname,MAX_FR_RX_BUF);
						card->devname);
					card->devname,fr_prot->tq_working);
		++card->wandev.stats.rx_dropped;
	if((addr + len) > card->u.c.rx_top_off + 1) {
		unsigned tmp = card->u.c.rx_top_off - addr + 1;
		card->hw_iface.peek(card->hw, addr, buf, tmp);
		addr = card->u.c.rx_base_off;
		len -= tmp;
	card->hw_iface.peek(card->hw, addr, buf, len);
	if (skb->len <= 7 && !(skb->data[3]&0x01)){
		if (skb->len == 7 && (skb->data[6]&0x01))
				skb->len,(rxbuf.frame_length-CRC_LENGTH));
		for (x=0;x<skb->len;x++){
			printk("%X ",skb->data[x]);
				card->u.c.rxmb_off,
				(u32)card->u.c.rx_top_off);
	skb_queue_tail(&fr_prot->rx_used,skb);
	if (!test_and_set_bit(0,&fr_prot->tq_working)){
		tasklet_schedule(&fr_prot->wanpipe_task);
	card->hw_iface.poke_byte(card->hw, 
			card->u.c.rxmb_off+offsetof(CHDLC_DATA_RX_STATUS_EL_STRUCT, opp_flag),
	card->u.c.rxmb_off += sizeof(rxbuf);
	if (card->u.c.rxmb_off > card->u.c.rxbuf_last_off){
		card->u.c.rxmb_off = card->u.c.rxbuf_base_off;
	if (card->wandev.new_if_cnt == 1){
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (devle->dev == dev){
				dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (test_bit(SEND_CRIT,&card->wandev.critical)){
	set_bit(SEND_TXIRQ_CRIT,&card->wandev.critical);
	while ((skb=skb_dequeue(&fr_prot->lmi_queue))!=NULL){
		if (hdlc_send(card, skb->data, skb->len)){
			skb_queue_head(&fr_prot->lmi_queue,skb);
		//card->wandev.stats.tx_aborted_errors++;
	clear_bit(SEND_TXIRQ_CRIT,&card->wandev.critical);
	if (fr_prot->tx_dev == NULL){
		fr_prot->tx_dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	dev = fr_prot->tx_dev;
		printk(KERN_INFO "%s: No dev in tx intr\n",card->devname);
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
		if (!dev || !(dev->flags & IFF_UP)){
			fr_private_area_t *chan=dev->priv;
			if (chan && chan->common.usedby == ANNEXG && chan->annexg_dev){
					lapb_protocol.lapb_mark_bh(chan->annexg_dev);
		if (++i >= card->wandev.new_if_cnt){
	fr_prot->tx_dev = dev;
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
 *    2) Reading board-level statistics for updating the proc file system.
	if (test_bit(SEND_CRIT,&card->wandev.critical)){
	if (card->u.c.timer_int_enabled & TMR_INT_ENABLED_TE) {
		DEBUG_EVENT("%s: TE Polling\n",card->devname);
		card->wandev.fe_iface.polling(&card->fe);
		card->u.c.timer_int_enabled &= ~TMR_INT_ENABLED_TE;
        if(!card->u.c.timer_int_enabled) {
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
/*------------------------------------------------------------------------------
	- set_hdlc_config() used to set configuration options on the board
------------------------------------------------------------------------------*/
	if(card->wandev.clocking)
		cfg.baud_rate = card->wandev.bps;
	cfg.line_config_options = (card->wandev.electrical_interface == WANOPT_RS232) ?
	cfg.max_CHDLC_data_field_length	= card->wandev.mtu+CRC_LENGTH;
	wan_mbox_t* mbox = &card->wan_mbox;
	mbox->wan_data_len = 0;
	mbox->wan_command = READ_GLOBAL_EXCEPTION_CONDITION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
		switch(mbox->wan_return_code) {
				card->hw_iface.peek(card->hw, 
						    card->fe_status_off, 
				card->fe.fe_param.k56_param.RR8_reg_56k = 
				card->fe.fe_param.k56_param.RRA_reg_56k = 
				card->fe.fe_param.k56_param.RRC_reg_56k = 
				card->wandev.fe_iface.read_alarm(&card->fe, 0);
				card->wandev.fe_iface.isr(&card->fe);
			if (mbox->wan_data[0] & DCD_HIGH){
				card->fe.fe_status = FE_CONNECTED;
				card->fe.fe_status = FE_DISCONNECTED;
				card->devname);
			switch(mbox->wan_data[0] & (DCD_HIGH | CTS_HIGH)) {
					printk(KERN_INFO "%s: DCD high, CTS low\n",card->devname);
                                        printk(KERN_INFO "%s: DCD low, CTS high\n",card->devname);
                                        printk(KERN_INFO "%s: DCD high, CTS high\n",card->devname);
                                        printk(KERN_INFO "%s: DCD low, CTS low\n",card->devname);
				card->devname);
				card->devname); 
				card->devname, mbox->wan_return_code);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CHDLC_EXCEPTION_CONDITION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			card->fe.fe_status = FE_CONNECTED;
			card->fe.fe_status = FE_DISCONNECTED;
						card->devname);
						card->devname);
					card->devname,err);
	if(!chan->udp_pkt_lgth &&
	  (skb->len <= MAX_LGTH_UDP_MGNT_PKT)) {
        	chan->udp_pkt_lgth = skb->len;
		chan->udp_pkt_src = udp_pkt_src;
       		memcpy(chan->udp_pkt_data, skb->data, skb->len);
		card->u.c.timer_int_enabled = TMR_INT_ENABLED_UDP;
	if (card->wandev.ignore_front_end_status == WANOPT_YES){
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (card->fe.fe_status == FE_CONNECTED){ 
			if (chan->dlci_state & PVC_STATE_ACTIVE &&
			    card->wandev.state == WAN_CONNECTED &&
			    chan->common.state != WAN_CONNECTED){
			if (chan->common.state != WAN_DISCONNECTED){
				if (chan->route_flag == ROUTE_ADDED) {
					chan->route_flag = REMOVE_ROUTE;
				if (chan->inarp == INARP_CONFIGURED) {
					chan->inarp = INARP_REQUEST;
        memset(&chan->drvstats_if_send.if_send_entry, 0,
        memset(&chan->drvstats_rx_intr.rx_intr_no_socket, 0,
        memset(&chan->drvstats_gen.UDP_PIPE_mgmt_kmalloc_err, 0,
        memset(&card->statistics.isr_entry, 0, sizeof(global_stats_t));
	wan_mbox_t *mbox = &card->wan_mbox;
			card->u.f.udp_pkt_lgth = 0;
			return -ENODEV;
		if ((chan = dev->priv) == NULL){
			card->u.f.udp_pkt_lgth = 0;
			return -ENODEV;
				card->u.f.udp_pkt_lgth = 0;
				return -EBUSY;
		wan_udp_pkt = (wan_udp_pkt_t *)card->u.f.udp_pkt_data;
			switch(wan_udp_pkt->wan_udp_command) {
		if ((chan = dev->priv) == NULL){
			return -ENODEV;
		dlci=chan->dlci;	
		if (atomic_read(&chan->udp_pkt_len) == 0){
			return -ENODEV;
		wan_udp_pkt = (wan_udp_pkt_t *)chan->udp_pkt_data;
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
		wan_udp_pkt->wan_udp_data_len = 0;
		wan_udp_pkt->wan_udp_return_code = 0xCD; 
		chan->drvstats_gen.UDP_PIPE_mgmt_direction_err ++;
			card->devname,wan_udp_pkt->wan_udp_command);
		switch(wan_udp_pkt->wan_udp_command) {
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len=0;
			unsigned short *data_buf = (unsigned short*)wan_udp_pkt->wan_udp_data;
				if (!fr_prot->global_dlci_map[ch])
				if (fr_prot->global_dlci_map[ch] & PVC_STATE_ACTIVE){
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len = data_len;
			unsigned char *data_buf = (unsigned char*)wan_udp_pkt->wan_udp_data;
			*data_buf = (card->wandev.state == WAN_CONNECTED) ? 1:0;
				if (!fr_prot->global_dlci_map[ch])
				*data_buf = (fr_prot->global_dlci_map[ch] | 0x40);
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len = data_len;
			memcpy(wan_udp_pkt->wan_udp_data,&fr_prot->link_stats,sizeof(fr_link_stat_t));
			wan_udp_pkt->wan_udp_data_len = sizeof(fr_link_stat_t);
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_return_code = 0;
			if (wan_udp_pkt->wan_udp_data[0] & TRC_ACTIVE){
				if (!test_bit(0,&chan->tracing_enabled)){
					chan->stats.tx_fifo_errors=0;
					chan->stats.rx_over_errors=0;
					chan->trace_timeout=jiffies;
					skb_queue_purge(&chan->trace_queue);
					set_bit (0,&chan->tracing_enabled);
							card->devname,chan->if_name,chan->dlci);
							card->devname,chan->if_name,chan->dlci);
					wan_udp_pkt->wan_udp_return_code = 2;
			}else if (wan_udp_pkt->wan_udp_data[0] & (TRC_SIGNALLING_FRMS|TRC_INFO_FRMS)){
				if (test_bit(0,&chan->tracing_enabled)){
							card->devname,chan->if_name,chan->dlci);
					wan_udp_pkt->wan_udp_return_code = 2;
				}else if (test_bit(1,&chan->tracing_enabled)){
							card->devname);
					wan_udp_pkt->wan_udp_return_code = 1;
				}else if(!test_bit(0,&fr_prot->tracing_enabled)){
					skb_queue_purge(&fr_prot->trace_queue);
					fr_prot->trace_timeout=jiffies;
					set_bit (1,&chan->tracing_enabled);
					set_bit (0,&fr_prot->tracing_enabled);
							card->devname);
							card->devname,chan->if_name);
					wan_udp_pkt->wan_udp_return_code = 2;
						card->devname,chan->if_name);
				wan_udp_pkt->wan_udp_return_code = 1;
			if (wan_udp_pkt->wan_udp_return_code == 0){
				chan->stats.rx_fifo_errors=0;
				chan->stats.tx_fifo_errors=0;
			wan_udp_pkt->wan_udp_data_len=0;
			wan_udp_pkt->wan_udp_return_code = 0;
			if(test_bit(0,&chan->tracing_enabled)) {
				clear_bit(0,&chan->tracing_enabled);
                    		skb_queue_purge(&chan->trace_queue);
						card->devname,chan->if_name, chan->dlci);
			}else if (test_bit(1,&chan->tracing_enabled)){
				clear_bit(1,&chan->tracing_enabled);
				clear_bit(0,&fr_prot->tracing_enabled);
				skb_queue_purge(&fr_prot->trace_queue);
						card->devname,chan->if_name);
				//			card->devname,chan->if_name);
				wan_udp_pkt->wan_udp_return_code = 1;
			wan_udp_pkt->wan_udp_data_len=0;
                        if(test_bit(0,&chan->tracing_enabled)){
				trace_queue=&chan->trace_queue;
				chan->trace_timeout=jiffies;
			}else if (test_bit(1,&chan->tracing_enabled)){
				trace_queue=&fr_prot->trace_queue;
				fr_prot->trace_timeout=jiffies;
						card->devname,chan->if_name);
                                wan_udp_pkt->wan_udp_return_code = 1;
				wan_udp_pkt->wan_udp_data_len=0;
			wan_udp_pkt->wan_udp_data[0x00] = 0x00;
				fr_trc_el_t *trc_el = (fr_trc_el_t*)skb->data;
				if (trc_el->length > skb->len){
				if((trc_el->length + sizeof(fpipemon_trc_hdr_t) + 1) >
					(MAX_TRACE_BUFFER - buffer_length)){
					wan_udp_pkt->wan_udp_data[0x00] |= MORE_TRC_DATA;
					(fpipemon_trc_t *)&wan_udp_pkt->wan_udp_data[buffer_length]; 
				fpipemon_trc->fpipemon_trc_hdr.status =
					trc_el->attr;
                            	fpipemon_trc->fpipemon_trc_hdr.tmstamp =
					trc_el->tmstamp;
                            	fpipemon_trc->fpipemon_trc_hdr.length = 
					trc_el->length;
                                if(!trc_el->length) {
                                     	fpipemon_trc->fpipemon_trc_hdr.data_passed = 0x00;
                                        fpipemon_trc->fpipemon_trc_hdr.data_passed = 0x01;
					memcpy(fpipemon_trc->data, (skb->data+sizeof(fr_trc_el_t)), trc_el->length);
                               	if(fpipemon_trc->fpipemon_trc_hdr.data_passed) {
                               		buffer_length += trc_el->length;
				if(wan_udp_pkt->wan_udp_data[0x00] & MORE_TRC_DATA) {
                        	wan_udp_pkt->wan_udp_data[0x00] |= MORE_TRC_DATA;
			wan_udp_pkt->wan_udp_data[0x00] |=
			wan_udp_pkt->wan_udp_data_len = buffer_length;
                        wan_udp_pkt->wan_udp_return_code = 0;
			((unsigned char *)wan_udp_pkt->wan_udp_data )[0] =
			((unsigned char *)wan_udp_pkt->wan_udp_data )[1] =
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len = 2;
			wan_udp_pkt->wan_udp_data_len=0;
			card->u.c.router_up_time = tv.tv_sec - 
					card->u.c.router_start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
					card->u.c.router_up_time;	
			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
			memcpy(wan_udp_pkt->wan_udp_data,
				&chan->drvstats_if_send.if_send_entry,
			wan_udp_pkt->wan_udp_data_len =sizeof(if_send_stat_t);	
			wan_udp_pkt->wan_udp_return_code = 0;
			memcpy(wan_udp_pkt->wan_udp_data,
                                &card->statistics.isr_entry,
                        memcpy(&wan_udp_pkt->wan_udp_data[sizeof(global_stats_t)],
                                &chan->drvstats_rx_intr.rx_intr_no_socket,
			wan_udp_pkt->wan_udp_data_len = 
			wan_udp_pkt->wan_udp_return_code = 0;
                        memcpy(wan_udp_pkt->wan_udp_data,
                                &chan->drvstats_gen.UDP_PIPE_mgmt_kmalloc_err,
                        memcpy(&wan_udp_pkt->wan_udp_data[sizeof(pipe_mgmt_stat_t)],
                               &card->statistics, sizeof(global_stats_t));
                        wan_udp_pkt->wan_udp_data_len = sizeof(global_stats_t)+
			wan_udp_pkt->wan_udp_return_code = 0;
			mbox->wan_command = 0x1C;
	        	if ((wan_udp_pkt->wan_udp_data[0] & ENABLE_READ_FT1_STATUS) ||  
				(wan_udp_pkt->wan_udp_data[0] & ENABLE_READ_FT1_OP_STATS)) {
					wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
					wan_udp_pkt->wan_udp_data_len=1;
					mbox->wan_data_len = 1;
	      		if( wan_udp_pkt->wan_udp_data[0] == 0) {
	      	   	     	if( --rCount != 0) {
		  			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
					wan_udp_pkt->wan_udp_data_len=1;
					mbox->wan_data_len = 1;
			mbox->wan_command = 0x1E;
				card->wandev.fe_iface.process_udp(
						&card->fe,
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				card->wandev.fe_iface.process_udp(
						&card->fe,
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				if (wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE){
		    			wan_udp_pkt->wan_udp_data_len = sizeof(wan_femedia_t); 
					wan_udp_pkt->wan_udp_return_code = CMD_OK;
					wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
			err = card->wandev.fe_iface.set_fe_lbmode(
						&card->fe, 
						wan_udp_pkt->wan_udp_data[0], 
						wan_udp_pkt->wan_udp_data[1]);
			wan_udp_pkt->wan_udp_return_code = 
			wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
		    wan_udp_pkt->wan_udp_data_len = 0x00;
	 		wan_udp_pkt->wan_udp_data[0] = 
		    	wan_udp_pkt->wan_udp_data_len = sizeof(unsigned char); 
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
			  	*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
					card->wandev.fe_iface.read_alarm(
							&card->fe, 0);
	        		memcpy(&wan_udp_pkt->wan_udp_data[sizeof(unsigned long)],
					&card->wandev.te_pmon,
		        	wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
		    		wan_udp_pkt->wan_udp_data_len = 
				card->wandev.k56_alarm = sdla_56k_alarm(card, 1); 
			 	*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
			                        card->wandev.k56_alarm;
				wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
	    			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
				card->wandev.fe_iface.flush_pmon(&card->fe);
	        		wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
			wan_udp_pkt->wan_udp_data_len=0;
        			memcpy(&wan_udp_pkt->wan_udp_data[0],
					&card->wandev.te_cfg,
		        	wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
	    			wan_udp_pkt->wan_udp_data_len = sizeof(sdla_te_cfg_t);
		   	wan_udp_pkt->wan_udp_data[0] = card->wandev.config_id;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_LINUX_PLATFORM;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
			orig_cmd=wan_udp_pkt->wan_udp_command;
			switch(wan_udp_pkt->wan_udp_command){
					mbox->wan_command = READ_MODEM_STATUS;
					mbox->wan_command = READ_COMMS_ERROR_STATS;
					mbox->wan_command = FLUSH_COMMS_ERROR_STATS;
					mbox->wan_return_code=1;
			mbox->wan_data_len = wan_udp_pkt->wan_udp_data_len;
			if (mbox->wan_data_len) {
				memcpy(&mbox->wan_data, (unsigned char *) wan_udp_pkt->
							wan_udp_data, mbox->wan_data_len);
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
			memcpy(&wan_udp_pkt->wan_udp_hdr.wan_cmd, mbox, sizeof(wan_cmd_t));
			if (mbox->wan_data_len) {
	         		memcpy(&wan_udp_pkt->wan_udp_data, &mbox->wan_data, 
								mbox->wan_data_len); 
			wan_udp_pkt->wan_udp_data_len=mbox->wan_data_len;
			wan_udp_pkt->wan_udp_return_code=err;
				chan->drvstats_gen.
                                chan->drvstats_gen.
						(COMMS_ERROR_STATS_STRUCT *)mbox->wan_data;
					wan_udp_pkt->wan_udp_data[8]=comm_stats->DCD_state_change_count;
					wan_udp_pkt->wan_udp_data[9]=comm_stats->CTS_state_change_count;
					wan_udp_pkt->wan_udp_data_len=mbox->wan_data_len=10;
					wan_udp_pkt->wan_udp_return_code=0;
        wan_udp_pkt->wan_ip_ttl = card->wandev.ttl;
		len = reply_udp(chan->udp_pkt_data, wan_udp_pkt->wan_udp_data_len);
        	//len = reply_udp(card->u.f.udp_pkt_data, mbox->wan_data_len);
		atomic_set(&chan->udp_pkt_len,len);
		chan->fr_header_len=2;
		chan->fr_header[0]=chan->fr_encap_0;
		chan->fr_header[1]=chan->fr_encap_1;
			card->u.f.udp_pkt_data,chan->fr_header_len);
			chan->drvstats_gen.UDP_PIPE_mgmt_adptr_send_passed ++;
			chan->drvstats_gen.UDP_PIPE_mgmt_adptr_send_failed ++;
			memcpy(buf, card->u.f.udp_pkt_data, len);
			chan->drvstats_gen.
			new_skb->dev = dev;
			new_skb->protocol = htons(ETH_P_IP);
			chan->drvstats_gen.UDP_PIPE_mgmt_no_socket ++;
			card->devname);
	card->u.f.udp_pkt_lgth = 0;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CHDLC_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
                ((CHDLC_CONFIGURATION_STRUCT *)mb->wan_data)->
		((CHDLC_CONFIGURATION_STRUCT *)mb->wan_data)->
	card->hw_iface.peek(card->hw, tx_config_off, &tx_config, sizeof(tx_config));
	card->hw_iface.peek(card->hw, rx_config_off, &rx_config, sizeof(rx_config));
       	card->u.c.txbuf_base_off =
       	card->u.c.txbuf_last_off = 
               	card->u.c.txbuf_base_off +
		(tx_config.number_Tx_status_elements - 1) * 
	card->hw_iface.peek(card->hw, tx_config_off, &tx_config, sizeof(tx_config));
       	card->u.c.rxbuf_base_off =
       	card->u.c.rxbuf_last_off =
		card->u.c.rxbuf_base_off +
		(rx_config.number_Rx_status_elements - 1) * 
       	card->u.c.txbuf_off =
       	card->u.c.rxmb_off =
        card->u.c.rx_base_off = rx_config.base_addr_Rx_buffer;
        card->u.c.rx_top_off  = rx_config.end_addr_Rx_buffer;
	wan_mbox_t* mb = &card->wan_mbox;
	card->timer_int_enabled = 0;
			mb->wan_data_len  = 0;
			mb->wan_command = READ_CHDLC_CODE_VERSION;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_udp_pkt_t *wan_udp_pkt = (wan_udp_pkt_t *)skb->data;
	if (skb->len < sizeof(wan_udp_pkt_t)){
		wan_udp_pkt = (wan_udp_pkt_t *)&skb->data[2];
        if((wan_udp_pkt->ip_pkt.protocol == UDPMGMT_UDP_PROTOCOL) &&
		(wan_udp_pkt->ip_pkt.ver_inet_hdr_length == 0x45) &&
		(wan_udp_pkt->udp_pkt.udp_dst_port == 
		ntohs(card->wandev.udp_port)) &&
		(wan_udp_pkt->wp_mgmt.request_reply == 
                        if(!strncmp(wan_udp_pkt->wp_mgmt.signature,
	if (!dev || !dev->priv){
	chan=dev->priv;
	card = chan->card;
        if (chan->common.state != state){
		chan->common.state = state;
                                card->devname,chan->if_name,chan->dlci);
			if (chan->common.usedby == ANNEXG && chan->annexg_dev){
					lapb_protocol.lapb_link_up(chan->annexg_dev);
                                card->devname,chan->if_name,chan->dlci);
                                card->devname,chan->if_name,chan->dlci);
			if (chan->common.usedby == ANNEXG && chan->annexg_dev){
					lapb_protocol.lapb_link_down(chan->annexg_dev);
	if (card->u.c.comm_enabled){
				card->devname);
		return -EIO;
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
		int	err = -EINVAL;
			card->devname, 
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
					card->devname,
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
		int	err = -EINVAL;
			card->devname);
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
				card->devname);
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
				card->devname);
		return -EIO;	
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, 
				card->devname);
		card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
		card->u.c.comm_enabled=0;
		return -EIO;
		card->wandev.fe_iface.read_alarm(&card->fe, 1);
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, 
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	printk(KERN_INFO "%s: Enabling data link layer!\n",card->devname);
#define PROC_CFG_FRM	"%-15s| %-12s| %-5u|\n"
#define PROC_STAT_FRM	"%-15s| %-12s| %-14s|\n"
		return m->count;
		card = chan->card;
		if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
			PROC_CFG_FRM, chan->if_name, card->devname, chan->dlci);
	return m->count;
	sdla_t*		card = chan->card;
		return m->count;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		PROC_STAT_FRM, chan->if_name, card->devname, STATE_DECODE(chan->common.state));
	return m->count;
#define PROC_DEV_FR_S_FRM	"%-20s| %-14s|\n"
#define PROC_DEV_FR_D_FRM	"%-20s| %-14d|\n"
#define PROC_DEV_FR_SDDD_TITLE_FRM    	"%-12s| %-5s | %-6s | %-7s | %-8s | %-13s |\n"
#define PROC_DEV_FR_SDDD_FRM    	"%-12s| %-5d | %-6d | %-7d | %-8d | %-13s |\n"
	card = (sdla_t*)wandev->priv;
			wandev->name, buffer);
#define PROC_IF_FR_S_FRM	"%-30s\t%-14s\n"
#define PROC_IF_FR_D_FRM	"%-30s\t%-14d\n"
#define PROC_IF_FR_L_FRM	"%-30s\t%-14ld\n"
	if (dev == NULL || dev->priv == NULL)
	chan = (fr_private_area_t*)dev->priv;
	if (chan->card == NULL)
	card = chan->card;
			chan->if_name, buffer);
	if (card->type != SDLA_S514){
		spin_lock_irqsave(&card->wandev.lock, *smp_flags);
		spin_lock(&card->u.c.if_send_lock);
	if (card->type != SDLA_S514){
		spin_unlock_irqrestore (&card->wandev.lock, *smp_flags);
		spin_unlock(&card->u.c.if_send_lock);
	for (val = 0; len && is_digit(*str); ++str, --len)
		val = (val * 10) + (*str - (unsigned)'0');
	fr_private_area_t *chan = dev->priv;
		return -ENODEV;
	if (chan->common.usedby == ANNEXG){
		dlci_to_q922(chan->header, chan->dlci);
		chan->hdr_len = 2;
		return chan->hdr_len;
		chan->hdr_len = 4;
		chan->header[3]=NLPID_IP;
		chan->hdr_len = 4;
		chan->header[3]=NLPID_IPV6;
		chan->hdr_len = 10;
		chan->header[3] = FR_PAD;
		chan->header[4] = NLPID_SNAP;
		chan->header[5] = FR_PAD;
		chan->header[6] = FR_PAD;
		chan->header[7] = FR_PAD;
		chan->header[8] = type>>8;
		chan->header[9] = (u8)type;
	dlci_to_q922(chan->header, chan->dlci);
	chan->header[2] = FR_UI;
	return chan->hdr_len;
	       ((sdla_t*)chan->card)->devname,
	       chan->if_name,
	       chan->dlci,
	       chan->dlci_state & PVC_STATE_ACTIVE ? "" : "in",
	       chan->dlci_state & PVC_STATE_NEW ? " new" : "");
//			fr_prot->state,fr_prot->last_errors);
	if (fr_prot->station == WANOPT_NODE){
		reliable = ((jiffies - fr_prot->last_rx_poll) < (fr_prot->cfg.t392*HZ));
			fr_prot->link_stats.T392_timeouts++;
		fr_prot->last_errors <<= 1; /* Shift the list */
		if (fr_prot->state & LINK_STATE_REQUEST) {
			       card->devname);
			fr_prot->last_errors |= 1;
			fr_prot->link_stats.T391_timeouts++;
		for (i = 0, list = fr_prot->last_errors; i < fr_prot->cfg.n393;
		reliable = (cnt < fr_prot->cfg.n392);
	if ((fr_prot->state & LINK_STATE_RELIABLE) != (reliable ? LINK_STATE_RELIABLE : 0)){ 
		WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
			if (!(dev->flags & IFF_UP))
			chan->dlci_state &= ~(PVC_STATE_NEW | PVC_STATE_ACTIVE);
		fr_prot->state ^= LINK_STATE_RELIABLE;
					card->devname);
		//printk(KERN_INFO "%s: Link %sreliable\n", card->devname,
			fr_prot->n391cnt = 0; /* Request full status */
			fr_prot->state |= LINK_STATE_CHANGED;
	if (fr_prot->station == WANOPT_NODE){
		fr_prot->timer.expires = jiffies + fr_prot->cfg.t392*HZ;
		if (fr_prot->n391cnt)
			fr_prot->n391cnt--;
		fr_lmi_send(card, (fr_prot->n391cnt == 0));
		fr_prot->state |= LINK_STATE_REQUEST;
		fr_prot->timer.expires = jiffies + (fr_prot->cfg.t391*HZ);
	add_timer(&fr_prot->timer);
	int len = (fr_prot->cfg.signalling == WANOPT_FR_ANSI) ? LMI_ANSI_LENGTH : LMI_LENGTH;
	if (fr_prot->station == WANOPT_NODE && fullrep) {
		dlci_cnt=card->wandev.new_if_cnt;
		if (len > card->wandev.mtu) {
					card->devname,len,card->wandev.mtu);
					card->devname);
			card->wandev.stats.tx_errors++;
			       card->devname);
		card->wandev.stats.tx_errors++;
	memset(skb->data, 0, len);
	skb->data[3] = LMI_PROTO;
	dlci_to_q922(skb->data, fr_prot->lmi_dlci);
	skb->data[2] = FR_UI;
	data = skb->tail;
	data[i++] = (fr_prot->station == WANOPT_NODE) ? LMI_STATUS : LMI_STATUS_ENQUIRY;
	if (fr_prot->cfg.signalling == WANOPT_FR_ANSI){
	data[i++] = fr_prot->txseq = fr_lmi_nextseq(fr_prot->txseq);
	data[i++] = fr_prot->rxseq;
	if (fr_prot->station == WANOPT_NODE && fullrep) {
			if ((dev=fr_prot->dlci_to_dev_map[ch]) == NULL)
			if (--dlci_cnt < 0)
			chan=dev->priv;
			//printk(KERN_INFO "Interigating %s DLCI=%i\n",chan->if_name,chan->dlci);
			if ((fr_prot->state & LINK_STATE_RELIABLE) &&
			    (dev->flags & IFF_UP) &&
			    !(chan->dlci_state & (PVC_STATE_ACTIVE|PVC_STATE_NEW))) {
				chan->dlci_state |= PVC_STATE_NEW;
				if (!(chan->dlci_state & PVC_STATE_ACTIVE)){
			dlci_to_status(card, chan->dlci,
				       data+i, chan->dlci_state);
	if (fr_prot->station == WANOPT_NODE){
			fr_prot->link_stats.node_tx_FSR++;
			fr_prot->link_stats.node_tx_LIV++;
			fr_prot->link_stats.cpe_tx_FSE++;
			fr_prot->link_stats.cpe_tx_LIV++;
	skb->priority = TC_PRIO_CONTROL;
	skb_queue_tail(&fr_prot->lmi_queue,skb);
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
	memset(fr_prot->global_dlci_map,0,sizeof(fr_prot->global_dlci_map));
	fr_prot->global_dlci_map[dlci] = state;
	int reptype = -1, error;
//	printk(KERN_INFO "FR LMI REC: Len=%i Min=%i\n",skb->len, LMI_ANSI_LENGTH);
	if (skb->len < ((fr_prot->cfg.signalling == WANOPT_FR_ANSI) ? LMI_ANSI_LENGTH : LMI_LENGTH)) {
		printk(KERN_INFO "%s: Short LMI frame\n", card->devname);
		fr_prot->link_stats.rx_dropped++;
	if (skb->data[5] != ((fr_prot->station != WANOPT_NODE) ?
		       card->devname, skb->data[2],
		       (fr_prot->station != WANOPT_NODE) ? "enquiry" : "reply");
		fr_prot->link_stats.rx_bad_format++;
	i = (fr_prot->cfg.signalling == WANOPT_FR_ANSI) ? 7 : 6;
	if (skb->data[i] !=
		       card->devname, skb->data[i]);
		fr_prot->link_stats.rx_bad_format++;
	reptype = skb->data[i++];
	if (skb->data[i] != ((MODE_FR_CCITT) ? LMI_CCITT_ALIVE : LMI_ALIVE)) {
		       card->devname, skb->data[i]);
		fr_prot->link_stats.rx_bad_format++;
	fr_prot->rxseq = skb->data[i++]; /* TX sequence from peer */
	rxseq = skb->data[i++];	/* Should confirm our sequence */
	txseq = fr_prot->txseq;
	//		txseq, fr_prot->rxseq, rxseq,i);
	if (fr_prot->station == WANOPT_NODE) {
			fr_prot->link_stats.node_rx_LIV++;
			//card->wandev.stats.rx_crc_errors++;
			fr_prot->link_stats.node_rx_FSE++;
			//card->wandev.stats.rx_frame_errors++;
			       card->devname, reptype);
			fr_prot->link_stats.rx_bad_format++;
			fr_prot->link_stats.cpe_rx_LIV++;
			fr_prot->link_stats.cpe_rx_FSR++;
	if (!(fr_prot->state & LINK_STATE_RELIABLE)){
		fr_prot->n391cnt = 0; /* Ask for full report next time */
	if (fr_prot->station == WANOPT_NODE) {
		if ((fr_prot->state & LINK_STATE_FULLREP_SENT) && !error) {
			/* Stop sending full report - the last one has been confirmed by DTE */
			fr_prot->state &= ~LINK_STATE_FULLREP_SENT;
			WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
				if (chan->dlci_state & PVC_STATE_NEW) {
					chan->dlci_state &= ~PVC_STATE_NEW;
					chan->dlci_state |= PVC_STATE_ACTIVE;
					if (card->fe.fe_status == FE_CONNECTED){
					fr_prot->state |= LINK_STATE_CHANGED;
		if (fr_prot->state & LINK_STATE_CHANGED) {
			fr_prot->state |= LINK_STATE_FULLREP_SENT;
			fr_prot->state &= ~LINK_STATE_CHANGED;
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		chan->newstate=0;
	while (skb->len >= (i + 2 + stat_len)) {
		if (skb->data[i] != ((MODE_FR_CCITT) ? LMI_CCITT_PVCSTAT : LMI_PVCSTAT)) {
			       card->devname, skb->data[i]);
			fr_prot->link_stats.rx_bad_format++;
		if (skb->data[i] != stat_len) {
			       card->devname, skb->data[i]);
			fr_prot->link_stats.rx_bad_format++;
		dlci = status_to_dlci((skb->data+i), &state);
			chan=dev->priv;
				fr_prot->link_stats.rx_dropped++;
			chan->newstate = state;
			       card->devname, dlci);
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (chan->newstate == PVC_STATE_NEW)
			chan->newstate = PVC_STATE_ACTIVE;
		chan->newstate |= (chan->dlci_state & ~(PVC_STATE_NEW|PVC_STATE_ACTIVE));
		if (chan->dlci_state != chan->newstate) {
			chan->dlci_state = chan->newstate;
			if ((chan->dlci_state & PVC_STATE_ACTIVE) &&
			    card->fe.fe_status == FE_CONNECTED){
			if (!(chan->dlci_state & PVC_STATE_ACTIVE)){
			if (!(chan->dlci_state & PVC_STATE_ACTIVE) && 
			      chan->common.state != WAN_DISCONNECTED){
	fr_prot->n391cnt = fr_prot->cfg.n391;
	fr_hdr *fh = (fr_hdr*)skb->data;
	u8 *data = skb->data;
	if (skb->len<4 || fh->ea1){ 
		fr_prot->link_stats.rx_bad_format++;
	dlci = q922_to_dlci(skb->data);
				fr_prot->state &= ~LINK_STATE_REQUEST;
				fr_prot->last_rx_poll = jiffies;
		printk(KERN_INFO "%s: Received non-LMI frame with LMI DLCI\n",card->devname);
		fr_prot->link_stats.rx_bad_format++;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));	
		printk(KERN_INFO "%s: FR Protocol no dev!\n",card->devname);
		fr_prot->link_stats.rx_bad_dlci++;
	if ((dev->flags & IFF_UP) == 0) {
		       card->devname, dlci);
		fr_prot->link_stats.rx_bad_dlci++;
	chan=(fr_private_area_t*)dev->priv;
		       card->devname, dlci);
		fr_prot->link_stats.rx_bad_dlci++;
	if ((chan->dlci_state & PVC_STATE_FECN) != (fh->fecn ? PVC_STATE_FECN : 0)) {
		chan->rx_FECN++;
		printk(KERN_INFO "%s: FECN O%s\n", dev->name,
		       fh->fecn ? "N" : "FF");
		chan->dlci_state ^= PVC_STATE_FECN;
	if ((chan->dlci_state & PVC_STATE_BECN) != (fh->becn ? PVC_STATE_BECN : 0)) {
		chan->rx_BECN++;
		printk(KERN_INFO "%s: BECN O%s\n", dev->name,
		       fh->becn ? "N" : "FF");
		chan->dlci_state ^= PVC_STATE_BECN;
	if (chan->dlci_state & PVC_STATE_BECN){
		chan->stats.rx_compressed++;
		chan->stats.rx_fifo_errors++;
	if (chan->common.usedby == ANNEXG){
		if (chan->annexg_dev){
				new_skb=dev_alloc_skb(skb->len);
					chan->stats.rx_errors++;
					card->wandev.stats.rx_dropped++;
					fr_prot->link_stats.rx_dropped++;
							card->devname);
				new_skb->protocol = htons(ETH_P_X25);
				new_skb->dev = chan->annexg_dev;
				memcpy(skb_put(new_skb,skb->len),skb->data,skb->len);
				if (new_skb->len <= 5 && !(new_skb->data[1]&0x01)){
					if (new_skb->len == 5 && (new_skb->data[4]&0x01))
							card->devname, new_skb->len);
					for (x=0;x<new_skb->len;x++){
						printk("%X ",new_skb->data[x]);
					chan->stats.rx_dropped++;
					card->wandev.stats.rx_dropped++;
				chan->stats.rx_packets++; 
				chan->stats.rx_bytes += new_skb->len;
				card->wandev.stats.rx_packets++;
       				card->wandev.stats.rx_bytes += new_skb->len;
				lapb_protocol.lapb_rx(chan->annexg_dev,new_skb);
				chan->stats.rx_errors++;
				card->wandev.stats.rx_dropped++;
				fr_prot->link_stats.rx_dropped++;
			chan->stats.rx_errors++;
			fr_prot->link_stats.rx_dropped++;
			card->wandev.stats.rx_dropped++;
		fr_prot->link_stats.rx_bad_format++;
		chan->stats.rx_errors++;
		skb_pull(skb, 4); /* Remove 4-byte header (hdr, UI, NLPID) */
		skb->protocol = htons(ETH_P_IP);
		skb->dev = dev;
			chan->stats.rx_errors++;
			fr_prot->link_stats.rx_dropped++;
		++card->wandev.stats.rx_packets;
       		card->wandev.stats.rx_bytes += skb->len;
		chan->stats.rx_packets++; /* PVC traffic */
		chan->stats.rx_bytes += skb->len;
		skb_pull(skb, 4); /* Remove 4-byte header (hdr, UI, NLPID) */
		skb->protocol = htons(ETH_P_IPV6);
		skb->dev = dev;
			chan->stats.rx_errors++;
			fr_prot->link_stats.rx_dropped++;
		++card->wandev.stats.rx_packets;
       		card->wandev.stats.rx_bytes += skb->len;
		chan->stats.rx_packets++; /* PVC traffic */
		chan->stats.rx_bytes += skb->len;
		skb->protocol = htons(ETH_P_ARP);
		skb->dev = dev;
			chan->stats.rx_errors++;
			fr_prot->link_stats.rx_dropped++;
		++card->wandev.stats.rx_packets;
       		card->wandev.stats.rx_bytes += skb->len;
		chan->stats.rx_packets++; /* PVC traffic */
		chan->stats.rx_bytes += skb->len;
	       card->devname, data[3]);
	fr_prot->link_stats.rx_bad_format++;
	card->wandev.stats.rx_dropped++;
	chan->stats.rx_dropped++;
	card->wandev.stats.rx_dropped++;
	return(fr_prot->dlci_to_dev_map[dlci]);
	if (!skb_queue_len(&fr_prot->rx_used)){
		clear_bit(0, &fr_prot->tq_working);
	while ((skb=skb_dequeue(&fr_prot->rx_used)) != NULL){
		skb->data = skb->head+16;
		skb_queue_tail(&fr_prot->rx_free,skb);
		if ((jiffies-timeout) >= 4){
					card->devname);
	clear_bit(0, &fr_prot->tq_working);
	if (test_bit(0,&chan->tracing_enabled)){
		if ((jiffies-chan->trace_timeout) > MAX_TRACE_TIMEOUT){
					card->devname,chan->if_name,chan->dlci);
			clear_bit(0,&chan->tracing_enabled);
		if (skb_queue_len(&chan->trace_queue) < chan->max_trace_queue){		
			new_skb=dev_alloc_skb(skb->len+sizeof(fr_trc_el_t)+chan->hdr_len);
				trc_el->attr = direction;
				trc_el->tmstamp = (unsigned short)(jiffies%0xFFFF);
				trc_el->length = skb->len;
					trc_el->length += chan->hdr_len;
					memcpy(skb_put(new_skb,chan->hdr_len),chan->header,chan->hdr_len);
				memcpy(skb_put(new_skb,skb->len),skb->data,skb->len);
				skb_queue_tail(&chan->trace_queue,new_skb);
				//		card->devname, chan->if_name, chan->dlci);
				return -ENOMEM;
			//		card->devname, chan->if_name, chan->dlci, 
			//		skb_queue_len(&chan->trace_queue));
			return -ENOBUFS;
	if (test_bit(0,&fr_prot->tracing_enabled)){
		if ((jiffies-fr_prot->trace_timeout) > MAX_TRACE_TIMEOUT){
					card->devname);
			clear_bit(0,&fr_prot->tracing_enabled);
		if (skb_queue_len(&fr_prot->trace_queue) < fr_prot->max_trace_queue){		
			new_skb=dev_alloc_skb(skb->len+sizeof(fr_trc_el_t));
				trc_el->attr = direction;
				trc_el->tmstamp = (unsigned short)(jiffies%0xFFFF);
				trc_el->length = skb->len;
				memcpy(skb_put(new_skb,skb->len),skb->data,skb->len);
				skb_queue_tail(&fr_prot->trace_queue,new_skb);
						card->devname);
				return -ENOMEM;
					card->devname, skb_queue_len(&fr_prot->trace_queue));
			return -ENOBUFS;
	if (dev == NULL || dev->priv == NULL)
		return -EFAULT;
	chan = (fr_channel_t*)dev->priv;
	if (card->wandev.update) {
		fr_prot->update_dlci = chan;
		rslt = card->wandev.update(&card->wandev);
			return (rslt) ? (-EBUSY) : (-EINVAL);
	switch(snmp->snmp_magic){
		 snmp->snmp_val = 
		 (card->wandev.signalling == WANOPT_FR_ANSI) ? SNMP_FR_ANSIT1617D :
		 (card->wandev.signalling == WANOPT_FR_Q933) ? SNMP_FR_ITUT933A :
		 (card->wandev.signalling == WANOPT_FR_LMI) ? SNMP_FR_LMIREV:
		snmp->snmp_val = SNMP_FR_Q922;
		snmp->snmp_val = SNMP_FR_4BYTE_ADDR;
		snmp->snmp_val = fr_prot->cfg.t391;
		snmp->snmp_val = fr_prot->cfg.n391;
		snmp->snmp_val = fr_prot->cfg.n392;
		snmp->snmp_val = fr_prot->cfg.n393;
		snmp->snmp_val = HIGHEST_VALID_DLCI;
		snmp->snmp_val = SNMP_FR_NONBROADCAST;
		snmp->snmp_val = SNMP_FR_RUNNING;
		snmp->snmp_val = 0;
		snmp->snmp_val = chan->dlci;
		snmp->snmp_val = (chan->common.state == WAN_CONNECTED) ? SNMP_FR_ACTIVE : SNMP_FR_INACTIVE;
		snmp->snmp_val = chan->rx_FECN;
		snmp->snmp_val = chan->rx_BECN;
		snmp->snmp_val = chan->stats.tx_packets;
		snmp->snmp_val = chan->stats.tx_bytes;
		snmp->snmp_val = chan->stats.rx_packets;
		snmp->snmp_val = chan->stats.rx_bytes;
		snmp->snmp_val = tv.tv_sec - card->u.c.router_start_time;
		snmp->snmp_val = tv.tv_sec - chan->router_last_change;
		snmp->snmp_val = (unsigned long)chan->bc;
		snmp->snmp_val = (unsigned long)chan->be;
		snmp->snmp_val = (unsigned long)0;
		snmp->snmp_val = (chan->mc) ? SNMP_FR_ONEWAY : SNMP_FR_UNICAST;
		snmp->snmp_val = chan->dlci_type;
		snmp->snmp_val = chan->stats.rx_errors;
		snmp->snmp_val = chan->rx_DE_set;
		snmp->snmp_val = chan->tx_DE_set;
		snmp->snmp_val = 0;
		snmp->snmp_val = 0;
		snmp->snmp_val = chan->err_type;
		strcpy((void*)snmp->snmp_data, chan->err_data);
		snmp->snmp_val = chan->err_time;
		snmp->snmp_val = chan->err_faults;
		snmp->snmp_val = (unsigned long)0;
		snmp->snmp_val = chan->trap_state;
		snmp->snmp_val = chan->trap_max_rate;
            	return -EAFNOSUPPORT;
	fr_channel_t* chan = dev->priv;
	sdla_t *card = chan->card;
		return -EINVAL;
	if (chan->common.usedby != ANNEXG)
		return -EPROTONOSUPPORT;
	if (chan->annexg_dev)
		return -EBUSY;
	spin_lock_irqsave(&card->wandev.lock,smp_flags);
	chan->annexg_dev = annexg_dev;
	spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
	sdla_t			*card = wandev->priv;
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (!chan->annexg_dev || chan->common.usedby != ANNEXG)
		if (chan->annexg_dev == annexg_dev){
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			chan->annexg_dev = NULL;
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
	fr_channel_t* 	chan = dev->priv;
	if (chan->common.usedby == ANNEXG && chan->annexg_dev){
			lapb_protocol.lapb_get_active_inactive(chan->annexg_dev,wp_stats);
	if (chan->common.state == WAN_CONNECTED){
		wp_stats->fr_active++;
		wp_stats->fr_inactive++;
	fr_channel_t* 	chan = dev->priv;
	if (!(dev->flags&IFF_UP)){
		return m->count;
	if (chan->common.usedby == ANNEXG && chan->annexg_dev){
			return lapb_protocol.lapb_get_map(chan->annexg_dev,
		chan->label, 
		wandev->name,(wandev->state == WAN_CONNECTED) ? '*' : ' ',
		dev->name,(chan->common.state == WAN_CONNECTED) ? '*' : ' ');
	return m->count;
	if (skb->len >= 2 && !test_bit(0,&skb->data[1])){
		ps_cnt = (skb->data[1]&0x0F)>>1;
				card->devname,skb->len,ps_cnt,g_ps_cnt,
	if (skb->len >= 5 && !test_bit(0,&skb->data[1])){
		if (!test_bit(0,&skb->data[4])){
			lcn=((skb->data[2]&0x0F)<<8) | skb->data[3];
			ps_cnt = (skb->data[4]&0x0F)>>1;
				card->devname,lcn,skb->len,ps_cnt,g_ps_cnt,
./sdla_mp_fr.c
* Copyright:	(c) 2003-2008 Sangoma Technologies Inc.
	conf->config_id			= WANCONFIG_AFT_TE1;
	conf->u.aft.dma_per_ch	= MAX_RX_BUF;
	conf->u.aft.mru	= 1500;
	conf->protocol = WANCONFIG_HDLC;
	memcpy(conf->usedby, "WANPIPE", 7);
	conf->if_down = 0;
	conf->ignore_dcd = WANOPT_NO;
	conf->ignore_cts = WANOPT_NO;
	conf->hdlc_streaming = WANOPT_NO;
	conf->mc = 0;
	conf->gateway = 0;
	conf->active_ch = ENABLE_ALL_CHANNELS;
        while ((SYSTEM_TICKS-timeout)<(sec*HZ)){
 * wp_aft_te1_init - Cisco HDLC protocol initialization routine.
 *  o initialize protocol-specific fields of the adapter data space.
	if (card->wandev.config_id != WANCONFIG_AFT_ANALOG) {
				  card->devname, card->wandev.config_id);
		return -EINVAL;
	ASSERT_AFT_HWDEV(card->wandev.card_type);
	card->hw_iface.getcfg(card->hw, SDLA_COREREV, &card->u.aft.firm_ver);
	card->hw_iface.getcfg(card->hw, SDLA_COREID, &card->u.aft.firm_id);
	if (card->u.aft.firm_ver < AFT_MIN_ANALOG_FRMW_VER){
				  card->devname, card->u.aft.firm_ver,AFT_MIN_ANALOG_FRMW_VER);
				  card->devname);
				  card->devname);
		return -EINVAL;
				card->devname);
		return -EINVAL;
	memset(&card->fe, 0, sizeof(sdla_fe_t));
	memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &adptr_type);
	wp_remora_iface_init(&card->fe, &card->wandev.fe_iface);
	card->fe.name		= card->devname;
	card->fe.card		= card;
	card->fe.write_fe_reg	= card->hw_iface.fe_write;	/* aft_analog_write_fe;  */
	card->fe.read_fe_reg	= card->hw_iface.fe_read;	/* aft_analog_read_fe;   */
	card->fe.__read_fe_reg	= card->hw_iface.__fe_read;	/* __aft_analog_read_fe; */
	card->fe.reset_fe	= card->hw_iface.reset_fe;
	card->wandev.fe_enable_timer = enable_timer;
	card->wandev.ec_enable_timer = enable_ec_timer;
	card->wandev.te_link_state = callback_front_end_state;
	if (card->wandev.comm_port == WANOPT_PRI){
		conf->clocking = WANOPT_EXTERNAL;
		card->wandev.comm_port=conf->comm_port;
		card->wandev.comm_port=card->fe.fe_cfg.line_no;
		if (card->wandev.comm_port != 0){
					card->devname,card->wandev.comm_port);
			return -EINVAL;
	card->u.aft.num_of_time_slots=MAX_REMORA_MODULES;
	if (card->wandev.config_id != WANCONFIG_AFT_ANALOG) {
			     card->devname, card->wandev.config_id);
		return -EINVAL;
	ASSERT_AFT_HWDEV(card->wandev.card_type);
	card->hw_iface.getcfg(card->hw, SDLA_COREREV, &card->u.aft.firm_ver);
	card->hw_iface.getcfg(card->hw, SDLA_COREID, &card->u.aft.firm_id);
	if (card->u.aft.firm_ver < AFT_MIN_A600_FRMW_VER){
			     card->devname, card->u.aft.firm_ver,AFT_MIN_A600_FRMW_VER);
			     card->devname);
			     card->devname);
		return -EINVAL;
			    card->devname);
		return -EINVAL;
	memset(&card->fe, 0, sizeof(sdla_fe_t));
	memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
	wp_remora_iface_init(&card->fe, &card->wandev.fe_iface);
	card->fe.name		= card->devname;
	card->fe.card		= card;
	card->fe.write_fe_reg	= card->hw_iface.fe_write;	/* aft_a600_write_fe;  */
	card->fe.read_fe_reg	= card->hw_iface.fe_read;	/* aft_a600_read_fe;   */
	card->fe.__read_fe_reg	= card->hw_iface.__fe_read;	/* __aft_a600_read_fe; */
	card->fe.reset_fe	= card->hw_iface.reset_fe;
	card->wandev.fe_enable_timer = enable_timer;
	card->wandev.ec_enable_timer = enable_ec_timer;
	card->wandev.te_link_state = callback_front_end_state;
	card->wandev.comm_port=card->fe.fe_cfg.line_no;
	if (card->wandev.comm_port == 0){
		card->u.aft.num_of_time_slots = NUM_A600_ANALOG_PORTS;
	} else if (card->wandev.comm_port == 1){
		DEBUG_A600("Configuring A600 daughter card - Not implemented yet\n");
			    card->devname,card->wandev.comm_port);	
	if (card->wandev.config_id != WANCONFIG_AFT_ISDN_BRI) {
				  card->devname, card->wandev.config_id);
		return -EINVAL;
	ASSERT_AFT_HWDEV(card->wandev.card_type);
	card->hw_iface.getcfg(card->hw, SDLA_COREREV, &card->u.aft.firm_ver);
	card->hw_iface.getcfg(card->hw, SDLA_COREID, &card->u.aft.firm_id);
	card->u.aft.firm_id = AFT_DS_FE_CORE_ID;
				card->devname);
		return -EINVAL;
	memset(&card->fe, 0, sizeof(sdla_fe_t));
	memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
	wp_bri_iface_init(&card->wandev.fe_iface);
	card->fe.name		= card->devname;
	card->fe.card		= card;
	card->fe.write_fe_reg	= aft_bri_write_fe;
	card->fe.read_fe_reg	= aft_bri_read_fe;
	card->fe.__read_fe_reg	= __aft_bri_read_fe;
	card->wandev.fe_enable_timer = enable_timer;
	card->wandev.ec_enable_timer = enable_ec_timer;
	card->wandev.te_link_state = callback_front_end_state;
	if (card->wandev.comm_port == WANOPT_PRI){
		conf->clocking = WANOPT_EXTERNAL;
	card->wandev.comm_port=0;
	if (card->fe.fe_cfg.line_no >= MAX_BRI_MODULES) {
		card->wandev.comm_port=1;
	card->wandev.comm_port=card->fe.fe_cfg.line_no;
			card->devname, card->wandev.comm_port, card->fe.fe_cfg.line_no);
	/* Set 'num_of_time_slots' to 31. This is needed for the d-chan,
	card->u.aft.num_of_time_slots = MAX_TIMESLOTS;
	if (card->wandev.config_id != WANCONFIG_AFT_SERIAL) {
				  card->devname, card->wandev.config_id);
		return -EINVAL;
	ASSERT_AFT_HWDEV(card->wandev.card_type);
	card->hw_iface.getcfg(card->hw, SDLA_COREREV, &card->u.aft.firm_ver);
	card->hw_iface.getcfg(card->hw, SDLA_COREID, &card->u.aft.firm_id);
	if (card->u.aft.firm_ver < AFT_SERIAL_MIN_FRMW_VER){
				  card->devname, card->u.aft.firm_ver,AFT_SERIAL_MIN_FRMW_VER);
				  card->devname);
				  card->devname);
		return -EINVAL;
				card->devname);
		return -EINVAL;
	memset(&card->fe, 0, sizeof(sdla_fe_t));
	memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
	FE_MEDIA(&(card->fe.fe_cfg)) = WAN_MEDIA_SERIAL;
	wp_serial_iface_init(&card->wandev.fe_iface);
	card->fe.name		= card->devname;
	card->fe.card		= card;
	card->fe.write_fe_reg	= card->hw_iface.fe_write;	/*aft_serial_write_fe;*/
	card->fe.read_fe_reg	= card->hw_iface.fe_read;	/*aft_serial_read_fe;*/
	card->fe.__read_fe_reg	= card->hw_iface.__fe_read;	/*__aft_serial_read_fe;*/
	card->wandev.fe_enable_timer = enable_timer;
	card->wandev.ec_enable_timer = enable_ec_timer;
	card->wandev.te_link_state = callback_front_end_state;
	card->wandev.comm_port=card->fe.fe_cfg.line_no;
			card->devname, card->wandev.comm_port, card->fe.fe_cfg.line_no,
			card->u.aft.firm_ver,card->u.aft.firm_id);
	card->u.aft.num_of_time_slots = 1;
	wan_set_bit(CARD_DOWN,&card->wandev.critical);
	if (card->wandev.config_id != WANCONFIG_AFT_TE1) {
				  card->devname, card->wandev.config_id);
		return -EINVAL;
	card->hw_iface.getcfg(card->hw, SDLA_COREREV, &card->u.aft.firm_ver);
	card->hw_iface.getcfg(card->hw, SDLA_COREID, &card->u.aft.firm_id);
	if (card->u.aft.firm_ver < AFT_MIN_FRMW_VER){
				  card->devname, card->u.aft.firm_ver,AFT_MIN_FRMW_VER);
				  card->devname);
				  card->devname);
		return -EINVAL;
	ASSERT_AFT_HWDEV(card->wandev.card_type);
				card->devname);
		return -EINVAL;
	memset(&card->fe, 0, sizeof(sdla_fe_t));
	memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
	if (IS_TE1_MEDIA(&conf->fe_cfg)){
		if (conf->fe_cfg.cfg.te_cfg.active_ch == 0){
			conf->fe_cfg.cfg.te_cfg.active_ch = -1;
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		if (card->u.aft.firm_id == AFT_DS_FE_CORE_ID) {
			sdla_ds_te1_iface_init(&card->fe, &card->wandev.fe_iface);
			sdla_te_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg	= card->hw_iface.fe_write;	/*a104_write_fe;*/
		card->fe.read_fe_reg	= card->hw_iface.fe_read;	/*a104_read_fe;*/
		card->fe.__read_fe_reg	= card->hw_iface.__fe_read;	/*__a104_read_fe;*/
		card->wandev.fe_enable_timer = enable_timer;
		card->wandev.ec_enable_timer = enable_ec_timer;
		card->wandev.te_link_state = callback_front_end_state;
		conf->electrical_interface =
		if (card->wandev.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
		card->wandev.comm_port=card->fe.fe_cfg.line_no;
			card->u.aft.num_of_time_slots=NUM_OF_T1_CHANNELS;
			card->u.aft.num_of_time_slots=NUM_OF_E1_CHANNELS;
		DEBUG_EVENT("%s: Invalid Front-End media type!!\n",
				card->devname);
		return -EINVAL;
	wan_set_bit(CARD_DOWN,&card->wandev.critical);
	if (card->wandev.config_id != WANCONFIG_AFT_56K) {
				  card->devname, card->wandev.config_id);
		return -EINVAL;
	card->hw_iface.getcfg(card->hw, SDLA_COREREV, &card->u.aft.firm_ver);
	card->hw_iface.getcfg(card->hw, SDLA_COREID, &card->u.aft.firm_id);
	if (card->u.aft.firm_ver < AFT_56K_MIN_FRMW_VER){
				  card->devname, card->u.aft.firm_ver,AFT_56K_MIN_FRMW_VER);
				  card->devname);
				  card->devname);
		return -EINVAL;
	ASSERT_AFT_HWDEV(card->wandev.card_type);
				card->devname);
		return -EINVAL;
	memset(&card->fe, 0, sizeof(sdla_fe_t));
	memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
	if (IS_56K_MEDIA(&conf->fe_cfg)){
		conf->fe_cfg.cfg.te_cfg.active_ch = 1;
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		DEBUG_56K("card->u.aft.firm_id: 0x%X\n", card->u.aft.firm_id);
		if(card->u.aft.firm_id != AFT_56K_FE_CORE_ID){
				card->devname, card->u.aft.firm_id);
			return -EINVAL;
		sdla_56k_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg	= card->hw_iface.fe_write;	/* a56k_write_fe;*/
		card->fe.read_fe_reg	= card->hw_iface.fe_read;	/* a56k_read_fe; */
		card->fe.__read_fe_reg	= card->hw_iface.__fe_read;	/* __a56k_read_fe; */
		card->wandev.fe_enable_timer = enable_timer;
		card->wandev.ec_enable_timer = enable_ec_timer;
		card->wandev.te_link_state = callback_front_end_state;
		card->wandev.comm_port=0;
		card->u.aft.num_of_time_slots=1;
		DEBUG_EVENT("%s: Invalid Front-End media type!!\n",
				card->devname);
		return -EINVAL;
	card->wandev.clocking 			= conf->clocking;
	card->wandev.ignore_front_end_status 	= conf->ignore_front_end_status;
	card->wandev.ttl 			= conf->ttl;
	card->wandev.electrical_interface 	= conf->electrical_interface;
	card->wandev.udp_port   		= conf->udp_port;
	card->wandev.new_if_cnt 		= 0;
	wan_atomic_set(&card->wandev.if_cnt,0);
	card->u.aft.chip_security_cnt=0;
	memcpy(&card->u.aft.cfg,&conf->u.aft,sizeof(wan_xilinx_conf_t));
	memcpy(&card->rtp_conf,&conf->rtp_conf,sizeof(conf->rtp_conf));
	memset(card->u.aft.dev_to_ch_map,0,sizeof(card->u.aft.dev_to_ch_map));
	memcpy(&card->tdmv_conf,&conf->tdmv_conf,sizeof(wan_tdmv_conf_t));
	memcpy(&card->hwec_conf,&conf->hwec_conf,sizeof(wan_hwec_conf_t));
	card->u.aft.cfg.dma_per_ch = MAX_RX_BUF;
	card->u.aft.tdmv_api_rx = NULL;
	card->u.aft.tdmv_api_tx = NULL;
	card->u.aft.tdmv_dchan=0;
	wan_skb_queue_init(&card->u.aft.tdmv_api_tx_list);
	wan_skb_queue_init(&card->u.aft.rtp_tap_list);
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
	card->wandev.update             = &update;
	card->wandev.new_if             = &new_if;
	card->wandev.del_if             = &del_if;
	card->disable_comm              = NULL;
	card->wandev.bind_annexg	= &bind_annexg;
	card->wandev.un_bind_annexg	= &un_bind_annexg;
	card->wandev.get_map		= &get_map;
	card->wandev.get_active_inactive= &get_active_inactive;
	card->wandev.get_config_info 	= &get_config_info;
	card->wandev.get_status_info 	= &get_status_info;
	card->wandev.get_dev_config_info= &get_dev_config_info;
	card->wandev.get_if_info     	= &get_if_info;
	card->wandev.set_dev_config    	= &set_dev_config;
	card->wandev.set_if_info     	= &set_if_info;
	card->wandev.get_info 		= &wan_aft_get_info;
	if(card->wandev.clocking) {
		card->wandev.bps = conf->bps;
        	card->wandev.bps = 0;
        card->wandev.mtu = conf->mtu;
	card->wan_tdmv.sc = NULL;
	card->wandev.mtu=conf->mtu;
	if (card->wandev.mtu > MAX_WP_PRI_MTU ||
	    card->wandev.mtu < MIN_WP_PRI_MTU){
				card->devname,card->wandev.mtu,
		return -EINVAL;
	if (!card->u.aft.cfg.mru){
		card->u.aft.cfg.mru = card->wandev.mtu;
	if (card->u.aft.cfg.mru > MAX_WP_PRI_MTU ||
	    card->u.aft.cfg.mru < MIN_WP_PRI_MTU){
				card->devname,card->u.aft.cfg.mru,
		return -EINVAL;
	card->hw_iface.getcfg(card->hw, SDLA_BASEADDR, &card->u.aft.bar);
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &card->u.aft.bar_virt);
	WAN_TASKQ_INIT((&card->u.aft.port_task),0,aft_port_task,card);
	card->u.aft.chip_cfg_status=0;
	card->hw_iface.getcfg(card->hw, SDLA_HWCPU_USEDCNT, &used_cnt);
	wan_clear_bit(CARD_DOWN,&card->wandev.critical);
	__sdla_push_ptr_isr_array(card->hw,card,WAN_FE_LINENO(&card->fe));
        card->isr = &wp_aft_global_isr;
	card->hw_iface.getcfg(card->hw, SDLA_HWTYPE_USEDCNT, &used_type_cnt);
				card->devname,used_cnt, used_type_cnt);
			wan_set_bit(CARD_DOWN,&card->wandev.critical);
			wan_set_bit(CARD_DOWN,&card->wandev.critical);
				card->devname,used_cnt, used_type_cnt);
	card->wandev.ec_intmask=SYSTEM_TICKS;
		wan_set_bit(CARD_DOWN,&card->wandev.critical);
	wan_set_bit(AFT_CHIP_CONFIGURED,&card->u.aft.chip_cfg_status);
	if (wan_test_bit(AFT_FRONT_END_UP,&card->u.aft.chip_cfg_status)){
				card->devname);
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		wan_clear_bit(AFT_FRONT_END_UP,&card->u.aft.chip_cfg_status);
			card->devname,card->devname,card->u.aft.firm_ver);
			card->devname,
			card->wandev.mtu);
			card->devname,
			card->u.aft.cfg.mru);
			card->devname,
			card->u.aft.cfg.data_mux_map);
			card->devname,
			card->u.aft.cfg.rx_crc_bytes);
	wan_clear_bit(AFT_TDM_GLOBAL_ISR,&card->u.aft.chip_cfg_status);
	wan_clear_bit(AFT_TDM_RING_BUF,&card->u.aft.chip_cfg_status);
	if (card->u.aft.firm_id == AFT_DS_FE_CORE_ID) {
		if ((card->adptr_type == A108_ADPTR_8TE1 &&
		     card->u.aft.firm_ver >= 0x27) ||
	            (card->adptr_type == A104_ADPTR_4TE1 &&
		     card->u.aft.firm_ver >= 0x26) ||
		    (card->adptr_type == A101_ADPTR_2TE1 &&
		     card->u.aft.firm_ver >= 0x26) ||
		    (card->adptr_type == A101_ADPTR_1TE1 &&
		     card->u.aft.firm_ver >= 0x26)) {
	    	     	wan_set_bit(AFT_TDM_GLOBAL_ISR,&card->u.aft.chip_cfg_status);
               		wan_set_bit(AFT_TDM_RING_BUF,&card->u.aft.chip_cfg_status);
            	if ((card->adptr_type == A104_ADPTR_4TE1 &&
		     card->adptr_subtype == AFT_SUBTYPE_SHARK  &&
	     	     card->u.aft.firm_ver >= 0x23)) {
                        wan_set_bit(AFT_TDM_GLOBAL_ISR,&card->u.aft.chip_cfg_status);
               		wan_set_bit(AFT_TDM_RING_BUF,&card->u.aft.chip_cfg_status);
		wan_set_bit(AFT_TDM_GLOBAL_ISR,&card->u.aft.chip_cfg_status);
		wan_set_bit(AFT_TDM_RING_BUF,&card->u.aft.chip_cfg_status);
	} else if (card->wandev.config_id == WANCONFIG_AFT_ANALOG) {
		wan_set_bit(AFT_TDM_SW_RING_BUF,&card->u.aft.chip_cfg_status);
			card->devname,
			wan_test_bit(AFT_TDM_GLOBAL_ISR,&card->u.aft.chip_cfg_status) ?
			card->devname,
			wan_test_bit(AFT_TDM_RING_BUF,&card->u.aft.chip_cfg_status) ?
	if (card->wandev.ec_dev){
		card->u.aft.tdmv_hw_dtmf = conf->tdmv_conf.hw_dtmf;
		card->u.aft.tdmv_hw_dtmf = WANOPT_NO;
			card->devname,
			(card->u.aft.tdmv_hw_dtmf == WANOPT_YES) ?
		wan_set_bit(CARD_DOWN,&card->wandev.critical);
	card->disable_comm = &disable_comm;
			card->devname,
	card->wandev.read_ec = aft_read_ec;
	card->wandev.write_ec = aft_write_ec;
 * update - Update wanpipe device status & statistics
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	if(wan_test_bit(PERI_CRIT, (void*)&card->wandev.critical))
                return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
		return -ENODEV;
       	if(card->update_comms_stats){
		return -EAGAIN;
			chan->if_name,
			chan->dma_chain_status,
			chan->tx_chain_indx,
			chan->tx_pending_chain_indx,
			chan->rx_chain_indx,
			chan->rx_pending_chain_indx);
	chan->first_time_slot=-1;
	chan->last_time_slot=-1;
	chan->logic_ch_num=-1;
	chan->single_dma_chain=1;
	chan->max_tx_bufs=MAX_AFT_DMA_CHAINS;
	chan->single_dma_chain=0;
	chan->max_tx_bufs=MAX_TX_BUF;
	chan->tslot_sync=0;
	strncpy(chan->if_name, wan_netif_name(dev), WAN_IFNAME_SZ);
	chan->card = card;
	chan->common.card = card;
	WAN_IFQ_INIT(&chan->wp_tx_pending_list,0);
	WAN_IFQ_INIT(&chan->wp_tx_complete_list,0);
	WAN_IFQ_INIT(&chan->wp_tx_hdlc_rpt_list,0);
	WAN_IFQ_INIT(&chan->wp_rx_free_list,0);
	WAN_IFQ_INIT(&chan->wp_rx_complete_list,0);
	WAN_IFQ_INIT(&chan->wp_rx_stack_complete_list, 0);
	WAN_IFQ_INIT(&chan->wp_rx_bri_dchan_complete_list, 0);
	wan_trace_info_init(&chan->trace_info,MAX_TRACE_QUEUE);
	WAN_TASKLET_INIT((&chan->common.bh_task),0,wp_bh,chan);
	chan->common.dev = dev;
	chan->tracing_enabled = 0;
	chan->xmtp2_api_index = -1;
	if (chan->common.usedby == API && chan->cfg.ss7_enable){
					card->devname,
					chan->cfg.ss7_mode?"4096":"128");
					card->devname,
					chan->cfg.ss7_lssu_size);
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),&lcfg_reg);
		if (chan->cfg.ss7_mode){
			aft_lcfg_ss7_mode4096_cfg(&lcfg_reg,chan->cfg.ss7_lssu_size);
			aft_lcfg_ss7_mode128_cfg(&lcfg_reg,chan->cfg.ss7_lssu_size);
		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),
		card->u.aft.lcfg_reg=lcfg_reg;
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		aft_hwdev[card->wandev.card_type].aft_fifo_adjust(card,AFT_TDMV_FIFO_LEVEL);
		chan->single_dma_chain=1;
		 chan->cfg.ss7_enable = 0;
		if (chan->common.usedby == XMTP2_API) {
			chan->xmtp2_api_index = xmtp2km_register(chan, chan->if_name, wp_xmtp2_callback);
			if (chan->xmtp2_api_index < 0) {
				chan->xmtp2_api_index = -1;
				return -EINVAL;
		if (chan->common.usedby == XMTP2_API && chan->xmtp2_api_index >= 0 ) {
			xmtp2km_unregister(chan->xmtp2_api_index);
			chan->xmtp2_api_index = -1;
	if (chan->mtu&0x03){
				card->devname,chan->if_name);
		return -EINVAL;
	chan->max_idle_size=chan->mtu;
	if (chan->tslot_sync && chan->mtu%chan->num_of_time_slots){
				card->devname,chan->if_name);
				card->devname,chan->if_name,
				chan->mtu,chan->num_of_time_slots);
		return -EINVAL;
	if (conf->protocol != WANCONFIG_LIP_ATM &&
	    conf->protocol != WANCONFIG_LIP_KATM &&
	    chan->mru%chan->num_of_time_slots){
				card->devname,chan->if_name);
				card->devname,chan->if_name,
				chan->mru,chan->num_of_time_slots);
		return -EINVAL;
		card->devname,chan->if_name,
		chan->idle_flag,chan->max_idle_size);
        if(conf->u.aft.idle_flag){
                chan->idle_flag=conf->u.aft.idle_flag;
                DEBUG_EVENT("%s:    Idle flag     :0x%02x\n", card->devname, chan->idle_flag);
                chan->idle_flag=0x7E;
	if (chan->tdmv_zaptel_cfg){
		chan->idle_flag = WAN_TDMV_IDLE_FLAG;
	chan->tx_idle_skb = wan_skb_alloc(chan->dma_mru);
	if (!chan->tx_idle_skb){
		return -EINVAL;
	buf = wan_skb_put(chan->tx_idle_skb,chan->dma_mru);
	if(conf->protocol != WANCONFIG_LIP_ATM &&
	   conf->protocol != WANCONFIG_LIP_KATM){
		memset(buf,chan->idle_flag,chan->dma_mru);
		chan->lip_atm = 1;
				wan_skb_len(chan->tx_idle_skb),
				chan->if_name,
				chan->cfg.data_mux )){
			wan_skb_free(chan->tx_idle_skb);
			chan->tx_idle_skb = NULL;
			return -EINVAL;
	wan_skb_init(chan->tx_idle_skb,16);
	wan_skb_trim(chan->tx_idle_skb,0);
	wan_skb_put(chan->tx_idle_skb,chan->max_idle_size);
	sdla_t* card = wandev->priv;
	int dma_per_ch=card->u.aft.cfg.dma_per_ch;
				card->devname, wan_netif_name(dev));
				card->devname, wan_netif_name(dev));
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)){
			card->devname);
		return -EINVAL;
	if (card->adptr_subtype != AFT_SUBTYPE_SHARK){
		if (card->u.aft.security_id != 0x01  &&
		    card->u.aft.security_cnt >= 2){
					card->devname);
			DEBUG_EVENT("%s: Un-Channelised AFT supports 2 HDLC ifaces!\n",
					card->devname);
			return -EINVAL;
		WAN_MEM_ASSERT(card->devname);
		return -ENOMEM;
	memcpy(&chan->cfg,&conf->u.aft,sizeof(chan->cfg));
	chan->true_if_encoding=conf->true_if_encoding;
	if (card->wandev.config_id == WANCONFIG_AFT_ANALOG) {
		chan->single_dma_chain = 1;
		conf->hdlc_streaming=0;
	if (card->wandev.config_id == WANCONFIG_AFT_ISDN_BRI) {
		chan->single_dma_chain = 1;
	chan->dchan_time_slot = dchan;
		chan->single_dma_chain = 1;
		conf->hdlc_streaming=1;
	if (chan->cfg.hdlc_repeat) {
		if (!conf->hdlc_streaming) {
				chan->if_name);
			err= -EINVAL;
		chan->single_dma_chain = 1;
		conf->hdlc_streaming=1;
	chan->channelized_cfg=channelized;
	chan->mtu = card->wandev.mtu;
	if (conf->u.aft.mtu){
		chan->mtu=conf->u.aft.mtu;
		if (chan->mtu > MAX_WP_PRI_MTU ||
	    	    chan->mtu < MIN_WP_PRI_MTU){
				card->devname,chan->if_name,chan->mtu,
			err= -EINVAL;
	chan->mru = card->u.aft.cfg.mru;
	if (conf->u.aft.mru){
		chan->mru = conf->u.aft.mru;
		if (chan->mru > MAX_WP_PRI_MTU ||
	    	    chan->mru < MIN_WP_PRI_MTU){
				card->devname,chan->if_name,chan->mru,
			err= -EINVAL;
	 *    WANPIPE 	  	= TCP/IP             -> Driver
	 *    API     	  	= Raw Socket Access  -> Driver
	 *    BRIDGE  	  	= Bridge to Ethernet -> Driver
	 *    BRIDGE_NODE 	= TCP/IP to Ethernet -> Driver
	 *    STACK	  	= LIP        -> Driver
	 *    TDM_VOICE  	= Zaptel     -> Trans Ch Driver
	 *    TDM_VOICE_DCHAN   = Zaptel     -> Hdlc Driver (PRIVATE)
	 *    TDM_VOICE_API	= Raw Socket -> Transp Ch Driver
	 *    TMD_API           = Raw Socket -> Transp Channelized API
	if(strcmp(conf->usedby, "WANPIPE") == 0) {
			wandev->name);
		chan->common.usedby = WANPIPE;
		if (conf->protocol != WANOPT_NO){
	} else if( strcmp(conf->usedby, "TDM_API") == 0) {
				card->devname,chan->if_name);
		err=-EINVAL;
	} else if( strcmp(conf->usedby, "API") == 0) {
		chan->common.usedby = API;
			wandev->name,chan->if_name, conf->usedby);
		wan_reg_api(chan, dev, card->devname);
	} else if (strcmp(conf->usedby, "TDM_SPAN_VOICE_API") == 0) {
		chan->common.usedby = API;
		chan->tdm_span_voice_api=1;
					wandev->name,chan->if_name);
			chan->common.usedby = TDM_VOICE_DCHAN;
			chan->cfg.data_mux=0;
			chan->single_dma_chain=0;
			conf->hdlc_streaming=1;
			chan->mru=chan->mtu=1500;
					wandev->name,chan->if_name, conf->usedby);
			if (chan->mtu <= 160) {
				chan->tdm_api_chunk=chan->mtu;
				chan->tdm_api_period=chan->tdm_api_chunk/8;
					if (wan_test_bit(scnt,&conf->active_ch)) {
						mtu+=chan->mtu;
				chan->mtu=mtu;
				chan->mru=mtu;
			chan->common.usedby = API;
			chan->cfg.data_mux=1;
			conf->hdlc_streaming=0;
			chan->single_dma_chain=1;
			chan->max_tx_bufs=MAX_AFT_DMA_CHAINS;
	} else if (strcmp(conf->usedby, "XMTP2_API") == 0) {
		chan->common.usedby = XMTP2_API;
		conf->hdlc_streaming=0;
		conf->mtu=80;
	}else if (strcmp(conf->usedby, "BRIDGE") == 0) {
		chan->common.usedby = BRIDGE;
				card->devname,chan->if_name);
	} else if (strcmp(conf->usedby, "BRIDGE_N") == 0) {
		chan->common.usedby = BRIDGE_NODE;
				card->devname,chan->if_name);
	} else if (strcmp(conf->usedby, "TDM_VOICE") == 0) {
		chan->common.usedby = TDM_VOICE;
		chan->tdmv_zaptel_cfg=1;
		card->u.aft.tdmv_zaptel_cfg=1;
		conf->hdlc_streaming=0;
		chan->single_dma_chain=1;
		chan->max_tx_bufs=MAX_AFT_DMA_CHAINS;
		       	chan->common.usedby = TDM_VOICE_DCHAN;
		       	conf->hdlc_streaming=1;
		       	chan->single_dma_chain=0;
		       	chan->mru=chan->mtu=1500;
					card->devname);
			err=-EINVAL;
				card->devname,chan->if_name,
				chan->common.usedby == TDM_VOICE_DCHAN?"DCHAN ":"");
				card->devname,chan->if_name);
				card->devname,chan->if_name);
		err=-EINVAL;
	} else if (strcmp(conf->usedby, "TDM_VOICE_API") == 0) {
		chan->common.usedby = TDM_VOICE_API;
		chan->cfg.data_mux=1;
		conf->hdlc_streaming=0;
		chan->single_dma_chain=1;
		chan->tdmv_zaptel_cfg=0;
		       	chan->common.usedby = TDM_VOICE_DCHAN;
		        chan->cfg.data_mux=0;
		       	chan->single_dma_chain=0;
		       	conf->hdlc_streaming=1;
		       	chan->mru=chan->mtu=1500;
			if (chan->common.usedby == TDM_VOICE_DCHAN) {
					card->devname,chan->if_name);
					card->devname,chan->if_name);
	} else	if (strcmp(conf->usedby, "ANNEXG") == 0) {
				wandev->name,chan->if_name);
			chan->common.usedby=ANNEXG;
			if (strlen(conf->label)){
				strncpy(chan->label,conf->label,WAN_IF_LABEL_SZ);
	}else if (strcmp(conf->usedby, "STACK") == 0) {
		chan->common.usedby = STACK;
				card->devname,chan->if_name);
	}else if (strcmp(conf->usedby, "NETGRAPH") == 0) {
		chan->common.usedby = WP_NETGRAPH;
				card->devname,chan->if_name);
				card->devname,chan->if_name,conf->usedby);
		err=-EINVAL;
	if (chan->channelized_cfg || chan->tdm_span_voice_api) {
			for (cptr=wan_netif_priv(dev);cptr->next!=NULL;cptr=cptr->next);
			cptr->next=chan;
			chan->next=NULL;
			chan->next = wan_netif_priv(dev);
		chan->channelized_cfg=0;
	if (conf->hwec.enable){
		if (card->wandev.config_id == WANCONFIG_AFT_ISDN_BRI) {
			card->wandev.ec_enable_map = 0x3;
			card->wandev.ec_enable_map |= conf->active_ch;
	chan->time_slot_map=conf->active_ch;
	chan->num_of_time_slots=
		aft_get_num_of_slots(card->u.aft.num_of_time_slots,
			             chan->time_slot_map);
	if (!chan->num_of_time_slots){
				chan->if_name,chan->time_slot_map);
		return -EINVAL;
	if (card->wandev.config_id == WANCONFIG_AFT_ANALOG && chan->num_of_time_slots > 1) {
				chan->if_name,chan->time_slot_map);
		return -EINVAL;
		err=-EINVAL;
		err=-EINVAL;
			card->devname,
			chan->mru);
			card->devname,
			chan->mtu);
	chan->hdlc_eng = conf->hdlc_streaming;
			card->devname,
			chan->hdlc_eng?"On":"Off (Transparent)",
			chan->cfg.hdlc_repeat?"Repeat":"N/A");
       	chan->dma_mru = chan->mtu;
	chan->dma_mru = aft_valid_mtu(chan->dma_mru);
	if (!chan->dma_mru){
			card->devname,
			chan->if_name,
			chan->mtu,chan->mru);
		err= -EINVAL;
    	if (conf->single_tx_buf ||
	    ((card->adptr_type == A101_ADPTR_2TE1 ||
	      card->adptr_type == A101_ADPTR_1TE1) &&
	      card->u.aft.firm_id == AFT_DS_FE_CORE_ID)){
       		chan->single_dma_chain=1;
			chan->max_tx_bufs=MAX_AFT_DMA_CHAINS;
	if (!chan->hdlc_eng){
		chan->single_dma_chain=1;
		chan->max_tx_bufs=MAX_AFT_DMA_CHAINS;
		if (chan->channelized_cfg) {
			dma_per_ch= (MAX_AFT_DMA_CHAINS*1500) / chan->mtu;
		if (chan->common.usedby == XMTP2_API) {
			dma_per_ch += 1024 * chan->num_of_time_slots;
		if (chan->tdm_span_voice_api) {
		chan->tslot_sync=1;
		if(conf->protocol == WANCONFIG_LIP_ATM ||
		   conf->protocol == WANCONFIG_LIP_KATM){
			chan->tslot_sync=0;
		chan->cfg.data_mux=0;
			card->devname,
			chan->cfg.data_mux?"On":"Off");
	if (chan->common.usedby == TDM_VOICE_DCHAN){
     		card->u.aft.tdmv_dchan=chan->logic_ch_num+1;
	if (card->u.aft.tdmv_dchan_cfg_on_master &&
            card->u.aft.tdmv_dchan){
		int dchan=card->u.aft.tdmv_dchan;
			dchan--;
		if (wan_test_bit(dchan,&conf->active_ch)){
					card->devname,dchan);
			card->u.aft.tdmv_chan_ptr=chan;
			card->u.aft.tdmv_dchan=chan->logic_ch_num+1;
	if (chan->channelized_cfg && !chan->hdlc_eng) {
		chan->dma_mru = 1024;
			card->devname,
			chan->dma_mru,
			chan->single_dma_chain?"Off":"On",
			card->wandev.ec_enable_map?"On":"Off");
	/* New DMA support A-DMA */
	if (chan->channelized_cfg && !chan->hdlc_eng){
	err = card->hw_iface.busdma_tag_create(	card->hw,
						&chan->rx_dma_chain_table[0],
						chan->dma_mru,
					card->devname);
		err = -EINVAL;
	err = card->hw_iface.busdma_tag_create(	card->hw,
						&chan->tx_dma_chain_table[0],
						chan->dma_mru,
					card->devname);
		err = card->hw_iface.busdma_tag_destroy(
						card->hw,
						&chan->rx_dma_chain_table[0],
		err = -EINVAL;
		err = card->hw_iface.busdma_alloc(
						card->hw,
						&chan->tx_dma_chain_table[i]);
					card->devname, chan->if_name, i, err);
			err = -EINVAL;
					card->devname, chan->if_name, i,
					chan->tx_dma_chain_table[i].dma_virt,
					chan->dma_mru);
		err = card->hw_iface.busdma_alloc(
						card->hw,
						&chan->rx_dma_chain_table[i]);
					card->devname, chan->if_name, i, err);
			err = -EINVAL;
					card->devname, chan->if_name, i,
					chan->rx_dma_chain_table[i].dma_virt,
					chan->dma_mru);
			card->hw_iface.busdma_free(
						card->hw,
						&chan->rx_dma_chain_table[i]);
			card->hw_iface.busdma_free(
						card->hw,
						&chan->tx_dma_chain_table[i]);
		err = card->hw_iface.busdma_tag_destroy(
						card->hw,
						&chan->rx_dma_chain_table[0],
		err = card->hw_iface.busdma_tag_destroy(
						card->hw,
						&chan->tx_dma_chain_table[0],
		err = -EINVAL;
	 *      is brought back up, we must know to re-astablish the
	if ((chan->gateway = conf->gateway) == WANOPT_YES){
			card->devname,chan->if_name);
	chan->mc = conf->mc;
	 * 	dev->if_init : function that will be called
	 * 	dev->priv    : private structure allocated above
	dev->init = &if_init;
	if (chan->common.usedby != TDM_VOICE &&
	    chan->common.usedby != TDM_VOICE_API){
		chan->common.is_netdev = 1;
	chan->common.iface.open      = &if_open;
        chan->common.iface.close     = &if_close;
        chan->common.iface.output    = &if_send;
        chan->common.iface.ioctl     = &if_do_ioctl;
        chan->common.iface.tx_timeout= &if_tx_timeout;
			wan_iface.attach(dev, NULL, chan->common.is_netdev);
				card->devname, wan_netif_name(dev));
		err = -EINVAL;
	wan_netif_set_mtu(dev, chan->mtu);
	wan_atomic_inc(&card->wandev.if_cnt);
	if (chan->hdlc_eng){
		++card->u.aft.security_cnt;
	chan->max_tx_bufs_orig = chan->max_tx_bufs;
	set_chan_state(card, dev, WAN_CONNECTING);	//chan->common.state = WAN_CONNECTING;
 * new_if - Create new logical channel.
 * to dev->priv pointer.
 * Also the dev->init pointer should also be initialized
 * o parse media- and hardware-specific configuration
	int err=-EINVAL;
	sdla_t *card=wandev->priv;
	if (IS_E1_CARD(card) && !(WAN_FE_FRAME(&card->fe) == WAN_FR_UNFRAMED)) {
		conf->active_ch = conf->active_ch << 1;
		wan_clear_bit(0,&conf->active_ch);
		conf->active_ch = conf->active_ch&~(0xFF000000);
		conf->active_ch = 1;
	if (strcmp(conf->usedby, "TDM_VOICE") == 0) {
		if (card->tdmv_conf.span_no){
			switch(card->wandev.config_id){
				err = wp_tdmv_remora_init(&card->tdmv_iface);
				err = wp_tdmv_bri_init(&card->tdmv_iface);
				err = wp_tdmv_te1_init(&card->tdmv_iface);
						card->devname);
				return -EINVAL;
			WAN_TDMV_CALL(create, (card, &card->tdmv_conf), err);
						card->devname);
				card->devname);
				card->devname);
		return -EINVAL;
	err=-EINVAL;
	if (strcmp(conf->usedby, "TDM_VOICE") == 0 ||
		strcmp(conf->usedby, "TDM_VOICE_API") == 0 ||
		strcmp(conf->usedby, "TDM_SPAN_VOICE_API") ==0){
		int i=0,master_if=-1;
		u32 active_ch=conf->active_ch;
			wan_set_bit(BRI_DCHAN_LOGIC_CHAN,&card->u.aft.tdmv_dchan);
		if (card->wandev.fe_iface.active_map){
			conf->active_ch = card->wandev.fe_iface.active_map(&card->fe, 0);
				wan_set_bit(BRI_DCHAN_LOGIC_CHAN,&conf->active_ch);
				wan_set_bit(BRI_DCHAN_LOGIC_CHAN,&card->tdmv_conf.dchan);
			active_ch=conf->active_ch;
				card->devname, active_ch, card->u.aft.num_of_time_slots,
				card->tdmv_conf.dchan,master_if);
		if (strcmp(conf->usedby, "TDM_SPAN_VOICE_API") ==0) {
			conf->active_ch=active_ch&~(card->tdmv_conf.dchan);
			conf->u.aft.tdmv_master_if=1;
			err=new_if_private(wandev,dev,conf,0,-1,if_cnt);
				conf->u.aft.tdmv_master_if=0;
				for (i=0;i<card->u.aft.num_of_time_slots;i++){
					if (wan_test_bit(i,&card->tdmv_conf.dchan)){
						int dchan=-1;
						conf->active_ch=0;
						conf->u.aft.tdmv_master_if=0;
						wan_set_bit(i,&conf->active_ch);
			for (i=0;i<card->u.aft.num_of_time_slots;i++){
					int dchan=-1;
					conf->active_ch=0;
					conf->u.aft.tdmv_master_if=0;
					wan_set_bit(i,&conf->active_ch);
					card->u.aft.global_isr=1;
					if (wan_test_bit(i,&card->tdmv_conf.dchan)){
						conf->u.aft.tdmv_master_if=1;
		if (!err && card->u.aft.tdmv_zaptel_cfg){
			WAN_TDMV_CALL(software_init, (&card->wan_tdmv), err);
			if (conf->active_ch & ~(0x07)) {
						card->devname,conf->active_ch);
				err=-EINVAL;
			if (wan_test_bit(BRI_DCHAN_ACTIVE_CFG_CHAN, &conf->active_ch)) {
				wan_set_bit(BRI_DCHAN_LOGIC_CHAN, &card->u.aft.tdmv_dchan);
				card->u.aft.tdmv_dchan = BRI_DCHAN_LOGIC_CHAN;
				/* BRI B-Channels */
				card->u.aft.tdmv_dchan = 0;
				conf->active_ch = conf->active_ch << (2*WAN_FE_LINENO(&card->fe));
					 card->devname,conf->active_ch);
				err=new_if_private(wandev,dev,conf,0,-1,0);
			card->tdmv_conf.dchan=0;
			err=new_if_private(wandev,dev,conf,0,-1,0);
		wan_spin_lock_irq(&card->wandev.lock,&flags);
		if (card->wandev.state == WAN_CONNECTED){
		wan_spin_unlock_irq(&card->wandev.lock,&flags);
		if (card->wandev.config_id == WANCONFIG_AFT_ANALOG ||
		    card->wandev.config_id == WANCONFIG_AFT_SERIAL) {
			wan_spin_lock_irq(&card->wandev.lock,&flags);
			card->fe.fe_status = FE_CONNECTED;
			wan_spin_unlock_irq(&card->wandev.lock,&flags);
		} else if (card->wandev.config_id == WANCONFIG_AFT_ISDN_BRI) {
			wan_spin_lock_irq(&card->wandev.lock,&flags);
			wan_spin_unlock_irq(&card->wandev.lock,&flags);
 * del_if - Delete logical channel.
 * NOTE: DO NOT deallocate dev->priv here! It will be
	card = chan->card;
	if (chan->common.usedby == ANNEXG && chan->annexg_dev){
		DEBUG_EVENT("%s: Unregistering Lapb Protocol\n",wandev->name);
			wan_spin_lock_irq(&wandev->lock, &flags);
			chan->annexg_dev = NULL;
			wan_spin_unlock_irq(&wandev->lock, &flags);
		wan_spin_lock_irq(&wandev->lock, &flags);
		tmp_dev=chan->annexg_dev;
		chan->annexg_dev=NULL;
		wan_spin_unlock_irq(&wandev->lock, &flags);
			wan_spin_lock_irq(&wandev->lock, &flags);
			chan->annexg_dev=tmp_dev;
			wan_spin_unlock_irq(&wandev->lock, &flags);
        wan_spin_lock_irq(&card->wandev.lock,&flags);
        wan_spin_unlock_irq(&card->wandev.lock,&flags);
	WAN_TASKLET_KILL(&chan->common.bh_task);
	if (chan->common.usedby == API){
		wan_unreg_api(chan, card->devname);
				chan->if_name);
		return -EBUSY;
	wan_spin_lock_irq(&card->wandev.lock,&flags);
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
		wan_iface.detach(dev, chan->common.is_netdev);
        wan_spin_lock_irq(&card->wandev.lock,&flags);
	chan->common.usedby = API;
        wan_spin_unlock_irq(&card->wandev.lock,&flags);
		card->hw_iface.busdma_free(
					card->hw,
					&chan->rx_dma_chain_table[i]);
		card->hw_iface.busdma_free(
					card->hw,
					&chan->tx_dma_chain_table[i]);
	card->hw_iface.busdma_tag_destroy(
					card->hw,
					&chan->rx_dma_chain_table[0],
	card->hw_iface.busdma_tag_destroy(
					card->hw,
					&chan->tx_dma_chain_table[0],
        wan_spin_lock_irq(&card->wandev.lock,&flags);
	WAN_IFQ_DMA_PURGE(&chan->wp_rx_free_list);
	WAN_IFQ_DESTROY(&chan->wp_rx_free_list);
	WAN_IFQ_PURGE(&chan->wp_rx_complete_list);
	WAN_IFQ_DESTROY(&chan->wp_rx_complete_list);
	WAN_IFQ_PURGE(&chan->wp_rx_stack_complete_list);
	WAN_IFQ_DESTROY(&chan->wp_rx_stack_complete_list);
	WAN_IFQ_PURGE(&chan->wp_tx_pending_list);
	WAN_IFQ_DESTROY(&chan->wp_tx_pending_list);
	WAN_IFQ_PURGE(&chan->wp_rx_bri_dchan_complete_list);
	WAN_IFQ_DESTROY(&chan->wp_rx_bri_dchan_complete_list);
	WAN_IFQ_PURGE(&chan->wp_tx_complete_list);
	WAN_IFQ_DESTROY(&chan->wp_tx_complete_list);
	if (chan->tx_idle_skb){
		wan_skb_free(chan->tx_idle_skb);
		chan->tx_idle_skb=NULL;
	if (chan->tx_realign_buf){
		wan_free(chan->tx_realign_buf);
		chan->tx_realign_buf=NULL;
	if (chan->tx_ss7_realign_buf){
		wan_free(chan->tx_ss7_realign_buf);
		chan->tx_ss7_realign_buf=NULL;
	if (card->u.aft.tdmv_chan_ptr == chan){
		card->u.aft.tdmv_chan_ptr=NULL;
	chan->logic_ch_num=-1;
        wan_spin_unlock_irq(&card->wandev.lock,&flags);
	wanrouter_proc_delete_interface(wandev, chan->if_name);
	wan_atomic_dec(&card->wandev.if_cnt);
	if (chan->hdlc_eng){
		--card->u.aft.security_cnt;
	if (!(card=chan->card)){
	wan_spin_lock_irq(&card->wandev.lock,&flags);
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	if (chan->channelized_cfg || chan->tdm_span_voice_api) {
		sdla_t *card=chan->card;
		if (chan->tdmv_zaptel_cfg) {
			sdla_t *card=chan->card;
				return -EBUSY;
	    wan_spin_lock_irq(&card->wandev.lock,&flags);
		if (chan->channelized_cfg) {
				card->wandev.state=WAN_DISCONNECTED;
				card->hw_iface.getcfg(card->hw, SDLA_HWTYPE_USEDCNT, &card_use_cnt);
						card->devname);
					This code re-triggers it just in case */
					card->hw_iface.bus_read_4(card->hw,
						card->hw_iface.bus_write_4(card->hw,
		card->wandev.rtp_len=0;
		if (card->wan_tdmv.sc) {
        wan_spin_unlock_irq(&card->wandev.lock,&flags);
			wan_netif_set_priv(dev, chan->next);
		if (card->wan_tdmv.sc) {
		if (card->sdla_tdmv_dummy) {
			sdla_tdmv_dummy_unregister(card->sdla_tdmv_dummy);
 * disable_comm - Main shutdown function
        while ((SYSTEM_TICKS-timeout)< (HZ/10)){
	wan_set_bit(CARD_PORT_TASK_DOWN,&card->wandev.critical);
	while (wan_test_bit(CARD_PORT_TASK_RUNNING,&card->wandev.critical)) {
			DEBUG_EVENT("%s: Warning: Port Task stuck! timing out!\n",card->devname);
	if (card->wandev.fe_iface.pre_release){
		card->wandev.fe_iface.pre_release(&card->fe);
	card->hw_iface.hw_lock(card->hw,&smp_flags1);
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	if (card->wandev.fe_iface.unconfig){
		card->wandev.fe_iface.unconfig(&card->fe);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
	card->hw_iface.hw_unlock(card->hw,&smp_flags1);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	wan_set_bit(CARD_DOWN,&card->wandev.critical);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	card->hw_iface.getcfg(card->hw, SDLA_HWCPU_USEDCNT, &used_cnt);
	card->hw_iface.getcfg(card->hw, SDLA_HWTYPE_USEDCNT, &used_type_cnt);
	card->hw_iface.hw_lock(card->hw,&smp_flags1);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	aft_hwdev[card->wandev.card_type].aft_led_ctrl(card, WAN_AFT_RED, 0,WAN_AFT_ON);
	aft_hwdev[card->wandev.card_type].aft_led_ctrl(card, WAN_AFT_GREEN, 0, WAN_AFT_ON);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	card->hw_iface.hw_unlock(card->hw,&smp_flags1);
	__sdla_pull_ptr_isr_array(card->hw,card,WAN_FE_LINENO(&card->fe));
				card->devname,used_cnt, used_type_cnt);
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		/* only re-enable front end interrupt if this
           the card->u.aft strcutre is fully initialized */
	memset(&card->u.aft,0,sizeof(card->u.aft));
 * if_init - Initialize Linux network interface.
	sdla_t*		card = chan->card;
	wan_device_t* 	wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	hdlc->xmit 	= if_send;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= 2*HZ;
	if (chan->common.usedby == TDM_VOICE ||
	    chan->common.usedby == TDM_VOICE_API){
		dev->tx_timeout		= NULL;
		dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= 2*HZ;
	dev->do_ioctl		= if_do_ioctl;
	dev->change_mtu		= if_change_mtu;
	if (chan->common.usedby == BRIDGE ||
            chan->common.usedby == BRIDGE_NODE){
		memcpy(dev->dev_addr, "\xFE\xFC\x00\x00\x00\x00", 6);
		*(int *)(dev->dev_addr + 2) += hw_addr;
		dev->flags     |= IFF_POINTOPOINT;
		dev->flags     |= IFF_NOARP;
		dev->type	= ARPHRD_PPP;
		dev->mtu		= chan->mtu;
		dev->hard_header_len	= 0;
		if (chan->common.usedby == API || chan->common.usedby == STACK){
			if (chan->hdlc_eng) {
				dev->mtu = chan->dma_mru+sizeof(api_tx_hdr_t);
				dev->mtu = chan->mtu+sizeof(api_tx_hdr_t);
		if (chan->mc == WANOPT_YES){
			dev->flags 	|= IFF_MULTICAST;
		if (chan->true_if_encoding){
			DEBUG_EVENT("%s: Setting IF Type to Broadcast\n",chan->if_name);
			dev->type	= ARPHRD_PPP; /* This breaks the tcpdump */
			dev->flags     &= ~IFF_POINTOPOINT;
			dev->flags     |=  IFF_BROADCAST;
			dev->type	= ARPHRD_PPP;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start);
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end);
        dev->tx_queue_len = 100;
 * if_open - Open network interface.
	sdla_t* card = chan->card;
		return -EBUSY;
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
			card->devname,chan->if_name);
		return -EINVAL;
	wan_getcurrenttime(&chan->router_start_time, NULL);
	if (card->wandev.state == WAN_CONNECTED){
	if (card->wandev.config_id == WANCONFIG_AFT_56K) {
		wan_set_bit(AFT_FE_POLL,&card->u.aft.port_task_cmd);
		WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
 * if_close - Close network interface.
	sdla_t* card = chan->card;
	dev->start=0;
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	WAN_NETIF_STATS_INC_COLLISIONS(&chan->common);	//++chan->if_stats.collisions;
					card->devname,
	dma_ram_desc=chan->logic_ch_num*4+AFT_PORT_REG(card,AFT_DMA_CHAIN_RAM_BASE_REG);
	card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
			chan->if_name,
			wan_test_bit(TX_INTR_PENDING,&chan->dma_chain_status),
			chan->tx_chain_indx,
			chan->tx_pending_chain_indx,
			chan->tx_attempts,
			WAN_NETIF_STATS_TX_PACKETS(&chan->common));
	if (wan_test_bit(TX_DMA_BUSY,&chan->dma_status)){
		wan_clear_bit(TX_DMA_BUSY,&chan->dma_status);
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	if (chan->channelized_cfg || chan->tdm_span_voice_api){
		for (ch_ptr=chan;ch_ptr;ch_ptr=ch_ptr->next){
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
 * if_send - Send a packet on a network interface.
 * 	Return a non-zero value to tell the stack
 *		non-0	packet may be re-transmitted
	sdla_t *card = chan->card;
					card->devname,
	if (dev->tbusy){
		 * kick start the device by making dev->tbusy = 0.  We expect
                WAN_NETIF_STATS_COLLISIONS(&chan->common);	//++chan->if_stats.collisions;
		if((SYSTEM_TICKS - chan->tick_counter) < (5 * HZ)) {
	if (chan->common.state != WAN_CONNECTED){
		WAN_NETIF_STATS_INC_TX_CARRIER_ERRORS(&chan->common);	//++chan->if_stats.tx_carrier_errors;
		WAN_NETIF_STATS_INC_TX_CARRIER_ERRORS(&chan->common);	//++chan->if_stats.tx_carrier_errors;
	if (chan->channelized_cfg) {
		private_area_t *top_chan=wan_netif_priv(chan->common.dev);
				chan->if_name,chan->logic_ch_num,
				card->u.aft.tdmv_dchan-1);
		if (!card->u.aft.tdmv_dchan || card->u.aft.tdmv_dchan>32){
					card->devname);
			chan=(private_area_t*)card->u.aft.dev_to_ch_map[BRI_DCHAN_LOGIC_CHAN];
			chan=(private_area_t*)card->u.aft.dev_to_ch_map[card->u.aft.tdmv_dchan-1];
					card->devname);
		if (!chan->hdlc_eng || (IS_BRI_CARD(card) && chan->dchan_time_slot < 0)){
		wan_capture_trace_packet(chan->card, &top_chan->trace_info,
				chan->if_name,chan->logic_ch_num,
				card->u.aft.tdmv_dchan-1);
	if (chan->common.usedby == TDM_VOICE_API){
		WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);
	if (chan->common.usedby == API){
			WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);
		if (chan->cfg.ss7_enable) {
				WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);
		} else if (chan->cfg.hdlc_repeat) {
				WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);
	if (!chan->hdlc_eng && chan->tslot_sync){
		if (wan_skb_len(skb)%chan->num_of_time_slots){
						card->devname,
						chan->if_name,
						chan->num_of_time_slots);
			WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);	//++chan->if_stats.tx_errors;
	if (!chan->hdlc_eng && !chan->lip_atm && (wan_skb_len(skb)%4)){
				chan->if_name,wan_skb_len(skb));
		WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);	//++chan->if_stats.tx_errors;
		if(chan->dchan_time_slot >= 0){
			card->hw_iface.hw_lock(card->hw,&smp_flags);
			card->hw_iface.hw_unlock(card->hw,&smp_flags);
			/* On b-channel data is transmitted using AFT DMA.
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	if (wan_skb_queue_len(&chan->wp_tx_pending_list) > chan->max_tx_bufs){
		wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
	wan_skb_queue_tail(&chan->wp_tx_pending_list,skb);
	if(!chan->lip_atm){
		wan_skb_queue_tail(&chan->wp_tx_hdlc_rpt_list,rskb);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
	if (dev->tx_queue_len < chan->max_tx_bufs &&
	    dev->tx_queue_len > 0) {
				chan->if_name,dev->tx_queue_len);
		chan->max_tx_bufs = dev->tx_queue_len;
	if (dev->tx_queue_len > chan->max_tx_bufs &&
	    chan->max_tx_bufs != chan->max_tx_bufs_orig) {
				chan->if_name,chan->max_tx_bufs_orig);
		chan->max_tx_bufs = chan->max_tx_bufs_orig;
	card=chan->card;
		if (card->wan_tdmv.sc &&
		    card->wandev.state == WAN_CONNECTED &&
		    card->wandev.config_id != WANCONFIG_AFT_ANALOG &&
		    chan->common.usedby == TDM_VOICE) {
			chan->common.if_stats.rx_packets = card->wandev.stats.rx_packets;
			chan->common.if_stats.tx_packets = card->wandev.stats.tx_packets;
	return &chan->common.if_stats;
 * if_do_ioctl - Ioctl handler for fr
	int err=-EOPNOTSUPP;
	if (!chan || !chan->card){
		return -ENODEV;
	card=chan->card;
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
			card->devname);
		return -ENODEV;
				err= -EINVAL;
			wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
			err=wan_bind_api_to_svc(chan,ifr->ifr_data);
			WAN_NETIF_STATS_RX_DROPPED(&chan->common)=0;	//chan->if_stats.rx_dropped=0;
			if (!chan->hdlc_eng){
				WAN_NETIF_STATS_TX_CARRIER_ERRORS(&chan->common)=0;	//chan->if_stats.tx_carrier_errors=0;
			wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
				err= -EINVAL;
			wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
			err=wan_unbind_api_from_svc(chan,ifr->ifr_data);
			wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
			err = chan->common.state;
			wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
			wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
			DEBUG_TEST("%s: WANPIPE API IOCTL!\n", card->devname);
			err = wan_aft_api_ioctl(card,chan,ifr->ifr_data);
				return -EINVAL;
				card->hw_iface.hw_lock(card->hw,&smp_flags1);
				wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
				wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
				card->hw_iface.hw_unlock(card->hw,&smp_flags1);
				return WAN_COPY_TO_USER(ifr->ifr_data,&cid,sizeof(unsigned char));
			err=card->wandev.config_id;
			if (wan_atomic_read(&chan->udp_pkt_len) != 0){
				return -EBUSY;
			wan_atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
			wan_udp_pkt=(wan_udp_pkt_t*)chan->udp_pkt_data;
					&wan_udp_pkt->wan_udp_hdr,
					ifr->ifr_data,
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			if (wan_atomic_read(&chan->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						card->devname,wan_atomic_read(&chan->udp_pkt_len));
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EINVAL;
					ifr->ifr_data,
					&wan_udp_pkt->wan_udp_hdr,
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			wan_atomic_set(&chan->udp_pkt_len,0);
			if (wan_test_and_set_bit(CARD_HW_EC,&card->wandev.critical)){
						card->devname);
				return -EBUSY;
			if (card->wandev.ec){
				err = wan_ec_ioctl(card->wandev.ec, ifr, card);
				err = -EINVAL;
			wan_clear_bit(CARD_HW_EC,&card->wandev.critical);
				card->devname,cmd);
			return -EOPNOTSUPP;
				card->devname,cmd);
			return -EOPNOTSUPP;
			if (card->wandev.hdlc_ioctl){
				err = card->wandev.hdlc_ioctl(card, dev, ifr, cmd);
	if (chan->single_dma_chain){
		dma_descr=(chan->logic_ch_num<<4) + AFT_PORT_REG(card,AFT_RX_DMA_HI_DESCR_BASE_REG);
		dma_ram_desc=chan->logic_ch_num*4 + AFT_PORT_REG(card,AFT_DMA_CHAIN_RAM_BASE_REG);
		card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
		card->hw_iface.bus_write_4(card->hw,dma_ram_desc,reg);
		dma_ram_desc=chan->logic_ch_num*4 + AFT_PORT_REG(card,AFT_DMA_CHAIN_RAM_BASE_REG);
		card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
     	   	dma_descr=(chan->logic_ch_num<<4) + (cur_dma_ptr*AFT_DMA_INDEX_OFFSET) +
                                __FUNCTION__,chan->if_name,chan->logic_ch_num,
       	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
			card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
			card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),&dmareg);
				card->devname,
				chan->if_name,
				chan->logic_ch_num,
				card->devname,chan->if_name);
	if (chan->single_dma_chain){
		dma_descr=(chan->logic_ch_num<<4) + AFT_PORT_REG(card,AFT_TX_DMA_HI_DESCR_BASE_REG);
		dma_ram_desc=chan->logic_ch_num*4 + AFT_PORT_REG(card,AFT_DMA_CHAIN_RAM_BASE_REG);
		card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
		card->hw_iface.bus_write_4(card->hw,dma_ram_desc,reg);
		dma_ram_desc=chan->logic_ch_num*4 + AFT_PORT_REG(card,AFT_DMA_CHAIN_RAM_BASE_REG);
		card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
		dma_descr=(chan->logic_ch_num<<4) + (cur_dma_ptr*AFT_DMA_INDEX_OFFSET) +
                                __FUNCTION__,chan->if_name,chan->logic_ch_num,
        card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
                	card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
				card->devname,
				chan->if_name,
				chan->logic_ch_num);
                                card->devname,chan->if_name);
	DEBUG_CFG("%s: Enabling Global Inter Mask !\n",chan->if_name);
	if (chan->channelized_cfg && !chan->hdlc_eng){
		chan->tdmv_irq_cfg=1;
		DEBUG_CFG("%s: Enabling FOR NON CHANNELIZED !\n",chan->if_name);
		if (chan->tdm_span_voice_api) {
	wan_set_bit(chan->logic_ch_num,&card->u.aft.active_ch_map);
	DEBUG_CFG("%s: ACTIVE CH MAP !\n",chan->if_name);
	if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
	if (card->wandev.state == WAN_CONNECTED &&
	    wan_test_bit(0,&card->u.aft.comm_enabled)){
					chan->if_name,chan->logic_ch_num);
		chan->dma_index=0;
		memset(chan->dma_history,0,sizeof(chan->dma_history));
		if (!chan->hdlc_eng){
	if (chan->channelized_cfg || chan->tdm_span_voice_api){
		for (chan=gchan; chan != NULL; chan=chan->next){
			wan_set_bit(0,&chan->up);
		if (gchan->common.usedby == TDM_VOICE_API){
			wan_netif_set_mtu(gchan->common.dev,
							  card->u.aft.tdmv_mtu+sizeof(api_tx_hdr_t));
		wan_set_bit(0,&card->u.aft.tdmv_master_if_up);
		if (card->wandev.state == WAN_CONNECTED &&
    		    !wan_test_bit(0,&card->u.aft.comm_enabled)){
				gchan->if_name,card->devname);
		wan_set_bit(0,&chan->up);
	if (gchan->cfg.ss7_enable){
	if (chan->logic_ch_num < 0){
	if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
	DEBUG_TEST("%s: Chan=%i\n",__FUNCTION__,chan->logic_ch_num);
	if (chan->channelized_cfg || chan->tdm_span_voice_api){
			card->hw_iface.getcfg(card->hw, SDLA_HWTYPE_USEDCNT, &card_use_cnt);
					card->devname);
		for (chan=gchan; chan != NULL; chan=chan->next){
					chan->if_name,chan->logic_ch_num);
			wan_clear_bit(0,&chan->up);
			wan_set_bit(0,&chan->interface_down);
			if (chan->cfg.tdmv_master_if){
				wan_clear_bit(0,&card->u.aft.tdmv_master_if_up);
					chan->if_name,chan->logic_ch_num,
					wan_test_bit(0,&card->u.aft.tdmv_master_if_up));
		wan_set_bit(0,&chan->interface_down);
		wan_clear_bit(0,&chan->up);
	DEBUG_TEST("%s: Tx interrupt wdt=%d\n",chan->if_name,wdt);
		wan_clear_bit(TX_INTR_PENDING,&chan->dma_chain_status);
	if (chan->channelized_cfg && !chan->hdlc_eng){
	wan_set_bit(0,&chan->idle_start);
	if (WAN_NETIF_QUEUE_STOPPED(chan->common.dev)){
	if (chan->tdm_span_voice_api ||  chan->common.usedby == TDM_VOICE_DCHAN){
		if (is_tdm_api(chan,&chan->wp_tdm_api_dev)){
			wanpipe_tdm_api_kick(&chan->wp_tdm_api_dev);
		chan->errstats.Tx_dma_len_nonzero++;
			card->devname,chan->if_name,reg);
                   		card->devname,chan->if_name);
			chan->errstats.Tx_dma_errors++;
                   		card->devname,chan->if_name,reg);
			chan->errstats.Tx_dma_errors++;
			chan->errstats.Tx_pci_errors++;
                	     		card->devname,chan->if_name);
                	     		card->devname,chan->if_name);
                	     		card->devname,chan->if_name);
				chan->errstats.Tx_pci_latency++;
                	     		card->devname,chan->if_name);
		WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);	//chan->if_stats.tx_errors++;
	chan->opstats.Data_frames_Tx_count++;
	chan->opstats.Data_bytes_Tx_count+=wan_skb_len(skb);
	WAN_NETIF_STATS_INC_TX_PACKETS(&chan->common);	//chan->if_stats.tx_packets++;
	WAN_NETIF_STATS_INC_TX_BYTES(&chan->common, wan_skb_len(skb));	//chan->if_stats.tx_bytes+=wan_skb_len(skb);
	if (chan->common.usedby != TDM_VOICE){
		wan_capture_trace_packet(card, &chan->trace_info, skb, TRC_OUTGOING_FRM);
				chan->if_name,
				rx_el->reg,
				rx_el->align,
				rx_el->dma_addr);
	WAN_NETIF_STATS_INC_RX_ERRORS(&chan->common);	//chan->if_stats.rx_errors++;
	rx_el->align&=AFT_RXDMA_LO_ALIGN_MASK;
	dma_status=aft_rxdma_hi_get_dma_status(rx_el->reg);
	if (wan_test_bit(AFT_RXDMA_HI_GO_BIT,&rx_el->reg)){
				card->devname,chan->if_name);
		WAN_NETIF_STATS_INC_RX_ERRORS(&chan->common);	//chan->if_stats.rx_errors++;
		chan->errstats.Rx_dma_descr_err++;
                                   card->devname,chan->if_name,rx_el->reg);
                                   card->devname,chan->if_name,rx_el->reg);
                                    card->devname,chan->if_name,rx_el->reg);
                                    card->devname,chan->if_name,rx_el->reg);
		chan->errstats.Rx_pci_errors++;
		WAN_NETIF_STATS_INC_RX_ERRORS(&chan->common);	//chan->if_stats.rx_errors++;
		card->wandev.stats.rx_errors++;
	if (chan->hdlc_eng){
		if (!wan_test_bit(AFT_RXDMA_HI_START_BIT,&rx_el->reg)){
					card->devname,chan->if_name,rx_el->reg);
			WAN_NETIF_STATS_INC_RX_FRAME_ERRORS(&chan->common);	//chan->if_stats.rx_frame_errors++;
			chan->opstats.Rx_Data_discard_long_count++;
			chan->errstats.Rx_hdlc_corrupiton++;
			card->wandev.stats.rx_errors++;
		if (!wan_test_bit(AFT_RXDMA_HI_EOF_BIT,&rx_el->reg)){
					card->devname,chan->if_name,rx_el->reg);
			WAN_NETIF_STATS_INC_RX_FRAME_ERRORS(&chan->common);	//chan->if_stats.rx_frame_errors++;
			chan->opstats.Rx_Data_discard_long_count++;
			chan->errstats.Rx_hdlc_corrupiton++;
			card->wandev.stats.rx_errors++;
			if (wan_test_bit(AFT_RXDMA_HI_FCS_ERR_BIT,&rx_el->reg)){
                                		card->devname,chan->if_name,rx_el->reg,
						(rx_el->reg&AFT_RXDMA_HI_DMA_LENGTH_MASK)>>2);
				WAN_NETIF_STATS_INC_RX_FRAME_ERRORS(&chan->common);	//chan->if_stats.rx_frame_errors++;
				chan->errstats.Rx_crc_err_count++;
				card->wandev.stats.rx_crc_errors++;
				wan_set_bit(WP_CRC_ERROR_BIT,&rx_el->pkt_error);
			if (wan_test_bit(AFT_RXDMA_HI_FRM_ABORT_BIT,&rx_el->reg)){
						card->devname,chan->if_name,rx_el->reg);
				WAN_NETIF_STATS_INC_RX_FRAME_ERRORS(&chan->common);	//chan->if_stats.rx_frame_errors++;
				chan->errstats.Rx_hdlc_corrupiton++;
				card->wandev.stats.rx_frame_errors++;
				wan_set_bit(WP_ABORT_ERROR_BIT,&rx_el->pkt_error);
			if (chan->common.usedby != API && data_error){
	len = rx_el->len;
	len=rx_el->reg&AFT_RXDMA_HI_DMA_LENGTH_MASK;
	if (chan->hdlc_eng){
		len=((((chan->dma_mru>>2)-1)-len)<<2) - (~(rx_el->align)&AFT_RXDMA_LO_ALIGN_MASK);
		if (len < 3 || len > chan->dma_mru){
			WAN_NETIF_STATS_INC_RX_FRAME_ERRORS(&chan->common);	//chan->if_stats.rx_frame_errors++;
			chan->errstats.Rx_hdlc_corrupiton++;
			card->wandev.stats.rx_frame_errors++;
		len=(((chan->mru>>2)-len)<<2) - (~(0x03)&AFT_RXDMA_LO_ALIGN_MASK);
		if (len < 1 || len > chan->mru){
			WAN_NETIF_STATS_INC_RX_FRAME_ERRORS(&chan->common);	//chan->if_stats.rx_frame_errors++;
			card->wandev.stats.rx_frame_errors++;
	*pkt_error=rx_el->pkt_error;
	if (wan_test_bit(WP_FIFO_ERROR_BIT,&rx_el->pkt_error)){
		if (chan->hdlc_eng){
			if (++chan->rx_fifo_err_cnt >= WP_MAX_FIFO_FRAMES){
				chan->rx_fifo_err_cnt=0;
			chan->rx_fifo_err_cnt=0;
		if (chan->rx_fifo_err_cnt){
			if (++chan->rx_fifo_err_cnt >= WP_MAX_FIFO_FRAMES){
                        	chan->rx_fifo_err_cnt=0;
					card->devname,chan->if_name,(len+20));
			WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common);	//chan->if_stats.rx_dropped++;
	if (chan->hdlc_eng){
		if (buf[wan_skb_len(*new_skb)-1] != 0x7E &&
		    buf[wan_skb_len(*new_skb)-1] != 0x7F){
						card->devname,
						buf[wan_skb_len(*new_skb)-3],
						buf[wan_skb_len(*new_skb)-2],
						buf[wan_skb_len(*new_skb)-1]);
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
			card->devname);
			card->devname,
			card->wandev.fe_iface.polling);
	wan_set_bit(AFT_FE_POLL,&card->u.aft.port_task_cmd);
	WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
	card->hw_iface.hw_lock(card->hw,&smp_flags1);
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	if (card->wandev.fe_iface.polling){
		delay = card->wandev.fe_iface.polling(&card->fe);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
		card->wandev.fe_iface.add_timer(&card->fe, delay);
	card->hw_iface.hw_unlock(card->hw,&smp_flags1);
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
			card->devname);
			card->devname);
	wan_set_bit(AFT_FE_EC_POLL,&card->u.aft.port_task_cmd);
	WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
	card->hw_iface.hw_lock(card->hw,&smp_flags1);
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	wanpipe_ec_poll(card->wandev.ec_dev, card);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
	card->hw_iface.hw_unlock(card->hw,&smp_flags1);
	sdla_t *card = chan->card;
	if (chan->common.usedby == API){
		if (chan->tdm_span_voice_api) {
			err=wanpipe_tdm_api_span_rx(&chan->wp_tdm_api_dev, new_skb);
				WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common); /* ++chan->if_stats.rx_dropped; */
			if (chan->hdlc_eng){
				if (card->u.aft.cfg.rx_crc_bytes == 3){
				}else if (card->u.aft.cfg.rx_crc_bytes == 2){
			if (chan->common.sk == NULL){
					chan->if_name);
				WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common); /* ++chan->if_stats.rx_dropped; */
				rx_hdr->wp_api_rx_hdr_error_flag=pkt_error;
						chan->if_name,
				WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common); /* ++chan->if_stats.rx_dropped; */
			new_skb->protocol = htons(PVC_PROT);
			new_skb->dev	  = chan->common.dev;
			new_skb->pkt_type = WAN_PACKET_DATA;
		WAN_NETIF_STATS_INC_RX_FRAME_ERRORS(&chan->common); /* chan->if_stats.rx_frame_errors++; */
				WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common); /* ++chan->if_stats.rx_dropped; */
	}else if (chan->common.usedby == TDM_VOICE_DCHAN){
		if (is_tdm_api(chan,&chan->wp_tdm_api_dev)) {
			DEBUG_RX("%s: RX TDM API DCHAN %d\n",chan->if_name, wan_skb_len(new_skb));
				//rx_hdr->error_flag=pkt_error;
						chan->if_name,
				WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common); /* ++chan->if_stats.rx_dropped; */
			err=wanpipe_tdm_api_rx_hdlc(&chan->wp_tdm_api_dev,new_skb);
				WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common); /* ++chan->if_stats.rx_dropped; */
			if (chan->tdmv_zaptel_cfg){
					(&card->wan_tdmv,chan->tdmv_chan,
					card->devname,wan_skb_len(new_skb),
					chan->tdmv_chan);
				DEBUG_EVENT("%s: DCHAN Rx Packet critical error TDMV not compiled!\n",card->devname);
					DEBUG_EVENT("%s: DCHAN Rx Packet critical error op not supported\n",card->devname);
				WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common); /* ++chan->if_stats.rx_dropped; */
	}else if (chan->common.usedby == TDM_VOICE){
			DEBUG_EVENT("%s: TDM VOICE CRITICAL: IN BH!!!!\n",card->devname);
		WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common); /* ++chan->if_stats.rx_dropped; */
	}else if (chan->common.usedby == STACK){
			WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common); /* ++chan->if_stats.rx_dropped; */
	}else if (chan->common.usedby == XMTP2_API){
		if (chan->xmtp2_api_index < 0) {
						chan->if_name);
			WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common); /* ++chan->if_stats.rx_dropped; */
		tskb=wan_skb_dequeue(&chan->wp_rx_free_list);
			WAN_NETIF_STATS_INC_RX_ERRORS(&chan->common);
			//WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common); /* ++chan->if_stats.rx_dropped; */
		xmtp2km_bs_handler (chan->xmtp2_api_index,
		wan_skb_queue_tail(&chan->wp_tx_pending_list,tskb);
	}else if (chan->common.usedby == ANNEXG){
		if (chan->annexg_dev){
			new_skb->protocol = htons(ETH_P_X25);
			new_skb->dev = chan->annexg_dev;
				lapb_protocol.lapb_rx(chan->annexg_dev,new_skb);
				card->wandev.stats.rx_packets++;
				card->wandev.stats.rx_bytes += len;
				WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common);
			WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common);
		protocol_recv(chan->card,chan,new_skb);
	chan->opstats.Data_frames_Rx_count++;
	chan->opstats.Data_bytes_Rx_count+=len;
	WAN_NETIF_STATS_INC_RX_PACKETS(&chan->common);		/* chan->if_stats.rx_packets++; */
	WAN_NETIF_STATS_INC_RX_BYTES(&chan->common, len);	/* chan->if_stats.rx_bytes+=len; */
	sdla_t		*card=chan->card;
      	card->wandev.stats.collisions++;
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
		WAN_TASKLET_END((&chan->common.bh_task));
	if (card->u.aft.tdmv_dchan){
		top_chan=wan_netif_priv(chan->common.dev);
	DEBUG_TEST("%s: ------------ BEGIN --------------: %ld\n",
	if (!wan_test_bit(0,&chan->up)){
                                chan->if_name);
		WAN_TASKLET_END((&chan->common.bh_task));
	while((skb=wan_skb_dequeue(&chan->wp_rx_complete_list)) != NULL){
		WAN_NETIF_STATS_INC_RX_ERRORS(&chan->common);	//chan->if_stats.rx_errors++;
		if (SYSTEM_TICKS-timeout > 1){
			wan_skb_queue_head(&chan->wp_rx_complete_list,skb);
		aft_rx_post_complete (chan->card, chan,
			if (chan->hdlc_eng){
					WAN_NETIF_STATS_INC_RX_ERRORS(&chan->common);	//++chan->if_stats.rx_errors;
				wan_skb_trim(new_skb,wan_skb_len(new_skb)-3);
				len-=3;
			wan_capture_trace_packet(chan->card, &top_chan->trace_info,
	while((skb=wan_skb_dequeue(&chan->wp_rx_stack_complete_list)) != NULL){
		wan_capture_trace_packet(chan->card, &top_chan->trace_info,
			WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common);	//++chan->if_stats.rx_dropped;
			chan->opstats.Data_frames_Rx_count++;
			chan->opstats.Data_bytes_Rx_count+=len;
			WAN_NETIF_STATS_INC_RX_PACKETS(&chan->common);	//chan->if_stats.rx_packets++;
			WAN_NETIF_STATS_INC_RX_BYTES(&chan->common,len);	//chan->if_stats.rx_bytes+=len;
	while((skb=wan_skb_dequeue(&chan->wp_rx_bri_dchan_complete_list)) != NULL){
		/* for BRI the rx data on D-chan is in 'wp_rx_bri_dchan_complete_list'. */
		wan_capture_trace_packet(chan->card, &top_chan->trace_info,
	while((skb=wan_skb_dequeue(&chan->wp_tx_complete_list)) != NULL){
		aft_tx_post_complete (chan->card,chan,skb);
	WAN_TASKLET_END((&chan->common.bh_task));
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
	if ((len=wan_skb_queue_len(&chan->wp_rx_complete_list))){
		WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
	}else if ((len=wan_skb_queue_len(&chan->wp_tx_complete_list))){
		WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
        }else if ((len=wan_skb_queue_len(&chan->wp_rx_stack_complete_list))){
		WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
	}else if ((len=wan_skb_queue_len(&chan->wp_rx_bri_dchan_complete_list))){
		WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
	DEBUG_TEST("%s: ------------ END -----------------: %ld\n",
	tx_status&=card->u.aft.active_ch_map;
	rx_status&=card->u.aft.active_ch_map;
	num_of_logic_ch=card->u.aft.num_of_time_slots;
	if (!wan_test_bit(0,&card->u.aft.comm_enabled)){
			card->wandev.stats.tx_aborted_errors++;
			card->wandev.stats.rx_over_errors++;
			if (wan_test_bit(i,&tx_status) && wan_test_bit(i,&card->u.aft.logic_ch_map)){
				chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
				if (wan_test_bit(0,&chan->interface_down)){
				if (!chan->hdlc_eng && !wan_test_bit(0,&chan->idle_start)){
                                                chan->if_name);
				if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
                           		card->devname,chan->if_name,chan->logic_ch_num,i);
				dma_descr=(chan->logic_ch_num<<4) +
        			card->hw_iface.bus_read_4(card->hw,dma_descr, &tmp_reg);
                           		card->devname,chan->if_name,chan->logic_ch_num,i,tmp_reg);
				WAN_NETIF_STATS_INC_TX_FIFO_ERRORS(&chan->common);	//++chan->if_stats.tx_fifo_errors;
				card->wandev.stats.tx_aborted_errors++;
        			__sdla_bus_read_4(card->hw,AFT_PORT_REG(card,AFT_TX_FIFO_INTR_PENDING_REG),&tmp_fifo_reg);
			if (wan_test_bit(i,&rx_status) && wan_test_bit(i,&card->u.aft.logic_ch_map)){
				chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
				if (wan_test_bit(0,&chan->interface_down)){
				if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
				u32 dma_ram_desc=chan->logic_ch_num*4 +
				card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&tmp_reg);
				dma_descr=(chan->logic_ch_num<<4) + cur_dma_ptr*AFT_DMA_INDEX_OFFSET +
        			card->hw_iface.bus_read_4(card->hw,dma_descr, &tmp_reg);
        			card->hw_iface.bus_read_4(card->hw,(dma_descr-4), &tmp1_reg);
							card->devname,
							chan->rx_dma_chain_table[chan->rx_chain_indx].dma_addr,
                           		card->devname,chan->if_name,chan->logic_ch_num,
					chan->rx_chain_indx,cur_dma_ptr,tmp_reg,dma_descr);
				WAN_NETIF_STATS_INC_RX_FIFO_ERRORS(&chan->common);	//++chan->if_stats.rx_fifo_errors;
				WAN_NETIF_STATS_INC_RX_OVER_ERRORS(&chan->common);	//++chan->if_stats.rx_over_errors;
				chan->errstats.Rx_overrun_err_count++;
				card->wandev.stats.rx_over_errors++;
				wan_set_bit(WP_FIFO_ERROR_BIT, &chan->pkt_error);
        			__sdla_bus_read_4(card->hw,AFT_PORT_REG(card,AFT_RX_FIFO_INTR_PENDING_REG),&tmp_fifo_reg);
        __sdla_bus_read_4(card->hw, AFT_PORT_REG(card,AFT_TX_FIFO_INTR_PENDING_REG),&tx_status);
	__sdla_bus_read_4(card->hw, AFT_PORT_REG(card,AFT_RX_FIFO_INTR_PENDING_REG),&rx_status);
		void **card_list=__sdla_get_ptr_isr_array(card->hw);
			    !wan_test_bit(CARD_DOWN,&tmp_card->wandev.critical)) {
	card_list=__sdla_get_ptr_isr_array(card->hw);
		if (tmp_card == NULL || wan_test_bit(CARD_DOWN,&tmp_card->wandev.critical)) {
		DEBUG_TEST("%s(): card ptr: %s, tmp_card ptr: %s\n", __FUNCTION__, card->devname, tmp_card->devname);
		if (tmp_card->wandev.fe_iface.check_isr &&
		    tmp_card->wandev.fe_iface.check_isr(&tmp_card->fe)) {
			if (tmp_card->wandev.fe_iface.isr &&
		            tmp_card->wandev.fe_iface.isr(&tmp_card->fe)) {
					wan_spin_lock_irq(&tmp_card->wandev.lock,&smp_flags);
					wan_spin_unlock_irq(&tmp_card->wandev.lock,&smp_flags);
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
			card->devname);
	card->wandev.stats.rx_errors++;
	card->wandev.stats.rx_packets++;
	if (SYSTEM_TICKS-card->u.aft.gtimeout >= HZ){
		card->wandev.stats.tx_packets=card->wandev.stats.rx_packets;
		card->wandev.stats.rx_packets=0;
		card->u.aft.gtimeout=SYSTEM_TICKS;
	wan_set_bit(0,&card->in_isr);
	/* -----------------2/6/2003 9:02AM------------------
	*  -- "Transmit/Receive DMA Engine"  interrupt disable
	*  -- "FiFo/Line Abort Error"		 interrupt disable
	* --------------------------------------------------*/
	__sdla_bus_read_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG), &reg);
	DEBUG_ISR("%s:ISR = 0x%X\n",card->devname,reg);
		card->wandev.stats.rx_dropped++;
					card->devname,reg);
			card->wandev.stats.tx_dropped++;
			if (!wan_test_bit(0,&card->fe_ignore_intr)) {
				wan_set_bit(AFT_FE_INTR,&card->u.aft.port_task_cmd);
				WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
			if (card->wandev.fe_iface.check_isr &&
				card->wandev.fe_iface.check_isr(&card->fe)){
	if (card->wandev.ec_dev && wanpipe_ec_isr(card->wandev.ec_dev)){
		if (!wan_test_bit(AFT_FE_EC_POLL,&card->u.aft.port_task_cmd)){
			wan_set_bit(AFT_FE_EC_POLL,&card->u.aft.port_task_cmd);
			WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
	if (card->u.aft.firm_id == AFT_DS_FE_CORE_ID || IS_BRI_CARD(card) || IS_A600_CARD(card) || IS_A700_CARD(card)) {
		__sdla_bus_read_4(card->hw,AFT_PORT_REG(card, AFT_CHIP_STAT_REG), &a108_reg);
		__sdla_bus_read_4(card->hw,AFT_PORT_REG(card, AFT_CHIP_STAT_REG), &serial_reg);
			card->devname,serial_reg);
		status_port_intr = aft_chipcfg_serial_get_status_intr_stats(serial_reg, card->wandev.comm_port);
       		__sdla_bus_read_4(card->hw,AFT_PORT_REG(card, AFT_CHIP_STAT_REG), &a56k_reg);
		if (wan_test_bit(AFT_TDM_GLOBAL_ISR,&card->u.aft.chip_cfg_status)) {
			card->devname,tdmv_port_intr,dma_port_intr,fifo_port_intr,
	if (wan_test_bit(AFT_LCFG_FIFO_INTR_BIT,&card->u.aft.lcfg_reg) &&
	    wan_test_bit(card->wandev.comm_port,&fifo_port_intr)){
		card->wandev.stats.multicast++;
	if (wan_test_bit(AFT_LCFG_DMA_INTR_BIT,&card->u.aft.lcfg_reg) &&
	    wan_test_bit(card->wandev.comm_port,&dma_port_intr)){
		card->wandev.stats.rx_length_errors++;
		if (wan_test_bit(0,&card->u.aft.comm_enabled) &&
			!wan_test_bit(AFT_LCFG_FIFO_INTR_BIT,&card->u.aft.lcfg_reg)){
	if (wan_test_bit(AFT_TDM_GLOBAL_ISR,&card->u.aft.chip_cfg_status)) {
		card->wandev.stats.rx_crc_errors++;
			if (card->adptr_type == A104_ADPTR_4TE1 &&
				card->u.aft.firm_id == AFT_PMC_FE_CORE_ID) {
			__sdla_bus_write_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),reg);	  
			if (IS_A700_ANALOG_CARD(card) && card->hw_iface.fe_test_bit(card->hw,2)) {
					DEBUG_EVENT("%s: Global TDM Ring Resync\n",card->devname);
					card->hw_iface.fe_clear_bit(card->hw,2);
			} else 	if (card->hw_iface.fe_test_bit(card->hw,1)) {
					DEBUG_EVENT("%s: Global TDM Ring Resync\n",card->devname);
					card->hw_iface.fe_clear_bit(card->hw,1);
			if (card->hw_iface.fe_test_bit(card->hw,1)) {
											card->devname,tdmv_port_intr);
					card->hw_iface.fe_clear_bit(card->hw,1);
		card_list=__sdla_get_ptr_isr_array(card->hw);
		DEBUG_TEST("%s: TDM IRQ MAP=0x%X\n", card->devname, tdmv_port_intr);
			    wan_test_bit(AFT_LCFG_TDMV_INTR_BIT,&tmp_card->u.aft.lcfg_reg)) {
				tmp_card->wandev.stats.rx_crc_errors++;
					if (!wan_test_bit(tmp_card->wandev.comm_port,&tdmv_port_intr)) {
					if (tmp_card->hw_iface.fe_test_bit(tmp_card->hw,1)) {
												tmp_card->devname,tdmv_port_intr);
						tmp_card->hw_iface.fe_clear_bit(tmp_card->hw,1);
						tmp_card->u.aft.tdm_rx_dma_toggle++;
						if (tmp_card->u.aft.tdm_rx_dma_toggle >= AFT_TDMV_CIRC_BUF_LEN) {
							tmp_card->u.aft.tdm_rx_dma_toggle=0;
						tmp_card->u.aft.tdm_tx_dma_toggle++;
						if (tmp_card->u.aft.tdm_tx_dma_toggle >= AFT_TDMV_CIRC_BUF_LEN) {
							tmp_card->u.aft.tdm_tx_dma_toggle=0;
				if (tmp_card->wan_tdmv.sc && 
					tmp_card->wandev.config_id != WANCONFIG_AFT_ANALOG) {
			if (card->adptr_type == A104_ADPTR_4TE1 &&
				card->u.aft.firm_id == AFT_PMC_FE_CORE_ID) {
			__sdla_bus_write_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),reg);
		if (wan_test_bit(AFT_LCFG_TDMV_INTR_BIT,&card->u.aft.lcfg_reg) &&
			wan_test_bit(card->wandev.comm_port,&tdmv_port_intr)){
			card->wandev.stats.rx_crc_errors++;
			if (card->wan_tdmv.sc &&
			    !card->wandev.rtp_len &&
			    card->wandev.config_id != WANCONFIG_AFT_ANALOG) {
				card->hw_iface.bus_read_4(card->hw,
				card->hw_iface.bus_write_4(card->hw,
	if (wan_test_bit(card->wandev.comm_port,&wdt_port_intr)){
		card->u.aft.wdt_tx_cnt=SYSTEM_TICKS;
		card->wandev.stats.rx_fifo_errors++;
	else if (card->wandev.state == WAN_CONNECTED &&
		 SYSTEM_TICKS-card->u.aft.wdt_tx_cnt > (HZ>>2)){
		card->u.aft.wdt_tx_cnt=SYSTEM_TICKS;
		card->wandev.stats.tx_aborted_errors++;
	/* -----------------2/6/2003 10:36AM-----------------
	 * --------------------------------------------------*/
		if (++card->u.aft.chip_security_cnt > AFT_MAX_CHIP_SECURITY_CNT){
				card->devname, reg);
				card->devname);
	} else if (aft_hwdev[card->wandev.card_type].aft_check_ec_security(card)){
		if (++card->u.aft.chip_security_cnt > AFT_MAX_CHIP_SECURITY_CNT){
				card->devname);
				card->devname);
			card->u.aft.chip_security_cnt=0;
        } else if (card->u.aft.firm_id == AFT_DS_FE_CORE_ID &&
	           card->wandev.state == WAN_CONNECTED &&
	           SYSTEM_TICKS-card->u.aft.sec_chk_cnt > HZ) {
		card->u.aft.sec_chk_cnt=SYSTEM_TICKS;
		__sdla_bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &lcfg_reg);
		card->u.aft.lcfg_reg=lcfg_reg;
			if (++card->u.aft.chip_security_cnt > AFT_MAX_CHIP_SECURITY_CNT){
				card->devname,
				card->devname);
			card->u.aft.chip_security_cnt=0;
			card->u.aft.chip_security_cnt=0;
	DEBUG_TEST("---- ISR end.-------------------\n");
	wan_clear_bit(0,&card->in_isr);
	__sdla_bus_read_4(card->hw, AFT_PORT_REG(card,AFT_SERIAL_LINE_CFG_REG), &reg);
	if (card->u.aft.serial_status == reg) {
	card->u.aft.serial_status=reg;
	if (card->wandev.ignore_front_end_status == WANOPT_YES) {
				card->devname,
				card->devname,
				card->devname,
	dma_rx_reg&=card->u.aft.active_ch_map;
	dma_rx_reg &= card->u.aft.logic_ch_map;
	dma_rx_reg &= ~(card->u.aft.tdm_logic_ch_map);
	for (i=0; i<card->u.aft.num_of_time_slots;i++){
			chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
						card->devname,i);
			if (!wan_test_bit(0,&chan->up)){
			if (chan->channelized_cfg && !chan->hdlc_eng){
			if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
			WAN_NETIF_STATS_INC_RX_FRAME_ERRORS(&chan->common);	//chan->if_stats.rx_frame_errors++;
			DEBUG_TEST("%s: RX Interrupt pend. \n",	card->devname);
			if (chan->tdm_span_voice_api) {
			if (chan->cfg.tdmv_master_if && !chan->tdmv_irq_cfg){
						card->devname,chan->if_name);
				chan->tdmv_irq_cfg=1;
	dma_tx_reg&=card->u.aft.active_ch_map;
	dma_tx_reg &= card->u.aft.logic_ch_map;
	dma_tx_reg &= ~(card->u.aft.tdm_logic_ch_map);
	for (i=0; i<card->u.aft.num_of_time_slots ;i++){
			chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
						card->devname,i);
			if (chan->channelized_cfg && !chan->hdlc_eng){
			if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
			DEBUG_ISR("---- TX Interrupt pend. --\n");
    	DEBUG_ISR("---- ISR SKB TX end.-------------------\n");
       /* -----------------2/6/2003 9:37AM------------------
      	* --------------------------------------------------*/
        if (card->wan_tdmv.sc) {
		__sdla_bus_read_4(card->hw,AFT_PORT_REG(card,AFT_RX_DMA_INTR_PENDING_REG),&dma_rx_reg);
	        __sdla_bus_read_4(card->hw,AFT_PORT_REG(card,AFT_TX_DMA_INTR_PENDING_REG),&dma_tx_reg);
	       	if (card->u.aft.tdmv_dchan) {
			chan=(private_area_t*)card->u.aft.dev_to_ch_map[card->u.aft.tdmv_dchan-1];
	    		if (chan && wan_test_bit(0,&chan->up)) {
	__sdla_bus_read_4(card->hw,AFT_PORT_REG(card,AFT_RX_DMA_INTR_PENDING_REG),&dma_rx_reg);
	__sdla_bus_read_4(card->hw,AFT_PORT_REG(card,AFT_TX_DMA_INTR_PENDING_REG),&dma_tx_reg);
		void **card_list=__sdla_get_ptr_isr_array(card->hw);
			    !wan_test_bit(CARD_DOWN,&tmp_card->wandev.critical) &&
			    !wan_test_bit(AFT_LCFG_TDMV_INTR_BIT,&tmp_card->u.aft.lcfg_reg)) {
			card->devname,card->u.aft.num_of_time_slots);
       /* -----------------2/6/2003 9:37AM------------------
      	* --------------------------------------------------*/
	for (i=0; i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.tdm_logic_ch_map)){
		chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
					card->devname,i);
		if (!wan_test_bit(0,&chan->up)){
		if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
		if (chan->channelized_cfg && !chan->hdlc_eng){
		WAN_NETIF_STATS_INC_RX_FRAME_ERRORS(&chan->common);	//chan->if_stats.rx_frame_errors++;
				card->devname);
         * we have to re-start it */
	if (card->rsync_timeout){
			if (SYSTEM_TICKS - card->rsync_timeout > 10*HZ) {
				card->rsync_timeout=0;
				if (card->fe.fe_status == FE_CONNECTED) {
						card->devname);
					wan_set_bit(AFT_FE_RESTART,&card->u.aft.port_task_cmd);
					WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
			if (SYSTEM_TICKS - card->rsync_timeout > 5*HZ) {
				void **card_list=__sdla_get_ptr_isr_array(card->hw);
				card->rsync_timeout=0;
					if (first_card && wan_test_bit(AFT_LCFG_TDMV_INTR_BIT,&first_card->u.aft.lcfg_reg)) {
						first_card->devname);
					if (!wan_test_bit(AFT_FE_RESTART,&first_card->u.aft.port_task_cmd)) {
						wan_set_bit(AFT_FE_RESTART,&first_card->u.aft.port_task_cmd);
						WAN_TASKQ_SCHEDULE((&first_card->u.aft.port_task));
	for (i=0; i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
		chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
		if (!wan_test_bit(0,&chan->up) ||
                    wan_test_bit(0,&chan->interface_down)){
		if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
			WAN_NETIF_STATS_INC_TX_DROPPED(&chan->common);	//++chan->if_stats.tx_dropped;
			WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);	//++chan->if_stats.tx_errors;
		if (card->wandev.state == WAN_CONNECTED){
			if (chan->single_dma_chain){
			WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);	//++chan->if_stats.tx_errors;
			if (chan->tdmv_zaptel_cfg &&
			    wan_test_bit(0,&chan->up) &&
			    chan->cfg.tdmv_master_if){
				if (wdt_intr && chan->cfg.tdmv_master_if){
					void **card_list=__sdla_get_ptr_isr_array(card->hw);
							DEBUG_TEST("%s: Disabling zaptel timing ! \n",card->devname);
					WAN_NETIF_STATS_INC_TX_DROPPED(&chan->common);	//++chan->if_stats.tx_dropped;
		void **card_list=__sdla_get_ptr_isr_array(card->hw);
			if (first_card && !wan_test_bit(CARD_DOWN,&first_card->wandev.critical)) {
	 * via interrupt poll, only re-enable wdt interrupt
        if (card->wandev.state != state)
                                card->devname);
                                card->devname);
                                card->devname);
                card->wandev.state = state;
		WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
	wan_set_bit(AFT_FE_POLL,&card->u.aft.port_task_cmd);
	WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
 * S514-1/2/3:		V32/RS232/FT1 Front End
 * S514-4/5/7/8:	56K/T1/E1 Front End
 * 1. Front End State (card->wandev.front_end_status)
 * 2. Protocol State  (card->wandev.state)
 * 3. Interface State (dev->flags & IFF_UP)
	if (!wan_test_bit(AFT_CHIP_CONFIGURED,&card->u.aft.chip_cfg_status) &&
	    card->fe.fe_status == FE_CONNECTED) {
				card->devname,card->fe.fe_status);
		wan_set_bit(AFT_FRONT_END_UP,&card->u.aft.chip_cfg_status);
	if (card->fe.fe_status == FE_CONNECTED || card->wandev.ignore_front_end_status == WANOPT_YES){
		if (card->wandev.state != WAN_CONNECTED){
				if (card->wan_tdmv.sc){
				/* WAN_TASKQ_SCHEDULE((&card->u.aft.port_task)); */
				if (card->u.aft.global_isr &&
				    !wan_test_bit(0,&card->u.aft.tdmv_master_if_up)){
							card->devname);
				if (!IS_BRI_CARD(card) || !wan_test_bit(0,&card->u.aft.comm_enabled)) {
				wan_set_bit(AFT_FE_LED,&card->u.aft.port_task_cmd);
		if (card->wandev.state == WAN_CONNECTED){
			wan_set_bit(AFT_FE_LED,&card->u.aft.port_task_cmd);
			/* WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));	*/
			if (card->wan_tdmv.sc){
	card->hw_iface.getcfg(card->hw, SDLA_HWTYPE_USEDCNT, &card_use_cnt);
			card->devname,__FUNCTION__,card->wandev.comm_port,card_use_cnt);
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
				card->devname);
	if (card->u.aft.global_isr &&
	    !wan_test_bit(0,&card->u.aft.tdmv_master_if_up)){
				card->devname);
	if (wan_test_bit(0,&card->u.aft.comm_enabled)){
		card->hw_iface.bus_read_4(card->hw,
		card->hw_iface.bus_read_4(card->hw,
	err=aft_hwdev[card->wandev.card_type].aft_test_sync(card,0);
		card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
				card->devname,reg);
	if (card->u.aft.global_isr){
		card->hw_iface.bus_read_4(card->hw, AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), reg);
	for (i=0; i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
		chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
		if (!wan_test_bit(0,&chan->up)){
		if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
				card->devname,chan->if_name);
				card->devname,chan->if_name);
		wan_clear_bit(TX_INTR_PENDING,&chan->dma_chain_status);
		if (chan->channelized_cfg && !chan->hdlc_eng){
				card->devname,chan->if_name);
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),&reg);
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),reg);
	for (i=0; i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
		chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
		if (!wan_test_bit(0,&chan->up)){
		if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
				card->devname,chan->if_name,chan->logic_ch_num);
				card->devname,chan->if_name,chan->logic_ch_num);
		wan_clear_bit(0,&chan->idle_start);
	for (i=0; i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
		chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
		if (!wan_test_bit(0,&chan->up)){
		if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
				card->devname,chan->if_name);
		chan->dma_index=0;
		memset(chan->dma_history,0,sizeof(chan->dma_history));
                                card->devname,chan->if_name);
	card->u.aft.tdm_rx_dma_toggle=0;
	card->u.aft.tdm_tx_dma_toggle=0;
	for (i=0; i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
		chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
		memset(&chan->swring,0,sizeof(chan->swring));
		if (!wan_test_bit(0,&chan->up)){
		if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
		if (!chan->hdlc_eng){
		if (chan->cfg.ss7_enable){
		if (chan->tdmv_zaptel_cfg && !chan->hdlc_eng){
	card->hw_iface.bus_read_4(card->hw,
	card->hw_iface.bus_read_4(card->hw,
	card->hw_iface.bus_read_4(card->hw,
	if (card->u.aft.global_isr){
	card->hw_iface.bus_write_4(card->hw,
	card->u.aft.lcfg_reg=reg;
	wan_set_bit(0,&card->u.aft.comm_enabled);
			card->devname);
	if (card->u.aft.global_isr) {
		card->hw_iface.bus_read_4(card->hw,
		card->hw_iface.bus_read_4(card->hw,
		if (wan_test_bit(AFT_TDM_GLOBAL_ISR,&card->u.aft.chip_cfg_status)) {
			card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),&reg);
			card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),reg);
			if (wan_test_bit(AFT_TDM_RING_BUF,&card->u.aft.chip_cfg_status)) {
				card->hw_iface.fe_set_bit(card->hw,1);
			if (card->adptr_type == A104_ADPTR_4TE1 &&
				card->u.aft.firm_id == AFT_PMC_FE_CORE_ID) {
	       		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),reg);
			card->rsync_timeout=SYSTEM_TICKS;
					card->devname);
			card->hw_iface.bus_read_4(card->hw,
			card->hw_iface.bus_write_4(card->hw,
			if (wan_test_bit(AFT_TDM_SW_RING_BUF,&card->u.aft.chip_cfg_status)) {
				DEBUG_EVENT("%s: AFT Per Port TDM Intr (swring)\n",card->devname);
				DEBUG_EVENT("%s: AFT Per Port TDM Intr\n",card->devname);
	}/* if (card->u.aft.global_isr) */
			,card->devname,__FUNCTION__,reg);
	card->hw_iface.getcfg(card->hw, SDLA_HWTYPE_USEDCNT, &type_use_cnt);
			card->devname, type_use_cnt,
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), reg);
	card->u.aft.lcfg_reg=reg;
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),&reg);
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),reg);
		card->fe_no_intr=1;
		if (card->u.aft.global_isr){
					card->devname);
	wan_clear_bit(0,&card->u.aft.comm_enabled);
	if (!chan->hdlc_eng){
				card->devname,chan->if_name);
	chan->dma_index=0;
	memset(chan->dma_history,0,sizeof(chan->dma_history));
	if (chan->channelized_cfg && !chan->hdlc_eng){
				card->devname,chan->if_name);
	wan_clear_bit(0,&chan->idle_start);
							card->devname,__FUNCTION__,__LINE__);
		return -EINVAL;
	chan->common.state = state;
	for (ch_ptr=chan; ch_ptr != NULL; ch_ptr=ch_ptr->next){
		ch_ptr->common.state=state;
		if (ch_ptr->tdmv_zaptel_cfg) {
		if (is_tdm_api(ch_ptr,&ch_ptr->wp_tdm_api_dev)) {
			wanpipe_tdm_api_update_state(&ch_ptr->wp_tdm_api_dev, state);
		if (ch_ptr->common.usedby == ANNEXG &&
			ch_ptr->annexg_dev){
					lapb_protocol.lapb_link_up(ch_ptr->annexg_dev);
					lapb_protocol.lapb_link_down(ch_ptr->annexg_dev);
		wan_clear_bit(0,&chan->idle_start);
		chan->opstats.link_active_count++;
		chan->opstats.link_inactive_modem_count++;
	if (chan->common.usedby == API) {
	if (chan->common.usedby == STACK){
	if (chan->common.usedby == WP_NETGRAPH){
		wan_ng_link_state(&chan->common, state);
	if (chan->common.usedby == XMTP2_API) {
			xmtp2km_facility_state_change(chan->xmtp2_api_index, 1);
			xmtp2km_facility_state_change(chan->xmtp2_api_index, 0);
	sdla_t *card = chan->card;
	if (wan_test_and_set_bit(TX_HANDLER_BUSY,&chan->dma_status)){
				chan->if_name,__FUNCTION__);
	dma_chain = &chan->tx_dma_chain_table[0];
		wan_clear_bit(0,&dma_chain->init);
		dma_descr=(chan->logic_ch_num<<4) + AFT_PORT_REG(card,AFT_TX_DMA_HI_DESCR_BASE_REG);
		card->hw_iface.bus_write_4(card->hw,dma_descr,0);
	if (!wan_test_bit(0,&dma_chain->init)){
	dma_descr=(chan->logic_ch_num<<4) + AFT_PORT_REG(card,AFT_TX_DMA_HI_DESCR_BASE_REG);
	card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
		chan->errstats.Tx_dma_len_nonzero++;
		chan->errstats.Tx_dma_errors++;
			card->devname,chan->if_name,reg);
			chan->errstats.Tx_pci_errors++;
                	     		card->devname,chan->if_name);
                	     		card->devname,chan->if_name);
                	     		card->devname,chan->if_name);
				chan->errstats.Tx_pci_latency++;
                	     		card->devname,chan->if_name);
		WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);	//chan->if_stats.tx_errors++;
	chan->opstats.Data_frames_Tx_count++;
	chan->opstats.Data_bytes_Tx_count+=wan_skb_len(dma_chain->skb);
	WAN_NETIF_STATS_INC_TX_PACKETS(&chan->common);	//chan->if_stats.tx_packets++;
	WAN_NETIF_STATS_INC_TX_BYTES(&chan->common,wan_skb_len(dma_chain->skb));	//chan->if_stats.tx_bytes+=wan_skb_len(dma_chain->skb);
	wan_clear_bit(0,&dma_chain->init);
	wan_clear_bit(TX_HANDLER_BUSY,&chan->dma_status);
	sdla_t *card = chan->card;
	if (wan_test_and_set_bit(TX_HANDLER_BUSY,&chan->dma_status)){
				chan->if_name,__FUNCTION__);
	dma_chain = &chan->tx_dma_chain_table[chan->tx_pending_chain_indx];
		if (!wan_test_bit(0,&dma_chain->init)){
		dma_descr=(chan->logic_ch_num<<4) + (chan->tx_pending_chain_indx*AFT_DMA_INDEX_OFFSET) +
		card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
			wan_clear_bit(TX_INTR_PENDING,&chan->dma_chain_status);
						card->devname,chan->if_name);
		DEBUG_TEST("%s: TX DMA Handler Chain %d\n",chan->if_name,dma_chain->index);
		if (chan->hdlc_eng){
			if (dma_chain->skb == chan->tx_hdlc_rpt_skb) {
				if (wan_skb_queue_len(&chan->wp_tx_hdlc_rpt_list) == 0) {
					wan_skb_queue_tail(&chan->wp_tx_hdlc_rpt_list,dma_chain->skb);
					dma_chain->skb=NULL;
				chan->tx_hdlc_rpt_skb=NULL;
			} else if (dma_chain->skb){
				wan_skb_set_csum(dma_chain->skb, reg);
				wan_skb_queue_tail(&chan->wp_tx_complete_list,dma_chain->skb);
				dma_chain->skb=NULL;
			if (dma_chain->skb != chan->tx_idle_skb){
				wan_skb_set_csum(dma_chain->skb, reg);
				aft_tx_post_complete(chan->card,chan,dma_chain->skb);
				aft_tx_dma_skb_init(chan,dma_chain->skb);
				dma_chain->skb=NULL;
		if (chan->single_dma_chain){
		if (++chan->tx_pending_chain_indx >= MAX_AFT_DMA_CHAINS){
			chan->tx_pending_chain_indx=0;
		dma_chain = &chan->tx_dma_chain_table[chan->tx_pending_chain_indx];
	wan_clear_bit(TX_HANDLER_BUSY,&chan->dma_status);
	if (wan_skb_queue_len(&chan->wp_tx_complete_list)){
		WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
#define dma_descr   dma_chain->dma_descr
#define reg	    dma_chain->reg
#define dma_ch_indx dma_chain->index
#define len_align   dma_chain->len_align
#define card	    chan->card
	unsigned int len = dma_chain->dma_len;
	dma_descr=(chan->logic_ch_num<<4) + (dma_ch_indx*AFT_DMA_INDEX_OFFSET) +
                    		__FUNCTION__, card->devname, chan->if_name,
				chan->logic_ch_num,dma_ch_indx,dma_descr);
	card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
				card->devname,dma_descr,dma_ch_indx,reg);
                card->hw_iface.bus_write_4(card->hw,dma_descr,0);
                card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
	dma_descr=(chan->logic_ch_num<<4) + (dma_ch_indx*AFT_DMA_INDEX_OFFSET) +
	reg=dma_chain->dma_addr;
	if (chan->cfg.ss7_enable){
		ss7_ctrl=wan_skb_csum(dma_chain->skb);
		wan_skb_set_csum(dma_chain->skb,0);
			len-=4;
			if (chan->cfg.ss7_mode == WANOPT_SS7_MODE_4096){
				len-=WANOPT_SS7_FISU_4096_SZ;
				len-=WANOPT_SS7_FISU_128_SZ;
			len-=chan->cfg.ss7_lssu_size;
			__FUNCTION__,card->devname,chan->if_name,
			reg,dma_chain->dma_addr,dma_descr,len);
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	dma_descr=(chan->logic_ch_num<<4) + (dma_ch_indx*AFT_DMA_INDEX_OFFSET) +
	if (chan->cfg.ss7_enable){
	if (chan->single_dma_chain){
		if (chan->channelized_cfg && !chan->hdlc_eng){
					chan->if_name,dma_ch_indx);
	if (chan->hdlc_eng){
                 * non-transparent hdlc configuration */
		if (chan->tslot_sync){
			__FUNCTION__,card->devname,chan->if_name,
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	++chan->tx_attempts;
#define card	    chan->card
	card->hw_iface.busdma_sync(	card->hw,
	card->hw_iface.busdma_unmap(	card->hw,
	if (dma_chain->skb){
		if (!chan->hdlc_eng){
			aft_tx_dma_skb_init(chan,dma_chain->skb);
			dma_chain->skb=NULL;
			wan_skb_free(dma_chain->skb);
			dma_chain->skb=NULL;
	wan_clear_bit(0,&dma_chain->init);
#define card	chan->card
	card->hw_iface.busdma_sync(	card->hw,
	card->hw_iface.busdma_unmap(	card->hw,
	if (dma_chain->skb){
		aft_init_requeue_free_skb(chan,dma_chain->skb);
		dma_chain->skb = NULL;
	wan_clear_bit(0,&dma_chain->init);
	if (wan_test_and_set_bit(TX_DMA_BUSY,&chan->dma_status)){
				chan->if_name,__FUNCTION__);
		return -EBUSY;
	dma_chain = &chan->tx_dma_chain_table[0];
			__FUNCTION__,card->devname,chan->if_name,
			dma_chain->index,dma_chain->init);
	if (wan_test_and_set_bit(0,&dma_chain->init)){
		err=-EBUSY;
	if (!dma_chain->skb){
		dma_chain->skb=wan_skb_dequeue(&chan->wp_rx_free_list);
		if (!dma_chain->skb){
					chan->if_name,dma_chain->index);
			wan_clear_bit(0,&dma_chain->init);
			err=-EINVAL;
		wan_skb_init(dma_chain->skb,16);
		wan_skb_trim(dma_chain->skb,0);
		buf=wan_skb_put(dma_chain->skb,chan->mtu*2);
		memset(buf,chan->idle_flag,chan->mtu*2);
		/* A-DMA */
		card->hw_iface.busdma_map(	card->hw,
						wan_skb_data(dma_chain->skb),
						wan_skb_len(dma_chain->skb),
						chan->dma_mru,
		card->hw_iface.busdma_sync(	card->hw,
	dma_ram_desc=chan->logic_ch_num*4 +
	card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
	card->hw_iface.bus_write_4(card->hw,dma_ram_desc,reg);
				chan->if_name,dma_chain->index);
		WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);	//chan->if_stats.tx_errors++;
		err=-EINVAL;
	wan_clear_bit(TX_DMA_BUSY,&chan->dma_status);
	if (chan->channelized_cfg && !chan->hdlc_eng){
	if (wan_test_and_set_bit(TX_DMA_BUSY,&chan->dma_status)){
				chan->if_name,__FUNCTION__);
		return -EBUSY;
	if (chan->tx_chain_indx >= MAX_AFT_DMA_CHAINS){
				chan->if_name,chan->tx_chain_indx);
		return -EBUSY;
		dma_chain = &chan->tx_dma_chain_table[chan->tx_chain_indx];
		if (wan_test_and_set_bit(0,&dma_chain->init)){
			wan_clear_bit(TX_DMA_BUSY,&chan->dma_status);
		if(!chan->lip_atm){
			skb=wan_skb_dequeue(&chan->wp_tx_pending_list);
			skb=atm_tx_skb_dequeue(&chan->wp_tx_pending_list, chan->tx_idle_skb, chan->if_name);
			if (!chan->hdlc_eng){
				skb=chan->tx_idle_skb;
							chan->if_name);
				WAN_NETIF_STATS_INC_TX_CARRIER_ERRORS(&chan->common);
				if (chan->cfg.hdlc_repeat) {
						skb=wan_skb_dequeue(&chan->wp_tx_hdlc_rpt_list);
						if (wan_skb_queue_len(&chan->wp_tx_hdlc_rpt_list)){
						chan->tx_hdlc_rpt_skb=skb;
						WAN_NETIF_STATS_INC_TX_CARRIER_ERRORS(&chan->common);
					wan_clear_bit(0,&dma_chain->init);
					wan_clear_bit(TX_DMA_BUSY,&chan->dma_status);
						chan->if_name,wan_skb_data(skb));
				WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);	//chan->if_stats.tx_errors++;
				chan->opstats.Tx_Data_discard_lgth_err_count++;
		if (!chan->hdlc_eng && (wan_skb_len(skb)%4)){
						chan->if_name,wan_skb_len(skb));
			WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);	//chan->if_stats.tx_errors++;
			chan->opstats.Tx_Data_discard_lgth_err_count++;
		dma_chain->skb=skb;
		/* A-DMA */
		card->hw_iface.busdma_map(	card->hw,
						wan_skb_data(dma_chain->skb),
						wan_skb_len(dma_chain->skb),
						wan_skb_len(dma_chain->skb),
		card->hw_iface.busdma_sync(	card->hw,
						1, chan->single_dma_chain,
				chan->if_name,dma_chain->index,
				chan->tx_chain_indx,chan->tx_pending_chain_indx);
		if (!wan_test_bit(TX_INTR_PENDING,&chan->dma_chain_status)){
			int pending_indx=chan->tx_pending_chain_indx;
			if (chan->tx_chain_indx >= pending_indx){
				intr = ((MAX_AFT_DMA_CHAINS-(chan->tx_chain_indx -
				intr = ((pending_indx - chan->tx_chain_indx)<=2);
						chan->if_name,dma_chain->index);
				wan_set_bit(TX_INTR_PENDING,&chan->dma_chain_status);
					chan->if_name,dma_chain->index);
			WAN_NETIF_STATS_INC_TX_ERRORS(&chan->common);	//chan->if_stats.tx_errors++;
			wan_capture_trace_packet(card, &chan->trace_info, skb, TRC_OUTGOING_FRM);
		if (chan->single_dma_chain){
			if (++chan->tx_chain_indx >= MAX_AFT_DMA_CHAINS){
				chan->tx_chain_indx=0;
	wan_clear_bit(TX_DMA_BUSY,&chan->dma_status);
#define dma_descr   dma_chain->dma_descr
#define reg	    dma_chain->reg
#define len	    dma_chain->dma_len
#define dma_ch_indx dma_chain->index
#define len_align   dma_chain->len_align
#define card	    chan->card
	reg=dma_chain->dma_addr;
    	dma_descr=(chan->logic_ch_num<<4) + (dma_ch_indx*AFT_DMA_INDEX_OFFSET) +
				__FUNCTION__,card->devname,chan->if_name,
				chan->logic_ch_num,reg,
				dma_chain->dma_addr, dma_descr,dma_chain);
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	dma_descr=(chan->logic_ch_num<<4) + (dma_ch_indx*AFT_DMA_INDEX_OFFSET) +
	if (chan->single_dma_chain){
		if (chan->channelized_cfg && !chan->hdlc_eng){
					chan->if_name,dma_ch_indx);
	if (chan->hdlc_eng){
		aft_rxdma_hi_set_dma_length(&reg,chan->dma_mru,1);
		aft_rxdma_hi_set_dma_length(&reg,chan->mru,0);
			__FUNCTION__,card->devname,chan->if_name,
			chan->logic_ch_num,reg,dma_descr);
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	if (wan_test_and_set_bit(RX_DMA_BUSY,&chan->dma_status)){
				chan->if_name,__FUNCTION__);
		return -EBUSY;
	dma_chain = &chan->rx_dma_chain_table[0];
			__FUNCTION__,card->devname,chan->if_name,
			dma_chain->index,dma_chain->init);
	if (wan_test_and_set_bit(0,&dma_chain->init)){
				card->devname, __FUNCTION__, __LINE__,
				dma_chain->index);
		err=-EBUSY;
	 * skb will be re-used all the time, thus no need for
	if (!dma_chain->skb){
		dma_chain->skb=wan_skb_dequeue(&chan->wp_rx_free_list);
		if (!dma_chain->skb){
					chan->if_name,dma_chain->index);
			wan_clear_bit(0,&dma_chain->init);
			err=-EINVAL;
		wan_skb_init(dma_chain->skb,16);
		wan_skb_trim(dma_chain->skb,0);
		/* A-DMA */
		card->hw_iface.busdma_map(
				card->hw,
				wan_skb_tail(dma_chain->skb),
				chan->dma_mru,
				chan->dma_mru,
		card->hw_iface.busdma_sync(
				card->hw,
				MAX_AFT_DMA_CHAINS, chan->single_dma_chain,
				chan->if_name,
				dma_chain->dma_addr,wan_skb_tail(dma_chain->skb)+dma_chain->dma_offset);
		wan_skb_init(dma_chain->skb,16);
		wan_skb_trim(dma_chain->skb,0);
	dma_ram_desc=chan->logic_ch_num*4 +
	card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
	card->hw_iface.bus_write_4(card->hw,dma_ram_desc,reg);
				chan->if_name,dma_chain->index);
		WAN_NETIF_STATS_INC_RX_ERRORS(&chan->common);	//chan->if_stats.rx_errors++;
	wan_clear_bit(RX_DMA_BUSY,&chan->dma_status);
	if (chan->channelized_cfg && !chan->hdlc_eng){
	if (wan_test_and_set_bit(RX_DMA_BUSY,&chan->dma_status)){
				chan->if_name,__FUNCTION__);
		return -EBUSY;
	free_queue_len=wan_skb_queue_len(&chan->wp_rx_free_list);
	if (!chan->single_dma_chain &&
		free_queue_len=wan_skb_queue_len(&chan->wp_rx_free_list);
					card->devname,__FUNCTION__);
	dma_ram_desc=chan->logic_ch_num*4 + AFT_PORT_REG(card,AFT_DMA_CHAIN_RAM_BASE_REG);
	card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
	aft_chain_history(chan,chan->rx_chain_indx, cur_dma_ptr, chan->rx_pending_chain_indx,1);
	if (!chan->single_dma_chain &&
			card->devname, __LINE__, cur_dma_ptr,chan->rx_chain_indx,max_dma_cnt);
		dma_chain = &chan->rx_dma_chain_table[chan->rx_chain_indx];
		if (wan_test_and_set_bit(0,&dma_chain->init)){
					card->devname, __FUNCTION__, __LINE__,
					dma_chain->index);
			err=-EBUSY;
		dma_chain->skb=wan_skb_dequeue(&chan->wp_rx_free_list);
		if (!dma_chain->skb){
					chan->if_name,
					wan_skb_queue_len(&chan->wp_rx_free_list),
					wan_skb_queue_len(&chan->wp_rx_complete_list));
			dma_chain->skb=wan_skb_dequeue(&chan->wp_rx_free_list);
			if (!dma_chain->skb) {
					chan->if_name,dma_chain->index,
					wan_skb_queue_len(&chan->wp_rx_free_list),
					wan_skb_queue_len(&chan->wp_rx_complete_list));
				wan_clear_bit(0,&dma_chain->init);
				err=-EINVAL;
		card->hw_iface.busdma_map(
					card->hw,
					wan_skb_tail(dma_chain->skb),
					chan->dma_mru,
					chan->dma_mru,
		card->hw_iface.busdma_sync(
					card->hw,
					1, chan->single_dma_chain,
		if (!wan_test_bit(RX_INTR_PENDING,&chan->dma_chain_status)){
			free_queue_len--;
					card->devname);
				if (chan->rx_chain_indx >= cur_dma_ptr){
					intr = ((MAX_AFT_DMA_CHAINS -
						(chan->rx_chain_indx-cur_dma_ptr)) <=4);
					intr = ((cur_dma_ptr - chan->rx_chain_indx)<=4);
					chan->if_name,dma_chain->index);
				wan_set_bit(RX_INTR_PENDING,&chan->dma_chain_status);
					chan->if_name,dma_chain->index, intr);
					chan->if_name,dma_chain->index);
			WAN_NETIF_STATS_INC_RX_ERRORS(&chan->common);	//chan->if_stats.rx_errors++;
		if (chan->single_dma_chain){
			if (++chan->rx_chain_indx >= MAX_AFT_DMA_CHAINS){
				chan->rx_chain_indx=0;
	aft_chain_history(chan,chan->rx_chain_indx, cur_dma_ptr, chan->rx_pending_chain_indx,2);
	if (chan->rx_chain_indx == cur_dma_ptr &&
            chan->rx_pending_chain_indx == cur_dma_ptr &&
			chan->if_name);
	wan_clear_bit(RX_DMA_BUSY,&chan->dma_status);
	sdla_t *card = chan->card;
	if (wan_test_and_set_bit(RX_HANDLER_BUSY,&chan->dma_status)){
				chan->if_name,__FUNCTION__);
	dma_ram_desc=chan->logic_ch_num*4 + AFT_PORT_REG(card,AFT_DMA_CHAIN_RAM_BASE_REG);
	card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
			card->devname, __LINE__,
			chan->rx_chain_indx,max_dma_cnt);
	aft_chain_history(chan,chan->rx_chain_indx, cur_dma_ptr, chan->rx_pending_chain_indx,3);
		dma_chain = &chan->rx_dma_chain_table[chan->rx_pending_chain_indx];
		if (i>0 && chan->rx_pending_chain_indx == cur_dma_ptr){
		if (!wan_test_bit(0,&dma_chain->init)){
				chan->if_name,__FUNCTION__,dma_chain->index);
		dma_descr=(chan->logic_ch_num<<4) + (dma_chain->index*AFT_DMA_INDEX_OFFSET) +
		card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
			if (wan_test_bit(WP_FIFO_ERROR_BIT, &chan->pkt_error)){
			if (chan->single_dma_chain){
					chan->if_name,__FUNCTION__,dma_chain->index);
				WAN_NETIF_STATS_INC_RX_ERRORS(&chan->common);	//++chan->if_stats.rx_errors;
					chan->if_name,__FUNCTION__,dma_chain->index);
			wan_clear_bit(RX_INTR_PENDING,&chan->dma_chain_status);
		if (sizeof(wp_rx_element_t) > wan_skb_headroom(dma_chain->skb)){
						chan->if_name,
						(u32)wan_skb_headroom(dma_chain->skb));
			aft_init_requeue_free_skb(chan, dma_chain->skb);
			WAN_NETIF_STATS_INC_RX_ERRORS(&chan->common);	//++chan->if_stats.rx_errors;
			rx_el=(wp_rx_element_t *)wan_skb_push(dma_chain->skb,
		WAN_NETIF_STATS_INC_RX_FRAME_ERRORS(&chan->common);	//chan->if_stats.rx_frame_errors++;
		dma_descr=(chan->logic_ch_num<<4) +(dma_chain->index*AFT_DMA_INDEX_OFFSET) +
		card->hw_iface.bus_read_4(card->hw,dma_descr, &rx_el->align);
		rx_el->align&=AFT_RXDMA_LO_ALIGN_MASK;
       		dma_descr=(chan->logic_ch_num<<4) +(dma_chain->index*AFT_DMA_INDEX_OFFSET) +
		card->hw_iface.bus_read_4(card->hw,dma_descr, &rx_el->reg);
		rx_el->len=rx_el->reg&AFT_RXDMA_HI_DMA_LENGTH_MASK;
		if (chan->hdlc_eng){
			rx_el->len=((((chan->dma_mru>>2)-1)-rx_el->len)<<2) - (~(rx_el->align)&AFT_RXDMA_LO_ALIGN_MASK);
			rx_el->len=(((chan->mru>>2)-rx_el->len)<<2) - (~(0x03)&AFT_RXDMA_LO_ALIGN_MASK);
		rx_el->pkt_error= dma_chain->pkt_error;
		rx_el->dma_addr = dma_chain->dma_addr;
		/* A-DMA */
		card->hw_iface.busdma_sync(	card->hw,
						1, chan->single_dma_chain,
		dma_chain->dma_len = rx_el->len;	/* update real dma len*/
		card->hw_iface.busdma_unmap(	card->hw,
		wan_skb_put(dma_chain->skb, rx_el->len);
		wan_skb_queue_tail(&chan->wp_rx_complete_list,dma_chain->skb);
				chan->if_name,dma_chain->index,
				wan_skb_queue_len(&chan->wp_rx_complete_list),
				rx_el->align,rx_el->reg, rx_el->len);
		dma_chain->skb=NULL;
		dma_chain->pkt_error=0;
		wan_clear_bit(0,&dma_chain->init);
		if (chan->single_dma_chain){
		if (++chan->rx_pending_chain_indx >= MAX_AFT_DMA_CHAINS){
			chan->rx_pending_chain_indx=0;
	if (wan_skb_queue_len(&chan->wp_rx_complete_list)){
		DEBUG_TEST("%s: Rx Queued list triggering\n",chan->if_name);
		WAN_TASKLET_SCHEDULE((&chan->common.bh_task));
	wan_clear_bit(RX_HANDLER_BUSY,&chan->dma_status);
	if (chan->cfg.ss7_enable){
		chan->tx_dma_chain_table[i].index=i;
		chan->rx_dma_chain_table[i].index=i;
	sdla_t *card=chan->card;
	if (chan->single_dma_chain){
	if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
		tx_dma_descr=(chan->logic_ch_num<<4) +
		rx_dma_descr=(chan->logic_ch_num<<4) +
		card->hw_iface.bus_write_4(card->hw,tx_dma_descr,reg);
		card->hw_iface.bus_write_4(card->hw,rx_dma_descr,reg);
		aft_tx_dma_chain_init(chan,&chan->tx_dma_chain_table[i]);
		aft_rx_dma_chain_init(chan,&chan->rx_dma_chain_table[i]);
	while((skb=wan_skb_dequeue(&chan->wp_rx_complete_list)) != NULL){
				chan->if_name);
		WAN_NETIF_STATS_INC_RX_DROPPED(&chan->common);	//chan->if_stats.rx_dropped++;
	sdla_t *card=chan->card;
	dma_ram_desc=chan->logic_ch_num*4 + AFT_PORT_REG(card,AFT_DMA_CHAIN_RAM_BASE_REG);
	card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
	dma_descr=(chan->logic_ch_num<<4) +(cur_dma_ptr*AFT_DMA_INDEX_OFFSET) +
	card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
				chan->if_name,
	sdla_t *card=chan->card;
	if (chan->single_dma_chain){
	if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
		dma_chain = &chan->rx_dma_chain_table[i];
		dma_descr=(chan->logic_ch_num<<4) +
			   (dma_chain->index*AFT_DMA_INDEX_OFFSET) +
				card->devname,chan->if_name,chan->logic_ch_num,dma_descr);
		card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
		card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
		card->hw_iface.busdma_sync(	card->hw,
						1, chan->single_dma_chain,
		card->hw_iface.busdma_unmap(	card->hw,
		if (dma_chain->skb){
			aft_init_requeue_free_skb(chan, dma_chain->skb);
		dma_chain->skb=NULL;
		dma_chain->pkt_error=0;
		wan_clear_bit(0,&dma_chain->init);
	sdla_t *card=chan->card;
	dma_ram_desc=chan->logic_ch_num*4+
	card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
	chan->rx_pending_chain_indx = chan->rx_chain_indx = cur_dma_ptr;
		chan->if_name,cur_dma_ptr);
	sdla_t *card=chan->card;
	dma_ram_desc=chan->logic_ch_num*4+
	card->hw_iface.bus_read_4(card->hw,dma_ram_desc,&reg);
	chan->tx_pending_chain_indx = chan->tx_chain_indx = cur_dma_ptr;
		chan->if_name,cur_dma_ptr);
	sdla_t *card=chan->card;
	if (chan->single_dma_chain){
	if (IS_BRI_CARD(card) && chan->dchan_time_slot >= 0){
	DEBUG_TEST("%s:%s: Tx: Freeing Descripors\n",card->devname,chan->if_name);
		dma_chain = &chan->tx_dma_chain_table[i];
		dma_descr=(chan->logic_ch_num<<4) +(dma_chain->index*AFT_DMA_INDEX_OFFSET) +
				card->devname,chan->if_name,chan->logic_ch_num,dma_descr);
		card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	chan->tx_chain_indx = chan->tx_pending_chain_indx;
	while((skb=wan_skb_dequeue(&chan->wp_tx_complete_list)) != NULL){
		if (!chan->hdlc_eng) {
	wan_clear_bit (logic_ch,&card->u.aft.logic_ch_map);
	card->u.aft.dev_to_ch_map[logic_ch]=NULL;
	if (logic_ch >= card->u.aft.top_logic_ch){
		card->u.aft.top_logic_ch=AFT_DEFLT_ACTIVE_CH;
		for (i=0;i<card->u.aft.num_of_time_slots;i++){
			if (card->u.aft.dev_to_ch_map[i]){
				card->u.aft.top_logic_ch=i;
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),&reg);
			card->devname,
			card->u.aft.top_logic_ch);
	if (card->u.aft.top_logic_ch > max_logic_ch) {
		aft_dmactrl_set_max_logic_ch(&reg,card->u.aft.top_logic_ch);
		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),reg);
	wan_set_bit(CARD_PORT_TASK_RUNNING,&card->wandev.critical);
	if (wan_test_bit(CARD_PORT_TASK_DOWN,&card->wandev.critical)){
		wan_clear_bit(CARD_PORT_TASK_RUNNING,&card->wandev.critical);
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
		wan_clear_bit(CARD_PORT_TASK_RUNNING,&card->wandev.critical);
	DEBUG_56K("%s: PORT TASK: 0x%X\n", card->devname,card->u.aft.port_task_cmd);
      	card->wandev.stats.rx_missed_errors++;
	if (wan_test_bit(AFT_FE_INTR,&card->u.aft.port_task_cmd)){
		DEBUG_TEST("%s: PORT TASK: FE INTER\n", card->devname);
		card->hw_iface.hw_lock(card->hw,&smp_flags);
		wan_clear_bit(AFT_FE_INTR,&card->u.aft.port_task_cmd);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
	if (wan_test_bit(AFT_FE_POLL,&card->u.aft.port_task_cmd)){
		DEBUG_TEST("%s: PORT TASK: FE POLL\n", card->devname);
		card->hw_iface.hw_lock(card->hw,&smp_flags);
		if (card->wandev.fe_iface.polling){
			card->wandev.fe_iface.polling(&card->fe);
		wan_spin_lock_irq(&card->wandev.lock,&smp_irq_flags);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_irq_flags);
		wan_clear_bit(AFT_FE_POLL,&card->u.aft.port_task_cmd);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
	if (wan_test_bit(AFT_FE_LED,&card->u.aft.port_task_cmd)){
		DEBUG_TEST("%s: PORT TASK: FE LED\n", card->devname);
		card->hw_iface.hw_lock(card->hw,&smp_flags);
		if (card->wandev.state == WAN_CONNECTED){
			aft_hwdev[card->wandev.card_type].aft_led_ctrl(card, WAN_AFT_RED, 0,WAN_AFT_OFF);
			aft_hwdev[card->wandev.card_type].aft_led_ctrl(card, WAN_AFT_GREEN, 0, WAN_AFT_ON);
			aft_hwdev[card->wandev.card_type].aft_led_ctrl(card, WAN_AFT_RED, 0,WAN_AFT_ON);
			aft_hwdev[card->wandev.card_type].aft_led_ctrl(card, WAN_AFT_GREEN, 0, WAN_AFT_OFF);
		wan_clear_bit(AFT_FE_LED,&card->u.aft.port_task_cmd);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
	if (wan_test_bit(AFT_FE_TDM_RBS,&card->u.aft.port_task_cmd)){
		DEBUG_TEST("%s: PORT TASK: FE RBS\n", card->devname);
		card->hw_iface.hw_lock(card->hw,&smp_flags);
		WAN_TDMV_CALL(rbsbits_poll, (&card->wan_tdmv, card), err);
		wan_clear_bit(AFT_FE_TDM_RBS,&card->u.aft.port_task_cmd);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
	if (wan_test_bit(AFT_FE_EC_POLL,&card->u.aft.port_task_cmd)){
		DEBUG_TEST("%s: PORT TASK: FE EC INTR\n", card->devname);
		if (card->wandev.ec_dev){
			pending = wanpipe_ec_poll(card->wandev.ec_dev, card);
			** If EC poll return 1 (pending), re-schedule port_task again
				WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
				wan_clear_bit(AFT_FE_EC_POLL,&card->u.aft.port_task_cmd);
	if (wan_test_bit(AFT_FE_RESTART,&card->u.aft.port_task_cmd)){
        	wan_clear_bit(AFT_FE_RESTART,&card->u.aft.port_task_cmd);
                                       card->devname);
			wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
			wan_clear_bit(0,&card->u.aft.comm_enabled);
			wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		} else if (card->fe.fe_status == FE_CONNECTED) {
                                       card->devname);
                       	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
                       	card->fe.fe_status = FE_DISCONNECTED;
			wan_clear_bit(0,&card->u.aft.comm_enabled);
                       	card->fe.fe_status = FE_CONNECTED;
                       	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	if (wan_test_bit(AFT_RTP_TAP_Q,&card->u.aft.port_task_cmd)){
		wan_clear_bit(AFT_FE_RESTART,&card->u.aft.port_task_cmd);
		while ((skb=wan_skb_dequeue(&card->u.aft.rtp_tap_list))) {
	wan_clear_bit(CARD_PORT_TASK_RUNNING,&card->wandev.critical);
	if (card->fe_ignore_intr) {
	if (!card->fe_no_intr || !status){
		card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),&reg);
		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),reg);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	if (!card->u.aft.cfg.data_mux_map){
		card->u.aft.cfg.data_mux_map=AFT_DEFAULT_DATA_MUX_MAP;
	card->hw_iface.bus_write_4(card->hw, AFT_PORT_REG(card,AFT_DATA_MUX_REG), 
				   card->u.aft.cfg.data_mux_map);		
		card->devname,card->u.aft.cfg.data_mux_map);
	card->hw_iface.bus_read_4(card->hw, 
				  &card->u.aft.cfg.data_mux_map);		
	if (tx_hdr->wp_api_tx_hdr_hdlc_rpt_len == 0 || tx_hdr->wp_api_tx_hdr_hdlc_rpt_len > 8) {
		return -1;
		return -1;
	buf=wan_skb_put(*rskb,tx_hdr->wp_api_tx_hdr_hdlc_rpt_len);
	memcpy(buf,tx_hdr->wp_api_tx_hdr_hdlc_rpt_data,tx_hdr->wp_api_tx_hdr_hdlc_rpt_len);
	api_tx_hdr_t *tx_hdr = &chan->tx_api_hdr;
	memcpy(&chan->tx_api_hdr,wan_skb_data(skb),sizeof(api_tx_hdr_t));
	if (!chan->tx_ss7_realign_buf){
		chan->tx_ss7_realign_buf=wan_malloc(chan->dma_mru);
		if (!chan->tx_ss7_realign_buf){
						chan->if_name);
			return -ENOMEM;
						chan->if_name,chan->dma_mru);
	memset(chan->tx_ss7_realign_buf,0,chan->dma_mru);
	memcpy(chan->tx_ss7_realign_buf,wan_skb_data(skb),wan_skb_len(skb));
		len-=len%4;
	if (tx_hdr->wp_api_tx_hdr_aft_ss7_type == WANOPT_SS7_FISU){
		if (chan->cfg.ss7_mode == WANOPT_SS7_MODE_4096){
		ss7_len=chan->cfg.ss7_lssu_size;
	if (tx_hdr->wp_api_tx_hdr_aft_ss7_force_tx){
			chan->if_name,
			tx_hdr->hdr_u.ss7.data[0],
			tx_hdr->hdr_u.ss7.data[1],
			tx_hdr->hdr_u.ss7.data[2]);
	memcpy(&chan->tx_ss7_realign_buf[len],tx_hdr->wp_api_tx_hdr_aft_ss7_data,ss7_len);
				chan->if_name,wan_skb_tailroom(skb),len);
		return -ENOMEM;
	memcpy(buf,chan->tx_ss7_realign_buf,len);
	debug_print_skb_pkt(chan->if_name, wan_skb_data(skb), wan_skb_len(skb), 0);
	if (card->wandev.fe_iface.update_alarm_info){
		m->count =
				&card->wandev,
				(&card->fe, m, stop_cnt));
	if (card->wandev.fe_iface.update_pmon_info){
		m->count =
				&card->wandev,
				(&card->fe, m, stop_cnt));
	return m->count;
			card->devname,
			card->tdmv_conf.span_no,
			card->tdmv_conf.span_no?"Enabled":"Disabled");
			card->devname,
			(conf->tdmv_conf.sdla_tdmv_dummy_enable == WANOPT_YES)? "Enabled":"Disabled");
	card->sdla_tdmv_dummy = NULL;
	if (conf->tdmv_conf.sdla_tdmv_dummy_enable == WANOPT_YES) {
		card->hw_iface.getcfg(card->hw, SDLA_HWCPU_USEDCNT, &used_cnt);
					card->devname);
			return -EINVAL;
		card->sdla_tdmv_dummy = sdla_tdmv_dummy_register();
		if (card->sdla_tdmv_dummy == NULL) {
			DEBUG_EVENT("%s: Failed to register sdla_tdmv_dummy\n", card->devname);
			return -EINVAL;
	if (conf->tdmv_conf.sdla_tdmv_dummy_enable == WANOPT_YES) {
		DEBUG_EVENT("%s: TDMV Dummy support not compiled in \n", card->devname);
		return -EINVAL;
	if (card->u.aft.global_isr) {
		if (card->wandev.config_id == WANCONFIG_AFT_ANALOG) {
		if (card->u.aft.firm_ver < valid_firmware_ver){
					card->devname,card->u.aft.firm_ver);
					card->devname,valid_firmware_ver);
			return -EINVAL;
	if (card->u.aft.global_isr && card->wan_tdmv.sc){
	if (!chan->channelized_cfg){
	if (!card->u.aft.global_isr){
				card->devname);
		return -EINVAL;
	if (chan->cfg.tdmv_master_if){
				card->devname,chan->if_name);
	if (conf->hdlc_streaming == 0){
		aft_hwdev[card->wandev.card_type].aft_fifo_adjust(card,AFT_TDMV_FIFO_LEVEL);
		if (chan->common.usedby == TDM_VOICE) {
			WAN_TDMV_CALL(check_mtu, (card, conf->active_ch, &chan->mtu), err);
				return -EINVAL;
		if (chan->common.usedby == TDM_VOICE_API) {
			if (aft_tdmapi_mtu_check(card, &chan->mtu) != 0){
				switch (chan->mtu) {
					if (!wan_test_bit(AFT_TDM_GLOBAL_ISR,&card->u.aft.chip_cfg_status)) {
						chan->mtu=16;
					if (card->wandev.card_type == WANOPT_AFT_ANALOG) {
						chan->mtu=8;
						chan->mtu=16;
		chan->mru = chan->mtu;
		card->u.aft.tdmv_mtu = chan->mtu;
		if (chan->tdmv_zaptel_cfg){
			chan->cfg.data_mux=1;
		conf->hdlc_streaming=0;
		chan->tx_realign_buf = NULL;
		card->wan_tdmv.brt_enable=0;
		chan->cfg.data_mux=0;
	if (chan->tdmv_zaptel_cfg){
			conf->active_ch=conf->active_ch>>1;
			if(chan->dchan_time_slot >= 0){
				conf->active_ch = 0x4<<(WAN_FE_LINENO(&card->fe)*2);
				/* For the d-chan MUST set ONLY bit 2!! */
				&conf->tdmv,
				conf->active_ch,
				conf->hwec.enable,
				chan->common.dev), channel);
					chan->if_name);
			return -EINVAL;
		chan->tdmv_chan=channel;
		if (card->u.aft.tdmv_dchan_cfg_on_master && chan->cfg.tdmv_master_if){
			u32 orig_ch=conf->active_ch;
			conf->active_ch=card->u.aft.tdmv_dchan_cfg_on_master;
					&conf->tdmv,
					conf->active_ch,
					conf->hwec.enable,
					chan->common.dev), channel);
						chan->if_name);
				return -EINVAL;
			card->u.aft.tdmv_chan=channel;
			card->u.aft.tdmv_dchan_active_ch=conf->active_ch;
			conf->active_ch=orig_ch;
	if (chan->tdmv_zaptel_cfg){
		WAN_TDMV_CALL(unreg, (card, chan->time_slot_map), err);
		if (card->u.aft.tdmv_dchan_cfg_on_master && chan->cfg.tdmv_master_if){
					card->devname);
			WAN_TDMV_CALL(unreg, (card, card->u.aft.tdmv_dchan_active_ch), err);
			card->u.aft.tdmv_dchan_cfg_on_master=0;
	private_area_t	*chan=(private_area_t*)card->u.aft.dev_to_ch_map[ch];
	tx_dma_chain = &chan->tx_dma_chain_table[0];
	buf = (u8*)wan_skb_data(tx_dma_chain->skb);
	card->wandev.stats.tx_packets++;
	if (card->wan_tdmv.sc){
		if (!card->wandev.ec_enable || card->wandev.ec_enable_map == 0){
		WAN_TDMV_CALL(is_rbsbits, (&card->wan_tdmv), err);
			wan_set_bit(AFT_FE_TDM_RBS,&card->u.aft.port_task_cmd);
			WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
	        card->wandev.stats.rx_packets++;
		card->wandev.stats.tx_packets++;
	tx_dma_chain = &chan->tx_dma_chain_table[0];
	rx_dma_chain = &chan->rx_dma_chain_table[0];
				card->devname,__FUNCTION__,__LINE__,
		return -EINVAL;
	if (!rx_dma_chain->skb || !tx_dma_chain->skb){
				card->devname,__FUNCTION__,__LINE__,
				rx_dma_chain->skb,tx_dma_chain->skb);
		return -EINVAL;
	rxbuf = (unsigned char*)rx_dma_chain->dma_virt+rx_offset;
	txbuf =	(unsigned char*)tx_dma_chain->dma_virt+tx_offset;
	if (wan_test_bit(AFT_TDM_RING_BUF,&card->u.aft.chip_cfg_status)) {
		rx_offset= AFT_TDMV_CIRC_BUF * card->u.aft.tdm_rx_dma_toggle;
		tx_offset= AFT_TDMV_CIRC_BUF * card->u.aft.tdm_tx_dma_toggle;
		rxbuf = (unsigned char*)rx_dma_chain->dma_virt+rx_offset;
		txbuf =	(unsigned char*)tx_dma_chain->dma_virt+tx_offset;
	} else if (wan_test_bit(AFT_TDM_SW_RING_BUF,&card->u.aft.chip_cfg_status)) {
		chan->swring.rx_toggle = (chan->swring.rx_toggle + 1) %  AFT_DMA_RING_MAX;
		memcpy(chan->swring.rbuf[chan->swring.rx_toggle].rxdata,
		       chan->mtu);
		rxbuf= chan->swring.rbuf[chan->swring.rx_toggle].rxdata;
		memcpy(txbuf, chan->swring.rbuf[chan->swring.tx_toggle].txdata,
		       chan->mtu);
		chan->swring.tx_toggle = (chan->swring.tx_toggle + 1) %  AFT_DMA_RING_MAX;
		txbuf = chan->swring.rbuf[chan->swring.tx_toggle].txdata;
	if (!chan->tdmv_rx_delay_cfg){
		unsigned char *buf=rx_dma_chain->dma_virt+offset;
				chan->tdmv_rx_delay_cfg=1;
						chan->if_name,chan->logic_ch_num,
						chan->tdmv_rx_delay);
			chan->tdmv_rx_delay++;
	if (chan->tdmv_zaptel_cfg){
		if (card->wan_tdmv.sc){
			wan_dma_descr_t *tx_bh_dma_chain = &chan->tx_dma_chain_table[1];
			wan_dma_descr_t *rx_bh_dma_chain = &chan->rx_dma_chain_table[1];
			if (!rx_bh_dma_chain->skb){
				rx_bh_dma_chain->skb=wan_skb_dequeue(&chan->wp_rx_free_list);
				if (!rx_bh_dma_chain->skb){
							chan->if_name);
				wan_skb_init(rx_bh_dma_chain->skb,16);
				wan_skb_trim(rx_bh_dma_chain->skb,0);
			if (!tx_bh_dma_chain->skb){
				tx_bh_dma_chain->skb=wan_skb_dequeue(&chan->wp_rx_free_list);
				if (!tx_bh_dma_chain->skb){
							chan->if_name);
				wan_skb_init(tx_bh_dma_chain->skb,16);
				wan_skb_trim(tx_bh_dma_chain->skb,0);
			memcpy(wan_skb_data(rx_bh_dma_chain->skb),
			       wan_skb_data(rx_dma_chain->skb),8);
			memcpy(wan_skb_data(tx_dma_chain->skb),
		       		wan_skb_data(tx_bh_dma_chain->skb),8);
					card->devname,chan->logic_ch_num,
					chan->tdmv_chan);
			if (card->wandev.rtp_len && card->wandev.rtp_tap) {
                                card->wandev.rtp_tap(card,
						     IS_T1_CARD(card) ? chan->first_time_slot :
						     			chan->first_time_slot-1,
                                                     chan->mtu);
					(&card->wan_tdmv,chan->tdmv_chan,
			if (((u8*)(rx_dma_chain->dma_virt+offset))[0] != 0xFF &&
                            ((u8*)(rx_dma_chain->dma_virt+offset))[0] != 0x7F &&
				card->devname,
				((u8*)(rx_dma_chain->dma_virt+offset))[0],
				((u8*)(rx_dma_chain->dma_virt+offset))[1],
				((u8*)(rx_dma_chain->dma_virt+offset))[2],
				((u8*)(rx_dma_chain->dma_virt+offset))[3],
				((u8*)(rx_dma_chain->dma_virt+offset))[4],
				((u8*)(rx_dma_chain->dma_virt+offset))[5],
				((u8*)(rx_dma_chain->dma_virt+offset))[6],
				((u8*)(rx_dma_chain->dma_virt+offset))[7]);
		wanpipe_tdm_api_rx_tx(&chan->wp_tdm_api_dev,
			    chan->mtu);
	if (chan->cfg.tdmv_master_if){
		if (chan->tdmv_zaptel_cfg){
					card->devname,chan->logic_ch_num);
			if (WAN_TASKLET_RUNNING((&chan->common.bh_task))){
						card->devname);
			WAN_WP_TASKLET_SCHEDULE_PER_CPU((&chan->common.bh_task),
							card->tdmv_conf.span_no);
			card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),&reg);
			card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),reg);
			if (wan_test_bit(AFT_TDM_SW_RING_BUF,&card->u.aft.chip_cfg_status)) {
				if (!wan_test_bit(AFT_TDM_GLOBAL_ISR,&card->u.aft.chip_cfg_status)) {
					card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),&reg);
					card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),reg);
			card->hw_iface.busdma_sync(
						card->hw,
						&chan->tx_dma_chain_table[0],
						chan->single_dma_chain,
			card->hw_iface.busdma_sync(
						card->hw,
						&chan->tx_dma_chain_table[0],
						chan->single_dma_chain,
			card->hw_iface.busdma_sync(
						card->hw,
						&chan->rx_dma_chain_table[0],
						chan->single_dma_chain,
			if (!wan_test_bit(AFT_TDM_SW_RING_BUF,&card->u.aft.chip_cfg_status) &&
         		    !wan_test_bit(AFT_TDM_GLOBAL_ISR,&card->u.aft.chip_cfg_status)) {
				card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),&reg);
				card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),reg);
			if (card->wan_tdmv.sc){
				WAN_TDMV_CALL(is_rbsbits, (&card->wan_tdmv), err);
					wan_set_bit(AFT_FE_TDM_RBS,&card->u.aft.port_task_cmd);
					WAN_TASKQ_SCHEDULE((&card->u.aft.port_task));
		if (!chan->tdmv_zaptel_cfg){
			if (card->sdla_tdmv_dummy) {
				err = sdla_tdmv_dummy_tick(card->sdla_tdmv_dummy);
			if (!wan_test_bit(AFT_TDM_GLOBAL_ISR,&card->u.aft.chip_cfg_status)) {
				card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),&reg);
				card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),reg);
			if (card->wandev.fe_iface.watchdog) {
				err = card->wandev.fe_iface.watchdog(&card->fe);
				card->devname,chan->logic_ch_num);
	if (card->wandev.state == WAN_CONNECTED) {
		chan->opstats.Data_frames_Rx_count++;
		chan->opstats.Data_bytes_Rx_count+=chan->mru;
		chan->opstats.Data_frames_Tx_count++;
		chan->opstats.Data_bytes_Tx_count+=chan->mtu;
		WAN_NETIF_STATS_INC_RX_PACKETS(&chan->common);	//chan->if_stats.rx_packets++;
		WAN_NETIF_STATS_INC_RX_BYTES(&chan->common,chan->mru);	//chan->if_stats.rx_bytes += chan->mru;
		WAN_NETIF_STATS_INC_TX_PACKETS(&chan->common);	//chan->if_stats.tx_packets++;
		WAN_NETIF_STATS_INC_TX_BYTES(&chan->common,chan->mtu);	//chan->if_stats.tx_bytes += chan->mtu;
			card->devname);
	if (card->wandev.fe_iface.pre_release){
		card->wandev.fe_iface.pre_release(&card->fe);
	if (card->wandev.fe_iface.disable_irq){
		card->wandev.fe_iface.disable_irq(&card->fe);
	if (card->wandev.fe_iface.unconfig){
		card->wandev.fe_iface.unconfig(&card->fe);
	wan_set_bit(CARD_DOWN,&card->wandev.critical);
		void **card_list=__sdla_get_ptr_isr_array(card->hw);
			    !wan_test_bit(CARD_DOWN,&tmp_card->wandev.critical)) {
				if (tmp_card->wandev.fe_iface.pre_release){
					tmp_card->wandev.fe_iface.pre_release(&tmp_card->fe);
				if (tmp_card->wandev.fe_iface.disable_irq){
					tmp_card->wandev.fe_iface.disable_irq(&tmp_card->fe);
				if (tmp_card->wandev.fe_iface.unconfig){
					tmp_card->wandev.fe_iface.unconfig(&tmp_card->fe);
				wan_set_bit(CARD_DOWN,&tmp_card->wandev.critical);
	aft_hwdev[card->wandev.card_type].aft_led_ctrl(card, WAN_AFT_RED, 0,WAN_AFT_ON);
	aft_hwdev[card->wandev.card_type].aft_led_ctrl(card, WAN_AFT_GREEN, 0, WAN_AFT_OFF);
	err = aft_hwdev[card->wandev.card_type].aft_global_chip_config(card);
	aft_hwdev[card->wandev.card_type].aft_global_chip_unconfig(card);
	return aft_hwdev[card->wandev.card_type].aft_chip_config(card, conf);
	wan_set_bit(CARD_DOWN,&card->wandev.critical);
	aft_hwdev[card->wandev.card_type].aft_chip_unconfig(card);
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),&card->u.aft.lcfg_reg);
	card->u.aft.lcfg_reg=reg;
	chan->logic_ch_num=-1;
	if (chan->time_slot_map == 0){
				card->devname,chan->time_slot_map);
		return -EINVAL;
		card->devname,chan->time_slot_map);
		__FUNCTION__,__LINE__,chan->logic_ch_num,
		chan->fifo_base_addr, chan->fifo_size_code);
	return aft_hwdev[card->wandev.card_type].aft_chan_config(card,chan);
	aft_hwdev[card->wandev.card_type].aft_chan_unconfig(card,chan);
./aft_core.c
 *		-- Alan
 *	Port for Linux-2.1 by Jan "Yenya" Kasprzak <kas@fi.muni.cz>
 * $Id: wanpipe_syncppp.c,v 1.33 2008-05-05 17:13:26 sangoma Exp $
 * $Id: wanpipe_syncppp.c,v 1.33 2008-05-05 17:13:26 sangoma Exp $
#define CHAP_MD5		5	/* hash algorithm - MD5 */
#define	SPP_ARGS(ifp)	(ifp)->if_name, (ifp)->if_unit
#define	SPP_ARGS(ifp)	(ifp)->name
	struct net_device *dev = sp->pp_if;	\
	int debug = sp->pp_flags & PP_DEBUG
	sp->pp_link_state=SPPP_LINK_DOWN;
	if (! (p->pp_flags & PP_TIMO)) 
		init_timer(&p->pp_timer);
		p->pp_timer.function=sppp_cp_timeout;
		p->pp_timer.expires=jiffies+s*HZ;
		p->pp_timer.data=(unsigned long)p;
		p->pp_flags |= PP_TIMO;
		add_timer(&p->pp_timer);
	if (p->pp_flags & PP_TIMO) 
		del_timer(&p->pp_timer);
		p->pp_flags &= ~PP_TIMO; 
	//printk(KERN_INFO "auth_timeout() : seconds : %u,  p->pp_auth_flags : 0x%X\n",
	//	seconds, p->pp_auth_flags);
	if (! (p->pp_auth_flags & PP_TIMO1)) 
		init_timer(&p->pp_auth_timer);
		p->pp_auth_timer.function = function;
		p->pp_auth_timer.expires  = jiffies + seconds * HZ;
		p->pp_auth_timer.data = (unsigned long)p;
		p->pp_auth_flags |= PP_TIMO1;
		add_timer(&p->pp_auth_timer);
	if (p->pp_auth_flags & PP_TIMO1) 
		del_timer(&p->pp_auth_timer);
		p->pp_auth_flags &= ~PP_TIMO1; 
 *	wp_sppp_input -	receive and process a WAN PPP frame
	skb->dev=dev;
	if (dev->flags & IFF_RUNNING)
		sp->ibytes+= skb->len + 3;
		sp->ipkts++;
	if (skb->len <= PPP_HEADER_LEN) {
		if (sp->pp_flags & PP_DEBUG)
				dev->name, skb->len);
	h = (struct ppp_header *)skb->data;
	switch (h->address) {
invalid:        if (sp->pp_flags & PP_DEBUG)
				dev->name,
				h->address, h->control, ntohs (h->protocol));
		if (h->control != PPP_UI)
		if (sp->pp_flags & PP_CISCO) {
			if (sp->pp_flags & PP_DEBUG)
					dev->name,
					h->address, h->control, ntohs (h->protocol));
		switch (ntohs (h->protocol)) {
			if (sp->lcp.state == LCP_STATE_OPENED)
					++sp->pp_seq[IDX_LCP], skb->len + 2,
					&h->protocol);
			if (sp->pp_flags & PP_DEBUG)
					dev->name,
					h->address, h->control, ntohs (h->protocol));
			if (sp->lcp.state == LCP_STATE_OPENED)
			if (sp->ipcp.state == IPCP_STATE_OPENED) {
				if(sp->pp_flags&PP_DEBUG)
				skb->protocol=htons(ETH_P_IP);
			if (sp->lcp.state == LCP_STATE_OPENED) {
				skb->protocol=htons(ETH_P_IPX);
				struct lcp_header * lcph = (struct lcp_header *)skb->data;
				int len = skb->len;
				switch (lcph->type) {
					printk(KERN_INFO "%s: Error : Got PAP_REQ !!\n", dev->name);
					skb->data[len] = '\0';
					printk(KERN_INFO "%s: Pap Ack: Remote Message : %s\n", dev->name,
						&skb->data[sizeof(struct lcp_header) + sizeof(u8)]);
					sp->lcp.state = LCP_STATE_OPENED;
					skb->data[len] = '\0';
					printk(KERN_INFO "%s: Pap Nack: Remote Message : %s\n", dev->name,
						&skb->data[sizeof(struct lcp_header) + sizeof(u8)]);
					printk(KERN_INFO "%s : Unknown PAP packet !!!\n", dev->name);
		if (! (sp->pp_flags & PP_CISCO)) {
			if (sp->pp_flags & PP_DEBUG)
					dev->name,
					h->address, h->control, ntohs (h->protocol));
		switch (ntohs (h->protocol)) {
			skb->protocol=htons(ETH_P_IP);
			skb->protocol=htons(ETH_P_IPX);
 *--------------------------------------------------------------------------*
 *--------------------------------------------------------------------------*
 * The authentication protocols don't employ a full-fledged state machine as
 *						    RCA-
 *	      +--------------------------------------------+
 *	  +--------+			       Close   +---------+ RCA+
 *	  |	   |<----------------------------------|	 |------+
 *   +--->| Closed |				TO*    | Opened	 | sca	|
 *   |	  |	   |-----+		       +-------|	 |<-----+
 *   |	  +--------+ irc |		       |       +---------+
 *   |	 TO-|		 |		       |	   |
 *   |	    |	+------->+		       |	   |
 *   |	  +--------+	 V		       |	   |
 *   |	  |	   |<----+<--------------------+	   |
 *   |	  | Req-   | scr				   |
 *   |	  +--------+					   |
 *   | RCA- |	| RCA+					   |
 *   +------+	+------------------------------------------+
 *	RCA+:	received reply (pap-req, chap-response), acceptable
 *	RCN:	received reply (pap-req, chap-response), not acceptable
 *	TO-:	timeout with restart counter < 0
 *	scr:	send request packet (none for PAP, chap-challenge)
 *	sca:	send ack packet (pap-ack, chap-success)
 *	scn:	send nak packet (pap-nak, chap-failure)
 *	ict:	initialize re-challenge timer (CHAP only)
 *	tlu:	this-layer-up, LCP reaches network phase
 *	tld:	this-layer-down, LCP enters terminate phase
 * automaton falls back into Req-Sent state, it doesn't signal a tld
	//strcpy(sp->hisauth.name, "RYELLE_LINX");
	//strcpy(sp->hisauth.secret, "ryelle");
	len = skb->len;
				dev->name, len);
	h = (struct lcp_header *)skb->data;
	if (len > ntohs (h->len))
		len = ntohs (h->len);
	switch (h->type) {
		value_len = value[-1];
		name_len = len - value_len - 5;
					dev->name,
					sppp_auth_type_name(PPP_CHAP, h->type),
					h->ident, ntohs(h->len));
				sppp_print_bytes((u_char*) (h+1), len-4);
				dev->name,
			    	sppp_auth_type_name(PPP_CHAP, h->type),
			    	h->ident,
			    	ntohs(h->len));
			printk(" value-size=%d value=", value_len);
		wp_MD5Update(&ctx, &h->ident, 1);
		wp_MD5Update(&ctx, sp->myauth.secret, sppp_strnlen(sp->myauth.secret, AUTHKEYLEN));
		sppp_auth_send(sp, PPP_CHAP, CHAP_RESPONSE, h->ident,
			       (size_t)sppp_strnlen(sp->myauth.name, AUTHNAMELEN),
			       sp->myauth.name,
			printk(KERN_INFO "%s: chap success ", dev->name);
				sppp_print_string((char*)(h + 1), len - 4);
		sp->pp_flags &= ~PP_NEEDAUTH;
		sp->lcp.state = LCP_STATE_OPENED;
			printk(KERN_INFO "%s: chap failure", dev->name);
				sppp_print_string((char*)(h + 1), len - 4);
			printk(KERN_INFO "%s: chap failure\n", dev->name);
		printk(KERN_INFO "%s : CHAP_RESPONSE - not implemented yet.\n",
			dev->name);
		value_len = value[-1];
		name_len = len - value_len - 5;
				    sppp_auth_type_name(PPP_CHAP, h->type),
				    h->ident, ntohs(h->len));
				sppp_print_bytes((u_char*)(h+1), len-4);
		if (h->ident != sp->confid[IDX_CHAP]) {
				    h->ident, sp->confid[IDX_CHAP]);
		if (name_len != sppp_strnlen(sp->hisauth.name, AUTHNAMELEN)
		    || memcmp(name, sp->hisauth.name, name_len) != 0) {
			sppp_print_string(sp->hisauth.name,
					  sppp_strnlen(sp->hisauth.name, AUTHNAMELEN));
			    	sppp_state_name(sp->state[IDX_CHAP]),
			    	sppp_auth_type_name(PPP_CHAP, h->type),
			    	h->ident, ntohs (h->len));
			printk(" value-size=%d value=", value_len);
		wp_MD5Update(&ctx, &h->ident, 1);
		wp_MD5Update(&ctx, sp->hisauth.secret,
			  sppp_strnlen(sp->hisauth.secret, AUTHKEYLEN));
		wp_MD5Update(&ctx, sp->myauth.challenge, AUTHKEYLEN);
			sppp_auth_send(sp, PPP_CHAP, CHAP_FAILURE, h->ident,
				       sizeof(FAILMSG) - 1, (u_char *)FAILMSG,
		if (sp->state[IDX_CHAP] == STATE_REQ_SENT ||
		    sp->state[IDX_CHAP] == STATE_OPENED)
			sppp_auth_send(sp, PPP_CHAP, CHAP_SUCCESS, h->ident,
				       sizeof(SUCCMSG) - 1, (u_char *)SUCCMSG,
		if (sp->state[IDX_CHAP] == STATE_REQ_SENT) {
		/* Unknown CHAP packet type -- ignore. */
		if (sp->pp_flags & PP_DEBUG){
				dev->name,
			    	h->type, h->ident, ntohs(h->len));
			sppp_print_bytes((u_char*)(h+1), len-4);
	struct net_device *dev = sp->pp_if;
			dev->name);
				dev->name);
	if (sp->pp_flags & PP_DEBUG){
			dev->name,
	while (len-- > 0) {
	sp->state[IDX_CHAP] = STATE_CLOSED;
	sp->fail_counter[IDX_CHAP] = 0;
	sp->pp_seq[IDX_CHAP] = 0;
	sp->pp_rseq[IDX_CHAP] = 0;
	callout_handle_init(&sp->ch[IDX_CHAP]);
	if (sp->myauth.proto == PPP_CHAP &&
	    (sp->lcp.opts & (1 << LCP_OPT_AUTH_PROTO)) != 0) {
		sp->rst_counter[IDX_CHAP] = sp->lcp.max_configure;
	if (sp->state[IDX_CHAP] != STATE_CLOSED)
		    sppp_state_name(sp->state[IDX_CHAP]),
		    sp->rst_counter[IDX_CHAP]);
	if (--sp->rst_counter[IDX_CHAP] < 0)
		/* TO- event */
		switch (sp->state[IDX_CHAP]) {
		switch (sp->state[IDX_CHAP]) {
			sp->rst_counter[IDX_CHAP] = sp->lcp.max_configure;
	sp->rst_counter[IDX_CHAP] = sp->lcp.max_configure;
	 * 4.0.?) don't want to re-authenticate their CHAP once the
	 * initial challenge-response exchange has taken place.
	if ((sp->hisauth.flags & AUTHFLAG_NORECHALLENGE) == 0) {
		 * Compute the re-challenge timeout.  This will yield
		    	sp->pp_phase == PHASE_NETWORK? "reconfirmed": "tlu");
		if ((sp->hisauth.flags & AUTHFLAG_NORECHALLENGE) == 0)
			printk(KERN_INFO "next re-challenge in %d seconds\n", i);
			printk(KERN_INFO "re-challenging supressed\n");
	sp->lcp.protos |= (1 << IDX_CHAP);
	if (sp->pp_flags & PP_NEEDAUTH) {
	 * is the case if this is a dummy tlu event after a re-challenge.
	if (sp->pp_phase != PHASE_NETWORK)
	sp->lcp.protos &= ~(1 << IDX_CHAP);
	sp->lcp.magic = jiffies;
	sp->lcp.state = LCP_STATE_CLOSED;
	sp->ipcp.state = IPCP_STATE_CLOSED;
	ch = (u_long *)sp->myauth.challenge;
	sp->confid[IDX_CHAP] = ++sp->pp_seq[IDX_CHAP];
	sppp_auth_send(sp, PPP_CHAP, CHAP_CHALLENGE, sp->confid[IDX_CHAP],
		       (size_t)AUTHKEYLEN, sp->myauth.challenge,
		       (size_t)sppp_strnlen(sp->myauth.name, AUTHNAMELEN),
		       sp->myauth.name,
	sp->state[cp->protoidx] = newstate;
		TIMEOUT(cp->TO, (void *)sp, sp->lcp.timeout);
	sp->pp_phase = PHASE_NETWORK;
			sppp_phase_name(sp->pp_phase));
		if ((cps[i])->flags & CP_NCP)
			(cps[i])->Open(sp);
		if ((sp->lcp.protos & mask) && ((cps[i])->flags & CP_NCP))
			(cps[i])->Up(sp);
	sp->ipcp.state = IPCP_STATE_CLOSED;
		if ((sp->lcp.protos & mask) && (cps[i])->flags & CP_NCP)
 * Re-check the open NCPs and see if we should terminate the link.
	if (sp->pp_phase < PHASE_NETWORK)
	case STATE_REQ_SENT:	return "req-sent";
	case STATE_ACK_RCVD:	return "ack-rcvd";
	case STATE_ACK_SENT:	return "ack-sent";
				dev->name,
	h=(struct ppp_header *)skb->data;
	if(sp->pp_flags&PP_CISCO)
		h->address = CISCO_UNICAST;
		h->control = 0;
		h->address = PPP_ALLSTATIONS;
		h->control = PPP_UI;
	if(sp->pp_flags & PP_CISCO)
		h->protocol = htons(type);
			h->protocol = htons(PPP_IP);
			h->protocol = htons(PPP_IPX);
	for (sp=spppq; sp; sp=sp->pp_next) 
		struct net_device *dev = sp->pp_if;
		if (! (sp->pp_flags & PP_KEEPALIVE) ||
		    ! (dev->flags & IFF_UP))
		if (! (sp->pp_flags & PP_CISCO) &&
		    sp->lcp.state != LCP_STATE_OPENED)
		if (sp->pp_alivecnt == sppp_max_keepalive_count) {
			printk (KERN_WARNING "%s: protocol down\n", dev->name);
			if (! (sp->pp_flags & PP_CISCO)) {
				sp->lcp.magic = jiffies;
				sp->lcp.state = LCP_STATE_CLOSED;
				sp->ipcp.state = IPCP_STATE_CLOSED;
		if (sp->pp_alivecnt <= sppp_max_keepalive_count)
			++sp->pp_alivecnt;
		if (sp->pp_flags & PP_CISCO)
			sppp_cisco_send (sp, CISCO_KEEPALIVE_REQ, ++sp->pp_seq[IDX_LCP],
				sp->pp_rseq[IDX_LCP]);
		else if (sp->lcp.state == LCP_STATE_OPENED) {
			long nmagic = htonl (sp->lcp.magic);
			sp->lcp.echoid = ++sp->pp_seq[IDX_LCP];
				sp->lcp.echoid, 4, &nmagic);
	struct net_device *dev = sp->pp_if;
	int len = skb->len;
		if (sp->pp_flags & PP_DEBUG)
				dev->name, len);
	h = (struct lcp_header *)skb->data;
	if (sp->pp_flags & PP_DEBUG) 
		switch (sp->lcp.state) {
			dev->name, state, len,
			sppp_lcp_type_name (h->type), h->ident, ntohs (h->len));
			sppp_print_bytes ((u8*) (h+1), len-4);
	if (len > ntohs (h->len))
		len = ntohs (h->len);
	switch (h->type) {
		/* Unknown packet type -- send Code-Reject packet. */
		sppp_cp_send (sp, PPP_LCP, LCP_CODE_REJ, ++sp->pp_seq[IDX_LCP],
			skb->len, h);
			if (sp->pp_flags & PP_DEBUG)
					dev->name, len);
		if (rmagic == sp->lcp.magic) {
			/* Local and remote magics equal -- loopback? */
			if (sp->pp_loopcnt >= sppp_max_keepalive_count*5) {
					dev->name);
				sp->pp_loopcnt = 0;
				if (dev->flags & IFF_UP) {
			} else if (sp->pp_flags & PP_DEBUG)
					dev->name);
			++sp->pp_loopcnt;
			/* MUST send Conf-Nack packet. */
			rmagic = ~sp->lcp.magic;
				h->ident, sizeof (opt), &opt);
			switch (sp->lcp.state) {
				sp->lcp.state = LCP_STATE_CLOSED;
				sp->ipcp.state = IPCP_STATE_CLOSED;
		/* Send Configure-Ack packet. */
		sp->pp_loopcnt = 0;
		if (sp->lcp.state != LCP_STATE_OPENED) {
			sppp_cp_send (sp, PPP_LCP, LCP_CONF_ACK, h->ident, len-4, h+1);
			sp->confid[IDX_PAP] = h->ident;
		//		h->ident, len-4, h+1);
		switch (sp->lcp.state) {
			sp->lcp.state = LCP_STATE_ACK_SENT;
			sp->lcp.state = LCP_STATE_OPENED;
			if(sp->pp_flags & PP_NEEDAUTH){
				sp->confid[IDX_PAP] = h->ident;
			/* Remote magic changed -- close session. */
			sp->lcp.state = LCP_STATE_CLOSED;
			sp->ipcp.state = IPCP_STATE_CLOSED;
				h->ident, len-4, h+1);
			sp->lcp.state = LCP_STATE_ACK_SENT;
		if (h->ident != sp->lcp.confid)
		if ((sp->pp_link_state != SPPP_LINK_UP) &&
		    (dev->flags & IFF_UP)) {
			sp->pp_link_state=SPPP_LINK_UP;
			printk (KERN_INFO "%s: protocol up\n", dev->name);
		switch (sp->lcp.state) {
			sp->lcp.state = LCP_STATE_ACK_RCVD;
			sp->lcp.state = LCP_STATE_OPENED;
			if(sp->pp_flags & PP_NEEDAUTH){
				sp->confid[IDX_PAP] = h->ident;
		if (h->ident != sp->lcp.confid)
			if (rmagic == ~sp->lcp.magic) {
				if (sp->pp_flags & PP_DEBUG)
						dev->name);
				sp->lcp.magic += newmagic;
				sp->lcp.magic = rmagic;
		if (sp->lcp.state != LCP_STATE_ACK_SENT) {
			sp->lcp.state = LCP_STATE_CLOSED;
			sp->ipcp.state = IPCP_STATE_CLOSED;
		 * to avoid endless req-nack loop. */
		if (h->ident != sp->lcp.confid)
		if (sp->lcp.state != LCP_STATE_ACK_SENT) {
			sp->lcp.state = LCP_STATE_CLOSED;
			sp->ipcp.state = IPCP_STATE_CLOSED;
		/* Send Terminate-Ack packet. */
		sppp_cp_send (sp, PPP_LCP, LCP_TERM_ACK, h->ident, 0, 0);
		sp->lcp.state = LCP_STATE_CLOSED;
		sp->ipcp.state = IPCP_STATE_CLOSED;
		if (sp->pp_link_state){ 	
			printk (KERN_INFO "%s: protocol down\n", dev->name);
		if (sp->lcp.state != LCP_STATE_OPENED)
			if (sp->pp_flags & PP_DEBUG)
					dev->name, len);
		if (ntohl (*(long*)(h+1)) == sp->lcp.magic) {
			printk (KERN_WARNING "%s: loopback\n", dev->name);
			sp->lcp.state = LCP_STATE_CLOSED;
			sp->ipcp.state = IPCP_STATE_CLOSED;
		*(long*)(h+1) = htonl (sp->lcp.magic);
		sppp_cp_send (sp, PPP_LCP, LCP_ECHO_REPLY, h->ident, len-4, h+1);
		if (h->ident != sp->lcp.echoid)
			if (sp->pp_flags & PP_DEBUG)
					dev->name, len);
		if (ntohl (*(long*)(h+1)) != sp->lcp.magic)
		sp->pp_alivecnt = 0;
	//sp->confid[IDX_PAP] = ++sp->pp_seq[IDX_PAP];
	pwdlen = sppp_strnlen(sp->myauth.secret, AUTHKEYLEN);
	idlen = sppp_strnlen(sp->myauth.name, AUTHNAMELEN);
	sppp_auth_send(sp, PPP_PAP, PAP_REQ, sp->confid[IDX_PAP],
		       (size_t)idlen, sp->myauth.name,
		       (size_t)pwdlen, sp->myauth.secret,
	struct net_device *dev = sp->pp_if;
	if (skb->len != CISCO_PACKET_LEN && skb->len != CISCO_BIG_PACKET_LEN) {
		if (sp->pp_flags & PP_DEBUG)
				dev->name,  skb->len);
	h = (struct cisco_packet *)skb->data;
	if (sp->pp_flags & PP_DEBUG)
		printk (KERN_WARNING "%s: cisco input: %d bytes <%xh %xh %xh %xh %xh-%xh>\n",
			dev->name,  skb->len,
			ntohl (h->type), h->par1, h->par2, h->rel,
			h->time0, h->time1);
	switch (ntohl (h->type)) {
		if (sp->pp_flags & PP_DEBUG)
				dev->name,  ntohl (h->type));
		sp->pp_alivecnt = 0;
		sp->pp_rseq[IDX_LCP] = ntohl (h->par1);
		if (sp->pp_seq[IDX_LCP] == sp->pp_rseq[IDX_LCP]) {
			if (sp->pp_loopcnt >= sppp_max_keepalive_count) {
					dev->name);
				sp->pp_loopcnt = 0;
				if (dev->flags & IFF_UP) {
			++sp->pp_loopcnt;
			sp->pp_seq[IDX_LCP] ^= newseq;
		sp->pp_loopcnt = 0;
		if (sp->pp_link_state==SPPP_LINK_DOWN &&
		    (dev->flags & IFF_UP)) {
			sp->pp_link_state=SPPP_LINK_UP;
			printk (KERN_INFO "%s: protocol up\n", dev->name);
		/* Stolen from net/ipv4/devinet.c -- SIOCGIFADDR ioctl */
			for (ifa=in_dev->ifa_list; ifa != NULL;
				ifa=ifa->ifa_next) {
				if (strcmp(dev->name, ifa->ifa_label) == 0) 
					addr = ifa->ifa_local;
					mask = ifa->ifa_mask;
		if ((in_dev=dev->ip_ptr) != NULL)
			for (ifa=in_dev->ifa_list; ifa != NULL;
				ifa=ifa->ifa_next)
				if (strcmp(dev->name, ifa->ifa_label) == 0) 
					addr = ifa->ifa_local;
					mask = ifa->ifa_mask;
	struct net_device *dev = sp->pp_if;
	skb=alloc_skb(dev->hard_header_len+PPP_HEADER_LEN+LCP_HEADER_LEN+len,
	skb_reserve(skb,dev->hard_header_len);
	h->address = PPP_ALLSTATIONS;        /* broadcast address */
	h->control = PPP_UI;                 /* Unnumbered Info */
	h->protocol = htons (proto);         /* Link Control Protocol */
	lh->type = type;
	lh->ident = ident;
	lh->len = htons (LCP_HEADER_LEN + len);
	if (sp->pp_flags & PP_DEBUG) {
			dev->name,
		    	lh->ident, len);
				dev->name, 
				proto==PPP_LCP ? sppp_lcp_type_name (lh->type) :
				sppp_ipcp_type_name (lh->type), lh->ident,
				ntohs (lh->len));
	sp->obytes += skb->len;
	skb->priority=TC_PRIO_CONTROL;
	skb->dev = dev;
	skb->protocol = htons(PPP_IP);
	struct net_device *dev = sp->pp_if;
	skb=alloc_skb(dev->hard_header_len+PPP_HEADER_LEN+CISCO_PACKET_LEN,
	skb_reserve(skb, dev->hard_header_len);
	h->address = CISCO_MULTICAST;
	h->control = 0;
	h->protocol = htons (CISCO_KEEPALIVE);
	ch->type = htonl (type);
	ch->par1 = htonl (par1);
	ch->par2 = htonl (par2);
	ch->rel = -1;
	ch->time0 = htons ((u16) (t >> 16));
	ch->time1 = htons ((u16) t);
	if (sp->pp_flags & PP_DEBUG)
		printk (KERN_WARNING "%s: cisco output: <%xh %xh %xh %xh %xh-%xh>\n",
			dev->name,  ntohl (ch->type), ch->par1,
			ch->par2, ch->rel, ch->time0, ch->time1);
	sp->obytes += skb->len;
	skb->priority=TC_PRIO_CONTROL;
	skb->dev = dev;
 *	wp_sppp_close - close down a synchronous PPP or Cisco HDLC link
	WAN_ASSERT2((!sp),-ENODEV);
	sp->pp_link_state = SPPP_LINK_DOWN;
	sp->lcp.state = LCP_STATE_CLOSED;
	sp->ipcp.state = IPCP_STATE_CLOSED;
 *	wp_sppp_open - open a synchronous PPP or Cisco HDLC link
	WAN_ASSERT2((!sp),-ENODEV);
	if (!(sp->pp_flags & PP_CISCO)) {
	sp->pp_link_state = SPPP_LINK_DOWN;
 *	wp_sppp_reopen - notify of physical link loss
	WAN_ASSERT2((!sp),-ENODEV);
	if (!(sp->pp_flags & PP_CISCO))
		sp->lcp.magic = jiffies;
		++sp->pp_seq[IDX_LCP];
		sp->lcp.state = LCP_STATE_CLOSED;
		sp->ipcp.state = IPCP_STATE_CLOSED;
	sp->pp_link_state=SPPP_LINK_DOWN;
 *	wp_sppp_change_mtu - Change the link MTU
	if(new_mtu<128||new_mtu>PPP_MTU||(dev->flags&IFF_UP))
		return -EINVAL;
	dev->mtu=new_mtu;
 *	wp_sppp_do_ioctl - Ioctl handler for ppp/hdlc
	WAN_ASSERT2((!sp),-ENODEV);
	if(dev->flags&IFF_UP)
		return -EBUSY;
		return -EPERM;
			sp->pp_flags|=PP_CISCO;
			dev->type = ARPHRD_HDLC;
			sp->pp_flags&=~PP_CISCO;
			dev->type = ARPHRD_PPP;
			sp->pp_flags&=~PP_DEBUG;
			if(ifr->ifr_flags)
				sp->pp_flags|=PP_DEBUG;
			if(copy_to_user(ifr->ifr_data, &sp->pp_flags, sizeof(sp->pp_flags)))
				return -EFAULT;
			if(copy_from_user(&sp->pp_flags, ifr->ifr_data, sizeof(sp->pp_flags)))
				return -EFAULT;
			return -EINVAL;
 *	wp_sppp_attach - attach synchronous PPP/HDLC to a device
	struct net_device *dev = pd->dev;
	struct sppp *sp = &pd->sppp;
	sp->pp_next = spppq;
	sp->pp_loopcnt = 0;
	sp->pp_alivecnt = 0;
	sp->pp_seq[IDX_LCP] = 0;
	sp->pp_rseq[IDX_LCP] = 0;
	sp->pp_auth_flags = 0;
	sp->pp_flags = PP_KEEPALIVE|PP_CISCO|debug;/*PP_DEBUG;*/
	sp->lcp.magic = 0;
	sp->lcp.state = LCP_STATE_CLOSED;
	sp->ipcp.state = IPCP_STATE_CLOSED;
	sp->pp_if = dev;
	if (sp->dynamic_ip){
		DEBUG_EVENT("%s: Dynamic IP Addressing Enabled!\n",dev->name);
		DEBUG_EVENT("%s: Dynamic IP Addressing Disabled!\n",dev->name);
	if (strlen(sp->hwdevname) > WAN_IFNAME_SZ || 
	    strlen(sp->hwdevname) == 0){
				dev->name);
	sp->task_working=0;
	sp->local_ip=0;
	sp->remote_ip=0;
	INIT_WORK((&sp->sppp_task),sppp_bh,sp);
	INIT_WORK((&sp->sppp_task),sppp_bh);
	sp->task_working=0;
	dev->header_ops = &sppp_header_ops;
	dev->hard_header = sppp_hard_header;
	dev->tx_queue_len = 100;
	dev->type = ARPHRD_HDLC;
	dev->addr_len = 0;
	dev->hard_header_len = sizeof(struct ppp_header);
	dev->mtu = PPP_MTU;
	dev->do_ioctl = wp_sppp_do_ioctl;
	dev->get_stats = NULL;		/* Let the driver override these */
	dev->open = wp_sppp_open;
	dev->stop = wp_sppp_close;
	dev->change_mtu = wp_sppp_change_mtu;
	dev->flags = IFF_MULTICAST|IFF_POINTOPOINT|IFF_NOARP;
 *	wp_sppp_detach - release PPP resources from a device
	for (q = &spppq; (p = *q); q = &p->pp_next)
			*q = p->pp_next;
 * Analyze the LCP Configure-Request options list
 * send Configure-reject packet, containing only unknown options.
	struct net_device *dev = sp->pp_if;
	len -= 4; //sizeof(struct lcp_header);
	for (rlen=0; len>1 && p[1]; len-=p[1], p+=p[1]) {
			/* Magic number -- extract. */
			/* Async control character map -- check to be zero. */
			/* Maximum receive unit -- always OK. */
					dev->name, *packet_length);
			if (sp->myauth.proto == 0) {
					dev->name);
			if (sp->myauth.proto != authproto) {
						dev->name,
					       	sppp_proto_name(sp->myauth.proto),
			sp->pp_flags |= PP_NEEDAUTH;
			//if we configured for PAP -- ack it
		sppp_cp_send (sp, PPP_LCP, LCP_CONF_REJ, h->ident, rlen, buf);
	} while (--words);
	ctx->buf[0] = 0x67452301;
	ctx->buf[1] = 0xefcdab89;
	ctx->buf[2] = 0x98badcfe;
	ctx->buf[3] = 0x10325476;
	ctx->bytes[0] = 0;
	ctx->bytes[1] = 0;
	t = ctx->bytes[0];
	if ((ctx->bytes[0] = t + len) < t)
		ctx->bytes[1]++;	/* Carry from low to high */
	t = 64 - (t & 0x3f);	/* Space available in ctx->in (at least 1) */
		memcpy((md5byte *)ctx->in + 64 - t, buf, len);
	memcpy((md5byte *)ctx->in + 64 - t, buf, t);
	byteSwap(ctx->in, 16);
	wp_MD5Transform(ctx->buf, ctx->in);
	len -= t;
	/* Process data in 64-byte chunks */
		memcpy(ctx->in, buf, 64);
		byteSwap(ctx->in, 16);
		wp_MD5Transform(ctx->buf, ctx->in);
		len -= 64;
	memcpy(ctx->in, buf, len);
 * Final wrapup - pad to 64-byte boundary with the bit pattern 
 * 1 0* (64-bit count of bits processed, MSB-first)
	int count = ctx->bytes[0] & 0x3f;	/* Number of bytes in ctx->in */
	md5byte *p = (md5byte *)ctx->in + count;
	/* Bytes of padding needed to make 56 bytes (-8..55) */
	count = 56 - 1 - count;
		byteSwap(ctx->in, 16);
		wp_MD5Transform(ctx->buf, ctx->in);
		p = (md5byte *)ctx->in;
	byteSwap(ctx->in, 14);
	ctx->in[14] = ctx->bytes[0] << 3;
	ctx->in[15] = ctx->bytes[1] << 3 | ctx->bytes[0] >> 29;
	wp_MD5Transform(ctx->buf, ctx->in);
	byteSwap(ctx->buf, 4);
	memcpy(digest, ctx->buf, 16);
/* The four core functions - F1 is optimized somewhat */
	 (w += f(x,y,z) + in, w = (w<<s | w>>(32-s)) + x)
	struct net_device *dev = sp->pp_if;
	int len = skb->len;
		if (sp->pp_flags & PP_DEBUG)
				dev->name,  len);
	h = (struct lcp_header *)skb->data;
	if (sp->pp_flags & PP_DEBUG) {
		switch (sp->ipcp.state) {
			dev->name,  
			sppp_ipcp_type_name (h->type), h->ident, ntohs (h->len));
			sppp_print_bytes ((u8*) (h+1), len-4);
	if (len > ntohs (h->len))
		len = ntohs (h->len);
	switch (h->type) {
		/* Unknown packet type -- send Code-Reject packet. */
		sppp_cp_send (sp, PPP_IPCP, IPCP_CODE_REJ, ++sp->pp_seq[IDX_LCP], len, h);
			if (sp->pp_flags & PP_DEBUG)
					dev->name, len);
			if (!sp->dynamic_ip){
				remote_ip=wan_get_ip_address(sp->pp_if,WAN_POINTOPOINT_IP);	
				if (remote_ip == *(unsigned long*)&ipcp_h->data[0]){
					sppp_cp_send (sp, PPP_IPCP, LCP_CONF_ACK, h->ident,
					len-4, h+1);
					remote_ip=*(unsigned long*)&ipcp_h->data[0];
					DEBUG_EVENT("%s: IPCP Static: P-to-P verified: %u.%u.%u.%u\n",
							sp->pp_if->name,
					remote_ip = *(unsigned long*)&ipcp_h->data[0];
					sp->local_ip=wan_get_ip_address(sp->pp_if,WAN_LOCAL_IP);
					sp->remote_ip=wan_get_ip_address(sp->pp_if,WAN_POINTOPOINT_IP);	
					DEBUG_EVENT("%s: IPCP Static Refusing P-to-P %u.%u.%u.%u: Dynamic ip disabled!\n",
							sp->pp_if->name, NIPQUAD(remote_ip));
					DEBUG_EVENT("%s: IPCP Current Cfg: Local %u.%u.%u.%u P-to-P %u.%u.%u.%u\n",
							sp->pp_if->name,
							NIPQUAD(sp->local_ip),
							NIPQUAD(sp->remote_ip));
					if (++sp->dynamic_failures > 10){
						sppp_cp_send (sp, PPP_IPCP, IPCP_TERM_REQ, h->ident, 0, 0);
						sp->ipcp.state = IPCP_STATE_CLOSED;
						sp->dynamic_failures=0;
						sppp_cp_send (sp, PPP_IPCP, LCP_CONF_REJ, h->ident,
							len-4, h+1);
						switch (sp->ipcp.state) {
							sp->ipcp.state = IPCP_STATE_CLOSED;
				sp->remote_ip = *(unsigned long*)&ipcp_h->data[0];
				sppp_cp_send (sp, PPP_IPCP, LCP_CONF_ACK, h->ident,
				len-4, h+1);
			/* Send Configure-Ack packet. */
			sppp_cp_send (sp, PPP_IPCP, IPCP_CONF_ACK, h->ident,
			if (sp->ipcp.state == IPCP_STATE_ACK_RCVD)
				sp->ipcp.state = IPCP_STATE_OPENED;
				sp->ipcp.state = IPCP_STATE_ACK_SENT;
		if (h->ident != sp->ipcp.confid)
		switch (sp->ipcp.state) {
			sp->ipcp.state = IPCP_STATE_ACK_RCVD;
			sp->ipcp.state = IPCP_STATE_OPENED;
			if (sp->dynamic_ip){
				wan_schedule_task(&sp->sppp_task);
		if (h->ident != sp->ipcp.confid)
		if (ipcp_h->len >= 6) {
			if (!sp->dynamic_ip) {
				local_ip=wan_get_ip_address(sp->pp_if,WAN_LOCAL_IP);
				if (local_ip == *(unsigned long*)&ipcp_h->data[0]) {
					sppp_cp_send (sp, PPP_IPCP, LCP_CONF_REQ, h->ident,
						len-4, h+1);
					sp->ipcp.state = IPCP_STATE_ACK_SENT;
					local_ip=*(unsigned long*)&ipcp_h->data[0];	
							sp->pp_if->name,
					local_ip=*(unsigned long*)&ipcp_h->data[0]; 
							sp->pp_if->name, NIPQUAD(local_ip));
					DEBUG_EVENT("%s: IPCP Current Cfg: Local %u.%u.%u.%u P-to-P %u.%u.%u.%u\n",
							sp->pp_if->name,
							NIPQUAD(sp->local_ip),
							NIPQUAD(sp->remote_ip));
					sppp_cp_send (sp, PPP_IPCP, LCP_CONF_REJ, h->ident,
						len-4, h+1);
				sp->local_ip = *(unsigned long*)&ipcp_h->data[0];
				sppp_cp_send (sp, PPP_IPCP, LCP_CONF_REQ, h->ident,
					len-4, h+1);
				sp->ipcp.state = IPCP_STATE_ACK_SENT;
		if (h->ident != sp->ipcp.confid)
		if (sp->ipcp.state != IPCP_STATE_ACK_SENT)
			sp->ipcp.state = IPCP_STATE_CLOSED;
		/* Send Terminate-Ack packet. */
		sppp_cp_send (sp, PPP_IPCP, IPCP_TERM_ACK, h->ident, 0, 0);
		sp->ipcp.state = IPCP_STATE_CLOSED;
	if (sp->dynamic_ip){
		sp->local_ip=0;
		sp->remote_ip=0;
		if (wan_get_ip_address(sp->pp_if,WAN_LOCAL_IP)){
			wan_schedule_task(&sp->sppp_task);
	if (! sp->lcp.magic)
		sp->lcp.magic = jiffies;
	opt[2] = sp->lcp.magic >> 24;
	opt[3] = sp->lcp.magic >> 16;
	opt[4] = sp->lcp.magic >> 8;
	opt[5] = sp->lcp.magic;
	sp->lcp.confid = ++sp->pp_seq[IDX_LCP];
	sppp_cp_send (sp, PPP_LCP, LCP_CONF_REQ, sp->lcp.confid,
	if (sp->dynamic_ip){
		sp->ipcp.confid = ++sp->pp_seq[IDX_LCP];
		sppp_cp_send (sp, PPP_IPCP, IPCP_CONF_REQ, sp->ipcp.confid, 6, data);
		sp->ipcp.confid = ++sp->pp_seq[IDX_LCP];
		sppp_cp_send (sp, PPP_IPCP, IPCP_CONF_REQ, sp->ipcp.confid, 0,0);
	sp->pp_flags &= ~PP_TIMO;
	if (! (sp->pp_if->flags & IFF_UP) || (sp->pp_flags & PP_CISCO)) {
	switch (sp->lcp.state) {
		/* No ACK for Configure-Request, retry. */
		/* ACK got, but no Configure-Request for peer, retry. */
		sp->lcp.state = LCP_STATE_CLOSED;
		/* ACK sent but no ACK for Configure-Request, retry. */
		switch (sp->ipcp.state) {
			/* No ACK for Configure-Request, retry. */
			/* ACK got, but no Configure-Request for peer, retry. */
			sp->ipcp.state = IPCP_STATE_CLOSED;
			/* ACK sent but no ACK for Configure-Request, retry. */
	case LCP_CONF_REQ:   return ("conf-req");
	case LCP_CONF_ACK:   return ("conf-ack");
	case LCP_CONF_NAK:   return ("conf-nack");
	case LCP_CONF_REJ:   return ("conf-rej");
	case LCP_TERM_REQ:   return ("term-req");
	case LCP_TERM_ACK:   return ("term-ack");
	case LCP_CODE_REJ:   return ("code-rej");
	case LCP_PROTO_REJ:  return ("proto-rej");
	case LCP_ECHO_REQ:   return ("echo-req");
	case LCP_ECHO_REPLY: return ("echo-reply");
	case LCP_DISC_REQ:   return ("discard-req");
	case IPCP_CONF_REQ:   return ("conf-req");
	case IPCP_CONF_ACK:   return ("conf-ack");
	case IPCP_CONF_NAK:   return ("conf-nack");
	case IPCP_CONF_REJ:   return ("conf-rej");
	case IPCP_TERM_REQ:   return ("term-req");
	case IPCP_TERM_ACK:   return ("term-ack");
	case IPCP_CODE_REJ:   return ("code-rej");
	while (--len > 0)
		printk ("-%x", *p++);
 *	sppp_rcv -	receive and process a WAN PPP frame
	struct inode *inode = file->f_dentry->d_inode;
        dent = inode->i_private;
        dent = inode->u.generic_ip;
	if ((dent == NULL) || (dent->get_info == NULL)){
		return -ENOBUFS;
	pos = dent->get_info(page, dent->data, 0, 0);
	pos = dent->get_info(page, dent->data, 0, 0, 0);
	offs = file->f_pos;
		len = wp_min(pos - offs, count);
			return -EFAULT;
		file->f_pos += len;
	char* eos = str + strlen(str);		/* -> end of string */
	while ((eos > str) && strchr(s, *(eos - 1)))
		--eos;				/* strip trailing spaces */
	while (tokens[cnt] && (cnt < MAX_TOKENS - 1)) {
	struct inode *inode = file->f_dentry->d_inode;
		return -EIO;
	        dent = inode->i_private;
	        dent = inode->u.generic_ip;
	if ((dent == NULL) || (dent->get_info == NULL))
		return -EIO;
		return -ENOBUFS;
		return -EFAULT;	
		return -EINVAL;
	for (sp=spppq; sp; sp=sp->pp_next){
		dev = sp->pp_if;
		if (!strcmp(dev->name,token[0]) && toknum == 3){
					sprintf(msg,"%s: SyncPPP debug: on\n",dev->name);
					sp->pp_flags |= PP_DEBUG;
					sprintf(msg,"%s: SyncPPP debug: off\n",dev->name);
					sp->pp_flags &= ~PP_DEBUG;
	int mode = inode->i_mode;
	if (!current->euid){
	return -EACCES;
		return -ENODEV;
		return -ENOMEM;
	p->proc_fops = &router_fops;
	p->proc_iops = &router_inode;
	p->ops = &router_inode;
	p->nlink = 1;
	p->get_info = status_get_info;
        "----------------------------------------------------------------------------\n"
	"----------------------------------------------------------------------------\n";
	cnt += sizeof(stat_hdr) - 1;
	for (sp=spppq; sp; sp=sp->pp_next){
		dev = sp->pp_if;
			"| %-13s| %-9s| %-6s| %-12s| %-12s| %-10s |\n",
			dev->name, 
			(sp->pp_flags & PP_CISCO) ? "CHDLC" : "PPP",
			(sp->pp_flags & PP_DEBUG) ? "on" : "off",
			decode_lcp_state(sp->lcp.state),
			decode_ipcp_state(sp->ipcp.state),
			sp->pp_link_state ? "up" : "down");
	cnt += sprintf(&buf[cnt], "----------------------------------------------------------------------------\n");
		case LCP_STATE_CLOSED:        	/* LCP state: closed (conf-req sent) */
		case LCP_STATE_ACK_RCVD:	/* LCP state: conf-ack received */
			return "conf-ack rx";
		case LCP_STATE_ACK_SENT:      	/* LCP state: conf-ack sent */
			return "conf-ack tx";
		case IPCP_STATE_CLOSED:      	/* IPCP state: closed (conf-req sent) */
		case IPCP_STATE_ACK_RCVD:	/* IPCP state: conf-ack received */
			return "conf-ack rx";
		case IPCP_STATE_ACK_SENT:	/* IPCP state: conf-ack sent */
			return "conf-ack tx";
	dev=sp->pp_if;
	if (!dev || !sp->dynamic_ip) {
	dev=sp->pp_if;
	if (!sp->dynamic_ip || !sp->pp_if)
	if (test_and_set_bit(0,&sp->task_working)){
		DEBUG_EVENT("%s: Critical in sppp bh!\n",dev->name);
	if (sp->ipcp.state == IPCP_STATE_OPENED){
		int err=wan_set_ip_address(sp->pp_if,WAN_LOCAL_IP,sp->local_ip);
					dev->name,NIPQUAD(sp->local_ip));
					dev->name,NIPQUAD(sp->local_ip),err);
		err=wan_set_ip_address(sp->pp_if,WAN_POINTOPOINT_IP,sp->remote_ip);
			DEBUG_EVENT("%s: P-to-P IP Address %u.%u.%u.%u\n",
					dev->name,NIPQUAD(sp->remote_ip));
			DEBUG_EVENT("%s: Failed to set P-to-P IP Address %u.%u.%u.%u: Rc=%i\n",
					dev->name,NIPQUAD(sp->remote_ip),err);
		if (sp->gateway){
			if (dev->flags & IFF_UP){
						dev->name);
		wan_run_wanrouter(sp->hwdevname,dev->name,"script");
		sp->local_ip=0;
		sp->remote_ip=0;
					dev->name,NIPQUAD(sp->local_ip));
		if (wan_get_ip_address(sp->pp_if,WAN_LOCAL_IP)){
					dev->name);
			wan_set_ip_address(sp->pp_if,WAN_LOCAL_IP,sp->local_ip);
					dev->name,NIPQUAD(sp->local_ip));
	clear_bit(0,&sp->task_working);
./wanpipe_syncppp.c
* Copyright:	(c) 1995-1999 Sangoma Technologies Inc.
 *  o initialize protocol-specific fields of the adapter data space.
	if (conf->config_id != WANCONFIG_CHDLC) {
				  card->devname, conf->config_id);
		return -EINVAL;
	card->u.c.comm_port = 0;
	/* Initialize protocol-specific fields */
	card->mbox_off = PRI_BASE_ADDR_MB_STRUCT;
	mb = &card->wan_mbox;
	mb1 = &card->wan_mbox;
	if (!card->configured){
			card->hw_iface.peek(card->hw, 
				card->mbox_off+offsetof(wan_mbox_t, wan_return_code),
			if ((jiffies - timeout) > 1*HZ) break;
				card->devname);
			return -EIO;
		return -EIO;
		card->devname, u.str); 
	card->isr			= NULL;
	card->poll			= NULL;
	card->exec			= &wpft1_exec;
	card->wandev.update		= NULL;
 	card->wandev.new_if		= NULL;
	card->wandev.del_if		= NULL;
	card->wandev.state		= WAN_DUALPORT;
	card->wandev.udp_port   	= conf->udp_port;
	card->wandev.new_if_cnt = 0;
	card->u.c.state = WAN_DISCONNECTED;
	card->u.c.update_call_count = 0;
	card->wandev.ttl = 0x7F;
	card->wandev.electrical_interface = 0; 
	card->wandev.clocking = 0;
	port_num = card->u.c.comm_port;
       	card->wandev.bps = 0;
	card->wandev.mtu = MIN_LGTH_CHDLC_DATA_CFG;
         * Use this pointer to calculate the value of card->u.c.flags !
	mb1->wan_data_len = 0;
	mb1->wan_command = READ_CHDLC_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb1);
		return -EIO;
	card->flags_off = 
			((CHDLC_CONFIGURATION_STRUCT *)mb1->wan_data)->
    	card->intr_type_off = 
			card->flags_off +
	card->intr_perm_off = 
			card->flags_off +
	card->wandev.state = WAN_FT1_READY;
	printk(KERN_INFO "%s: FT1 Config Ready !\n",card->devname);
	wan_mbox_t* mbox = &card->wan_mbox;
		return -EFAULT;
	mbox->wan_opp_flag=0;
	len = mbox->wan_data_len;
		if(copy_from_user((void*)&mbox->wan_data, u_data, len)){
			return -EFAULT;
	if ((err=card->hw_iface.cmd(card->hw, card->mbox_off, mbox)) != 0){
		return -EIO;
		return -EFAULT;
	len = mbox->wan_data_len;
	if (len && u_data && copy_to_user(u_data, (void*)&mbox->wan_data, len)){
		return -EFAULT;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CHDLC_CODE_VERSION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		len = mb->wan_data_len;
		memcpy(str, mb->wan_data, len);
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_command;
			card->devname, cmd);
				card->devname);
			card->devname, cmd, err);
./sdla_ft1.c
* Copyright:	(c) 2003-2006 Sangoma Technologies Inc.
./sdla_usb.c
* Copyright:	(c) 1995-2001 Sangoma Technologies Inc.
#define IS_TE1_CARD(card)	IS_TE1(card->wandev.te_cfg)
#define IS_56K_CARD(card)	IS_56K(card->wandev.te_cfg)
						     "MSU INHIB",        "CLR RTB",          "SIB RX",           "FORCED RE-TX (PCR)",
 *  o initialize protocol-specific fields of the adapter data space.
	if (conf->config_id != WANCONFIG_SS7) {
				  card->devname, conf->config_id);
		return -EINVAL;
	card->hw_iface.getcfg(card->hw, SDLA_PCIEXTRAVER, &pciextraver);
		printk(KERN_INFO "%s: ERROR: SS7 firmware on invalid hardware!\n",card->devname);
		return -EPERM;
	card->u.s.comm_port = WANOPT_PRI;
	card->u.s.line_cfg_opt 		= conf->u.ss7.line_cfg_opt;
	card->u.s.modem_cfg_opt 	= conf->u.ss7.modem_cfg_opt;
	card->u.s.modem_status_timer 	= conf->u.ss7.modem_status_timer;
	card->u.s.api_options 		= conf->u.ss7.api_options;
	card->u.s.protocol_options 	= conf->u.ss7.protocol_options;
	card->u.s.stats_history_options	= conf->u.ss7.stats_history_options;
	card->u.s.max_length_msu_sif	= conf->u.ss7.max_length_msu_sif;
	card->u.s.max_unacked_tx_msus	= conf->u.ss7.max_unacked_tx_msus;
	card->u.s.link_inactivity_timer	= conf->u.ss7.link_inactivity_timer;
	card->u.s.t1_timer 		= conf->u.ss7.t1_timer;
	card->u.s.t2_timer 		= conf->u.ss7.t2_timer;
	card->u.s.t3_timer 		= conf->u.ss7.t3_timer;
	card->u.s.t4_timer_emergency 	= conf->u.ss7.t4_timer_emergency;	
	card->u.s.t4_timer_normal	= conf->u.ss7.t4_timer_normal;	
	card->u.s.t5_timer 		= conf->u.ss7.t5_timer;
	card->u.s.t6_timer 		= conf->u.ss7.t6_timer;
	card->u.s.t7_timer 		= conf->u.ss7.t7_timer;
	card->u.s.t8_timer 		= conf->u.ss7.t8_timer;
	card->u.s.n1 			= conf->u.ss7.n1;
	card->u.s.n2 			= conf->u.ss7.n2;
	card->u.s.tie 			= conf->u.ss7.tie;
	card->u.s.tin 			= conf->u.ss7.tin;
	card->u.s.suerm_error_threshold	= conf->u.ss7.suerm_error_threshold;
	card->u.s.suerm_number_octets	= conf->u.ss7.suerm_number_octets;
	card->u.s.suerm_number_sus	= conf->u.ss7.suerm_number_sus;
	card->u.s.sie_interval_timer	= conf->u.ss7.sie_interval_timer;
	card->u.s.sio_interval_timer	= conf->u.ss7.sio_interval_timer;
	card->u.s.sios_interval_timer	= conf->u.ss7.sios_interval_timer;
	card->u.s.fisu_interval_timer	= conf->u.ss7.fisu_interval_timer;
	switch(conf->u.ss7.protocol_specification) {
			card->u.s.protocol_specification = L2_PROTOCOL_ANSI;
			card->u.s.protocol_specification = L2_PROTOCOL_ITU;
			card->u.s.protocol_specification = L2_PROTOCOL_NTT;
	/* Initialize protocol-specific fields */
	card->mbox_off = PRI_BASE_ADDR_MB_STRUCT;
	card->wandev.ignore_front_end_status = conf->ignore_front_end_status;
	//ALEX_TODAY err=check_conf_hw_mismatch(card,conf->te_cfg.media);
	err = (card->hw_iface.check_mismatch) ? 
			card->hw_iface.check_mismatch(card->hw,conf->fe_cfg.media) : -EINVAL;
	if (IS_TE1_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_te_iface_init(&card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg   = card->hw_iface.fe_write;
		card->fe.read_fe_reg	= card->hw_iface.fe_read;
		card->wandev.fe_enable_timer = ss7_enable_timer;
		card->wandev.te_link_state = ss7_handle_front_end_state;
		conf->electrical_interface = 
		conf->clocking = WANOPT_EXTERNAL;
        }else if (IS_56K_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_56k_iface_init(&card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg   = card->hw_iface.fe_write;
		card->fe.read_fe_reg    = card->hw_iface.fe_read;
		card->fe.fe_status = FE_CONNECTED;
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
	mb = &card->wan_mbox;
	mb1 = &card->wan_mbox;
	if (!card->configured){
			card->hw_iface.peek(card->hw,
					    card->mbox_off+offsetof(wan_mbox_t, wan_return_code),
			if ((jiffies - timeout) > 1*HZ){ 
				card->devname);
			return -EIO;
			return -EIO;
		return -EIO;
		card->devname, u.str); 
	card->isr			= &wpc_isr;
	card->poll			= NULL;
	card->exec			= NULL;
	card->wandev.update		= &update;
 	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= &del_if;
	card->wandev.udp_port   	= conf->udp_port;
	card->disable_comm		= &disable_comm;
	card->wandev.new_if_cnt = 0;
	card->wandev.ttl = conf->ttl;
	card->wandev.electrical_interface = conf->electrical_interface; 
	if ((card->u.s.comm_port == WANOPT_SEC && conf->electrical_interface == WANOPT_V35)&&
	    card->type != SDLA_S514){
		printk(KERN_INFO "%s: ERROR - V35 Interface not supported on S508 %s port \n",
			card->devname, PORT(card->u.s.comm_port));
		return -EIO;
	card->wandev.clocking = conf->clocking;
	if (card->wandev.clocking) {
		card->wandev.bps = conf->bps;
        	card->wandev.bps = 0;
	card->wandev.mtu = MAX_LENGTH_MSU_SIF; 
         * Use this pointer to calculate the value of card->u.s.flags !
	mb1->wan_data_len = 0;
	mb1->wan_command = L2_READ_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb1);
		return -EIO;
	card->flags_off = 
			((L2_CONFIGURATION_STRUCT *)mb1->wan_data)->
    	card->intr_type_off = 
			card->flags_off +
	card->intr_perm_off = 
			card->flags_off +
	card->fe_status_off = 
			card->flags_off + 
	card->wandev.state = WAN_DUALPORT;
	card->u.s.state = WAN_DISCONNECTED;
	if (!card->wandev.piggyback){	
		if(err || (card->timer_int_enabled < MAX_INTR_TEST_COUNTER)) { 
					card->devname, card->timer_int_enabled);
					card->devname);
			return -EIO;
				card->devname, card->timer_int_enabled);
		card->configured = 1;
				card->devname);
		return -EIO;	
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	card->wandev.state = WAN_DISCONNECTED;
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
        if(!card->flags_off)
                return -ENODEV;
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical))
                return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
	if((ss7_priv_area=dev->priv) == NULL)
		return -ENODEV;
       	if(ss7_priv_area->update_comms_stats){
		return -EAGAIN;
	ss7_priv_area->update_comms_stats = 
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	ss7_priv_area->timer_int_enabled = TMR_INT_ENABLED_UPDATE;
		if(ss7_priv_area->update_comms_stats == 0)
                if ((jiffies - timeout) > (1 * HZ)){
    			ss7_priv_area->update_comms_stats = 0;
 			ss7_priv_area->timer_int_enabled &=
 			return -EAGAIN;
	ss7_private_area_t* ss7_priv_area = dev->priv;
		return -ENODEV;
	card = ss7_priv_area->card;
	mb = &card->wan_mbox;
				err= -EINVAL;
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			err=wan_bind_api_to_svc(ss7_priv_area,ifr->ifr_data);
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
				err= -EINVAL;
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			err=wan_unbind_api_from_svc(ss7_priv_area,ifr->ifr_data);
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
			err = ss7_priv_area->common.state;
			if (atomic_read(&ss7_priv_area->udp_pkt_len) != 0){
				return -EBUSY;
			atomic_set(&ss7_priv_area->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
			if (test_bit(0,&card->in_isr)){
				atomic_set(&ss7_priv_area->udp_pkt_len,0);
				return -EBUSY;
			wan_udp_pkt=(wan_udp_pkt_t*)ss7_priv_area->udp_pkt_data;
			if (copy_from_user(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				atomic_set(&ss7_priv_area->udp_pkt_len,0);
				return -EFAULT;
			spin_lock_irqsave(&card->wandev.lock, smp_flags);
			if (test_bit(0,&card->in_isr)) {
						card->devname,dev->name);
				atomic_set(&ss7_priv_area->udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
				return -EBUSY;
			spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
			if (atomic_read(&ss7_priv_area->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						card->devname,atomic_read(&ss7_priv_area->udp_pkt_len));
				atomic_set(&ss7_priv_area->udp_pkt_len,0);
				return -EINVAL;
			if (copy_to_user(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				atomic_set(&ss7_priv_area->udp_pkt_len,0);
				return -EFAULT;
			atomic_set(&ss7_priv_area->udp_pkt_len,0);
				return -EINVAL;
			usr_mb = (wan_mbox_t*)ifr->ifr_ifru.ifru_data;
				card->devname, cmd);
				return -EINVAL;
			if (copy_from_user(&ss7_priv_area->usr_cmd_mb.wan_command, 
					   &usr_mb->wan_command,SS7_CMD_BLOCK_SZ)){
				printk(KERN_INFO "%s: SS7 Cmd: Failed to copy mb \n",card->devname);
				return -EFAULT;
			if (ss7_priv_area->usr_cmd_mb.wan_data_len){
				if (copy_from_user(&ss7_priv_area->usr_cmd_mb.wan_data[0], 
						   &usr_mb->wan_data[0],
						   ss7_priv_area->usr_cmd_mb.wan_data_len)){
							card->devname, ss7_priv_area->usr_cmd_mb.wan_data_len);
					return -EFAULT;
			spin_lock_irqsave(&card->wandev.lock,flags);
			memcpy(&mb->wan_command,&ss7_priv_area->usr_cmd_mb.wan_command,SS7_CMD_BLOCK_SZ);
			if (ss7_priv_area->usr_cmd_mb.wan_data_len){
				memcpy(&mb->wan_data[0], 
				       &ss7_priv_area->usr_cmd_mb.wan_data[0],
				       ss7_priv_area->usr_cmd_mb.wan_data_len);
			if (mb->wan_command == L2_START && 
			    card->fe.fe_status != FE_CONNECTED &&
				err = usr_mb->wan_return_code = 0xFF;
				spin_unlock_irqrestore(&card->wandev.lock,flags);
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
					__FUNCTION__,mb->wan_command,err);
				if (mb->wan_command == L2_START && err==L2_INVALID_STATE_FOR_CMND){
				spin_unlock_irqrestore(&card->wandev.lock,flags);
				if (mb->wan_command == L2_START){
					set_bit(1,&card->comm_enabled);
				}else if (mb->wan_command == L2_RETRIEVAL_REQ_AND_FSNC){
					L2_RETRIEVAL_STRUCT *l2_ret=(L2_RETRIEVAL_STRUCT *)mb->wan_data;
					ss7_priv_area->ptr_first_MSU_bfr = 
						l2_ret->ptr_first_MSU_bfr;
					ss7_priv_area->number_MSUs =
						l2_ret->number_MSUs;
							card->devname,
							(u32)ss7_priv_area->ptr_first_MSU_bfr,
							ss7_priv_area->number_MSUs);
			memcpy(&ss7_priv_area->usr_cmd_mb.wan_command,&mb->wan_command,SS7_CMD_BLOCK_SZ);
			if (ss7_priv_area->usr_cmd_mb.wan_data_len){
				memcpy(&ss7_priv_area->usr_cmd_mb.wan_data[0],
				       &mb->wan_data[0], 
				       ss7_priv_area->usr_cmd_mb.wan_data_len);
			spin_unlock_irqrestore(&card->wandev.lock,flags);
			if (copy_to_user(&usr_mb->wan_command, 
					 &ss7_priv_area->usr_cmd_mb.wan_command,
				err= -EFAULT;
			if (ss7_priv_area->usr_cmd_mb.wan_data_len) {
				if (copy_to_user(&usr_mb->wan_data[0], 
						 &ss7_priv_area->usr_cmd_mb.wan_data[0], 
						 ss7_priv_area->usr_cmd_mb.wan_data_len)){
					err= -EFAULT;
			if (card->fe.fe_status == FE_CONNECTED){
				return -EINVAL;
			usr_mb = (wan_mbox_t*)ifr->ifr_ifru.ifru_data;
				card->devname, cmd);
				return -EINVAL;
			if (copy_from_user(&ss7_priv_area->usr_cmd_mb.wan_command, 
					   &usr_mb->wan_command,SS7_CMD_BLOCK_SZ)){
				printk(KERN_INFO "%s: SS7 Cmd: Failed to copy mb \n",card->devname);
				return -EFAULT;
			if (ss7_priv_area->usr_cmd_mb.wan_data_len){
				if (copy_from_user(&ss7_priv_area->usr_cmd_mb.wan_data[0], 
						   &usr_mb->wan_data[0],
						   ss7_priv_area->usr_cmd_mb.wan_data_len)){
							card->devname, ss7_priv_area->usr_cmd_mb.wan_data_len);
					return -EFAULT;
						card->devname);
				return  -EINVAL;
			spin_lock_irqsave(&card->wandev.lock,flags);
			memcpy(&mb->wan_command,&ss7_priv_area->usr_cmd_mb.wan_command,SS7_CMD_BLOCK_SZ);
			if (ss7_priv_area->usr_cmd_mb.wan_data_len){
				memcpy(&mb->wan_data[0], 
				       &ss7_priv_area->usr_cmd_mb.wan_data[0],
				       ss7_priv_area->usr_cmd_mb.wan_data_len);
			cur_msu_buf=mb->wan_data[0];
			if (cur_msu_buf >= ss7_priv_area->number_MSUs){
						card->devname,cur_msu_buf);
				err = -EINVAL;
				spin_unlock_irqrestore(&card->wandev.lock,flags);
			if (!ss7_priv_area->ptr_first_MSU_bfr){
						card->devname);
				err = -EINVAL;
				spin_unlock_irqrestore(&card->wandev.lock,flags);
			txbuf_off = ss7_priv_area->ptr_first_MSU_bfr;
				if (txbuf_off > card->u.s.txbuf_last_off){
					txbuf_off = card->u.s.txbuf_base_off;
			card->hw_iface.peek(card->hw, txbuf_off, &txbuf, sizeof(txbuf));
			card->hw_iface.peek(card->hw,
				  &mb->wan_data[0],
			mb->wan_data_len = txbuf.frame_length;
			memcpy(&ss7_priv_area->usr_cmd_mb.wan_command,&mb->wan_command,SS7_CMD_BLOCK_SZ);
			if (ss7_priv_area->usr_cmd_mb.wan_data_len){
				memcpy(&ss7_priv_area->usr_cmd_mb.wan_data[0],
				       &mb->wan_data[0], 
				       ss7_priv_area->usr_cmd_mb.wan_data_len);
			spin_unlock_irqrestore(&card->wandev.lock,flags);
			if (copy_to_user(&usr_mb->wan_command, 
					 &ss7_priv_area->usr_cmd_mb.wan_command,
				err= -EFAULT;
			if (ss7_priv_area->usr_cmd_mb.wan_data_len) {
				if (copy_to_user(&usr_mb->wan_data[0], 
						 &ss7_priv_area->usr_cmd_mb.wan_data[0], 
						 ss7_priv_area->usr_cmd_mb.wan_data_len)){
					err= -EFAULT;
				return -EINVAL;
			usr_mb = (wan_mbox_t*)ifr->ifr_ifru.ifru_data;
				card->devname, cmd);
				return -EINVAL;
			if (test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)){
				return -EBUSY;
				unsigned long txbuf_off = card->u.s.txbuf_off;
				card->hw_iface.peek(card->hw, txbuf_off, &txbuf, sizeof(txbuf));
					clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
					return -EBUSY;
			if (!usr_mb->wan_data_len || usr_mb->wan_data_len <= sizeof(api_tx_hdr_t)){
				printk(KERN_INFO "Tx: Buffer Length =%i\n", usr_mb->wan_data_len);
				clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
				return -ENODATA;
			if (usr_mb->wan_data_len > dev->mtu){
				clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
				return -EOVERFLOW;
			if (copy_from_user(ss7_priv_area->tx_data,usr_mb->wan_data,usr_mb->wan_data_len)){
				clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
				return -EFAULT;
			api_tx_hdr = (api_tx_hdr_t *)ss7_priv_area->tx_data;
			ss7_priv_area->tx_len =  usr_mb->buffer_length - sizeof(api_tx_hdr_t);
			if (ss7_send(card, (ss7_priv_area->tx_data+sizeof(api_tx_hdr_t)), 
					    ss7_priv_area->tx_len, api_tx_hdr->SIO)){
				clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
				return -EBUSY;
			++card->wandev.stats.tx_packets;
			card->wandev.stats.tx_bytes += ss7_priv_area->tx_len;
			clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
			return atomic_read(&ss7_priv_area->bh_buff_used);
				return -EINVAL;
			usr_mb = (wan_mbox_t*)ifr->ifr_ifru.ifru_data;
				card->devname, cmd);
				return -EINVAL;
			if (test_and_set_bit(RX_CRIT, (void*)&card->wandev.critical)){
				return -EBUSY;
			if (atomic_read(&ss7_priv_area->bh_buff_used) > 0){
				err=-ENODATA;
				add_wait_queue(&ss7_priv_area->sleep, &wait);
				current->state = TASK_INTERRUPTIBLE;
					if (atomic_read(&ss7_priv_area->bh_buff_used) > 0){
						err = -ERESTARTSYS;
				current->state = TASK_RUNNING;
				remove_wait_queue(&ss7_priv_area->sleep, &wait);
					clear_bit(RX_CRIT, (void*)&card->wandev.critical);
				return -EINVAL;
			usr_mb = (wan_mbox_t*)ifr->ifr_ifru.ifru_data;
				card->devname, cmd);
				return -EINVAL;
			if (atomic_read(&ss7_priv_area->bh_buff_used) == 0){
				return -ENODATA;
			if (test_and_set_bit(RX_CRIT, (void*)&card->wandev.critical)){
				return -EBUSY;
			skb  = ((bh_data_t *)&ss7_priv_area->bh_head[ss7_priv_area->bh_read])->skb;
				++card->wandev.stats.rx_errors;
				clear_bit(RX_CRIT, (void*)&card->wandev.critical);
				return -ENOBUFS;
			err = skb->len;
			if (copy_to_user(&usr_mb->wan_data[0], &skb->data[0], skb->len)){
				++card->wandev.stats.rx_errors;
				clear_bit(RX_CRIT, (void*)&card->wandev.critical);
				return -EFAULT;
			++card->wandev.stats.rx_packets;
			card->wandev.stats.rx_bytes +=err;
			clear_bit(RX_CRIT, (void*)&card->wandev.critical);
			err = -EOPNOTSUPP;
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
			card->devname, conf->name);
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
		return -ENOMEM;
	ss7_priv_area->card = card; 
	wan_reg_api(ss7_priv_area,dev,card->devname);
	WAN_TASKLET_INIT((&ss7_priv_area->common.bh_task),0,ss7_bh,(unsigned long)ss7_priv_area);
	strcpy(ss7_priv_area->if_name,conf->name);
	if(card->wandev.new_if_cnt > 0) {
		return -EEXIST;
	card->wandev.new_if_cnt++;
	ss7_priv_area->TracingEnabled = 0;
	ss7_priv_area->route_status = NO_ROUTE;
	ss7_priv_area->route_removed = 0;
	if ((ss7_priv_area->true_if_encoding = conf->true_if_encoding) == WANOPT_YES){
			card->devname);
			wandev->name);
	init_waitqueue_head(&ss7_priv_area->sleep);
	ss7_priv_area->sleep=NULL;
	if (strcmp(conf->usedby, "API") == 0){
		ss7_priv_area->common.usedby=API;
			wandev->name);
			wandev->name);
	init_timer(&ss7_priv_area->tx_timer);
	ss7_priv_area->tx_timer.function=tx_intr;
	ss7_priv_area->tx_timer.data=(unsigned long)card;
	dev->init = &if_init;
	dev->priv = ss7_priv_area;
	ss7_private_area_t* 	ss7_priv_area = dev->priv;
	sdla_t*			card = wandev->priv;
	WAN_TASKLET_KILL(&ss7_priv_area->common.bh_task);
	wan_unreg_api(ss7_priv_area, card->devname);
	ss7_private_area_t* ss7_priv_area = dev->priv;
	sdla_t* card = ss7_priv_area->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->do_ioctl		= &do_ioctl;
	dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= TX_TIMEOUT;
	/* Initialize media-specific parameters */
	dev->flags		|= IFF_POINTOPOINT;
	dev->flags		|= IFF_NOARP;
	if (ss7_priv_area->mc == WANOPT_YES){
		dev->flags 	|= IFF_MULTICAST;
	if (ss7_priv_area->true_if_encoding){
		dev->type	= ARPHRD_HDLC; /* This breaks the tcpdump */
		dev->type	= ARPHRD_PPP;
	dev->mtu		= card->wandev.mtu;
	if(ss7_priv_area->common.usedby == API) {
		dev->mtu += sizeof(api_tx_hdr_t);
	dev->hard_header_len	= 0;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start); //ALEX_TODAY wandev->maddr;
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end); //ALEX_TODAY wandev->maddr + wandev->msize - 1;
        dev->tx_queue_len = 100;
	ss7_private_area_t* ss7_priv_area = dev->priv;
	sdla_t* card = ss7_priv_area->card;
		return -EBUSY;
	ss7_priv_area->router_start_time = tv.tv_sec;
	ss7_priv_area->timer_int_enabled |= TMR_INT_ENABLED_CONFIG;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	ss7_private_area_t* ss7_priv_area = dev->priv;
	sdla_t* card = ss7_priv_area->card;
	dev->start=0;
	del_timer(&ss7_priv_area->tx_timer);
	/* TE1 - Unconfiging */
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
	if (test_bit(0,&card->comm_enabled)){
		card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
    	ss7_private_area_t* chan = dev->priv;
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++card->wandev.stats.collisions;
	printk (KERN_INFO "%s: Transmit timed out on %s\n", card->devname,dev->name);
 * o set tbusy flag (marks start of the transmission) to block a timer-based
 *		non-0	packet may be re-transmitted (tbusy must be set)
	ss7_private_area_t *ss7_priv_area = dev->priv;
	sdla_t *card = ss7_priv_area->card;
	++card->wandev.stats.tx_errors;
		 * tx-done interrupt.
			card->devname, dev->name);
	if (dev->tbusy){
		 * kick start the device by making dev->tbusy = 0.  We expect 
                ++card->wandev.stats.collisions;
		if((jiffies - ss7_priv_area->tick_counter) < (5 * HZ)) {
      	if(card->type != SDLA_S514){
    	if(test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
					card->wandev.name,card->wandev.critical);
                ++card->wandev.stats.tx_dropped;
	if(card->wandev.state != WAN_CONNECTED){
       		++card->wandev.stats.tx_dropped;
	}else if(!skb->protocol){
        	++card->wandev.stats.tx_errors;
		void* data = skb->data;
		unsigned len = skb->len;
			++card->wandev.stats.tx_dropped;
		SIO = api_tx_hdr->SIO;
		len -= sizeof(api_tx_hdr_t);
			++card->wandev.stats.tx_packets;
                        card->wandev.stats.tx_bytes += len;
		 	dev->trans_start = jiffies;
		 * Delay TX_INTR_TIMEOUT before re-triggering
		del_timer(&ss7_priv_area->tx_timer);
		ss7_priv_area->tx_timer.expires=jiffies+TX_INTR_TIMEOUT;
		add_timer(&ss7_priv_area->tx_timer);
	clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
	if(card->type != SDLA_S514){
 * Get ethernet-style interface statistics.
	if ((ss7_priv_area=dev->priv) == NULL)
	my_card = ss7_priv_area->card;
	return &my_card->wandev.stats; 
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_SS7_CODE_VERSION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		len = mb->wan_data_len;
		memcpy(str, mb->wan_data, len);
/*-----------------------------------------------------------------------------
	wan_mbox_t *mbox = &card->wan_mbox;
	mbox->wan_data_len = data_length;  
	memcpy(mbox->wan_data, data, data_length);
	mbox->wan_command = L2_SET_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
		printk(KERN_INFO "Error offset: 0x%02X\n", mbox->wan_data_len);               
 * Set interrupt mode -- HDLC Version.
	wan_mbox_t* mb = &card->wan_mbox;
		 (L2_INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->L2_interrupt_triggers 	= mode;
	int_data->IRQ				= card->wandev.irq; // ALEX_TODAY card->hw.irq;
	int_data->interrupt_timer               = 1;
	mb->wan_data_len = sizeof(L2_INT_TRIGGERS_STRUCT);
	mb->wan_command = L2_SET_INTERRUPT_TRIGGERS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t* mb = &card->wan_mbox;
		 (L2_INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->L2_interrupt_triggers 	= 0;
	int_data->IRQ				= card->wandev.irq; // ALEX_TODAY card->hw.irq;
	int_data->interrupt_timer               = 1;
	mb->wan_data_len = sizeof(L2_INT_TRIGGERS_STRUCT);
	mb->wan_command = L2_SET_INTERRUPT_TRIGGERS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	mb->wan_command = L2_STOP;
	mb->wan_data_len = 0;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	clear_bit(0,&card->comm_enabled);	
	wan_mbox_t* mb = &card->wan_mbox;
	if (!test_bit(1,&card->comm_enabled)){
	mb->wan_command = L2_STOP;
	mb->wan_data_len = 0;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	clear_bit(1,&card->comm_enabled);
	wan_mbox_t* mb = &card->wan_mbox;
	if (test_bit(0,&card->comm_enabled))
	mb->wan_data_len = 0;
	mb->wan_command = L2_POWER_ON;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	set_bit(0,&card->comm_enabled);
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_COMMS_ERROR_STATS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = L2_READ_OPERATIONAL_STATS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
	if(ss7_priv_area->update_comms_stats == 3) {
			card->wandev.fe_iface.read_alarm(&card->fe, 0); 
			card->wandev.fe_iface.read_pmon(&card->fe, 0); 
			card->wandev.fe_iface.read_alarm(&card->fe, 1); 
	}else if(ss7_priv_area->update_comms_stats == 2) {
		err_stats = (COMMS_ERROR_STATS_STRUCT *)mb->wan_data;
		card->wandev.stats.rx_over_errors = 
				err_stats->Rx_overrun_err_count;
		card->wandev.stats.rx_crc_errors = 
				err_stats->CRC_err_count;
		card->wandev.stats.rx_frame_errors = 
				err_stats->Rx_abort_count;
		card->wandev.stats.rx_fifo_errors = 
				err_stats->Rx_dis_pri_bfrs_full_count; 
		card->wandev.stats.rx_missed_errors =
				card->wandev.stats.rx_fifo_errors;
	//	card->wandev.stats.tx_aborted_errors =
	//			err_stats->sec_Tx_abort_count;
		op_stats = (L2_OPERATIONAL_STATS_STRUCT *)mb->wan_data;
		card->wandev.stats.rx_length_errors=0;
		card->wandev.stats.rx_length_errors =
			(op_stats->Rx_MSU_discard_short_count +
			op_stats->Rx_MSU_discard_long_count);
 *	Return:	0 - o.k.
 *		1 - no transmit buffers available
	unsigned long txbuf_off = card->u.s.txbuf_off;
	card->hw_iface.peek(card->hw, txbuf_off, &txbuf, sizeof(txbuf));
	card->hw_iface.poke(card->hw, txbuf.ptr_data_bfr, data, len);
	card->hw_iface.poke(card->hw, txbuf_off, &txbuf, sizeof(txbuf));
	card->u.s.txbuf_off += sizeof(L2_MSU_TX_STATUS_EL_STRUCT);
	if (card->u.s.txbuf_off > card->u.s.txbuf_last_off)
		card->u.s.txbuf_off = card->u.s.txbuf_base_off;
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_command;
			card->devname, cmd);
	---- SECONDARY PORT NOT ENABLED -------
				card->devname);
			card->devname, cmd, err);
	sdla_t *card = chan->card;
		len = skb->len;
			card->wandev.stats.rx_packets++;
			card->wandev.stats.rx_bytes += len;
			++card->wandev.stats.rx_dropped;
	WAN_TASKLET_END(&chan->common.bh_task);
			card->devname);
			,card->devname);
	wan_mbox_t *mbox = &card->wan_mbox;
	ss7_private_area_t *chan = dev->priv;
	int len=sizeof(wan_mbox_t)-SIZEOF_MB_DATA_BFR+mbox->wan_data_len;
	if (!chan->common.sk){
		DEBUG_EVENT("%s: OOB MSG: No sock buffers\n",card->devname);
	memcpy(&usr_mb->wan_command,&mbox->wan_command,SS7_CMD_BLOCK_SZ);
	if (mbox->wan_data_len > 0){
		memcpy(&usr_mb->wan_data[0], &mbox->wan_data[0], mbox->wan_data_len);
	usr_mb->wan_return_code = chan->L2_state;
	skb->pkt_type = WAN_PACKET_ERR;
	skb->dev=chan->common.dev;
	skb->protocol=htons(SS7_PROT);
	if (wanpipe_api_sock_rx(skb,chan->common.dev,chan->common.sk) != 0){
				card->devname);
//			card->devname, dev->name, mbox->command);
	flags = card->u.s.flags;
	if (!flags->interrupt_info_struct.interrupt_type){
		if((my_card = card->next)){
			flags = my_card->u.s.flags;
			if (flags->interrupt_info_struct.interrupt_type){
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	card->in_isr = 1;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
				card->devname);
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical)) {
	if(card->type != SDLA_S514) {
		if(test_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
				card->devname, card->wandev.critical);
			card->in_isr = 0;
			card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
			ss7_private_area_t *chan=dev->priv;
			if (chan->common.usedby == API){
		++ card->timer_int_enabled;
			card->hw_iface.peek(card->hw, 
					    card->fe_status_off,
			card->hw_iface.poke(card->hw, 
					    card->fe_status_off,
			card->devname,
	card->in_isr = 0;
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	unsigned long rxbuf_off = card->u.s.rxmb_off;
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	card->hw_iface.peek(card->hw, rxbuf_off, &rxbuf, sizeof(rxbuf));
			card->devname, rxbuf_off, rxbuf.opp_flag);
		printk(KERN_INFO "%s: Critical router failure ...!!!\n", card->devname);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	ss7_priv_area = dev->priv;
					card->devname);
		++card->wandev.stats.rx_dropped;
	card->hw_iface.peek(card->hw, addr, buf, len);
	api_rx_hdr = (api_rx_hdr_t*)&skb->data[0x00];
	api_rx_hdr->SIO = rxbuf.SIO;
	api_rx_hdr->time_stamp = rxbuf.time_stamp;
	skb->protocol = htons(PVC_PROT);
	skb->dev      = dev;
	skb->pkt_type = WAN_PACKET_DATA;
		++card->wandev.stats.rx_dropped;
	wake_up_interruptible(&ss7_priv_area->sleep);
	WAN_TASKLET_SCHEDULE(&ss7_priv_area->common.bh_task);
	card->hw_iface.poke(card->hw, rxbuf_off, &rxbuf, sizeof(rxbuf));
	card->u.s.rxmb_off += sizeof(L2_MSU_RX_STATUS_EL_STRUCT);
	if (card->u.s.rxmb_off > card->u.s.rxbuf_last_off){
		card->u.s.rxmb_off = card->u.s.rxbuf_base_off;
 *    2) Reading board-level statistics for updating the proc file system.
        dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
        ss7_priv_area = dev->priv;
	if (ss7_priv_area->timer_int_enabled & TMR_INT_ENABLED_CONFIG) {
		ss7_priv_area->timer_int_enabled &= ~TMR_INT_ENABLED_CONFIG;
		ss7_priv_area->timer_int_enabled |= TMR_INT_ENABLED_L2_HIST;
		ss7_priv_area->L2_hist_counter = 0;
       	if(ss7_priv_area->timer_int_enabled & TMR_INT_ENABLED_UDP) {
		ss7_priv_area->timer_int_enabled &= ~TMR_INT_ENABLED_UDP;
	if(ss7_priv_area->timer_int_enabled & TMR_INT_ENABLED_UPDATE) {
                if(!(-- ss7_priv_area->update_comms_stats)) {
			ss7_priv_area->timer_int_enabled &= 
	if(ss7_priv_area->timer_int_enabled & TMR_INT_ENABLED_L2_HIST) {
		if((++ ss7_priv_area->L2_hist_counter) == 50) {
			ss7_priv_area->L2_hist_counter = 0; 
	if (ss7_priv_area->timer_int_enabled & TMR_INT_ENABLED_TE) {
		card->wandev.fe_iface.polling(&card->fe);
		ss7_priv_area->timer_int_enabled &= ~TMR_INT_ENABLED_TE;
        if(!ss7_priv_area->timer_int_enabled) {
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (dev == NULL || ((ss7_priv_area=dev->priv) == NULL))
	ss7_priv_area->timer_int_enabled |= TMR_INT_ENABLED_TE;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
/*------------------------------------------------------------------------------
	- set_ss7_config() used to set configuration options on the board
------------------------------------------------------------------------------*/
	if(card->wandev.clocking){
		cfg.baud_rate = card->wandev.bps;
	cfg.line_config_options = (card->wandev.electrical_interface == WANOPT_RS232) ?
	cfg.modem_config_options	= card->u.s.modem_cfg_opt;
	cfg.modem_status_timer		= card->u.s.modem_status_timer;
	cfg.L2_API_options		= card->u.s.api_options;
	cfg.L2_protocol_options		= card->u.s.protocol_options;
	cfg.L2_protocol_specification	= card->u.s.protocol_specification;
	cfg.L2_stats_history_options	= card->u.s.stats_history_options;
	cfg.max_length_MSU_SIF		= card->u.s.max_length_msu_sif; 
	cfg.max_unacked_Tx_MSUs		= card->u.s.max_unacked_tx_msus; 
	cfg.link_inactivity_timer       = card->u.s.link_inactivity_timer;
	cfg.T1_timer			= card->u.s.t1_timer;
	cfg.T2_timer 			= card->u.s.t2_timer;
	cfg.T3_timer 			= card->u.s.t3_timer;
	cfg.T4_timer_emergency		= card->u.s.t4_timer_emergency;
	cfg.T4_timer_normal		= card->u.s.t4_timer_normal;
	cfg.T5_timer			= card->u.s.t5_timer;
	cfg.T6_timer			= card->u.s.t6_timer;
	cfg.T7_timer 			= card->u.s.t7_timer;
	cfg.T8_timer			= card->u.s.t8_timer;
	cfg.N1				= card->u.s.n1;
	cfg.N2				= card->u.s.n2;
	cfg.Tin				= card->u.s.tin;
	cfg.Tie				= card->u.s.tie;
	cfg.SUERM_error_threshold	= card->u.s.suerm_error_threshold;
	cfg.SUERM_number_octets		= card->u.s.suerm_number_octets;
	cfg.SUERM_number_SUs		= card->u.s.suerm_number_sus;
	cfg.SIE_interval_timer		= card->u.s.sie_interval_timer;
	cfg.SIO_interval_timer		= card->u.s.sio_interval_timer;
	cfg.SIOS_interval_timer		= card->u.s.sios_interval_timer;
	cfg.FISU_interval_timer		= card->u.s.fisu_interval_timer;
	wan_mbox_t	*mbox = &card->wan_mbox;
	mbox->wan_data_len = 0;
	mbox->wan_command = READ_GLOBAL_EXCEPTION_CONDITION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		switch(mbox->wan_return_code) {
				card->hw_iface.peek(card->hw,
					            card->fe_status_off, 
				card->fe.fe_param.k56_param.RR8_reg_56k = 
				card->fe.fe_param.k56_param.RRA_reg_56k = 
				card->fe.fe_param.k56_param.RRC_reg_56k = 
				card->wandev.fe_iface.read_alarm(&card->fe, 0); 
				card->wandev.fe_iface.isr(&card->fe);
			if ((mbox->wan_data[0] & (DCD_HIGH | CTS_HIGH)) == (DCD_HIGH | CTS_HIGH)){
				card->fe.fe_status = FE_CONNECTED;
				card->fe.fe_status = FE_DISCONNECTED;
				card->devname);
			switch(mbox->wan_data[0] & (DCD_HIGH | CTS_HIGH)) {
					printk(KERN_INFO "%s: DCD high, CTS low\n",card->devname);
                                        printk(KERN_INFO "%s: DCD low, CTS high\n",card->devname);
                                        printk(KERN_INFO "%s: DCD high, CTS high\n",card->devname);
                                        printk(KERN_INFO "%s: DCD low, CTS low\n",card->devname);
				card->devname, mbox->wan_return_code);
	wan_mbox_t		*mb = &card->wan_mbox;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (!dev) return -EINVAL;	
	ss7_priv_area = dev->priv;
	mb->wan_data_len = 0;
	mb->wan_command = L2_READ_EXCEPTION_CONDITION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	ss7_priv_area->L2_state = mb->wan_return_code;
			card->u.s.state=WAN_CONNECTED;
			if (card->wandev.ignore_front_end_status == WANOPT_YES ||
			    card->fe.fe_status == FE_CONNECTED){
					card->devname,mb->wan_data[0]);
						card->devname);
						card->devname);
						card->devname);
			printk(KERN_INFO "%s: RB cleared\n", card->devname);
			printk(KERN_INFO "%s: BSNT\n", card->devname);
						card->devname);
						card->devname);
						card->devname);
						card->devname);
						card->devname);
						card->devname);
					card->devname, err);
	wan_mbox_t *mb = &card->wan_mbox;
	wan_udp_pkt_t *wan_udp_pkt = (wan_udp_pkt_t *) ss7_priv_area->udp_pkt_data;
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	switch(wan_udp_pkt->wan_udp_command) {
	     if (!ss7_priv_area->TracingEnabled) {
		mb->wan_data_len = sizeof(LINE_TRACE_CONFIG_STRUCT);
		mb->wan_command = SET_TRACE_CONFIGURATION;
		((LINE_TRACE_CONFIG_STRUCT *)mb->wan_data)->
		((LINE_TRACE_CONFIG_STRUCT *)mb->wan_data)->
			trace_config |= wan_udp_pkt->wan_udp_data[0];
		DEBUG_EVENT("%s: Enableing SS7 Trace: ",card->devname);
		if (wan_udp_pkt->wan_udp_data[0] & TRACE_FISU){
		if (wan_udp_pkt->wan_udp_data[0] & TRACE_LSSU){
		if (wan_udp_pkt->wan_udp_data[0] & TRACE_MSU){
		((LINE_TRACE_CONFIG_STRUCT *)mb->wan_data)->
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			card->TracingEnabled = 0;
			wan_udp_pkt->wan_udp_return_code = err;
			mb->wan_data_len = 0;
		mb->wan_data_len = 0;
		mb->wan_command = READ_TRACE_CONFIGURATION;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			ss7_priv_area->TracingEnabled = 0;
			wan_udp_pkt->wan_udp_return_code = err;
			mb->wan_data_len = 0;
			mb->wan_data) -> ptr_trace_stat_el_cfg_struct;
		card->hw_iface.peek(card->hw, trace_status_cfg_addr, 
		ss7_priv_area->start_trace_addr = trace_cfg_struct.
		ss7_priv_area->number_trace_elements = 
		ss7_priv_area->end_trace_addr = (unsigned long)
				 ss7_priv_area->start_trace_addr + 
				 (ss7_priv_area->number_trace_elements - 1));
		ss7_priv_area->base_addr_trace_buffer = 
		ss7_priv_area->end_addr_trace_buffer = 
		ss7_priv_area->curr_trace_addr = 
		ss7_priv_area->available_buffer_space = 2000 - 
							  sizeof(struct iphdr) -
							  sizeof(struct udphdr) -
						      	  sizeof(wan_mgmt_t)-
							  sizeof(wan_cmd_t)-
	     wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
	     mb->wan_data_len = 0;
	     ss7_priv_area->TracingEnabled = 1;
	     if (ss7_priv_area->TracingEnabled) {
		mb->wan_data_len = sizeof(LINE_TRACE_CONFIG_STRUCT);
		mb->wan_command = SET_TRACE_CONFIGURATION;
		((LINE_TRACE_CONFIG_STRUCT *)mb->wan_data)->
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	     ss7_priv_area->TracingEnabled = 0;
	     wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
	     mb->wan_data_len = 0;
	     if (!ss7_priv_area->TracingEnabled) {
		wan_udp_pkt->wan_udp_return_code = 1;
		mb->wan_data_len = 0;
	     wan_udp_pkt->wan_udp_ss7_ismoredata = 0x00;
			     card->devname,
			     ss7_priv_area->number_trace_elements,
			     ss7_priv_area->base_addr_trace_buffer,
			     ss7_priv_area->curr_trace_addr);
	     for (frames=0; frames < ss7_priv_area->number_trace_elements; frames++){
			&wan_udp_pkt->wan_udp_data[buffer_length];
		card->hw_iface.peek(card->hw, ss7_priv_area->curr_trace_addr,
			wan_udp_pkt->wan_udp_ss7_ismoredata = 0x01;
		if( (ss7_priv_area->available_buffer_space - buffer_length)
			wan_udp_pkt->wan_udp_ss7_ismoredata = 0x01;
		trace_pkt->status = trace_element_struct.trace_type;
		trace_pkt->time_stamp =
		trace_pkt->real_length =
		real_len = trace_pkt->real_length;
			trace_pkt->data_avail = 0x00;
			trace_pkt->data_avail = 0x01;
				     ss7_priv_area->end_addr_trace_buffer + 1){
				tmp = ss7_priv_area->end_addr_trace_buffer - data_ptr + 1;
				card->hw_iface.peek(card->hw, data_ptr,
					  trace_pkt->data,tmp);
				data_ptr = ss7_priv_area->base_addr_trace_buffer;
			card->hw_iface.peek(card->hw, data_ptr,
				  &trace_pkt->data[tmp], real_len - tmp);
		card->hw_iface.poke(card->hw, ss7_priv_area->curr_trace_addr, &ut_char, 1);
		ss7_priv_area->curr_trace_addr += sizeof(TRACE_STATUS_ELEMENT_STRUCT);
		if ( ss7_priv_area->curr_trace_addr > ss7_priv_area->end_trace_addr ) {
			ss7_priv_area->curr_trace_addr = ss7_priv_area->start_trace_addr;
		if(trace_pkt->data_avail == 0x01) {
			buffer_length += real_len - 1;
	     if (frames == ss7_priv_area->number_trace_elements){
		wan_udp_pkt->wan_udp_ss7_ismoredata = 0x01;
	     wan_udp_pkt->wan_udp_ss7_num_frames = frames;
	     mb->wan_data_len = buffer_length;
	     wan_udp_pkt->wan_udp_data_len = buffer_length; 
	     wan_udp_pkt->wan_udp_return_code = COMMAND_OK; 
		((unsigned char *)wan_udp_pkt->wan_udp_data )[0] =
		((unsigned char *)wan_udp_pkt->wan_udp_data )[1] =
		wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
		wan_udp_pkt->wan_udp_data_len = 2;
		mb->wan_data_len = 2;
		ss7_priv_area->router_up_time = tv.tv_sec - 
				ss7_priv_area->router_start_time;
		*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
				ss7_priv_area->router_up_time;	
		mb->wan_data_len = sizeof(unsigned long);
		wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
		wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
			card->wandev.fe_iface.process_udp(
					&card->fe, 
					&wan_udp_pkt->wan_udp_cmd,
					&wan_udp_pkt->wan_udp_data[0]);
			card->wandev.fe_iface.process_udp(
					&card->fe, 
					&wan_udp_pkt->wan_udp_cmd,
					&wan_udp_pkt->wan_udp_data[0]);
			if (wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE){
				wan_udp_pkt->wan_udp_data_len = sizeof(unsigned char); 
				wan_udp_pkt->wan_udp_return_code = CMD_OK;
				wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
		mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
		wan_udp_pkt->wan_udp_ss7_num_frames = card->wandev.config_id;
		wan_udp_pkt->wan_udp_return_code = CMD_OK;
		mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
		wan_udp_pkt->wan_udp_data[0] = WAN_LINUX_PLATFORM;
		wan_udp_pkt->wan_udp_return_code = CMD_OK;
		mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
		mb->wan_command = wan_udp_pkt->wan_udp_command;
		mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
		if (mb->wan_data_len){
			memcpy(&mb->wan_data, (unsigned char *) wan_udp_pkt->
						wan_udp_data, mb->wan_data_len);
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		memcpy(&wan_udp_pkt->wan_udp_hdr.wan_cmd, mb, sizeof(wan_cmd_t)); 
		if (mb->wan_data_len) {
			memcpy(&wan_udp_pkt->wan_udp_data, &mb->wan_data, 
							mb->wan_data_len); 
	wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = L2_READ_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	tx_config_off = ((L2_CONFIGURATION_STRUCT *)mb->wan_data)->
	rx_config_off = ((L2_CONFIGURATION_STRUCT *)mb->wan_data)->
	card->hw_iface.peek(card->hw, tx_config_off, &tx_config, sizeof(tx_config));
	card->hw_iface.peek(card->hw, rx_config_off, &rx_config, sizeof(rx_config));
       	card->u.s.txbuf_base_off = tx_config.base_addr_Tx_status_elements;
       	card->u.s.txbuf_last_off = 
       		card->u.s.txbuf_base_off +
		(tx_config.number_Tx_status_elements - 1) *
       	card->u.s.rxbuf_base_off = rx_config.base_addr_Rx_status_elements;
       	card->u.s.rxbuf_last_off =
       		card->u.s.rxbuf_base_off +
		(rx_config.number_Rx_status_elements - 1) * 
      	card->u.s.txbuf_off = tx_config.next_Tx_status_element_to_use;
       	card->u.s.rxmb_off = rx_config.next_Rx_status_element_to_use;
        card->u.s.rx_base_off = rx_config.base_addr_Rx_status_elements;
	wan_mbox_t* mb = &card->wan_mbox;
	card->timer_int_enabled = 0;
			mb->wan_data_len  = 0;
			mb->wan_command = READ_SS7_CODE_VERSION;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	ss7_priv_area = dev->priv;
        if (card->wandev.state != state){
                                card->devname);
                                card->devname);
                                card->devname);
                card->wandev.state = state;
		ss7_priv_area->common.state = state;
	if (test_bit(0,&card->comm_enabled)){
			card->devname);
		return -EINVAL;
	card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
		int	err = -EINVAL;
			card->devname, 
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
					card->devname,
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);	
		int	err = -EINVAL;
			card->devname);
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
				card->devname);
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
				card->devname);
		return -EINVAL;	
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, 
				card->devname);
		card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
		return -EINVAL;
		card->wandev.fe_iface.read_alarm(&card->fe, 1); 
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, 
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, (APP_INT_ON_TX_FRAME | APP_INT_ON_TIMER));
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	spin_lock_irqsave(&card->wandev.lock, *smp_flags);
        if (card->next){
        	spin_lock(&card->next->wandev.lock);
        if (card->next){
        	spin_unlock(&card->next->wandev.lock);
        spin_unlock_irqrestore(&card->wandev.lock, *smp_flags);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if ((ss7_priv_area=dev->priv) == NULL){
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0x00;
        mb->wan_command = L2_READ_HISTORY_TABLE;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        if ((err != COMMAND_OK) || !mb->wan_data_len) {
		sprintf(outs, "%s: ", card->devname);
                phist = (L2_HISTORY_STRUCT *)&mb->wan_data[i];
		switch(phist->function) {
		sprintf(outs+strlen(outs), " (Time: %u)", phist->time);
                sprintf(outs, "  Action: 0x%04X - ", phist->action);
		switch(phist->function) {
				if(phist->status_before_action & 
                                	prt_hist(phist->action, act_LSC_0, outs);
				else if(phist->status_before_action & LSC_STAT_PROCESSOR_OUTAGE) {
                                	prt_hist(phist->action, act_LSC_1, outs);
                               		prt_hist(phist->action, act_LSC_2, outs);
                       		prt_hist(phist->action, act_IAC, outs);
                                prt_hist(phist->action, act_DAEDR, outs);
                                prt_hist(phist->action, act_DAEDT, outs);
                              	prt_hist(phist->action, act_TXC, outs);
                                prt_hist(phist->action, act_RXC, outs);
                                prt_hist(phist->action, act_AERM, outs);
                                prt_hist(phist->action, act_SUERM, outs);
                                prt_hist(phist->action, act_CC, outs);
                                prt_hist(phist->action, act_EIM, outs);
		sprintf(outs, "  State : 0x%04X - ", phist->status_before_action);
		switch(phist->function) {
                       		prt_hist(phist->status_before_action, state_LSC, outs);
                       		prt_hist(phist->status_before_action, state_IAC, outs);
                       		prt_hist(phist->status_before_action, state_DAEDR, outs);
                                prt_hist(phist->status_before_action, state_DAEDT, outs);
                                prt_hist(phist->status_before_action, state_TXC, outs);
                                prt_hist(phist->status_before_action, state_RXC, outs);
                                prt_hist(phist->status_before_action, state_AERM, outs);
                                prt_hist(phist->status_before_action, state_SUERM, outs);
                                prt_hist(phist->status_before_action, state_CC, outs);
                              	prt_hist(phist->status_before_action, state_EIM, outs);
		if((phist->function == L2_HISTORY_TXC) || (phist->function == L2_HISTORY_RXC)) {
			if(phist->function == L2_HISTORY_TXC) {
                        	sprintf(outs, "Tx LSSU SF: 0x%02X ", phist->LSSU_SF);
			if(phist->function == L2_HISTORY_RXC) {
                       		sprintf(outs, "Rx LSSU SF: 0x%02X ", phist->LSSU_SF);
			switch(phist->LSSU_SF) {
		mb->wan_data_len -= sizeof(L2_HISTORY_STRUCT);
		if(!mb->wan_data_len) {
 //       flags = card->u.s.flags;
   //     flags->interrupt_info_struct.interrupt_permission &=
	if (card->wandev.ignore_front_end_status == WANOPT_YES){
	if (card->tty_opt){
	if (card->fe.fe_status == FE_CONNECTED){
		if (card->u.s.state == WAN_CONNECTED){
	wan_mbox_t*			mb = &card->wan_mbox;
	ADAPTER_CONFIGURATION_STRUCT*	cfg = (ADAPTER_CONFIGURATION_STRUCT*)mb->wan_data;
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &cfg->adapter_type); 
	cfg->adapter_config = 0x00; 
	cfg->operating_frequency = 00; 
	mb->wan_data_len = sizeof(ADAPTER_CONFIGURATION_STRUCT);
	mb->wan_command = SET_ADAPTER_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
./sdla_ss7.c
* Copyright:	(c) 1995-2004 Sangoma Technologies Inc.
* Dec 12, 2001  Nenad Corbic	Re-wrote the tty receive algorithm, using
* Dec 03, 2001  Gideon Hack	Updated for S514-5 56K adapter.
#define MAX_PORT NR_PORTS-1 
static char *opt_decode[] = {"NONE","CRTSCTS","XONXOFF-RX",
	  	             "CRTSCTS XONXOFF-RX","XONXOFF-TX",
		             "CRTSCTS XONXOFF-TX","CRTSCTS XONXOFF"};
 * wpc_init - Cisco HDLC protocol initialization routine.
 *  o initialize protocol-specific fields of the adapter data space.
	if (conf->config_id != WANCONFIG_CHDLC) {
				  card->devname, conf->config_id);
		return -EINVAL;
	if ((conf->comm_port == WANOPT_PRI) || (conf->comm_port == WANOPT_SEC)){
		if (card->next){
			if (conf->comm_port != card->next->u.c.comm_port){
				card->u.c.comm_port = conf->comm_port;
				printk(KERN_INFO "%s: ERROR - %s port used!\n",
        		        	card->wandev.name, PORT(conf->comm_port));
				return -EINVAL;
			card->u.c.comm_port = conf->comm_port;
		printk(KERN_INFO "%s: ERROR - Invalid Port Selected!\n",
                			card->wandev.name);
		return -EINVAL;
	/* Initialize protocol-specific fields */
	if (card->u.c.comm_port == WANOPT_PRI){
		card->mbox_off = PRI_BASE_ADDR_MB_STRUCT;
		card->mbox_off = SEC_BASE_ADDR_MB_STRUCT;
	mb = &card->wan_mbox;
	mb1 = &card->wan_mbox;
	if (!card->configured){
			card->hw_iface.peek(card->hw, 
				card->mbox_off+offsetof(wan_mbox_t, wan_return_code),
			if ((jiffies - timeout) > 1*HZ) break;
				card->devname);
			return -EIO;
	card->wandev.clocking = conf->clocking;
	card->wandev.ignore_front_end_status = conf->ignore_front_end_status;
	card->wandev.line_idle = conf->line_idle;
	card->wandev.line_coding = conf->line_coding;
	card->wandev.connection = conf->connection;
	err = (card->hw_iface.check_mismatch) ? 
			card->hw_iface.check_mismatch(card->hw,conf->fe_cfg.media) : -EINVAL;
	if (IS_TE1_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_te_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg = card->hw_iface.fe_write;
		card->fe.read_fe_reg	 = card->hw_iface.fe_read;
		card->wandev.fe_enable_timer = chdlc_enable_timer;
		card->wandev.te_link_state = chdlc_handle_front_end_state;
		conf->electrical_interface = 
		if (card->u.c.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
	}else if (IS_56K_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_56k_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg = card->hw_iface.fe_write;
		card->fe.read_fe_reg	 = card->hw_iface.fe_read;
		if (card->u.c.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
		card->fe.fe_status = FE_CONNECTED;
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
		return -EIO;
		card->devname, str); 
		return -EIO;
	card->isr			= &wpc_isr;
	card->poll			= NULL;
	card->exec			= NULL;
	card->wandev.update		= &update;
 	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= &del_if;
	card->wandev.udp_port   	= conf->udp_port;
	card->wandev.new_if_cnt = 0;
	atomic_set(&card->wandev.if_cnt,0);
	card->wandev.get_config_info 	= &chdlc_get_config_info;
	card->wandev.get_status_info 	= &chdlc_get_status_info;
	card->wandev.set_dev_config    	= &chdlc_set_dev_config;
	card->wandev.set_if_info     	= &chdlc_set_if_info;
	card->wan_debugging		= &chdlc_debugging;
	card->get_crc_frames		= &chdlc_crc_frames;
	card->get_abort_frames		= &chdlc_abort_frames;
	card->get_tx_underun_frames	= &chdlc_tx_underun_frames;
	card->u.c.update_call_count = 0;
	card->wandev.ttl = conf->ttl;
	card->wandev.electrical_interface = conf->electrical_interface; 
	if ((card->u.c.comm_port == WANOPT_SEC && conf->electrical_interface == WANOPT_V35)&&
	    card->type != SDLA_S514){
		printk(KERN_INFO "%s: ERROR - V35 Interface not supported on S508 %s port \n",
			card->devname, PORT(card->u.c.comm_port));
		return -EIO;
	port_num = card->u.c.comm_port;
	if(card->type == SDLA_S514) {
		card->u.c.receive_only = conf->receive_only;
		if(conf->receive_only) {
                                card->devname);
	if(card->wandev.clocking) {
		if((port_num == WANOPT_PRI) || card->u.c.receive_only) {
				(card->type == SDLA_S514) ?
                               (card->type == SDLA_S514) ?
			if(conf->bps > max_permitted_baud) {
				conf->bps = max_permitted_baud;
					card->wandev.name);
					card->wandev.name, max_permitted_baud);
			card->wandev.bps = conf->bps;
        	card->wandev.bps = 0;
	if((port_num == WANOPT_PRI) || card->u.c.receive_only) {
		card->wandev.mtu =
			(conf->mtu >= MIN_LGTH_CHDLC_DATA_CFG) ?
			wp_min(conf->mtu, PRI_MAX_NO_DATA_BYTES_IN_FRAME) :
		card->wandev.mtu =
			(conf->mtu >= MIN_LGTH_CHDLC_DATA_CFG) ?
			wp_min(conf->mtu, SEC_MAX_NO_DATA_BYTES_IN_FRAME) :
	if (conf->u.chdlc.fast_isr == WANOPT_YES){
				card->devname);
		card->u.c.protocol_options|=INSTALL_FAST_INT_HANDLERS;
         * Use this pointer to calculate the value of card->u.c.flags !
	mb1->wan_data_len = 0;
	mb1->wan_command = READ_CHDLC_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb1);
		if(card->type != SDLA_S514)
                	enable_irq(card->wandev.irq);
		return -EIO;
	card->flags_off = 
		((CHDLC_CONFIGURATION_STRUCT *)mb1->wan_data)->
    	card->intr_type_off = 
		card->flags_off +
	card->intr_perm_off = 
		card->flags_off +
	card->fe_status_off = 
		card->flags_off + 
	card->wandev.state = WAN_DUALPORT;
	card->u.c.state = WAN_DISCONNECTED;
	if (!card->wandev.piggyback){	
		if(err || (card->timer_int_enabled < 1)) { 
					card->devname, card->timer_int_enabled);
					card->devname);
			return -EIO;
				card->devname, card->timer_int_enabled);
		card->configured = 1;
	if ((card->tty_opt=conf->tty) == WANOPT_YES){
				card->devname);
		return -EINVAL;
		card->tty_minor = conf->tty_minor;
		if ((card->u.c.async_mode = conf->tty_mode)){
			card->wandev.clocking = 1;
				card->devname);
		return -EINVAL;
				card->devname);
			return -EIO;	
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	card->u.c.backup = conf->backup;
	card->disable_comm = &disable_comm;
 * update - Update wanpipe device status & statistics
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical))
                return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
		return -ENODEV;
      	flags = card->u.c.flags;
	if(test_and_set_bit(0,&chdlc_priv_area->update_comms_stats)){
		return -EAGAIN;
	chdlc_priv_area->update_comms_stats = 
       	flags->interrupt_info_struct.interrupt_permission |= APP_INT_ON_TIMER;
	card->u.c.timer_int_enabled = TMR_INT_ENABLED_UPDATE;
		if(chdlc_priv_area->update_comms_stats == 0)
                if ((jiffies - timeout) > (1 * HZ)){
    			chdlc_priv_area->update_comms_stats = 0;
 			card->u.c.timer_int_enabled &=
 			return -EAGAIN;
	spin_lock_irqsave(&card->wandev.lock, smp_flags);
	chdlc_priv_area->update_comms_stats=0;
	spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
 * new_if - Create new logical channel.
 * to dev->priv pointer.  
 * Also the dev->init pointer should also be initialized
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
			card->devname, conf->name);
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
		WAN_MEM_ASSERT(card->devname);
		return -ENOMEM;
	chdlc_priv_area->card = card; 
	strcpy(chdlc_priv_area->if_name, conf->name);
	WAN_TASKLET_INIT((&chdlc_priv_area->common.bh_task),0,chdlc_bh,(unsigned long)chdlc_priv_area);
	if (atomic_read(&card->wandev.if_cnt) > 0){
		err=-EEXIST;
	chdlc_priv_area->TracingEnabled = 0;
	chdlc_priv_area->route_status = NO_ROUTE;
	chdlc_priv_area->route_removed = 0;
	card->u.c.async_mode = conf->async_mode;
	if(conf->async_mode) {
			wandev->name);
		if(card->u.c.comm_port == WANOPT_PRI) {
					wandev->name);
			err=-EINVAL;
	       	if(strcmp(conf->usedby, "WANPIPE") == 0) {
						wandev->name);
			chdlc_priv_area->common.usedby = WANPIPE;
			chdlc_priv_area->common.usedby = API;
			wan_reg_api(chdlc_priv_area, dev, card->devname);
		if(!card->wandev.clocking) {
				wandev->name);
			err=-EINVAL;
		if((card->wandev.bps < MIN_ASY_BAUD_RATE) ||
			(card->wandev.bps > MAX_ASY_BAUD_RATE)) {
				wandev->name);
			err=-EINVAL;
		card->u.c.api_options = 0;
                if (conf->asy_data_trans == WANOPT_YES) {
                        card->u.c.api_options |= ASY_RX_DATA_TRANSPARENT;
		card->u.c.protocol_options = 0;
		if (conf->rts_hs_for_receive == WANOPT_YES) {
			card->u.c.protocol_options |= ASY_RTS_HS_FOR_RX;
                if (conf->xon_xoff_hs_for_receive == WANOPT_YES) {
                        card->u.c.protocol_options |= ASY_XON_XOFF_HS_FOR_RX;
                if (conf->xon_xoff_hs_for_transmit == WANOPT_YES) {
                        card->u.c.protocol_options |= ASY_XON_XOFF_HS_FOR_TX;
                if (conf->dcd_hs_for_transmit == WANOPT_YES) {
                        card->u.c.protocol_options |= ASY_DCD_HS_FOR_TX;
                if (conf->cts_hs_for_transmit == WANOPT_YES) {
                        card->u.c.protocol_options |= ASY_CTS_HS_FOR_TX;
		card->u.c.tx_bits_per_char = conf->tx_bits_per_char;
                card->u.c.rx_bits_per_char = conf->rx_bits_per_char;
                card->u.c.stop_bits = conf->stop_bits;
		card->u.c.parity = conf->parity;
		card->u.c.break_timer = conf->break_timer;
		card->u.c.inter_char_timer = conf->inter_char_timer;
		card->u.c.rx_complete_length = conf->rx_complete_length;
		card->u.c.xon_char = conf->xon_char;
		if (conf->ignore_dcd == WANOPT_YES){
			card->u.c.protocol_options |= IGNORE_DCD_FOR_LINK_STAT;
		if (conf->ignore_cts == WANOPT_YES){
			card->u.c.protocol_options |= IGNORE_CTS_FOR_LINK_STAT;
		if (conf->ignore_keepalive == WANOPT_YES) {
			card->u.c.protocol_options |=
			card->u.c.kpalv_tx  = MIN_Tx_KPALV_TIMER; 
			card->u.c.kpalv_rx  = MIN_Rx_KPALV_TIMER; 
			card->u.c.kpalv_err = MIN_KPALV_ERR_TOL; 
			card->u.c.kpalv_tx =
				((conf->keepalive_tx_tmr - MIN_Tx_KPALV_TIMER)
	   			wp_min(conf->keepalive_tx_tmr,MAX_Tx_KPALV_TIMER) :
			card->u.c.kpalv_rx =
		   		((conf->keepalive_rx_tmr - MIN_Rx_KPALV_TIMER)
	   			wp_min(conf->keepalive_rx_tmr,MAX_Rx_KPALV_TIMER) :
			card->u.c.kpalv_err =
		   		((conf->keepalive_err_margin-MIN_KPALV_ERR_TOL)
	   			wp_min(conf->keepalive_err_margin,
		card->u.c.slarp_timer = 
			((conf->slarp_timer - MIN_SLARP_REQ_TIMER) >= 0) ?
			wp_min(conf->slarp_timer, MAX_SLARP_REQ_TIMER) :
		if (conf->hdlc_streaming == WANOPT_YES) {
				wandev->name);
			card->u.c.protocol_options |= HDLC_STREAMING_MODE;
		if ((chdlc_priv_area->true_if_encoding = conf->true_if_encoding) == WANOPT_YES){
				card->devname);
		if( strcmp(conf->usedby, "WANPIPE") == 0) {
				wandev->name);
			chdlc_priv_area->common.usedby = WANPIPE;
			if (conf->if_down){
				set_bit(DYN_OPT_ON,&chdlc_priv_area->interface_down);
				   card->devname,chdlc_priv_area->if_name);
		} else if( strcmp(conf->usedby, "API") == 0) {
			chdlc_priv_area->common.usedby = API;
				wandev->name,chdlc_priv_area->if_name);
			wan_reg_api(chdlc_priv_area, dev, card->devname);
		}else if (strcmp(conf->usedby, "BRIDGE") == 0) {
			chdlc_priv_area->common.usedby = BRIDGE;
					card->devname,chdlc_priv_area->if_name);
		}else if (strcmp(conf->usedby, "BRIDGE_N") == 0) {
			chdlc_priv_area->common.usedby = BRIDGE_NODE;
					card->devname,chdlc_priv_area->if_name);
					card->devname,chdlc_priv_area->if_name);
			err=-EINVAL;
	if ((chdlc_priv_area->gateway = conf->gateway) == WANOPT_YES){
			card->devname,chdlc_priv_area->if_name);
	if (conf->single_tx_buf) {
		DEBUG_EVENT("%s: Enabling Single Tx Buffer \n",chdlc_priv_area->if_name);
		card->u.c.protocol_options|=SINGLE_TX_BUFFER;
	chdlc_priv_area->mc = conf->mc;
	WAN_TASKQ_INIT((&chdlc_priv_area->poll_task),0,chdlc_poll,dev);
	init_timer(&chdlc_priv_area->poll_delay_timer);
	chdlc_priv_area->poll_delay_timer.data = (unsigned long)dev;
	chdlc_priv_area->poll_delay_timer.function = chdlc_poll_delay;
					   &chdlc_priv_area->dent, 
					   chdlc_priv_area->if_name, 
			card->devname, chdlc_priv_area->if_name);
	dev->init = &if_init;
	dev->priv = chdlc_priv_area;
	set_bit(0,&chdlc_priv_area->config_chdlc);
	atomic_inc(&card->wandev.if_cnt);
	WAN_TASKLET_KILL(&chdlc_priv_area->common.bh_task);
	wan_unreg_api(chdlc_priv_area, card->devname);
	dev->priv=NULL;
 * del_if - Delete logical channel.
	chdlc_private_area_t* 	chdlc_priv_area = dev->priv;
	sdla_t*			card = chdlc_priv_area->card;
	WAN_TASKLET_KILL(&chdlc_priv_area->common.bh_task);
	wan_unreg_api(chdlc_priv_area, card->devname);
	wanrouter_proc_delete_interface(wandev, chdlc_priv_area->if_name);
	atomic_dec(&card->wandev.if_cnt);
 * if_init - Initialize Linux network interface.
	chdlc_private_area_t* chdlc_priv_area = dev->priv;
	sdla_t* card = chdlc_priv_area->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= TX_TIMEOUT;
	dev->do_ioctl		= if_do_ioctl;
	if (chdlc_priv_area->common.usedby == BRIDGE || 
            chdlc_priv_area->common.usedby == BRIDGE_NODE){
		memcpy(dev->dev_addr, "\xFE\xFC\x00\x00\x00\x00", 6);
		*(int *)(dev->dev_addr + 2) += hw_addr;
		/* Initialize media-specific parameters */
		dev->flags		|= IFF_POINTOPOINT;
		dev->flags		|= IFF_NOARP;
		if (chdlc_priv_area->mc == WANOPT_YES){
			dev->flags 	|= (IFF_MULTICAST|IFF_ALLMULTI);
		if (chdlc_priv_area->true_if_encoding){
			dev->type	= ARPHRD_HDLC; /* This breaks the tcpdump */
			dev->type	= ARPHRD_PPP;
		dev->mtu		= card->wandev.mtu;
		if(chdlc_priv_area->common.usedby == API) {
			dev->mtu += sizeof(api_tx_hdr_t);
		dev->hard_header_len	= 0;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start); 
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end); 
        dev->tx_queue_len = 100;
 * if_open - Open network interface.
	chdlc_private_area_t* chdlc_priv_area = dev->priv;
	sdla_t* card = chdlc_priv_area->card;
		return -EBUSY;
	chdlc_priv_area->router_start_time = tv.tv_sec;
	if (card->tty_opt)
	set_bit(0,&chdlc_priv_area->config_chdlc);
	chdlc_priv_area->config_chdlc_timeout=jiffies;
	del_timer(&chdlc_priv_area->poll_delay_timer);
	chdlc_priv_area->poll_delay_timer.expires=jiffies+HZ;
	add_timer(&chdlc_priv_area->poll_delay_timer);
 * if_close - Close network interface.
	chdlc_private_area_t* chdlc_priv_area = dev->priv;
	sdla_t* card = chdlc_priv_area->card;
	dev->start=0;
	del_timer(&chdlc_priv_area->poll_delay_timer);
	if (chdlc_priv_area->common.usedby == API){	
		spin_lock_irqsave(&card->wandev.lock,smp_flags);
				chdlc_priv_area->common.sk);
		spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
 * disable_comm - Main shutdown function
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	if (card->u.c.comm_enabled){
		card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	/* TE1 - Unconfiging, only on shutdown */
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
	if (card->tty_opt){
		if (!(--tty_init_cnt)){
					card->devname,WAN_TTY_MAJOR);
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		card->tty=NULL;
		tty_card_map[card->tty_minor]=NULL;
		state = &rs_table[card->tty_minor];
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
    	chdlc_private_area_t* chan = dev->priv;
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++card->wandev.stats.collisions;
	printk (KERN_INFO "%s: Transmit timed out on %s\n", card->devname,dev->name);
 * if_send - Send a packet on a network interface.
 *   block a timer-based transmit from overlapping.
 *		non-0	packet may be re-transmitted (tbusy must be set)
	chdlc_private_area_t *chdlc_priv_area = dev->priv;
	sdla_t *card = chdlc_priv_area->card;
		 * tx-done interrupt.
			card->devname, dev->name);
	if (dev->tbusy){
		 ++card->wandev.stats.collisions;
		if((jiffies - chdlc_priv_area->tick_counter) < (5 * HZ)) {
   	if (chdlc_priv_area->common.usedby != ANNEXG && 
	    skb->protocol != htons(PVC_PROT)){
				card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
                if(chdlc_priv_area->common.usedby == WANPIPE && chk_bcast_mcast_addr(card, dev, skb)){
			++card->wandev.stats.tx_dropped;
      	if(card->type != SDLA_S514){
    	if(test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
					card->wandev.name,card->wandev.critical);
                ++card->wandev.stats.tx_dropped;
	if(card->wandev.state != WAN_CONNECTED){
       		++card->wandev.stats.tx_dropped;
	}else if(!skb->protocol){
        	++card->wandev.stats.tx_errors;
		void* data = skb->data;
		unsigned len = skb->len;
		if (chdlc_priv_area->common.usedby == API){
			if (card->u.c.receive_only ||
				++card->wandev.stats.tx_dropped;
			attr = api_tx_hdr->wp_api_tx_hdr_chdlc_attr;
			misc_Tx_bits = api_tx_hdr->wp_api_tx_hdr_chdlc_misc_tx_bits;
			len -= sizeof(api_tx_hdr_t);
			err=-1;
			++card->wandev.stats.tx_packets;
                        card->wandev.stats.tx_bytes += len;
		 	dev->trans_start = jiffies;
		chdlc_priv_area->tick_counter = jiffies;
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
	clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
	if(card->type != SDLA_S514){
 * chk_bcast_mcast_addr - Check for source broadcast addresses
	chdlc_private_area_t *chdlc_priv_area=dev->priv;
        src_ip_addr = *(u32 *)(skb->data + 12);
	if (chdlc_priv_area->common.usedby != WANPIPE){
        in_dev = dev->ip_ptr;
                struct in_ifaddr *ifa= in_dev->ifa_list;
                        broadcast_ip_addr = ifa->ifa_broadcast;
        if((dev->flags & IFF_BROADCAST) && (src_ip_addr == broadcast_ip_addr)) {
				card->devname);
				card->devname);
	c_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	c_udp_pkt->wan_udp_len = temp;
	temp = c_udp_pkt->wan_udp_sport;
	c_udp_pkt->wan_udp_sport = 
			c_udp_pkt->wan_udp_dport; 
	c_udp_pkt->wan_udp_dport = temp;
	*((unsigned short *)(c_udp_pkt->wan_udp_data+mbox_len+even_bound)) = temp;	
	*((unsigned short *)(c_udp_pkt->wan_udp_data+mbox_len+even_bound+2)) = temp;
	c_udp_pkt->wan_udp_sum = 0;
	c_udp_pkt->wan_udp_sum = calc_checksum(&data[UDP_OFFSET],udp_length+UDP_OFFSET);
	c_udp_pkt->wan_ip_len = temp;
	ip_temp = c_udp_pkt->wan_ip_src;
	c_udp_pkt->wan_ip_src = c_udp_pkt->wan_ip_dst;
	c_udp_pkt->wan_ip_dst = ip_temp;
	c_udp_pkt->wan_ip_sum = 0;
	c_udp_pkt->wan_ip_sum = calc_checksum(data,sizeof(struct iphdr));
 * Get ethernet-style interface statistics.
	if ((chdlc_priv_area=dev->priv) == NULL)
	my_card = chdlc_priv_area->card;
	return &my_card->wandev.stats; 
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CHDLC_CODE_VERSION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		len = mb->wan_data_len;
			memcpy(str, mb->wan_data, len);
					card->devname,len,str_size);
/*-----------------------------------------------------------------------------
	wan_mbox_t *mb = &card->wan_mbox;
	mb->wan_data_len = data_length;  
	memcpy(mb->wan_data, data, data_length);
	mb->wan_command = SET_CHDLC_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
 * Set interrupt mode -- HDLC Version.
	wan_mbox_t* mb = &card->wan_mbox;
		 (CHDLC_INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->CHDLC_interrupt_triggers 	= mode;
	int_data->IRQ				= card->wandev.irq;
	int_data->interrupt_timer               = 1;
	mb->wan_data_len = sizeof(CHDLC_INT_TRIGGERS_STRUCT);
	mb->wan_command = SET_CHDLC_INTERRUPT_TRIGGERS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t* mb = &card->wan_mbox;
		 (CHDLC_INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->CHDLC_interrupt_triggers 	= 0;
	int_data->IRQ				= card->wandev.irq;	
	int_data->interrupt_timer               = 1;
	mb->wan_data_len = sizeof(CHDLC_INT_TRIGGERS_STRUCT);
	mb->wan_command = SET_CHDLC_INTERRUPT_TRIGGERS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	if (card->u.c.async_mode) {
		mb->wan_command = DISABLE_ASY_COMMUNICATIONS;
		mb->wan_command = DISABLE_CHDLC_COMMUNICATIONS;
	mb->wan_data_len = 0;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card->u.c.comm_enabled = 0;
	/* TE1 - Unconfiging, only on shutdown */
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = ENABLE_CHDLC_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->u.c.comm_enabled = 1;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = DISABLE_CHDLC_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->u.c.comm_enabled = 0;
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_COMMS_ERROR_STATS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_CHDLC_OPERATIONAL_STATS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
		card->wandev.fe_iface.read_alarm(&card->fe, 0); 
		card->wandev.fe_iface.read_pmon(&card->fe, 0); 
		card->wandev.fe_iface.read_alarm(&card->fe, 1); 
	err_stats = (COMMS_ERROR_STATS_STRUCT *)mb->wan_data;
	card->wandev.stats.rx_over_errors = 
		err_stats->Rx_overrun_err_count;
	card->wandev.stats.rx_crc_errors = 
		err_stats->CRC_err_count;
	card->wandev.stats.rx_frame_errors = 
		err_stats->Rx_abort_count;
	card->wandev.stats.rx_fifo_errors = 
		err_stats->Rx_dis_pri_bfrs_full_count; 
	card->wandev.stats.rx_missed_errors =
		card->wandev.stats.rx_fifo_errors;
	card->wandev.stats.tx_aborted_errors =
		err_stats->sec_Tx_abort_count;
	op_stats = (CHDLC_OPERATIONAL_STATS_STRUCT *)mb->wan_data;
	card->wandev.stats.rx_length_errors =
			(op_stats->Rx_Data_discard_short_count +
			op_stats->Rx_Data_discard_long_count);
 *	Return:	0 - o.k.
 *		1 - no transmit buffers available
	card->hw_iface.peek(card->hw, card->u.c.txbuf_off, &txbuf, sizeof(txbuf));
	card->hw_iface.poke(card->hw, txbuf.ptr_data_bfr, data, len);
	card->hw_iface.poke(card->hw,
		       		card->u.c.txbuf_off,
	card->hw_iface.poke_byte(card->hw,
		       		card->u.c.txbuf_off+
	card->u.c.txbuf_off += sizeof(txbuf);
	if (card->u.c.txbuf_off > card->u.c.txbuf_last_off){
		card->u.c.txbuf_off = card->u.c.txbuf_base_off;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	DEBUG_TEST("%s: Chdlc enabling timer %s\n",card->devname,
	card->u.c.timer_int_enabled |= TMR_INT_ENABLED_TE;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_command;
			card->devname, cmd);
				card->devname);
			card->devname, cmd, err);
	sdla_t *card = chan->card;
		len=skb->len;
		if (chan->common.usedby == API){
				card->wandev.stats.rx_packets++;
				card->wandev.stats.rx_bytes += len;
				++card->wandev.stats.rx_dropped;
			++card->wandev.stats.rx_dropped;
	WAN_TASKLET_END((&chan->common.bh_task));
	if (!card->hw){
	card->hw_iface.peek(card->hw, card->flags_off,
	set_bit(0,&card->in_isr);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (!card->tty_opt && !dev && 
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical)) {
				card->devname);
	if(card->type != SDLA_S514) {
		if(test_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
				card->devname);
			card->in_isr = 0;
			card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
		if (card->tty_opt){
			set_bit(TX_INTR,(void*)&card->wandev.critical);
				card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
			chdlc_private_area_t* chdlc_priv_area=dev->priv;
			if (chdlc_priv_area->common.usedby == API){
		++ card->timer_int_enabled;
			card->hw_iface.peek(card->hw, 
					    card->fe_status_off,
			card->hw_iface.poke(card->hw, 
					    card->fe_status_off,
		if (card->next){
			set_bit(0,&card->spurious);
				card->devname,
	card->in_isr = 0;
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	card->hw_iface.peek(card->hw, card->u.c.rxmb_off, &rxbuf, sizeof(rxbuf));
			card->devname, (unsigned)card->u.c.rxmb_off, rxbuf.opp_flag);
		printk(KERN_INFO "%s: Critical router failure ...!!!\n", card->devname);
	if (card->tty_opt){
		if (!card->u.c.async_mode){
			len -= CRC_LENGTH;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (chdlc_priv_area->common.usedby == ANNEXG){
		len = rxbuf.frame_length - CRC_LENGTH;
					card->devname);
		++card->wandev.stats.rx_dropped;
	if((addr + len) > card->u.c.rx_top_off + 1) {
		unsigned tmp = card->u.c.rx_top_off - addr + 1;
		card->hw_iface.peek(card->hw, addr, buf, tmp);
		addr = card->u.c.rx_base_off;
		len -= tmp;
	card->hw_iface.peek(card->hw, addr, buf, len);
	skb->protocol = htons(ETH_P_IP);
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	} else if(chdlc_priv_area->common.usedby == API) {
		api_rx_hdr = (api_rx_hdr_t*)&skb->data[0x00];
		api_rx_hdr->wp_api_rx_hdr_chdlc_error_flag = rxbuf.error_flag;
		api_rx_hdr->wp_api_rx_hdr_chdlc_time_stamp = rxbuf.time_stamp;
		api_rx_hdr->wan_hdr_chdlc_time_sec=tv.tv_sec;
		api_rx_hdr->wan_hdr_chdlc_time_usec=tv.tv_usec;
		skb->protocol = htons(WP_PVC_PROT);
		skb->dev      = dev;
		skb->pkt_type = WAN_PACKET_DATA;
			++card->wandev.stats.rx_dropped;
		WAN_TASKLET_SCHEDULE(&chdlc_priv_area->common.bh_task);
	} else if (chdlc_priv_area->common.usedby == ANNEXG){
		if (chdlc_priv_area->annexg_dev){
			skb->protocol = htons(ETH_P_X25);
			skb->dev = chdlc_priv_area->annexg_dev;
				++card->wandev.stats.rx_dropped;
			WAN_TASKLET_SCHEDULE(&chdlc_priv_area->common.bh_task);
			++card->wandev.stats.rx_errors;
	}else if (chdlc_priv_area->common.usedby == BRIDGE ||
		  chdlc_priv_area->common.usedby == BRIDGE_NODE){
		if (skb->len <= ETH_ALEN) {
			++card->wandev.stats.rx_errors;
		card->wandev.stats.rx_packets ++;
		card->wandev.stats.rx_bytes += skb->len;
		skb->dev = dev;
		skb->protocol=eth_type_trans(skb,dev);
                          ++ chdlc_priv_area->if_stats.multicast;
		card->wandev.stats.rx_packets ++;
		card->wandev.stats.rx_bytes += skb->len;
		skb->protocol = htons(ETH_P_IP);
                skb->dev = dev;
	card->hw_iface.poke_byte(card->hw, 
			card->u.c.rxmb_off+offsetof(CHDLC_DATA_RX_STATUS_EL_STRUCT, opp_flag),
	card->u.c.rxmb_off += sizeof(rxbuf);
	if (card->u.c.rxmb_off > card->u.c.rxbuf_last_off){
		card->u.c.rxmb_off = card->u.c.rxbuf_base_off;
 *    2) Reading board-level statistics for updating the proc file system.
	if (card->u.c.timer_int_enabled & TMR_INT_ENABLED_TE) {
		card->wandev.fe_iface.polling(&card->fe);
		card->u.c.timer_int_enabled &= ~TMR_INT_ENABLED_TE;
   	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
        chdlc_priv_area = dev->priv;
	if (card->u.c.timer_int_enabled & TMR_INT_ENABLED_CONFIG) {
		card->u.c.timer_int_enabled &= ~TMR_INT_ENABLED_CONFIG;
       	if(card->u.c.timer_int_enabled & TMR_INT_ENABLED_UDP) {
		card->u.c.timer_int_enabled &= ~TMR_INT_ENABLED_UDP;
	if(card->u.c.timer_int_enabled & TMR_INT_ENABLED_UPDATE) {
                if(!(-- chdlc_priv_area->update_comms_stats)) {
			card->u.c.timer_int_enabled &= 
        if(!card->u.c.timer_int_enabled) {
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
/*------------------------------------------------------------------------------
	- set_chdlc_config() used to set configuration options on the board
------------------------------------------------------------------------------*/
	if(card->wandev.clocking){
		cfg.baud_rate = card->wandev.bps;
	cfg.line_config_options = (card->wandev.electrical_interface == WANOPT_RS232) ?
	if (card->wandev.line_coding == WANOPT_NRZI){
		printk(KERN_INFO "%s: Configuring for NRZI encoding\n", card->devname);
	if (card->wandev.line_idle == WANOPT_IDLE_MARK){
		printk(KERN_INFO "%s: Configuring for Idle Mark\n", card->devname);
	if (card->wandev.connection == WANOPT_SWITCHED){
		printk(KERN_INFO "%s: Configuring for Switched CTS/RTS\n", card->devname);
	cfg.CHDLC_protocol_options	= card->u.c.protocol_options;
	if (card->tty_opt){
	cfg.percent_data_buffer_for_Tx  = (card->u.c.receive_only) ? 0 : 50;
	if (card->tty_opt){
		card->wandev.mtu = TTY_CHDLC_MAX_MTU;
	cfg.max_CHDLC_data_field_length	= card->wandev.mtu;
	cfg.transmit_keepalive_timer	= card->u.c.kpalv_tx;
	cfg.receive_keepalive_timer	= card->u.c.kpalv_rx;
	cfg.keepalive_error_tolerance	= card->u.c.kpalv_err;
	cfg.SLARP_request_timer		= card->u.c.slarp_timer;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
                struct in_device *in_dev = dev->ip_ptr;
			struct in_ifaddr *ifa = in_dev->ifa_list;
				cfg.IP_address	= ntohl(ifa->ifa_local);
				cfg.IP_netmask	= ntohl(ifa->ifa_mask); 
				chdlc_priv_area->IP_address = ntohl(ifa->ifa_local);
				chdlc_priv_area->IP_netmask = ntohl(ifa->ifa_mask); 
		/* FIXME: We must re-think this message in next release
				card->devname);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = START_BAUD_CALIBRATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_BAUD_CALIBRATION_RESULT;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			mb->wan_data_len = 0;
			mb->wan_command = READ_CHDLC_CONFIGURATION;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
				card->wandev.bps = ((CHDLC_CONFIGURATION_STRUCT*)mb->wan_data)->baud_rate;
					card->devname,card->wandev.bps);
					card->devname);
			return -EINVAL;
					card->devname);
			return -EINVAL;
					card->devname);
			return -EINVAL;
			return -EINVAL;
/*-----------------------------------------------------------------------------
------------------------------------------------------------------------------*/
 	wan_mbox_t *mb = &card->wan_mbox;
	if(card->wandev.clocking)
		cfg.baud_rate = card->wandev.bps;
	cfg.line_config_options = (card->wandev.electrical_interface == WANOPT_RS232) ?
	cfg.asy_API_options 		= card->u.c.api_options;
	cfg.asy_protocol_options	= card->u.c.protocol_options;
	cfg.Tx_bits_per_char		= card->u.c.tx_bits_per_char;
	cfg.Rx_bits_per_char		= card->u.c.rx_bits_per_char;
	cfg.stop_bits			= card->u.c.stop_bits;
	cfg.parity			= card->u.c.parity;
	cfg.break_timer			= card->u.c.break_timer;
	cfg.asy_Rx_inter_char_timer	= card->u.c.inter_char_timer; 
	cfg.asy_Rx_complete_length	= card->u.c.rx_complete_length; 
	cfg.XON_char			= card->u.c.xon_char;
	cfg.XOFF_char			= card->u.c.xoff_char;
	mb->wan_data_len = sizeof(ASY_CONFIGURATION_STRUCT);
	memcpy(mb->wan_data, &cfg, mb->wan_data_len);
	mb->wan_command = SET_ASY_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t		*mb = &card->wan_mbox;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -EINVAL;
	mb->wan_data_len = 0;
	mb->wan_command = ENABLE_ASY_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->u.c.comm_enabled = 1;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_GLOBAL_EXCEPTION_CONDITION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		switch(mb->wan_return_code) {
				card->hw_iface.peek(card->hw, 
					    	    card->fe_status_off,
				card->fe.fe_param.k56_param.RR8_reg_56k = 
				card->fe.fe_param.k56_param.RRA_reg_56k = 
				card->fe.fe_param.k56_param.RRC_reg_56k = 
				card->wandev.fe_iface.read_alarm(&card->fe, 0); 
				card->wandev.fe_iface.isr(&card->fe);
			if ((mb->wan_data[0] & (DCD_HIGH | CTS_HIGH)) == (DCD_HIGH | CTS_HIGH)){
				card->fe.fe_status = FE_CONNECTED;
				card->fe.fe_status = FE_DISCONNECTED;
				card->devname);
			switch(mb->wan_data[0] & (DCD_HIGH | CTS_HIGH)) {
                                        printk(KERN_INFO "%s: DCD high, CTS high\n",card->devname);
					printk(KERN_INFO "%s: DCD high, CTS low\n",card->devname);
                                        printk(KERN_INFO "%s: DCD low, CTS high\n",card->devname); 
                                        printk(KERN_INFO "%s: DCD low, CTS low\n",card->devname);
				card->devname);
				card->devname); 
					card->devname);
			if (card->tty_opt){
				if (card->tty && card->tty_open){ 
						card->devname);
					tty_hangup(card->tty);
				card->devname, mb->wan_return_code);
	wan_mbox_t		*mb = &card->wan_mbox;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -EINVAL;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CHDLC_EXCEPTION_CONDITION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			card->u.c.state = WAN_CONNECTED;
			if (card->wandev.ignore_front_end_status == WANOPT_YES ||
			    card->fe.fe_status == FE_CONNECTED){
			card->u.c.state = WAN_DISCONNECTED;
			card->u.c.state = WAN_DISCONNECTED;
				 		card->devname);
				return -1;
						card->devname);
						card->devname);
	chdlc_priv_area = dev->priv;
        if(card->u.c.slarp_timer != 0x00) {
		wan_mbox_t* mb = &card->wan_mbox;
     		mb->wan_data_len = 0;
		mb->wan_command = READ_CHDLC_CONFIGURATION;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			return -1;
		cfg = (CHDLC_CONFIGURATION_STRUCT *)mb->wan_data;
                chdlc_priv_area->IP_address = cfg->IP_address;
                chdlc_priv_area->IP_netmask = cfg->IP_netmask;
		chdlc_priv_area->route_status = ADD_ROUTE;
 * Un-Configure IP negotiated by SLARP
	chdlc_priv_area= dev->priv;
	if (chdlc_priv_area->route_status == ROUTE_ADDED) {
		chdlc_priv_area->route_status = REMOVE_ROUTE;
   	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
        port_num = card->u.c.comm_port;
	if((chdlc_priv_area->route_status == ADD_ROUTE) &&
		((chdlc_priv_area->IP_address & ~chdlc_priv_area->IP_netmask) > 2)) {
		printk(KERN_INFO "%s: Dynamic route failure.\n",card->devname);
		tmp_ip=ntohl(chdlc_priv_area->IP_address);
		if(card->u.c.slarp_timer) {
				card->devname,
				card->devname);
				card->devname,
				card->devname);
				card->devname);
			printk(KERN_INFO "%s: or A.B.C.2.\n",card->devname);
		chdlc_priv_area->route_status = REMOVE_ROUTE;
        if((chdlc_priv_area->route_status == REMOVE_ROUTE) && err) {
        	if(chdlc_priv_area->route_removed) {
                in_dev = dev->ip_ptr;
                        struct in_ifaddr *ifa = in_dev->ifa_list;
                                local_IP_addr = ifa->ifa_local;
                                IP_netmask  = ifa->ifa_mask;
       		/* According to Cisco HDLC, if the point-to-point address is
		   A.B.C.1, then we are the opposite (A.B.C.2), and vice-versa.
		IP_netmask = ntohl(chdlc_priv_area->IP_netmask);
	        remote_IP_addr = ntohl(chdlc_priv_area->IP_address);
	        if(!card->u.c.slarp_timer) {
        strcpy(if_info.ifr_name, dev->name);
	switch (chdlc_priv_area->route_status) {
		if(!card->u.c.slarp_timer) {
			if_data2->sin_addr.s_addr = remote_IP_addr;
			if_data2->sin_family = AF_INET;
			if_data1->sin_addr.s_addr = local_IP_addr;
			if_data1->sin_family = AF_INET;
				if_data2->sin_addr.s_addr = remote_IP_addr;
				if_data2->sin_family = AF_INET;
				card->devname, NIPQUAD(remote_IP_addr), err);
			((chdlc_private_area_t *)dev->priv)->route_status = ROUTE_ADDED;
				card->devname);
				card->devname, NIPQUAD(local_IP_addr));
				card->devname, NIPQUAD(remote_IP_addr));
			chdlc_priv_area->route_removed = 0;
		if(!card->u.c.slarp_timer) {
			if_data2->sin_addr.s_addr = 0;
			if_data2->sin_family = AF_INET;
			if_data1->sin_addr.s_addr = 0;
			if_data1->sin_family = AF_INET;
					card->devname, NIPQUAD(remote_IP_addr),
			((chdlc_private_area_t *)dev->priv)->route_status =
                                        card->devname, NIPQUAD(local_IP_addr)); 
			chdlc_priv_area->route_removed = 1;
 *	if_do_ioctl - Ioctl handler for fr
	chdlc_private_area_t* chan= (chdlc_private_area_t*)dev->priv;
		return -ENODEV;
	card=chan->card;
				err= -EINVAL;
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			err=wan_bind_api_to_svc(chan,ifr->ifr_data);
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
				err= -EINVAL;
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			err=wan_unbind_api_from_svc(chan,ifr->ifr_data);
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
			err = chan->common.state;
			if (atomic_read(&chan->udp_pkt_len) != 0){
				return -EBUSY;
			atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
			if (test_bit(0,&card->in_isr)){
				atomic_set(&chan->udp_pkt_len,0);
				return -EBUSY;
			wan_udp_pkt=(wan_udp_pkt_t*)chan->udp_pkt_data;
			if (copy_from_user(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			spin_lock_irqsave(&card->wandev.lock, smp_flags);
			if (test_bit(0,&card->in_isr)) {
						card->devname,dev->name);
				atomic_set(&chan->udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
				return -EBUSY;
			spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
			if (atomic_read(&chan->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						card->devname,atomic_read(&chan->udp_pkt_len));
				atomic_set(&chan->udp_pkt_len,0);
				return -EINVAL;
			if (copy_to_user(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			atomic_set(&chan->udp_pkt_len,0);
			return -EOPNOTSUPP;
	if(!atomic_read(&chdlc_priv_area->udp_pkt_len) &&
	  (skb->len <= MAX_LGTH_UDP_MGNT_PKT)) {
		atomic_set(&chdlc_priv_area->udp_pkt_len, skb->len);
		chdlc_priv_area->udp_pkt_src = udp_pkt_src;
       		memcpy(chdlc_priv_area->udp_pkt_data, skb->data, skb->len);
		card->u.c.timer_int_enabled = TMR_INT_ENABLED_UDP;
	wan_mbox_t *mb = &card->wan_mbox;
	wan_udp_pkt = (wan_udp_pkt_t *) chdlc_priv_area->udp_pkt_data;
		if(chdlc_priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK){
			switch(wan_udp_pkt->wan_udp_command) {
		wan_udp_pkt->wan_udp_data_len = 0;
		wan_udp_pkt->wan_udp_return_code = 0xCD;
			card->devname,wan_udp_pkt->wan_udp_command);
		wan_udp_pkt->wan_udp_opp_flag = 0;
		switch(wan_udp_pkt->wan_udp_command) {
		     if (!chdlc_priv_area->TracingEnabled) {
			mb->wan_data_len = sizeof(LINE_TRACE_CONFIG_STRUCT);
			mb->wan_command = SET_TRACE_CONFIGURATION;
    			((LINE_TRACE_CONFIG_STRUCT *)mb->wan_data)->
			((LINE_TRACE_CONFIG_STRUCT *)mb->wan_data)->trace_config |= 
					wan_udp_pkt->wan_udp_data[0];
			((LINE_TRACE_CONFIG_STRUCT *)mb->wan_data)->
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
				card->TracingEnabled = 0;
				wan_udp_pkt->wan_udp_return_code = err;
				mb->wan_data_len = 0;
			mb->wan_data_len = 0;
			mb->wan_command = READ_TRACE_CONFIGURATION;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
				chdlc_priv_area->TracingEnabled = 0;
				wan_udp_pkt->wan_udp_return_code = err;
				mb->wan_data_len = 0;
				mb->wan_data) -> ptr_trace_stat_el_cfg_struct;
			card->hw_iface.peek(card->hw, trace_status_cfg_addr,
			chdlc_priv_area->start_trace_addr = trace_cfg_struct.
			chdlc_priv_area->number_trace_elements = 
			chdlc_priv_area->end_trace_addr = (unsigned long)
					 chdlc_priv_area->start_trace_addr + 
					 (chdlc_priv_area->number_trace_elements - 1));
			chdlc_priv_area->base_addr_trace_buffer = 
			chdlc_priv_area->end_addr_trace_buffer = 
		    	chdlc_priv_area->curr_trace_addr = 
	    		chdlc_priv_area->available_buffer_space = 2000 - 
								  sizeof(struct iphdr) -
								  sizeof(struct udphdr) -
							      	  sizeof(wan_mgmt_t)-
								  sizeof(wan_cmd_t)-
		     wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
		     mb->wan_data_len = 0;
	       	     chdlc_priv_area->TracingEnabled = 1;
		     if (chdlc_priv_area->TracingEnabled) {
			mb->wan_data_len = sizeof(LINE_TRACE_CONFIG_STRUCT);
			mb->wan_command = SET_TRACE_CONFIGURATION;
    			((LINE_TRACE_CONFIG_STRUCT *)mb->wan_data)->
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		     chdlc_priv_area->TracingEnabled = 0;
		     wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
		     mb->wan_data_len = 0;
		     if (!chdlc_priv_area->TracingEnabled) {
			wan_udp_pkt->wan_udp_return_code = 1;
			mb->wan_data_len = 0;
  		     wan_udp_pkt->wan_udp_chdlc_ismoredata = 0x00;
		     for (frames=0; frames < chdlc_priv_area->number_trace_elements; frames++){
				&wan_udp_pkt->wan_udp_data[buffer_length];
			card->hw_iface.peek(card->hw, chdlc_priv_area->curr_trace_addr,
				wan_udp_pkt->wan_udp_chdlc_ismoredata = 0x01;
   			if( (chdlc_priv_area->available_buffer_space - buffer_length)
				wan_udp_pkt->wan_udp_chdlc_ismoredata = 0x01;
			trace_pkt->status = trace_element_struct.trace_type;
			trace_pkt->time_stamp =
			trace_pkt->real_length =
			trace_pkt->sec=tv.tv_sec;
			trace_pkt->usec=tv.tv_usec;		
			real_len = trace_pkt->real_length;
			     	trace_pkt->data_avail = 0x00;
			        trace_pkt->data_avail = 0x01;
					     chdlc_priv_area->end_addr_trace_buffer + 1){
				    	tmp = chdlc_priv_area->end_addr_trace_buffer - data_ptr + 1;
				    	card->hw_iface.peek(card->hw, data_ptr,
					       	  trace_pkt->data,tmp);
				    	data_ptr = chdlc_priv_area->base_addr_trace_buffer;
		        	card->hw_iface.peek(card->hw, data_ptr,
					  &trace_pkt->data[tmp], real_len - tmp);
			card->hw_iface.poke_byte(card->hw, chdlc_priv_area->curr_trace_addr, 0x00);
       			chdlc_priv_area->curr_trace_addr += sizeof(TRACE_STATUS_ELEMENT_STRUCT);
			if ( chdlc_priv_area->curr_trace_addr > chdlc_priv_area->end_trace_addr ) {
				chdlc_priv_area->curr_trace_addr = chdlc_priv_area->start_trace_addr;
            		if(trace_pkt->data_avail == 0x01) {
		     if (frames == chdlc_priv_area->number_trace_elements){
			wan_udp_pkt->wan_udp_chdlc_ismoredata = 0x01;
 		     wan_udp_pkt->wan_udp_chdlc_num_frames = frames;
    		     mb->wan_data_len = buffer_length;
		     wan_udp_pkt->wan_udp_data_len = buffer_length; 
		     wan_udp_pkt->wan_udp_return_code = COMMAND_OK; 
			card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
			((unsigned char *)wan_udp_pkt->wan_udp_data )[0] =
			((unsigned char *)wan_udp_pkt->wan_udp_data )[1] =
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
			wan_udp_pkt->wan_udp_data_len = 2;
			mb->wan_data_len = 2;
			chdlc_priv_area->router_up_time = tv.tv_sec - 
					chdlc_priv_area->router_start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
					chdlc_priv_area->router_up_time;	
			mb->wan_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
	        	if ((wan_udp_pkt->wan_udp_data[0] & ENABLE_READ_FT1_STATUS) ||  
				(wan_udp_pkt->wan_udp_data[0] & ENABLE_READ_FT1_OP_STATS)) {
					wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
					mb->wan_data_len = 1;
	      		if( wan_udp_pkt->wan_udp_data[0] == 0) {
	      	   	     	if( --rCount != 0) {
		  			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
					mb->wan_data_len = 1;
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				if (wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE){
		    			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned char); 
					wan_udp_pkt->wan_udp_return_code = CMD_OK;
					wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
		   	wan_udp_pkt->wan_udp_chdlc_num_frames = card->wandev.config_id;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_LINUX_PLATFORM;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
			mb->wan_command = wan_udp_pkt->wan_udp_command;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
			if (mb->wan_data_len) {
				memcpy(&mb->wan_data, (unsigned char *) wan_udp_pkt->
							wan_udp_data, mb->wan_data_len);
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
				wan_udp_pkt->wan_udp_return_code = mb->wan_return_code;
	         	memcpy(&wan_udp_pkt->wan_udp_hdr.wan_cmd, mb, sizeof(wan_cmd_t)); 
			if (mb->wan_data_len) {
	         		memcpy(&wan_udp_pkt->wan_udp_data, &mb->wan_data, 
								mb->wan_data_len); 
	wan_udp_pkt->wan_ip_ttl= card->wandev.ttl; 
		wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	len = reply_udp(chdlc_priv_area->udp_pkt_data, mb->wan_data_len);
     	if(chdlc_priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK){
	   	if (!test_bit(SEND_CRIT,&card->wandev.critical)) {
			if(!chdlc_send(card, chdlc_priv_area->udp_pkt_data, len, 0)) {
				++ card->wandev.stats.tx_packets;
				card->wandev.stats.tx_bytes += len;
  	    		memcpy(buf, chdlc_priv_area->udp_pkt_data, len);
	    		new_skb->protocol = htons(ETH_P_IP);
            		new_skb->dev = dev;
					card->devname);
	atomic_set(&chdlc_priv_area->udp_pkt_len,0);
	wan_mbox_t			*mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CHDLC_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		((CHDLC_CONFIGURATION_STRUCT *)mb->wan_data)->
		((CHDLC_CONFIGURATION_STRUCT *)mb->wan_data)->
	card->hw_iface.peek(card->hw, tx_config_off, &tx_config, sizeof(tx_config));
       	card->u.c.txbuf_base_off = tx_config.base_addr_Tx_status_elements;
       	card->u.c.txbuf_last_off = 
               	card->u.c.txbuf_base_off +
		(tx_config.number_Tx_status_elements - 1) * 
	card->hw_iface.peek(card->hw, rx_config_off, &rx_config, sizeof(rx_config));
       	card->u.c.rxbuf_base_off =
       	card->u.c.rxbuf_last_off =
		card->u.c.rxbuf_base_off +
		(rx_config.number_Rx_status_elements - 1) * 
       	card->u.c.txbuf_off = tx_config.next_Tx_status_element_to_use;
       	card->u.c.rxmb_off =
        card->u.c.rx_base_off = rx_config.base_addr_Rx_buffer;
        card->u.c.rx_top_off  = rx_config.end_addr_Rx_buffer;
	wan_mbox_t* 	mb = &card->wan_mbox;
	card->timer_int_enabled = 0;
			mb->wan_data_len  = 0;
			mb->wan_command = READ_CHDLC_CODE_VERSION;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	 wan_udp_pkt_t *wan_udp_pkt = (wan_udp_pkt_t *)skb->data;
	 if (skb->len < sizeof(wan_udp_pkt_t)){
				  wan_udp_pkt->wan_udp_signature,
				  wan_udp_pkt->wan_udp_dport,
				  ntohs(card->wandev.udp_port),
				  wan_udp_pkt->wan_ip_p,
				  wan_udp_pkt->wan_udp_request_reply,
				  skb->data[36], skb->data[37]);
	if ((wan_udp_pkt->wan_udp_dport == ntohs(card->wandev.udp_port)) &&
	   (wan_udp_pkt->wan_ip_p == UDPMGMT_UDP_PROTOCOL) &&
	   (wan_udp_pkt->wan_udp_request_reply == UDPMGMT_REQUEST)) {
		if (!strncmp(wan_udp_pkt->wan_udp_signature,UDPMGMT_SIGNATURE,8)){
		if (!strncmp(wan_udp_pkt->wan_udp_signature,GLOBAL_UDP_SIGNATURE,8)){
   	if (card->wandev.state != state)
                                card->devname);
                                card->devname);
                                card->devname);
                card->wandev.state = state;
		dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
			chdlc_priv_area->common.state = state;
			if (chdlc_priv_area->common.usedby == API){
	if (card->u.c.comm_enabled){
		if ((chdlc_priv_area->ip_local_tmp != chdlc_priv_area->ip_local ||
		     chdlc_priv_area->ip_remote_tmp != chdlc_priv_area->ip_remote) && 
		     chdlc_priv_area->common.usedby == WANPIPE) {
			card->u.c.state = WAN_DISCONNECTED;
					card->devname);
					card->devname);
	chdlc_priv_area->ip_local = chdlc_priv_area->ip_local_tmp;
	chdlc_priv_area->ip_remote = chdlc_priv_area->ip_remote_tmp;
	if (card->u.c.async_mode){
				card->devname);
				card->devname);
		if (card->wandev.clocking == WANOPT_EXTERNAL &&
		    (card->wandev.line_idle == WANOPT_IDLE_MARK ||
		     card->wandev.connection == WANOPT_SWITCHED)){
			printk(KERN_INFO "%s: Calibrating Baud Rate ...\n",card->devname);
				return -EINVAL;
				return -EINVAL;
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
		int	err = -EINVAL;
			card->devname, 
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
					card->devname,
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
		int	err = -EINVAL;
			card->devname);
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
				card->devname);
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
				card->devname);
		return -EINVAL;	
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off,
	if (card->tty_opt){
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_RX_FRAME);
	if(IS_TE1_CARD(card) && card->wandev.ignore_front_end_status == WANOPT_NO) {
		if (card->u.c.async_mode){
						card->devname);
				card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
				card->u.c.comm_enabled=0;
				return -EINVAL;
						card->devname);
				card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
				card->u.c.comm_enabled=0;
				return -EINVAL;
						card->devname);
	card->u.c.state = WAN_CONNECTING;
		card->wandev.fe_iface.read_alarm(&card->fe, 1); 
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, 
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);		
	dev = chdlc_priv_area->common.dev;
	card = chdlc_priv_area->card;
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	if (test_bit(PERI_CRIT,&card->wandev.critical)){
		clear_bit(POLL_CRIT,&card->wandev.critical);
	if (test_bit(0,&chdlc_priv_area->config_chdlc)){
		chdlc_priv_area->ip_local_tmp  = get_ip_address(dev,WAN_LOCAL_IP);
		chdlc_priv_area->ip_remote_tmp = get_ip_address(dev,WAN_POINTOPOINT_IP);
		if (chdlc_priv_area->ip_local_tmp == chdlc_priv_area->ip_remote_tmp && 
		    card->u.c.slarp_timer == 0x00 && 
		    !card->u.c.backup && 
		    chdlc_priv_area->common.usedby == WANPIPE){
			if (++chdlc_priv_area->ip_error > MAX_IP_ERRORS){
				printk(KERN_INFO "%s: --- WARNING ---\n",
						card->devname);
						card->devname);
				"%s: Point-to-Point IP address.\n",
						card->devname);
				printk(KERN_INFO "%s: --- WARNING ---\n\n",
						card->devname);
				clear_bit(POLL_CRIT,&card->wandev.critical);
				chdlc_priv_area->poll_delay_timer.expires = jiffies+HZ;
				add_timer(&chdlc_priv_area->poll_delay_timer);
		clear_bit(0,&chdlc_priv_area->config_chdlc);
		clear_bit(POLL_CRIT,&card->wandev.critical);
		card->u.c.timer_int_enabled |= TMR_INT_ENABLED_CONFIG;
		card->hw_iface.poke(card->hw, card->flags_off, &flags, sizeof(flags));
	switch (card->wandev.state){
		if (test_bit(DYN_OPT_ON,&chdlc_priv_area->interface_down) && 
		    !test_bit(DEV_DOWN,  &chdlc_priv_area->interface_down) &&		
		    dev->flags & IFF_UP){	
				card->devname,dev->name);
			change_dev_flags(dev,(dev->flags&~IFF_UP));
			set_bit(DEV_DOWN,&chdlc_priv_area->interface_down);
			chdlc_priv_area->route_status = NO_ROUTE;
			if (dev->flags & IFF_UP && 
		    	    chdlc_priv_area->route_status != NO_ROUTE &&
			    card->u.c.slarp_timer){
		if (test_bit(DYN_OPT_ON,&chdlc_priv_area->interface_down) &&
		    test_bit(DEV_DOWN,  &chdlc_priv_area->interface_down) &&
		    !(dev->flags & IFF_UP)){
				card->devname,dev->name);
			change_dev_flags(dev,(dev->flags|IFF_UP));
			clear_bit(DEV_DOWN,&chdlc_priv_area->interface_down);
		if (chdlc_priv_area->route_status == ADD_ROUTE && 
		    card->u.c.slarp_timer){ 
		if (chdlc_priv_area->gateway && check_gateway)
	clear_bit(POLL_CRIT,&card->wandev.critical);
	if ((chdlc_priv_area = dev->priv)==NULL)
	card = chdlc_priv_area->card;
	if (test_and_set_bit(POLL_CRIT,&card->wandev.critical)){
	if (test_bit(PERI_CRIT,&card->wandev.critical)){
	WAN_TASKQ_SCHEDULE((&chdlc_priv_area->poll_task));
	wan_mbox_t* mb = &card->wan_mbox;
	ADAPTER_CONFIGURATION_STRUCT* cfg = (ADAPTER_CONFIGURATION_STRUCT*)mb->wan_data;
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &cfg->adapter_type);
	cfg->adapter_config = 0x00; 
	cfg->operating_frequency = 00; 
	mb->wan_data_len = sizeof(ADAPTER_CONFIGURATION_STRUCT);
	mb->wan_command = SET_ADAPTER_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	spin_lock_irqsave(&card->wandev.lock, *smp_flags);
        if (card->next){
        	spin_lock(&card->next->wandev.lock);
        if (card->next){
        	spin_unlock(&card->next->wandev.lock);
        spin_unlock_irqrestore(&card->wandev.lock, *smp_flags);
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
	if (test_and_set_bit(TASK_POLL,(void*)&card->wandev.critical)){
	if (wanpipe_queue_tq(&card->tty_task_queue) != 0){
		clear_bit(TASK_POLL,(void*)&card->wandev.critical);
		return -EINVAL;
		clear_bit(TASK_POLL,(void*)&card->wandev.critical);
		return -EINVAL;
	clear_bit(TASK_POLL,(void*)&card->wandev.critical);
	if ((tty=card->tty)==NULL)
	while ((skb=skb_dequeue(&card->tty_rx_full)) != NULL){
		if (tty->ldisc.receive_buf){
			tty->ldisc.receive_buf(tty,skb->data,&fp,skb->len);
		skb_queue_tail(&card->tty_rx_empty,skb);
	if (test_and_clear_bit(TX_INTR,(void*)&card->wandev.critical)){
		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
		    tty->ldisc.write_wakeup){
			(tty->ldisc.write_wakeup)(tty);
		wake_up_interruptible(&tty->write_wait);
		wake_up_interruptible(&tty->poll_wait);
	if (!tty || !tty->driver_data){
	card = (sdla_t*)tty->driver_data;
			card->devname);
	if (!card->tty_open)
	if (--card->tty_open == 0){
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);	
		card->tty=NULL;
		if (card->tty_buf){
			kfree(card->tty_buf);
			card->tty_buf=NULL;			
		while ((skb=skb_dequeue(&card->tty_rx_empty)) != NULL){
		while ((skb=skb_dequeue(&card->tty_rx_full)) != NULL){
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		return -ENODEV;
	if (!tty->driver_data){
		port = tty->index;
		port = MINOR(tty->device) - tty->driver.minor_start;
			return -ENODEV;
		tty->driver_data = WAN_CARD(port);
		if (!tty->driver_data)
			return -ENODEV;
	card = (sdla_t*)tty->driver_data;
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);	
		card->tty=NULL;
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		return -ENODEV;
			card->devname);
	if (card->tty_open == 0){
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);	
		card->tty=tty;
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		if (!card->tty_buf){
			card->tty_buf = kmalloc(TTY_CHDLC_MAX_MTU, GFP_KERNEL);
			if (!card->tty_buf){
				card->tty_buf=NULL;
				card->tty=NULL;
				return -ENOMEM;	
		skb_queue_head_init(&card->tty_rx_empty);
		skb_queue_head_init(&card->tty_rx_full);
				while ((skb=skb_dequeue(&card->tty_rx_empty)) != NULL){
				kfree(card->tty_buf);
				card->tty_buf=NULL;
				card->tty=NULL;
				return -ENOMEM;
			skb_queue_tail(&card->tty_rx_empty,skb);
		clear_bit(TTY_HANGUP,&card->wandev.critical);
	++card->tty_open;
		return -ENODEV;
	card = (sdla_t *)tty->driver_data;
		return -ENODEV;
	if (count > card->wandev.mtu){
				count,card->wandev.mtu);
		return -EINVAL;
	if (card->wandev.state != WAN_CONNECTED){
		return -EINVAL;
      	if(card->type != SDLA_S514){
	if (test_and_set_bit(SEND_CRIT,(void*)&card->wandev.critical)){
				card->devname);
		if(card->type != SDLA_S514)
		return -EINVAL; 
		if ((tmp_buf=card->tty_buf)==NULL){
			clear_bit(SEND_CRIT,(void*)&card->wandev.critical);
			if(card->type != SDLA_S514)
			return -ENOMEM;
					card->devname);
			clear_bit(SEND_CRIT,(void*)&card->wandev.critical);
			if(card->type != SDLA_S514)
			return -EINVAL;
					card->devname);
			clear_bit(SEND_CRIT,(void*)&card->wandev.critical);
			if(card->type != SDLA_S514)
					card->devname);
			clear_bit(SEND_CRIT,(void*)&card->wandev.critical);
			if(card->type != SDLA_S514)
	DEBUG_TEST("%s: Packet sent OK: %i\n",card->devname,count);
	clear_bit(SEND_CRIT,(void*)&card->wandev.critical);
	if(card->type != SDLA_S514)
	if (!card->tty_open){
				card->devname);
	if ((tty=card->tty) == NULL){
				card->devname);
	if (!tty->driver_data){
				card->devname);
	if (card->u.c.async_mode){
					card->devname,len,TTY_CHDLC_MAX_MTU);
		skb=skb_dequeue(&card->tty_rx_empty);
		if ((tty->flip.count+len) >= TTY_CHDLC_MAX_MTU){
					card->devname,len,TTY_CHDLC_MAX_MTU);
		if((addr + len) > card->u.c.rx_top_off + 1) {
			offset = card->u.c.rx_top_off - addr + 1;
			card->hw_iface.peek(card->hw, addr, buf, offset);  
			addr = card->u.c.rx_base_off;
			len -= offset;
			card->hw_iface.peek(card->hw, addr, tty->flip.char_buf_ptr, offset);
			addr = card->u.c.rx_base_off;
			len -= offset;
			tty->flip.char_buf_ptr+=offset;
			tty->flip.count+=offset;
				*tty->flip.flag_buf_ptr = 0;
				tty->flip.flag_buf_ptr++;
		card->hw_iface.peek(card->hw, addr, buf, len);
		skb_queue_tail(&card->tty_rx_empty,skb);
		card->hw_iface.peek(card->hw, addr, tty->flip.char_buf_ptr, len);
		tty->flip.char_buf_ptr+=len;
		card->tty->flip.count+=len;
			*tty->flip.flag_buf_ptr = 0;
			tty->flip.flag_buf_ptr++;
		tty->low_latency=1;
					card->devname,len,TTY_CHDLC_MAX_MTU);
			skb=skb_dequeue(&card->tty_rx_empty);
			if((addr + len) > card->u.c.rx_top_off + 1) {
				offset = card->u.c.rx_top_off - addr + 1;
				card->hw_iface.peek(card->hw, addr, buf, offset);
				addr = card->u.c.rx_base_off;
				len -= offset;
			card->hw_iface.peek(card->hw, addr, buf, len);
			skb_queue_tail(&card->tty_rx_full,skb);
	return -ENOIOCTLCMD;
	if (card->u.c.async_mode){
				card->devname);
			return -EINVAL;
				card->devname);
			return -EINVAL;
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
		int	err = -EINVAL;
			card->devname, 
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
					card->devname,
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
		int	err = -EINVAL;
			card->devname);
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
				card->devname);
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
				card->devname);
		return -EINVAL;	
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, 
	if(IS_TE1_CARD(card) && card->wandev.ignore_front_end_status == WANOPT_NO) {
		if (card->u.c.async_mode){
						card->devname);
				card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
				card->u.c.comm_enabled=0;
				return -EINVAL;
						card->devname);
				card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
				card->u.c.comm_enabled=0;
				return -EINVAL;
						card->devname);
	card->u.c.state = WAN_CONNECTING;
		card->wandev.fe_iface.read_alarm(&card->fe, 1); 
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, 
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	cflag = tty->termios->c_cflag;
	if (card->u.c.async_mode){
		if (card->wandev.bps != baud)
		card->wandev.bps = baud;
	if (card->u.c.async_mode){
		if (card->u.c.protocol_options != handshaking)
		card->u.c.protocol_options = handshaking;
		if (card->u.c.tx_bits_per_char != dbits)
		card->u.c.tx_bits_per_char = dbits;
		if (card->u.c.rx_bits_per_char != dbits)
		card->u.c.rx_bits_per_char = dbits;
		if (card->u.c.stop_bits != sbits)
		card->u.c.stop_bits = sbits;
		if (card->u.c.parity != parity)
		card->u.c.parity = parity;	
		card->u.c.break_timer = 50;
		card->u.c.inter_char_timer = 10;
		card->u.c.rx_complete_length = 100;
		card->u.c.xon_char = 0xFE;
		card->u.c.protocol_options |= HDLC_STREAMING_MODE;
	card = (sdla_t *)tty->driver_data;
	if (change_speed(card, tty, old_termios) || !card->u.c.comm_enabled){
		if (card->u.c.comm_enabled){
			wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
			wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		if (card->u.c.async_mode){
				 card->devname,
				 card->wandev.bps,
				 opt_decode[card->u.c.protocol_options],
				 card->u.c.tx_bits_per_char,
				 card->u.c.rx_bits_per_char,
				 p_decode[card->u.c.parity] ,
				 card->u.c.stop_bits);
				 card->devname,card->wandev.bps);
			card->u.c.state = WAN_CONNECTED;
			card->u.c.state = WAN_DISCONNECTED;
	card = (sdla_t *)tty->driver_data;
	if (card->wandev.state != WAN_CONNECTED)
	if(card->type != SDLA_S514)
	if (test_and_set_bit(SEND_CRIT,(void*)&card->wandev.critical)){
		if(card->type != SDLA_S514)
		DEBUG_TEST("%s: Failed to TX char!\n",card->devname);
		DEBUG_TEST("%s: Char TX OK\n",card->devname);
	clear_bit(SEND_CRIT,(void*)&card->wandev.critical);
	if(card->type != SDLA_S514)
	wake_up_interruptible(&tty->write_wait);
	wake_up_interruptible(&tty->poll_wait);
	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
	    tty->ldisc.write_wakeup)
		(tty->ldisc.write_wakeup)(tty);
 * This function is used to send a high-priority XON/XOFF character to
	card = (sdla_t *)tty->driver_data;
	if (card->wandev.state != WAN_CONNECTED)
	wan_mbox_t *mb = &card->wan_mbox;
	mb->wan_data_len=1;
	mb->wan_command=SET_MODEM_STATUS;
	mb->wan_data[0]=data;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card = (sdla_t *)tty->driver_data;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
 * The serial driver boot-time initialization code!
	if (card->tty_minor < 0 || card->tty_minor > NR_PORTS){
		printk(KERN_INFO "%s: Illegal Minor TTY number (0-4): %i\n",
				card->devname,card->tty_minor);
		return -EINVAL;
	if (WAN_CARD(card->tty_minor)){
				card->devname,card->tty_minor);
		return -EBUSY;
		printk(KERN_INFO "%s: TTY %s Driver Init: Major %i, Minor Range %i-%i\n",
				card->devname,
				card->u.c.async_mode ? "ASYNC" : "SYNC",
		tty_driver_mode = card->u.c.async_mode;
					card->devname);
					card->devname);
	if (tty_driver_mode != card->u.c.async_mode){
				card->devname);
				card->devname, tty_driver_mode ? "ASYNC" : "SYNC");
		return -EINVAL;
			card->devname,
			card->tty_minor,card->tty_minor);
			card->devname,
			card->tty_minor,card->tty_minor);
	tty_card_map[card->tty_minor] = card;
	state = &rs_table[card->tty_minor];
	state->magic = SSTATE_MAGIC;
	state->line = 0;
	state->type = PORT_UNKNOWN;
	state->custom_divisor = 0;
	state->close_delay = 5*HZ/10;
	state->closing_wait = 30*HZ;
	state->callout_termios = callout_driver.init_termios;
	state->normal_termios = serial_driver.init_termios;
	state->icount.cts = state->icount.dsr = 
		state->icount.rng = state->icount.dcd = 0;
	state->icount.rx = state->icount.tx = 0;
	state->icount.frame = state->icount.parity = 0;
	state->icount.overrun = state->icount.brk = 0;
	state->irq = card->wandev.irq; 
	WAN_TASKQ_INIT((&card->tty_task_queue),0,tty_poll_task,card);
#define PROC_CFG_FRM	"%-15s| %-12s|\n"
#define PROC_STAT_FRM	"%-15s| %-12s| %-14s|\n"
		return m->count;
	card = chdlc_priv_area->card;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		PROC_CFG_FRM, chdlc_priv_area->if_name, card->devname);
	return m->count;
		return m->count;
	card = chdlc_priv_area->card;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		chdlc_priv_area->if_name,
		card->devname,
		STATE_DECODE(chdlc_priv_area->common.state));
	return m->count;
#define PROC_DEV_FR_S_FRM	"%-20s| %-14s|\n"
#define PROC_DEV_FR_D_FRM	"%-20s| %-14d|\n"
	card = (sdla_t*)wandev->priv;
			wandev->name, buffer);
#define PROC_IF_FR_S_FRM	"%-30s\t%-14s\n"
#define PROC_IF_FR_D_FRM	"%-30s\t%-14d\n"
#define PROC_IF_FR_L_FRM	"%-30s\t%-14ld\n"
	if (dev == NULL || dev->priv == NULL)
	chdlc_priv_area = (chdlc_private_area_t*)dev->priv;
			chdlc_priv_area->if_name, buffer);
	if (card->tty_opt){
		if (card->fe.fe_status == FE_CONNECTED){
			set_bit(TTY_HANGUP,&card->wandev.critical);
			if(card->u.c.comm_enabled == 0) {
							card->devname);
					card->u.c.state = WAN_CONNECTING;
							card->devname,rc);
			 if (card->wandev.ignore_front_end_status == WANOPT_NO && 
			     card->u.c.comm_enabled){ 
						card->devname);
				card->u.c.state = WAN_DISCONNECTED;
			if (card->tty && card->tty_open){
				if (test_and_clear_bit(TTY_HANGUP,&card->wandev.critical)){
							card->devname);
					tty_hangup(card->tty);
	if (card->wandev.ignore_front_end_status == WANOPT_YES){
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		if (card->fe.fe_status == FE_CONNECTED) {
			if (card->u.c.state != WAN_CONNECTED) {
				if(card->u.c.comm_enabled == 0) {
								card->devname);
						card->u.c.state = WAN_CONNECTING;
								card->devname,rc);
							card->devname);
			if (card->u.c.comm_enabled){
							card->devname);
				card->u.c.state = WAN_DISCONNECTED;
		if (card->fe.fe_status == FE_CONNECTED){
			if (card->u.c.state == WAN_CONNECTED){
			if (!(card->u.c.protocol_options & IGNORE_KPALV_FOR_LINK_STAT)){
        wan_mbox_t*			mb = &card->wan_mbox;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);		
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);		
	op_stats = (CHDLC_OPERATIONAL_STATS_STRUCT *)mb->wan_data;
	if (card->wan_debugging_state == WAN_DEBUGGING_CONT){
		rx_keepalives	= op_stats->CHDLC_SLARP_REPLY_Rx_count;
		card->wan_debugging_state = WAN_DEBUGGING_PROTOCOL;
	if (op_stats->CHDLC_SLARP_REPLY_Rx_count != rx_keepalives){
		if (card->wan_debug_last_msg != WAN_DEBUG_CHDLC_UNKNWN_MSG){
						card->devname);
						card->devname);
		card->wan_debug_last_msg = WAN_DEBUG_CHDLC_UNKNWN_MSG;
		if (card->wan_debug_last_msg != WAN_DEBUG_CHDLC_KPLV_MSG){
						card->devname);
						card->devname);
		card->wan_debug_last_msg = WAN_DEBUG_CHDLC_KPLV_MSG;
        wan_mbox_t*			mb = &card->wan_mbox;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);		
		stats = (COMMS_ERROR_STATS_STRUCT *)mb->wan_data;
		crc_err_count = stats->CRC_err_count;	
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);		
        wan_mbox_t*			mb = &card->wan_mbox;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);		
		stats = (COMMS_ERROR_STATS_STRUCT *)mb->wan_data;
		rx_abort_count = stats->Rx_abort_count;	
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);		
        wan_mbox_t*			mb = &card->wan_mbox;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);		
		stats = (COMMS_ERROR_STATS_STRUCT *)mb->wan_data;
		tx_underruns = stats->sec_Tx_abort_msd_Tx_int_count;	
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);		
./sdla_chdlc.c
	((type) == WP_RM_POLL_EVENT) ? "RM-Event":				\
	((type) == WP_RM_POLL_TXSIG_OFFHOOK) ? "TX Sig Off-hook":		\
	((type) == WP_RM_POLL_TXSIG_ONHOOK) ? "TX Sig On-hook":			\
	((type) == WP_RM_POLL_ONHOOKTRANSFER) ? "On-hook transfer":		\
	((type) == WP_RM_POLL_RXSIG_OFFHOOK) ? "RX Sig Off-hook":		\
	((type) == WP_RM_POLL_RXSIG_ONHOOK) ? "RX Sig On-hook":			\
** OSC1= 350 Hz OSC2= 440 Hz .0975 Volts -18 dBm */
** OSC1= 480  OSC2 = 620 .0975 Voltz -18 dBm 8 */
** OSC1 = 440 Hz OSC2 = 480 .0975 Volts -18 dBm */
** OSC1= 480 Hz OSC2 = 620 .0975 Volts -18 dBM */
	WP_SCHEDULE(foo, "A-USB");
		if (!fast) WP_SCHEDULE(foo, "A-USB");
				fe->name, address, data);
	int res = -1;
	DEBUG_CFG("%s: Initializing Indirect Registers...\n", fe->name);
			return -1;
	DEBUG_CFG("%s: Initializing Indirect Registers...Done!\n", fe->name);
	DEBUG_CFG("%s: Verifing Indirect Registers...\n", fe->name);
						fe->name, mod_no+1,
			return -1;
						fe->name, mod_no+1,
						fe->name, mod_no+1);
		return -1;
	DEBUG_CFG("%s: Verifing Indirect Registers...Done!\n", fe->name);
** wp_usb_remora_module_detect() - 
					fe->name, mod_no+1);
			fe->rm_param.mod[mod_no].type	=
			DEBUG_RM("%s: Module %d - Not detected!\n",
					fe->name, mod_no+1);
			fe->rm_param.mod[mod_no].type	=
					fe->name,
		return -1;
					fe->name);
		return -1;
					fe->name,
		return -1;
					fe->name, mod_no+1, value);
		return -1;
					fe->name, mod_no+1, value);
		return -1;
					fe->name, mod_no+1, value);
		return -1;
	DEBUG_CFG("%s: PowerUp SLIC initialization...\n", fe->name);
	fxs = &fe->rm_param.mod[mod_no].u.fxs;
	/* set the period of the DC-DC converter to 1/64 kHz  START OUT SLOW*/
		if ((SYSTEM_TICKS - start_ticks) > HZ/2){
		if (fxs->proslic_power == PROSLIC_POWER_UNKNOWN){
					fe->name,
					(u_int32_t)(((SYSTEM_TICKS - start_ticks) * 1000 / HZ)),
					fe->name,
		fxs->proslic_power = PROSLIC_POWER_WARNED;
		return -1;
	fxs->proslic_power = PROSLIC_POWER_ON;
					fe->name, mod_no+1,
        lim = (loopcurrent - 20) / 3;
					fe->name, mod_no+1);
					fe->name,
	WRITE_USB_RM_REG(mod_no, 93, 0x99);  /* DC-DC Calibration  */
	/* Wait for DC-DC Calibration to complete */
		if ((SYSTEM_TICKS - start_ticks) > 2*HZ){
			"%s: Module %d: Timeout waiting for DC-DC calibration (%02X)\n",
						fe->name, mod_no+1,
			return -EINVAL;
	DEBUG_CFG("%s: PowerUp SLIC initialization...Done!\n", fe->name);
	DEBUG_CFG("%s: PowerLeak ProSLIC testing...\n", fe->name);
					fe->name, mod_no+1,
					(u_int32_t)((SYSTEM_TICKS - start_ticks) * 1000 / HZ));
		return -1;
	DEBUG_RM("%s: Module %d: Post-leakage voltage: %d volts\n",
					fe->name,
	DEBUG_CFG("%s: PowerLeak ProSLIC testing...Done!\n", fe->name);
	DEBUG_CFG("%s: ProSLIC calibration...\n", fe->name);
		if ((SYSTEM_TICKS - start_ticks) > 2*HZ){
					fe->name, mod_no+1);
			return -1;
	DEBUG_CFG("%s: ProSLIC calibration...Done!\n", fe->name);
	DEBUG_CFG("%s: ProSLIC manual calibration...\n", fe->name);
		if ((SYSTEM_TICKS - start_ticks) > 800){
					fe->name, mod_no+1);
			return -1;
	for (i = 0x1f; i > 0; i--){
	for (i = 0x1f; i > 0; i--){
		if ((SYSTEM_TICKS - start_ticks) > 400){
				fe->name, mod_no+1,
			return -1;
				fe->name, mod_no+1);
	DEBUG_CFG("%s: ProSLIC manual calibration...Done!\n", fe->name);
	if (fe->fe_cfg.cfg.remora.reversepolarity){
		fe->rm_param.mod[mod_no].u.fxs.idletxhookstate = 5;
		fe->rm_param.mod[mod_no].u.fxs.idletxhookstate = 1;
	DEBUG_CFG("%s: Start ProSLIC configuration...\n", fe->name);
		return -2;
		fe->rm_param.mod[mod_no].u.fxs.proslic_power = PROSLIC_POWER_UNKNOWN;
							fe->name,
		return -1;
	/* Power up the DC-DC converter */
					fe->name,
		return -1;
						fe->name,
						fe->name,
			return -1;
			return -1;
			return -1;
		/* Perform DC-DC calibration */
			"%s: Module %d: DC-DC calibration has a surprising direct 107 of 0x%02x!\n",
						fe->name,
			fe->rm_param.mod[mod_no].u.fxs.callregs.vals[x] =
				fe->rm_param.mod[mod_no].u.fxs.callregs.vals[x]);
					fe->name,
		return -1;
	if (fe->fe_cfg.tdmv_law == WAN_TDMV_ALAW){
	}else if (fe->fe_cfg.tdmv_law == WAN_TDMV_MULAW){
	/* U-Law 8-bit interface */
	if (!strcmp(fxo_modes[fe->fe_cfg.cfg.remora.opermode].name, "AUSTRALIA")) {
		value = (unsigned char)acim2tiss[fxo_modes[fe->fe_cfg.cfg.remora.opermode].acim];
		if (fxo_modes[fe->fe_cfg.cfg.remora.opermode].ring_osc){
				(unsigned char)fxo_modes[fe->fe_cfg.cfg.remora.opermode].ring_osc);
		if (fxo_modes[fe->fe_cfg.cfg.remora.opermode].ring_x){
				(unsigned char)fxo_modes[fe->fe_cfg.cfg.remora.opermode].ring_x);
	if (fe->fe_cfg.cfg.remora.fxs_lowpower == WANOPT_YES){
	if (fe->fe_cfg.cfg.remora.fxs_fastringer == WANOPT_YES){
		if (!strcmp(fxo_modes[fe->fe_cfg.cfg.remora.opermode].name, "AUSTRALIA")) {
				return -1;
					fe->name, mod_no + 1);
		} else if (fe->fe_cfg.cfg.remora.fxs_lowpower == WANOPT_YES){
				return -1;
					fe->name, mod_no + 1);
					fe->name, mod_no + 1);
		if (!strcmp(fxo_modes[fe->fe_cfg.cfg.remora.opermode].name, "AUSTRALIA")) {
			if (fe->fe_cfg.cfg.remora.fxs_ringampl){
				switch(fe->fe_cfg.cfg.remora.fxs_ringampl){
							fe->name,mod_no+1, fe->fe_cfg.cfg.remora.fxs_ringampl, ringx, vbath);
							fe->name, mod_no+1); 
							fe->name, mod_no+1, fe->fe_cfg.cfg.remora.fxs_ringampl); 
					return -1;
						fe->name, mod_no+1);
		} else if (fe->fe_cfg.cfg.remora.fxs_lowpower == WANOPT_YES){
				return -1;
						fe->name, mod_no+1);
	if (fe->fe_cfg.cfg.remora.fxs_txgain || fe->fe_cfg.cfg.remora.fxs_rxgain) {
					fe->name, mod_no+1,
					(fe->fe_cfg.cfg.remora.fxs_txgain == 35) ? "3.5dB":
					(fe->fe_cfg.cfg.remora.fxs_txgain == -35) ? "-3.5dB":"0dB");
		switch (fe->fe_cfg.cfg.remora.fxs_txgain) {
		case -35:
					fe->name, mod_no+1,
					(fe->fe_cfg.cfg.remora.fxs_rxgain == 35) ? "3.5dB":
					(fe->fe_cfg.cfg.remora.fxs_rxgain == -35) ? "-3.5dB":"0dB");
		switch (fe->fe_cfg.cfg.remora.fxs_rxgain) {
		case -35:
		fe->rm_param.mod[mod_no].u.fxs.imask1 = 0x00;
		fe->rm_param.mod[mod_no].u.fxs.imask2 = 0x03;
		fe->rm_param.mod[mod_no].u.fxs.imask3 = 0x01;
		fe->rm_param.mod[mod_no].u.fxs.imask1 = 0x00;
		fe->rm_param.mod[mod_no].u.fxs.imask2 = 0xFC;
		fe->rm_param.mod[mod_no].u.fxs.imask3 = 0x00;
					fe->name, mod_no+1,
			if ((SYSTEM_TICKS - start_ticks) > HZ*10){
						fe->name,
			return -1;
				fe->name,
		return -1;
					fe->name, mod_no+1,
	DEBUG_CFG("%s: Start ProSLIC configuration...Done!\n", fe->name);
		return -2;
				fe->name,
		return -2;
	if (fe->fe_cfg.tdmv_law == WAN_TDMV_ALAW){
	}else if (fe->fe_cfg.tdmv_law == WAN_TDMV_MULAW){
	/* Set On-hook speed, Ringer impedence, and ringer threshold */
	reg16 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].ohs << 6);
	reg16 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].rz << 1);
	reg16 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].rt);
	reg26 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].dcv << 6);
	reg26 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].mini << 4);
	reg26 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].ilim << 1);
	reg30 = (unsigned char)(fxo_modes[fe->fe_cfg.cfg.remora.opermode].acim);
	reg31 |= (fxo_modes[fe->fe_cfg.cfg.remora.opermode].ohs2 << 3);
	/* Enable ISO-Cap */
		/* Wait 1000ms for ISO-cap to come up */
						fe->name,
			return -1;
		DEBUG_TEST("%s: Module %d: ISO-Cap is now up, line side: %02x rev %02x\n", 
				fe->name,
	/* Enable on-hook line monitor */
	fe->rm_param.mod[mod_no].u.fxo.imask = 0xFF;
	fe->rm_param.mod[mod_no].u.fxo.imask = 0x00;
	if (fe->fe_cfg.cfg.remora.fxo_txgain) {
		if (fe->fe_cfg.cfg.remora.fxo_txgain >= -150 && fe->fe_cfg.cfg.remora.fxo_txgain < 0) {
					fe->name, mod_no+1,
					fe->fe_cfg.cfg.remora.fxo_txgain / 10,
					fe->fe_cfg.cfg.remora.fxo_txgain % -10);
			WRITE_USB_RM_REG(mod_no, 38, 16 + (fe->fe_cfg.cfg.remora.fxo_txgain/-10));
			if(fe->fe_cfg.cfg.remora.fxo_txgain % 10) {
				WRITE_USB_RM_REG(mod_no, 40, 16 + (-fe->fe_cfg.cfg.remora.fxo_txgain%10));
		else if (fe->fe_cfg.cfg.remora.fxo_txgain <= 120 && fe->fe_cfg.cfg.remora.fxo_txgain > 0) {
					fe->name, mod_no+1,
					fe->fe_cfg.cfg.remora.fxo_txgain / 10,
					fe->fe_cfg.cfg.remora.fxo_txgain % 10);
			WRITE_USB_RM_REG(mod_no, 38, fe->fe_cfg.cfg.remora.fxo_txgain/10);
			if (fe->fe_cfg.cfg.remora.fxo_txgain % 10){
				WRITE_USB_RM_REG(mod_no, 40, (fe->fe_cfg.cfg.remora.fxo_txgain % 10));
	if (fe->fe_cfg.cfg.remora.fxo_rxgain) {
		if (fe->fe_cfg.cfg.remora.fxo_rxgain >= -150 && fe->fe_cfg.cfg.remora.fxo_rxgain < 0) {
					fe->name, mod_no+1,
					fe->fe_cfg.cfg.remora.fxo_rxgain / 10,
					(-1) * (fe->fe_cfg.cfg.remora.fxo_rxgain % 10));
			WRITE_USB_RM_REG(mod_no, 39, 16 + (fe->fe_cfg.cfg.remora.fxo_rxgain/-10));
			if(fe->fe_cfg.cfg.remora.fxo_rxgain%10) {
				WRITE_USB_RM_REG(mod_no, 41, 16 + (-fe->fe_cfg.cfg.remora.fxo_rxgain%10));
		}else if (fe->fe_cfg.cfg.remora.fxo_rxgain <= 120 && fe->fe_cfg.cfg.remora.fxo_rxgain > 0) {
					fe->name, mod_no+1,
					fe->fe_cfg.cfg.remora.fxo_rxgain / 10,
					fe->fe_cfg.cfg.remora.fxo_rxgain % 10);
			WRITE_USB_RM_REG(mod_no, 39, fe->fe_cfg.cfg.remora.fxo_rxgain/10);
			if(fe->fe_cfg.cfg.remora.fxo_rxgain % 10) {
				WRITE_USB_RM_REG(mod_no, 41, (fe->fe_cfg.cfg.remora.fxo_rxgain%10));
	/* NZ -- crank the tx gain up by 7 dB */
	if (!strcmp(fxo_modes[fe->fe_cfg.cfg.remora.opermode].name, "NEWZEALAND")) {
					fe->name,
** wp_usb_remora_iface_init) - 
	fe_iface->config	= &wp_usb_remora_config;
	fe_iface->unconfig	= &wp_usb_remora_unconfig;
	fe_iface->post_init	= &wp_usb_remora_post_init;
	fe_iface->if_config	= &wp_usb_remora_if_config;
	fe_iface->if_unconfig	= &wp_usb_remora_if_unconfig;
	fe_iface->pre_release	= &wp_usb_remora_pre_release;
	fe_iface->active_map	= &wp_usb_remora_active_map;
	fe_iface->isr		= &wp_usb_remora_intr;
	fe_iface->disable_irq	= &wp_usb_remora_disable_irq;
	fe_iface->check_isr	= &wp_usb_remora_check_intr;
	fe_iface->polling	= &wp_usb_remora_polling;
	fe_iface->process_udp	= &wp_usb_remora_udp;
	fe_iface->get_fe_media	= &wp_usb_remora_fe_media;
	fe_iface->set_dtmf	= &wp_usb_remora_set_dtmf;
	fe_iface->intr_ctrl	= &wp_usb_remora_intr_ctrl;
	fe_iface->event_ctrl	= &wp_usb_remora_event_ctrl;
	fe_iface->watchdog	= &wp_usb_remora_watchdog;
	WAN_LIST_INIT(&fe->event);
	wan_spin_lock_irq_init(&fe->lockirq, "wan_rm_lock");
** wp_usb_remora_opermode() - 
	sdla_fe_cfg_t	*fe_cfg = &fe->fe_cfg;
	if (!strlen(fe_cfg->cfg.remora.opermode_name)){
		memcpy(fe_cfg->cfg.remora.opermode_name, "FCC", 3);
		fe_cfg->cfg.remora.opermode = 0;
			if (!strcmp(fxo_modes[x].name, fe_cfg->cfg.remora.opermode_name))
			fe_cfg->cfg.remora.opermode = x;
						fe->name,
						fe_cfg->cfg.remora.opermode_name);
						fe->name);
					fe->name, fxo_modes[x].name);
			return -ENODEV;
** wp_usb_remora_config() - 
        		     	fe->name);
	fe->rm_param.max_fe_channels 	= MAX_USB_REMORA_MODULES;
	fe->rm_param.module_map 	= 0;
	fe->rm_param.intcount		= 0;
	fe->rm_param.last_watchdog 	= SYSTEM_TICKS;
		return -EINVAL;
				fe->name);
		return -EINVAL;
		switch(fe->rm_param.mod[mod_no].type){
				"%s: Module %d: Installed -- Auto FXS!\n",
					fe->name, mod_no+1);	
				wan_set_bit(mod_no, &fe->rm_param.module_map);
				fe->rm_param.mod[mod_no].u.fxs.oldrxhook = 1;	/* default (off-hook) */
				"%s: Module %d: Installed -- Auto FXO (%s mode)!\n",
					fe->name, mod_no+1,
					fxo_modes[fe->fe_cfg.cfg.remora.opermode].name);
				wan_set_bit(mod_no, &fe->rm_param.module_map);
			"%s: Module %d: Installed -- FXS/FXO tester!\n",
					fe->name, mod_no+1);
			wan_set_bit(mod_no, &fe->rm_param.module_map);
			((sdla_t*)fe->card)->fe_no_intr = 0x1;
						fe->name, mod_no+1);	
					fe->name, mod_no+1);
				fe->name, mod_no+1,
				WP_REMORA_DECODE_TYPE(fe->rm_param.mod[mod_no].type));
	if (err_cnt && fe->fe_cfg.cfg.remora.relaxcfg != WANOPT_YES){
					fe->name, err_cnt);
		return -EINVAL;
	fe->remora_modules_counter = mod_cnt;
					fe->name);
					fe->name);
		return -EINVAL;
	wan_set_bit(WP_RM_TIMER_KILL,(void*)&fe->rm_param.critical);
		&fe->timer, 
	wan_clear_bit(WP_RM_TIMER_KILL,(void*)&fe->rm_param.critical);
	wan_clear_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical);
	wan_set_bit(WP_RM_CONFIGURED,(void*)&fe->rm_param.critical);
** wp_usb_remora_unconfig() - 
        		     	fe->name);
	wan_clear_bit(WP_RM_CONFIGURED,(void*)&fe->rm_param.critical);
		if (!wan_test_bit(mod_no, &fe->rm_param.module_map)) continue;
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
		wan_clear_bit(mod_no, &fe->rm_param.module_map);
	wan_set_bit(WP_RM_TIMER_KILL,(void*)&fe->rm_param.critical);
	if (wan_test_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical)){
		wan_del_timer(&fe->timer);
	wan_clear_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical);
		wan_spin_lock_irq(&fe->lockirq,&smp_flags);
		if (!WAN_LIST_EMPTY(&fe->event)){
			fe_event = WAN_LIST_FIRST(&fe->event);
		wan_spin_unlock_irq(&fe->lockirq,&smp_flags);
** wp_usb_remora_post_init() - 
	DEBUG_EVENT("%s: Running post initialization...\n", fe->name);
** wp_usb_remora_if_config() - 
	if (!wan_test_bit(WP_RM_CONFIGURED,(void*)&fe->rm_param.critical)){
		return -EINVAL;
			if (!wan_test_bit(mod_no, &fe->rm_param.module_map) ||
** wp_usb_remora_if_unconfig() - 
	if (!wan_test_bit(WP_RM_CONFIGURED,(void*)&fe->rm_param.critical)){
		return -EINVAL;
			if (!wan_test_bit(mod_no, &fe->rm_param.module_map) ||
** wp_usb_remora_disable_irq() - 
	if (!wan_test_bit(WP_RM_CONFIGURED,(void*)&fe->rm_param.critical)){
		return -EINVAL;
		if (wan_test_bit(mod_no, &fe->rm_param.module_map)) {
	return fe->rm_param.module_map;
	return fe->fe_cfg.media;
					fe->name, mod_no+1);
		return -EINVAL;
	if (!wan_test_bit(mod_no-1, &fe->rm_param.module_map)){
					fe->name, mod_no+1);
		return -EINVAL;
	return -EINVAL;
	sdla_t 		*card = (sdla_t*)fe->card;
	wan_device_t	*wandev = &card->wandev;
	DEBUG_TEST("%s: RM timer!\n", fe->name);
	if (wan_test_bit(WP_RM_TIMER_KILL,(void*)&fe->rm_param.critical)){
		wan_clear_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical);
	if (!wan_test_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical)){
					fe->name);
	wan_clear_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical);
	wan_spin_lock_irq(&fe->lockirq,&smp_flags);	
	empty = WAN_LIST_EMPTY(&fe->event);
	wan_spin_unlock_irq(&fe->lockirq,&smp_flags);	
		if (wan_test_and_set_bit(WP_RM_TIMER_EVENT_PENDING,(void*)&fe->rm_param.critical)){
			DEBUG_EVENT("%s: USB-FXO timer event is pending!\n", fe->name);
		if (wandev->fe_enable_timer){
			wandev->fe_enable_timer(fe->card);
DEBUG_EVENT("%s: USB-FXO event timer event is NULL!\n", fe->name);
	DEBUG_TEST("%s: Add new RM timer!\n", fe->name);
	err = wan_add_timer(&fe->timer, delay * HZ / 1000);
		return -EINVAL;
	wan_set_bit(WP_RM_TIMER_RUNNING,(void*)&fe->rm_param.critical);
	sdla_t			*card = (sdla_t*)fe->card;
	WAN_ASSERT_RC(fe->write_fe_reg == NULL,0);
	WAN_ASSERT_RC(fe->read_fe_reg == NULL, 0);
	DEBUG_EVENT("%s: %s:%d: ---------------START ----------------------\n",
				fe->name, __FUNCTION__,__LINE__);
	DEBUG_EVENT("%s: %s:%d: ---------------STOP ----------------------\n",
				fe->name, __FUNCTION__,__LINE__);
	wan_spin_lock_irq(&fe->lockirq,&smp_flags);			
	if (WAN_LIST_EMPTY(&fe->event)){
		wan_clear_bit(WP_RM_TIMER_EVENT_PENDING,(void*)&fe->rm_param.critical);
		wan_spin_unlock_irq(&fe->lockirq,&smp_flags);	
					fe->name);
	fe_event = WAN_LIST_FIRST(&fe->event);
	wan_spin_unlock_irq(&fe->lockirq,&smp_flags);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	mod_no = fe_event->rm_event.mod_no;
			fe->name, mod_no+1,
			fe->fe_status==FE_CONNECTED?"Con":"Disconn",
			WP_RM_POLL_DECODE(fe_event->type), fe_event->type,
			WAN_EVENT_MODE_DECODE(fe_event->mode));
	switch(fe_event->type){
		if (fe_event->mode == WAN_EVENT_ENABLE){
				&fe->rm_param.mod[mod_no].events);
				&fe->rm_param.mod[mod_no].events);
		if (fe_event->mode == WAN_EVENT_ENABLE){
				&fe->rm_param.mod[mod_no].events);
				&fe->rm_param.mod[mod_no].events);
		if (fe_event->mode == WAN_EVENT_ENABLE){
				&fe->rm_param.mod[mod_no].events);
				&fe->rm_param.mod[mod_no].events);
		if (fe_event->mode == WAN_EVENT_ENABLE){
				&fe->rm_param.mod[mod_no].events);
				&fe->rm_param.mod[mod_no].events);
		if (fe_event->mode == WAN_EVENT_ENABLE){
				&fe->rm_param.mod[mod_no].events);
				&fe->rm_param.mod[mod_no].events);
		if (fe_event->mode == WAN_EVENT_ENABLE){
					fe->name, mod_no+1,
					WAN_EVENT_MODE_DECODE(fe_event->mode),
					WP_RM_POLL_DECODE(fe_event->type),
					fe_event->rm_event.tone);
			switch(fe_event->rm_event.tone){
				&fe->rm_param.mod[mod_no].events);
				&fe->rm_param.mod[mod_no].events);
		fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 0;
		WRITE_USB_RM_REG(mod_no, 64, fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
					fe->name, mod_no+1);
			fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 4;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
			DEBUG_RM("%s: Module %d: goes off-hook.\n", 
					fe->name, mod_no+1);
			fe->rm_param.mod[mod_no].u.fxo.offhook = 1;
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
			DEBUG_RM("%s: Module %d: goes off-hook.\n",
						fe->name, mod_no+1);
			switch(fe->rm_param.mod[mod_no].sig) {
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 5;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook =
					fe->rm_param.mod[mod_no].u.fxs.idletxhookstate;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
			DEBUG_TDMV("%s: Module %d: goes off-hook.\n", 
					fe->name, mod_no+1);
			fe->rm_param.mod[mod_no].u.fxo.offhook = 1;
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
			DEBUG_RM("%s: Module %d: goes on-hook.\n",
						fe->name, mod_no+1);
			switch(fe->rm_param.mod[mod_no].sig) {
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook =
					fe->rm_param.mod[mod_no].u.fxs.idletxhookstate;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 3;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
			DEBUG_RM("%s: Module %d: goes on-hook.\n", 
					fe->name, mod_no+1);
			fe->rm_param.mod[mod_no].u.fxo.offhook = 0;
		fe->rm_param.mod[mod_no].u.fxs.ohttimer = 
				fe_event->rm_event.ohttimer << 3;
		if (fe->fe_cfg.cfg.remora.reversepolarity){
			fe->rm_param.mod[mod_no].u.fxs.idletxhookstate  = 0x6;
			fe->rm_param.mod[mod_no].u.fxs.idletxhookstate  = 0x2;
		if (fe->rm_param.mod[mod_no].u.fxs.lasttxhook == 0x1) {
			if (fe->fe_cfg.cfg.remora.reversepolarity){
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 0x6;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 0x2;
				fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		if ((fe->rm_param.mod[mod_no].u.fxs.lasttxhook == 0x04) ||
		    (fe->rm_param.mod[mod_no].u.fxs.lasttxhook == 0x00)){
			fe->rm_param.mod[mod_no].current_control_event_ptr = NULL;
			wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
			card->event_control_running = 0;
			wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		if ((fe_event->mode && !fe->fe_cfg.cfg.remora.reversepolarity) ||
		    (!fe_event->mode && fe->fe_cfg.cfg.remora.reversepolarity)){
			fe->rm_param.mod[mod_no].u.fxs.lasttxhook |= 0x04;
			fe->rm_param.mod[mod_no].u.fxs.lasttxhook &= ~0x04;
		WRITE_USB_RM_REG(mod_no, 64, fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
			if (fe_event->mode == WAN_EVENT_ENABLE){
					&fe->rm_param.mod[mod_no].events);
					&fe->rm_param.mod[mod_no].events);
		wp_usb_init_proslic(fe, fe_event->rm_event.mod_no, 1, 1);
		fe->rm_param.reg_dbg_value = READ_USB_RM_REG(mod_no,fe_event->rm_event.reg);
		fe->rm_param.reg_dbg_ready = 1;		
					fe->name, mod_no+1,
					fe_event->rm_event.reg,
					fe->rm_param.reg_dbg_value); 
		WRITE_USB_RM_REG(mod_no, fe_event->rm_event.reg, fe_event->rm_event.value);
		if (card->wandev.event_callback.hook){
			card->wandev.event_callback.hook(card, &event);
		if (card->wandev.event_callback.hook){
			card->wandev.event_callback.hook(card, &event);
				fe->name, fe_event->type);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	fe->rm_param.mod[mod_no].current_control_event_ptr = NULL;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	card->event_control_running = 0;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	wan_clear_bit(WP_RM_TIMER_EVENT_PENDING,(void*)&fe->rm_param.critical);
	fe_event = WAN_LIST_FIRST(&fe->event);
		wp_usb_remora_add_timer(fe, fe_event->delay);	
	sdla_t			*card = (sdla_t*)fe->card;
	WAN_ASSERT_RC(card == NULL, -EINVAL);
			fe->name,fe_event->type);
					fe->name);
		return -EINVAL;
	DEBUG_EVENT("%s: %s:%d: ---------------START ----------------------\n",
				fe->name, __FUNCTION__,__LINE__);
	DEBUG_EVENT("%s: %s:%d: ---------------STOP ----------------------\n",
				fe->name, __FUNCTION__,__LINE__);
	wan_spin_lock_irq(&fe->lockirq,&smp_flags);	
	if (WAN_LIST_EMPTY(&fe->event)){
		WAN_LIST_INSERT_HEAD(&fe->event, event, next);
			fe->name);
		wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
			fe->name);
		wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
//		WAN_LIST_FOREACH(tmp, &fe->event, next){
//			DEBUG_EVENT("%s: Internal Error!!!\n", fe->name);
//			wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
//			return -EINVAL;
	wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
	wp_usb_remora_add_timer(fe, fe_event->delay);	
* Arguments: mod_no -  Module number (1,2,3,... MAX_USB_REMORA_MODULES)
	int	mod_no = ectrl->mod_no-1;
	if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
		switch(ectrl->type){
					fe->name,mod_no+1,
					ectrl->type);
			return -EINVAL;
	}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
		switch(ectrl->type){
					fe->name,mod_no+1,
					ectrl->type);
			return -EINVAL;
				fe->name,mod_no+1,
				fe->rm_param.mod[mod_no].type);
		return -EINVAL;	
* Arguments: mod_no -  Module number (1,2,3,... MAX_USB_REMORA_MODULES)
	int			mod_no = ectrl->mod_no-1, err = 0;
					fe->name, mod_no+1);
		return -EINVAL;
	if (!wan_test_bit(mod_no, &fe->rm_param.module_map)) {
					fe->name, mod_no);
		return -EINVAL;
		return -EINVAL;
				fe->name, mod_no+1,
				WAN_EVENT_TYPE_DECODE(ectrl->type),
				WAN_EVENT_MODE_DECODE(ectrl->mode), ectrl->mode);
	fe_event.mode		= ectrl->mode;
	switch(ectrl->type){
		fe_event.rm_event.tone	= ectrl->tone;
		fe_event.rm_event.ohttimer= ectrl->ohttimer;
				fe->name, mod_no+1);
				fe->name, mod_no+1);
				fe->name, mod_no+1);
				fe->name, mod_no+1);
	mod_no = rm_udp->mod_no;
	if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
		rm_udp->type = MOD_TYPE_FXS;
		regs_fxs = &rm_udp->u.regs_fxs;
			regs_fxs->direct[reg] = READ_USB_RM_REG(mod_no, reg);
			regs_fxs->indirect[reg] =
	}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
		rm_udp->type = MOD_TYPE_FXO;
		regs_fxo = &rm_udp->u.regs_fxo;
			regs_fxo->direct[reg] = READ_USB_RM_REG(mod_no, reg);
	mod_no = rm_udp->mod_no;
	if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
		rm_udp->type = MOD_TYPE_FXS;
		rm_udp->u.stats.tip_volt = READ_USB_RM_REG(mod_no, 80);
		rm_udp->u.stats.ring_volt = READ_USB_RM_REG(mod_no, 81);
		rm_udp->u.stats.bat_volt = READ_USB_RM_REG(mod_no, 82);
	} else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
		rm_udp->type = MOD_TYPE_FXO;
		rm_udp->u.stats.volt = READ_USB_RM_REG(mod_no, 29);
		rm_udp->u.stats.status = fe->rm_param.mod[mod_no].u.fxo.status; 
	int			err = -EINVAL;
	switch(udp_cmd->wan_cmd_command){
		udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
		udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_data_len = (unsigned short)err; 
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_data_len = (unsigned short)err; 
		switch(fe_debug->type){
			if (fe->rm_param.reg_dbg_busy){
				if (fe_debug->fe_debug_reg.read == 2 && fe->rm_param.reg_dbg_ready){
					fe_debug->fe_debug_reg.value = fe->rm_param.reg_dbg_value;
					udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
					fe->rm_param.reg_dbg_busy = 0;
			event.type		= (fe_debug->fe_debug_reg.read) ? 
			event.rm_event.mod_no	= fe_debug->mod_no;
			event.rm_event.reg	= (u_int16_t)fe_debug->fe_debug_reg.reg;
			event.rm_event.value	= fe_debug->fe_debug_reg.value;
			if (fe_debug->fe_debug_reg.read){
				fe->rm_param.reg_dbg_busy = 1;
				fe->rm_param.reg_dbg_ready = 0;
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			event.type		= (fe_debug->fe_debug_hook.offhook) ? 
			event.rm_event.mod_no	= fe_debug->mod_no;
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
		    	udp_cmd->wan_cmd_data_len = 0;
		udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
	    	udp_cmd->wan_cmd_data_len = 0;
	if (!res && (res != fe->rm_param.mod[mod_no].u.fxs.lasttxhook)) {
					fe->name, mod_no+1);
			if (fe->rm_param.mod[mod_no].u.fxs.palarms++ < MAX_ALARMS) {
					fe->name, mod_no + 1);
				if (fe->rm_param.mod[mod_no].u.fxs.lasttxhook == 4){
					fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 1;
				WRITE_USB_RM_REG(mod_no, 64, fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
				if (fe->rm_param.mod[mod_no].u.fxs.palarms == MAX_ALARMS){
						fe->name, mod_no + 1);
	WAN_ASSERT1(fe->card == NULL);
	card	= (sdla_t*)fe->card;
		/* Not good -- don't look at anything else */
				fe->name, mod_no + 1, b); 
	if (fe->rm_param.mod[mod_no].u.fxo.offhook) {
	if (!fe->rm_param.mod[mod_no].u.fxo.offhook) {
		if ((res & 0x60) && fe->rm_param.mod[mod_no].u.fxo.battery) {
			fe->rm_param.mod[mod_no].u.fxo.ringdebounce += (WP_RM_CHUNKSIZE * 4);
			if (fe->rm_param.mod[mod_no].u.fxo.ringdebounce >= WP_RM_CHUNKSIZE * 64) {
				if (!fe->rm_param.mod[mod_no].u.fxo.wasringing) {
					fe->rm_param.mod[mod_no].u.fxo.wasringing = 1;
							fe->name,
					if (card->wandev.event_callback.ringdetect){
						card->wandev.event_callback.ringdetect(card, &event);
				fe->rm_param.mod[mod_no].u.fxo.ringdebounce = WP_RM_CHUNKSIZE * 64;
			fe->rm_param.mod[mod_no].u.fxo.ringdebounce -= WP_RM_CHUNKSIZE * 2;
			if (fe->rm_param.mod[mod_no].u.fxo.ringdebounce <= 0) {
				if (fe->rm_param.mod[mod_no].u.fxo.wasringing) {
					fe->rm_param.mod[mod_no].u.fxo.wasringing = 0;
							fe->name,
					if (card->wandev.event_callback.ringdetect){
						card->wandev.event_callback.ringdetect(card, &event);
				fe->rm_param.mod[mod_no].u.fxo.ringdebounce = 0;
		fe->rm_param.mod[mod_no].u.fxo.nobatttimer++;
		if (wr->mod[mod_no].fxo.battery)
			printk("Battery loss: %d (%d debounce)\n", b, wr->mod[mod_no].fxo.battdebounce);
		if (fe->rm_param.mod[mod_no].u.fxo.battery &&
		    !fe->rm_param.mod[mod_no].u.fxo.battdebounce) {
						fe->name,
			fe->rm_param.mod[mod_no].u.fxo.battery =  0;
			if ((!fe->rm_param.mod[mod_no].u.fxo.ohdebounce) &&
			     fe->rm_param.mod[mod_no].u.fxo.offhook) {
				DEBUG_RM("%s: Module %d: On-Hook status!\n",
							fe->name,
				if (card->wandev.event_callback.hook){
					card->wandev.event_callback.hook(
				fe->rm_param.mod[mod_no].u.fxo.onhook++;
			DEBUG_RM("%s: Module %d: On-Hook status!\n",
							fe->name,
			if (card->wandev.event_callback.hook){
				card->wandev.event_callback.hook(card, &event);
			fe->rm_param.mod[mod_no].u.fxo.battdebounce = battdebounce;
		} else if (!fe->rm_param.mod[mod_no].u.fxo.battery)
			fe->rm_param.mod[mod_no].u.fxo.battdebounce = battdebounce;
		if (!fe->rm_param.mod[mod_no].u.fxo.battery &&
		    !fe->rm_param.mod[mod_no].u.fxo.battdebounce) {
						fe->name,
						(b < 0) ? "-" : "+");			    
			if (fe->rm_param.mod[mod_no].u.fxo.onhook) {
				fe->rm_param.mod[mod_no].u.fxo.onhook = 0;
				DEBUG_RM("%s: Module %d: Off-Hook status!\n",
							fe->name,
				if (card->wandev.event_callback.hook){
					card->wandev.event_callback.hook(card, &event);
			DEBUG_RM("%s: Module %d: Off-Hook status!\n",
						fe->name,
			if (card->wandev.event_callback.hook){
				card->wandev.event_callback.hook(card, &event);
			fe->rm_param.mod[mod_no].u.fxo.battery = 1;
			fe->rm_param.mod[mod_no].u.fxo.nobatttimer = 0;
			fe->rm_param.mod[mod_no].u.fxo.battdebounce = battdebounce;
		} else if (fe->rm_param.mod[mod_no].u.fxo.battery)
			fe->rm_param.mod[mod_no].u.fxo.battdebounce = battdebounce;
		if (fe->rm_param.mod[mod_no].u.fxo.lastpol >= 0) {
			fe->rm_param.mod[mod_no].u.fxo.lastpol = -1;
			fe->rm_param.mod[mod_no].u.fxo.polaritydebounce = POLARITY_DEBOUNCE;
		if (fe->rm_param.mod[mod_no].u.fxo.lastpol <= 0) {
			fe->rm_param.mod[mod_no].u.fxo.lastpol = 1;
			fe->rm_param.mod[mod_no].u.fxo.polaritydebounce = POLARITY_DEBOUNCE;
		fe->rm_param.mod[mod_no].u.fxo.battdebounce = battdebounce;
	if (fe->rm_param.mod[mod_no].u.fxo.battdebounce)
		fe->rm_param.mod[mod_no].u.fxo.battdebounce--;
	if (fe->rm_param.mod[mod_no].u.fxo.polaritydebounce) {
	        fe->rm_param.mod[mod_no].u.fxo.polaritydebounce--;
		if (fe->rm_param.mod[mod_no].u.fxo.polaritydebounce < 1) {
			if (fe->rm_param.mod[mod_no].u.fxo.lastpol !=
					fe->rm_param.mod[mod_no].u.fxo.polarity) {
				"%s: Module %d: Polarity reversed (%d -> %d) (%ul)\n",
						fe->name, mod_no + 1,
						fe->rm_param.mod[mod_no].u.fxo.polarity, 
						fe->rm_param.mod[mod_no].u.fxo.lastpol,
				if (fe->rm_param.mod[mod_no].u.fxo.polarity){
				fe->rm_param.mod[mod_no].u.fxo.polarity =
						fe->rm_param.mod[mod_no].u.fxo.lastpol;
	WAN_ASSERT1(fe->card == NULL);
	card	= fe->card;
	if (hook != fe->rm_param.mod[mod_no].u.fxs.lastrxhook) {
		fe->rm_param.mod[mod_no].u.fxs.debounce = 4 * (4 * 8);
				fe->name, mod_no + 1, hook,
				fe->rm_param.mod[mod_no].u.fxs.debounce);
		if (fe->rm_param.mod[mod_no].u.fxs.debounce > 0) {
			fe->rm_param.mod[mod_no].u.fxs.debounce-= 16 * WP_RM_CHUNKSIZE;
					fe->name, mod_no + 1,
					hook, fe->rm_param.mod[mod_no].u.fxs.debounce);
			if (!fe->rm_param.mod[mod_no].u.fxs.debounce) {
							fe->name,
				fe->rm_param.mod[mod_no].u.fxs.debouncehook = hook;
			if (!fe->rm_param.mod[mod_no].u.fxs.oldrxhook &&
			    fe->rm_param.mod[mod_no].u.fxs.debouncehook) {
							fe->name, mod_no + 1);
				if (card->wandev.event_callback.hook){
					card->wandev.event_callback.hook(card, &event);
				//zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_OFFHOOK);
				fe->rm_param.mod[mod_no].u.fxs.oldrxhook = 1;
			} else if (fe->rm_param.mod[mod_no].u.fxs.oldrxhook &&
				   !fe->rm_param.mod[mod_no].u.fxs.debouncehook) {
							fe->name, mod_no + 1);
				if (card->wandev.event_callback.hook){
					card->wandev.event_callback.hook(card, &event);
				//zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_ONHOOK);
				fe->rm_param.mod[mod_no].u.fxs.oldrxhook = 0;
	fe->rm_param.mod[mod_no].u.fxs.lastrxhook = hook;
* Arguments: mod_no -  Module number (1,2,3,... MAX_USB_REMORA_MODULES)
	for (mod_no = 0; mod_no < fe->rm_param.max_fe_channels; mod_no++) {
		if (!wan_test_bit(mod_no, &fe->rm_param.module_map)) {
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
			if (fe->rm_param.mod[mod_no].u.fxs.lasttxhook == 0x4) {
				fe->rm_param.mod[mod_no].u.fxs.ohttimer = OHT_TIMER << 3;
				if (fe->fe_cfg.cfg.remora.reversepolarity){
					fe->rm_param.mod[mod_no].u.fxs.idletxhookstate = 0x6;
					fe->rm_param.mod[mod_no].u.fxs.idletxhookstate = 0x2; 
				if (fe->rm_param.mod[mod_no].u.fxs.ohttimer) {
					fe->rm_param.mod[mod_no].u.fxs.ohttimer-= WP_RM_CHUNKSIZE;
					if (!fe->rm_param.mod[mod_no].u.fxs.ohttimer) {
						if (fe->fe_cfg.cfg.remora.reversepolarity){
							fe->rm_param.mod[mod_no].u.fxs.idletxhookstate = 0x5;
							fe->rm_param.mod[mod_no].u.fxs.idletxhookstate = 0x1;
						if ((fe->rm_param.mod[mod_no].u.fxs.lasttxhook == 0x2) ||
						    (fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 0x6)) {
							if (fe->fe_cfg.cfg.remora.reversepolarity){ 
								fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 0x5;
								fe->rm_param.mod[mod_no].u.fxs.lasttxhook = 0x1;
							WRITE_USB_RM_REG(mod_no, 64, fe->rm_param.mod[mod_no].u.fxs.lasttxhook);
		} else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO) {
			if (wr->mod[x].fxo.echotune){
							fe->name, x);
				B_RM_REG(x, 30, wr->mod[x].fxo.echoregs.acim);
				B_RM_REG(x, 45, wr->mod[x].fxo.echoregs.coef1);
				B_RM_REG(x, 46, wr->mod[x].fxo.echoregs.coef2);
				B_RM_REG(x, 47, wr->mod[x].fxo.echoregs.coef3);
				B_RM_REG(x, 48, wr->mod[x].fxo.echoregs.coef4);
				B_RM_REG(x, 49, wr->mod[x].fxo.echoregs.coef5);
				B_RM_REG(x, 50, wr->mod[x].fxo.echoregs.coef6);
				B_RM_REG(x, 51, wr->mod[x].fxo.echoregs.coef7);
				B_RM_REG(x, 52, wr->mod[x].fxo.echoregs.coef8);
						fe->name, x);
				wr->mod[x].fxo.echotune = 0;
	if (SYSTEM_TICKS - fe->rm_param.last_watchdog  > WP_RM_WATCHDOG_TIMEOUT) {
		fe->rm_param.last_watchdog = SYSTEM_TICKS;
* Arguments: mod_no -  Module number (1,2,3,... MAX_USB_REMORA_MODULES)
					fe->name, mod_no+1);
		return -EINVAL;
	if (!wan_test_bit(mod_no, &fe->rm_param.module_map)) {
					fe->name, mod_no+1);
		return -EINVAL;
	if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
				WRITE_USB_RM_REG(mod_no, 21, fe->rm_param.mod[mod_no].u.fxs.imask1);
				WRITE_USB_RM_REG(mod_no, 22, fe->rm_param.mod[mod_no].u.fxs.imask2);
				WRITE_USB_RM_REG(mod_no, 23, fe->rm_param.mod[mod_no].u.fxs.imask3);
					fe->name, mod_no+1, type);
			err = -EINVAL;
	}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
				WRITE_USB_RM_REG(mod_no, 3, fe->rm_param.mod[mod_no].u.fxo.imask);
					fe->name, mod_no+1, type);
			err = -EINVAL;
				fe->name, mod_no+1);
	fe->rm_param.intcount++;
		if (wan_test_bit(mod_no, &fe->rm_param.module_map)) {
			if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
			}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
	if (card->wan_tdmv.sc && fe->rm_param.intcount % 100 == 0){
	WAN_ASSERT(fe->card == NULL);
	card		= fe->card;
				fe->name,
		if (card->wandev.event_callback.dtmf){
			card->wandev.event_callback.dtmf(card, &event);
	WAN_ASSERT(fe->card == NULL);
	card		= fe->card;
				fe->name, mod_no+1);
			if (card->wandev.fe_notify_iface.hook_state){
				card->wandev.fe_notify_iface.hook_state(
				"RM: %s: Module %d: Off-hook status!\n",
						fe->name, mod_no+1);
				fe->rm_param.mod[mod_no].u.fxs.oldrxhook = 1;
			}else/* if (fe->rm_param.mod[mod_no].u.fxs.oldrxhook)*/{
				"RM: %s: Module %d: On-hook status!\n",
						fe->name, mod_no+1);
				fe->rm_param.mod[mod_no].u.fxs.oldrxhook = 0;
			if (card->wandev.event_callback.hook){
				card->wandev.event_callback.hook(
				fe->name, mod_no+1);
			if (card->wandev.fe_notify_iface.hook_state){
				card->wandev.fe_notify_iface.hook_state(
			off-hook during the ringing state.
						fe->name, mod_no+1);
						fe->name, mod_no+1);
			if (card->wandev.event_callback.ringtrip){
				card->wandev.event_callback.ringtrip(card, &event);
					fe->name, mod_no+1);
					fe->name, mod_no+1);
					fe->name, mod_no+1);
					fe->name, mod_no+1);
					fe->name, mod_no+1);
					fe->name, mod_no+1);
			fe->name, mod_no+1,
	WAN_ASSERT(fe->card == NULL);
	card		= fe->card;
			if (fe->rm_param.mod[mod_no].u.fxo.ring_detect){
					fe->name, mod_no+1);
				fe->rm_param.mod[mod_no].u.fxo.ring_detect = 0;			
					fe->name, mod_no+1);
				fe->rm_param.mod[mod_no].u.fxo.ring_detect = 1;
				fe->name, mod_no+1);
			fe->rm_param.mod[mod_no].u.fxo.ring_detect = 1;
		if (card->wandev.event_callback.ringdetect){
			card->wandev.event_callback.ringdetect(card, &event);
					fe->name, mod_no+1);
		if (!wan_test_bit(mod_no, &fe->rm_param.module_map)) {
		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
		}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
./sdla_usb_remora.c
 * Copyright:	(c) 1984-2007 Sangoma Technologies Inc.
#define IS_TDMV_RUNNING(wr)		wan_test_bit(WP_TDMV_RUNNING, &(wr)->flags)
#define IS_TDMV_UP(wr)			wan_test_bit(WP_TDMV_UP, &(wr)->flags)
	/* BRI D-chan */
	int		err = -ENOTTY;
			DEBUG_TDMV_BRI("chan->pvt: 0x%p\n", chan->pvt);
		WAN_ASSERT(chan == NULL || chan->pvt == NULL);
		wp = chan->pvt;	
		if (wp->dchan_dev && wp->dchan_dev->hard_start_xmit){
			DEBUG_TDMV_BRI("wp->dchan_dev: 0x%p\n",	wp->dchan_dev);
			if(wp->dchan_dev){
				DEBUG_TDMV_BRI("wp->dchan_dev->hard_start_xmit: 0x%p\n",
					wp->dchan_dev->hard_start_xmit);
			err=-EOPNOTSUPP;
		err = -ENOTTY;
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wr = chan->pvt;
	wr->usecount++;
	wan_set_bit(WP_TDMV_RUNNING, &wr->flags);
				wr->devname,
				wr->usecount,
				chan->channo,
				chan->chanpos);
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wr	= chan->pvt;
	card	= wr->card;
	fe	= &card->fe;
	wr->usecount--;
	wan_clear_bit(WP_TDMV_RUNNING, &wr->flags);
	wctdm_restart_dma(span->pvt);
** wp_remora_zap_hwec() - 
	int		fe_chan = chan->chanpos;
	int		err = -ENODEV;
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wr = chan->pvt;
	WAN_ASSERT2(wr->card == NULL, -ENODEV);
	card	= wr->card;
	fe	= &card->fe;
	if (card->wandev.ec_enable){
			wr->devname, __FUNCTION__, fe_chan);
			err = card->wandev.ec_enable(card, enable, fe_chan);
				wr->devname, __FUNCTION__, fe_chan);
		DEBUG_EVENT("[TDMV_BRI]: %s: %s(): card->wandev.ec_enable == NULL!!!!!!\n",
			wr->devname, __FUNCTION__);
** wp_tdmv_rbsbits_poll() -
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wp = wan_tdmv->sc;
** wp_tdmv_bri_init() - 
	iface->check_mtu	= wp_tdmv_bri_check_mtu;
	iface->create		= wp_tdmv_bri_create;
	iface->remove		= wp_tdmv_bri_remove;
	iface->reg		= wp_tdmv_bri_reg;
	iface->unreg		= wp_tdmv_bri_unreg;
	iface->software_init	= wp_tdmv_bri_software_init;
	iface->state		= wp_tdmv_bri_state;
	iface->running		= wp_tdmv_bri_running;
	iface->is_rbsbits	= wp_tdmv_bri_is_rbsbits;
	iface->rx_tx_span	= wp_tdmv_bri_rx_tx_span;
	iface->rx_chan		= wp_tdmv_bri_rx_chan;
	iface->ec_span		= wp_tdmv_bri_ec_span;  
	iface->rbsbits_poll	= wp_tdmv_rbsbits_poll;	//?????
	iface->rx_dchan		= wp_tdmv_rx_dchan;
	iface->buf_rotate	= wp_tdmv_span_buf_rotate;
	wp_tdmv_bri_t	*wr = wan_tdmv->sc;
	WAN_ASSERT(wr->card == NULL);
	card = wr->card;
	fe = &card->fe;
	if (wan_test_bit(WP_TDMV_REGISTER, &wr->flags)){
					wr->devname, wr->span.spanno);
	sprintf(wr->span.name, "WPBRI/%d", wr->num);
	sprintf(wr->span.desc, "wrtdm Board %d", wr->num + 1);
	switch(fe->fe_cfg.tdmv_law){
					wr->devname);
		wr->span.deflaw = ZT_LAW_ALAW;
		wr->span.deflaw = ZT_LAW_MULAW;
wr->span.deflaw = ZT_LAW_ALAW;//FIXME: hardcoded
	wr->dtmfsupport = card->u.aft.tdmv_hw_dtmf;
		sprintf(wr->chans[x].name, "WPBRI/%d/%d", wr->num, x);
		wr->chans[x].sigcap =  ZT_SIG_EM | ZT_SIG_CLEAR | ZT_SIG_FXSLS |
			DEBUG_EVENT("%s: Port %d Configure B-chan %d for voice (%s, type %s)!\n", 
					wr->devname, 
					wr->chans[x].name,
					WP_BRI_DECODE_MOD_TYPE(fe->bri_param.mod[WAN_FE_LINENO(fe)].type));
			DEBUG_EVENT("%s: Port %d Configure BRI D-chan (%s, type %s)!\n", 
					wr->devname, 
					wr->chans[x].name,
					WP_BRI_DECODE_MOD_TYPE(fe->bri_param.mod[WAN_FE_LINENO(fe)].type));/* fe->bri_param.mod[2], there is no [2] */
		wr->chans[x].chanpos = x+1;
		wr->chans[x].pvt = wr;
		//wr->rxsig_state[x] = ZT_RXSIG_INITIAL;
	wr->span.pvt		= wr;
	wr->span.chans		= wr->chans_ptrs;
	wr->span.chans		= wr->chans;
	wr->span.channels	= MAX_BRI_TIMESLOTS;/* this is the number of b-chans (2) and the d-chan on one BRI line. */;
	wr->span.linecompat	= ZT_CONFIG_AMI | ZT_CONFIG_CCS; /* <--- this is really BS */
	wr->span.open		= wp_bri_zap_open;
	wr->span.close		= wp_bri_zap_close;
	//wr->span.flags	= ZT_FLAG_RBS;
	wr->span.ioctl		= wp_bri_zap_ioctl;
	wr->span.watchdog	= wp_bri_zap_watchdog;
	if (card->wandev.ec_dev){
		wr->span.echocan = wp_bri_zap_hwec;
	init_waitqueue_head(&wr->span.maintq);
	if (zt_register(&wr->span, 0)) {
				wr->devname);
		return -EINVAL;
	if (wr->span.spanno != wr->spanno +1){
						wr->spanno + 1);
						wr->devname,wr->span.spanno);
		wr->spanno = wr->span.spanno-1;
					wr->devname, wr->span.spanno);
	wp_tdmv_bri_check_mtu(card, wr->reg_module_map, &wr->max_rxtx_len);
	wan_set_bit(WP_TDMV_REGISTER, &wr->flags);
	if (wr->dtmfsupport == WANOPT_YES){
		card->wandev.event_callback.dtmf = wp_tdmv_bri_dtmf;
	wr->span.alarms = ZT_ALARM_NONE;//FIXME: report real line state, also report alarms on line connect/disconnect.
	zt_alarm_notify(&wr->span);
** wp_tdmv_release() - 
	if (wan_test_bit(WP_TDMV_REGISTER, &wr->flags)){
				wr->devname);
		wan_clear_bit(WP_TDMV_REGISTER, &wr->flags);
		zt_unregister(&wr->span);
		wan_clear_bit(WP_TDMV_REGISTER, &wr->flags);
** wp_tdmv_bri_check_mtu() - 
** wp_tdmv_bri_create() - 
	WAN_ASSERT(tdmv_conf->span_no == 0);
					card->devname);
		return -EINVAL;
	memset(&card->wan_tdmv, 0x0, sizeof(wan_tdmv_t));
		if (tmp->spanno == tdmv_conf->span_no){
					card->devname);
					card->devname, tdmv_conf->span_no);
			return -EINVAL;
	memset(&card->wan_tdmv, 0x0, sizeof(wan_tdmv_t));
	card->wan_tdmv.max_timeslots	= card->fe.bri_param.max_fe_channels;
	card->wan_tdmv.spanno		= tdmv_conf->span_no;
	card->wandev.te_report_alarms	= wp_tdmv_report_alarms;	
		return -ENOMEM;
	card->wan_tdmv.sc	= wr;
	wr->spanno		= tdmv_conf->span_no-1;
	wr->num			= wp_remora_no++;
	wr->card		= card;
	wr->devname		= card->devname;
	wr->max_timeslots	= card->fe.bri_param.max_fe_channels;
	wr->max_rxtx_len	= 0;
	wan_spin_lock_init(&wr->lock, "wan_britdmv_lock");
	wan_spin_lock_init(&wr->tx_rx_lock, "wan_britdmv_txrx_lock");
	for (i = 0; i < sizeof(wr->chans)/sizeof(wr->chans[0]); i++) {
		wr->chans_ptrs[i] = &wr->chans[i];
	wr->dchan = 3;/* MUST be 3! */
		WAN_LIST_INSERT_AFTER(tmp, &card->wan_tdmv, next);
		WAN_LIST_INSERT_HEAD(&wan_tdmv_head, &card->wan_tdmv, next);
** wp_tdmv_bri_reg()  - calculate 'channo' based on 'activ_ch' for the
** Returns: 	0-31	- Return TDM Voice channel number.
**		-EINVAL - otherwise
	sdla_fe_t		*fe = &card->fe;
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = wan_tdmv->sc;
			card->devname, __FUNCTION__, WAN_FE_LINENO(fe));
		return -EINVAL;
	if (wan_test_bit(WP_TDMV_REGISTER, &wr->flags)){
				card->devname);
		return -EINVAL;
	DEBUG_BRI("%s(): wr->max_timeslots: %d\n", __FUNCTION__, wr->max_timeslots);
	for(i = 0; i < wr->max_timeslots; i++){
			if (tdmv_conf->tdmv_echo_off){
				wan_set_bit(i, &wr->echo_off_map);
	DEBUG_BRI("1  %s(): channo: %d, wr->timeslot_map: 0x%X\n", 
		__FUNCTION__, channo, wr->timeslot_map);
					card->devname,
		return -EINVAL;
	wan_set_bit(channo, &wr->timeslot_map);
	if (i == wr->max_timeslots){
					card->devname,
		return -EINVAL;
			card->devname,
			WP_BRI_DECODE_MOD_TYPE(fe->bri_param.mod[WAN_FE_LINENO(fe)].type),
	wan_set_bit(channo, &wr->reg_module_map);
	if (tdmv_conf->tdmv_echo_off){
				wr->devname);
	memset(wr->chans[channo].sreadchunk, WAN_TDMV_IDLE_FLAG, ZT_CHUNKSIZE);
	memset(wr->chans[channo].swritechunk, WAN_TDMV_IDLE_FLAG, ZT_CHUNKSIZE);
	wr->chans[channo].readchunk = wr->chans[channo].sreadchunk;
	wr->chans[channo].writechunk = wr->chans[channo].swritechunk;
	wr->channelized = WAN_TRUE;
	wp_tdmv_bri_check_mtu(card, active_ch, &wr->max_rxtx_len);
	DEBUG_BRI("%s(): card->u.aft.tdmv_dchan: %d, channo: %d, wr->dchan: %d\n", 
		__FUNCTION__, card->u.aft.tdmv_dchan, channo, wr->dchan);
	if(wr->dchan != 3){
				card->devname, wan_netif_name(dev), wr->dchan);
		return -EINVAL;
	if((channo + 1) == wr->dchan){ /* 3 */
		DEBUG_BRI("%s(): registering BRI D-chan 'dev' pointer\n", __FUNCTION__);
		wr->dchan_dev = dev;
		card->u.aft.tdmv_dchan = BRI_DCHAN_LOGIC_CHAN;
** wp_tdmv_unreg() - 
	sdla_fe_t		*fe = &card->fe;
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = wan_tdmv->sc;
	for(channo = 0; channo < wr->max_timeslots; channo++){
		if (wan_test_bit(channo, &wr->reg_module_map)){
				card->devname,
				WP_BRI_DECODE_MOD_TYPE(fe->bri_param.mod[0].type),
			wan_clear_bit(channo, &wr->reg_module_map);
			wan_clear_bit(channo, &wr->echo_off_map);
			memset(wr->chans[channo].sreadchunk, 
			memset(wr->chans[channo].swritechunk, 
			wr->chans[channo].readchunk = 
					wr->chans[channo].sreadchunk;
			wr->chans[channo].writechunk = 
					wr->chans[channo].swritechunk;
** wp_tdmv_remove() - 
	wan_tdmv_t	*wan_tdmv = &card->wan_tdmv;
	if (!card->wan_tdmv.sc){
	wr = wan_tdmv->sc;
	if (wr && wr->reg_module_map){
				card->devname,
				wr->reg_module_map);
		return -EINVAL;
	if (wr && wr->usecount){
				card->devname);
		return -EINVAL;
		wan_clear_bit(WP_TDMV_RUNNING, &wr->flags);
		wan_clear_bit(WP_TDMV_UP, &wr->flags);
		wan_tdmv->sc = NULL;
		card->wandev.te_report_alarms = NULL;	
		wan_tdmv->sc = NULL;
	wan_tdmv_t	*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wp = wan_tdmv->sc; 
	rx_offset = buf_sz * card->u.aft.tdm_rx_dma_toggle;
	tx_offset = buf_sz * card->u.aft.tdm_tx_dma_toggle;
		if (wan_test_bit(x,&wp->timeslot_map)) {
			wan_spin_lock(&wp->chans[x].lock);
                        ptr=(void*)((((unsigned long)wp->chans[x].readchunk) & ~(mask)) + rx_offset);
			wp->chans[x].readchunk = ptr;
                        ptr=(void*)((((unsigned long)wp->chans[x].writechunk) & ~(mask)) + tx_offset);
			wp->chans[x].writechunk = ptr;
			wan_spin_unlock(&wp->chans[x].lock);
      			prefetch(wp->chans[x].readchunk);
      			prefetch(wp->chans[x].writechunk);
			if (card->wandev.rtp_len && card->wandev.rtp_tap) {
				card->wandev.rtp_tap(card,x,
						     wp->chans[x].readchunk,
						     wp->chans[x].writechunk,
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = (wp_tdmv_bri_t*)wan_tdmv->sc;
					wr->devname);
		wan_set_bit(WP_TDMV_UP, &wr->flags);
					wr->devname);
		wan_clear_bit(WP_TDMV_UP, &wr->flags);
** wp_tdmv_running() - 
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	wr = wan_tdmv->sc;
	if (wr && wr->usecount){
				card->devname);
		return -EINVAL;
** wp_tdmv_bri_is_rbsbits() - 
** wp_tdmv_rx_chan() - 
	wp_tdmv_bri_t	*wr = wan_tdmv->sc;
	WAN_ASSERT2(wr == NULL, -EINVAL);
	WAN_ASSERT2(channo < 0, -EINVAL);
	WAN_ASSERT2(channo > 31, -EINVAL);
		return -EINVAL;
	pwr_rxtx = &wan_tdmv->chan_pwr[channo];
	wr->chans[channo].readchunk = rxbuf;	
	wr->chans[channo].writechunk = txbuf;	
	wp_tdmv_echo_check(wan_tdmv, &wr->chans[channo], channo);
	if (!wan_test_bit(channo, &wr->echo_off_map)){
		if(pwr_rxtx->current_state != ECHO_ABSENT){
				&wr->chans[channo], 
				wr->chans[channo].readchunk, 
				wr->chans[channo].writechunk);
				&wr->chans[channo], 
				wr->chans[channo].readchunk, 
				wr->ec_chunk1[channo]);
				wr->ec_chunk1[channo],
				wr->chans[channo].writechunk,
				&wr->chans[channo], 
				wr->chans[channo].readchunk, 
				wr->ec_chunk1[channo]);
				wr->ec_chunk1[channo],
				wr->ec_chunk2[channo],
				wr->ec_chunk2[channo],
				wr->chans[channo].writechunk,
		} /*if(pwr_rxtx->current_state != ECHO_ABSENT) */
	} /* if (!wan_test_bit(channo, &wr->echo_off_map)) */
	wan_tdmv_t	*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = wan_tdmv->sc;
	wr->intcount++;
	zt_receive(&wr->span);
	zt_transmit(&wr->span);
	wan_tdmv_t      *wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = wan_tdmv->sc;
	zt_ec_span(&wr->span);
        wan_tdmv_t      *wan_tdmv = &card->wan_tdmv;
        WAN_ASSERT1(wan_tdmv->sc == NULL);
        wr = wan_tdmv->sc;
	if (event->type == WAN_EVENT_EC_DTMF){
			card->devname,
			event->channel,
			event->digit,
			(event->dtmf_port == WAN_EC_CHANNEL_PORT_ROUT)?"ROUT":"SOUT",
			(event->dtmf_type == WAN_EC_TONE_PRESENT)?"PRESENT":"STOP");
	}else if (event->type == WAN_EVENT_RM_DTMF){
			card->devname,
			event->channel,
			event->digit);	
	if (!(wr->dtmfmask & (1 << (event->channel-1)))){
					card->devname,
					event->channel);
	if (event->dtmf_type == WAN_EC_TONE_PRESENT){
		wr->dtmfactive |= (1 << event->channel);
				wr->span.chans[event->channel-1],
				(ZT_EVENT_DTMFDOWN | event->digit));
				&wr->span.chans[event->channel-1],
				(ZT_EVENT_DTMFDOWN | event->digit));
		wr->dtmfactive &= ~(1 << event->channel);
				wr->span.chans[event->channel-1],
				(ZT_EVENT_DTMFUP | event->digit));
				&wr->span.chans[event->channel-1],
				(ZT_EVENT_DTMFUP | event->digit));
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wp	= chan->pvt;
	WAN_ASSERT(wp->dchan_dev == NULL);
		return -EINVAL;
	len -= 2; /* Remove checksum */
        	return -ENOMEM;
	wan_spin_lock_irq(&chan->lock, &smp_flags);
	memcpy(data, chan->writebuf[chan->inwritebuf], len);
	wan_spin_unlock_irq(&chan->lock, &smp_flags);
		DEBUG_EVENT("%s: TX DCHAN len: %d\n", chan->name, len);
		err = wp->dchan_dev->hard_start_xmit(skb, wp->dchan_dev);
** wp_tdmv_rx_dchan() - 
	wp_tdmv_bri_t	*wp = wan_tdmv->sc;
	DEBUG_TDMV("%s(): channo: %d, wp->dchan: %d, len: %d\n", __FUNCTION__, channo, wp->dchan, len);
	WAN_ASSERT(channo != wp->dchan-1);
	chan	= &wp->chans[wp->dchan-1];
	WAN_ASSERT(chan == NULL || chan->master == NULL);
	ms = chan->master;
				wp->devname); 
		return -EINVAL;
	if (!(ms->flags & ZT_FLAG_HDLC)){
		DEBUG_TDMV("%s: ERROR: %s not defined as D-CHAN! Or received HDLC data before 'ztcfg' was run.\n",
				wp->devname, ms->name); 
		return -EINVAL;
	if (ms->inreadbuf < 0){
		return -EINVAL;
	if (ms->inreadbuf >= ZT_MAX_NUM_BUFS){
		DEBUG_EVENT("%s: RX buffer (%s) is out of range (%d-%d)!\n",
				wp->devname, ms->name, ms->inreadbuf,ZT_MAX_NUM_BUFS); 
		return -EINVAL;
	/* FIXME wan_spin_lock_irqsave(&wp->tx_rx_lock, smp_flags); */
	wan_spin_lock_irq(&chan->lock, &smp_flags);
	buf = ms->readbuf[ms->inreadbuf];
	left = ms->blocksize - ms->readidx[ms->inreadbuf];
				wp->devname, len+2, left); 
		wan_spin_unlock_irq(&chan->lock, &smp_flags);
		return -EINVAL;
		buf[ms->readidx[ms->inreadbuf]++] = rxbuf[i];
	buf[ms->readidx[ms->inreadbuf]++] = 0x00;
	buf[ms->readidx[ms->inreadbuf]++] = 0x00;
	oldbuf = ms->inreadbuf;
	ms->readn[ms->inreadbuf] = ms->readidx[ms->inreadbuf];
	ms->inreadbuf = (ms->inreadbuf + 1) % ms->numbufs;
	if (ms->inreadbuf == ms->outreadbuf) {
		ms->inreadbuf = -1;
		ms->rxdisable = 0;
	if (ms->outreadbuf < 0) { /* start out buffer if not already */
		ms->outreadbuf = oldbuf;
	/* FIXME wan_spin_unlock_irq(&wp->tx_rx_lock, &smp_flags); */
	wan_spin_unlock_irq(&chan->lock, &smp_flags);
	if (!ms->rxdisable) { /* if receiver enabled */
					wp->devname);
		wake_up_interruptible(&ms->readbufq);
		wake_up_interruptible(&ms->sel);
		if (ms->iomask & ZT_IOMUX_READ)
			wake_up_interruptible(&ms->eventbufq);
		wakeup(&ms->readbufq);
		wakeup(&ms->sel);
		if (ms->iomask & ZT_IOMUX_READ)
			wakeup(&ms->eventbufq);
** wp_tdmv_report_alarms() - 
	wan_tdmv_t	*wan_tdmv = &card->wan_tdmv;
	wp_tdmv_bri_t	*wp = wan_tdmv->sc;
		wp->span.alarms = ZT_ALARM_NONE;
		wp->span.alarms = ZT_ALARM_RED;
	zt_alarm_notify(&wp->span);
./sdla_bri_tdmv.c
* Copyright:	(c) 1995-2002 Sangoma Technologies Inc.
* Dec 03, 2001  Gideon Hack	o Updated for S514-5 56K adapter. 
* Nov 10, 1997	Jaspreet Singh	o Initialized 'skb->mac.raw' to 'skb->data'
*				of Configure-Request packets without receiving a
*				OR-ed 0x300 to conf_flags 
#define CVHexToAscii(b) (((unsigned char)(b) > (unsigned char)9) ? ((unsigned char)'A' + ((unsigned char)(b) - (unsigned char)10)) : ((unsigned char)'0' + (unsigned char)(b)))
	unsigned char sysname[31];		/* system name for in-bnd auth*/
 *  o initialize protocol-specific fields of the adapter data space.
	if (conf->config_id != WANCONFIG_PPP) {
			card->devname, conf->config_id);
		return -EINVAL;
	switch (card->type) {
			card->mbox_off = PPP514_MB_OFFS;
			card->flags_off = PPP514_FLG_OFFS;
			return -EINVAL;
    	card->intr_type_off = 
			card->flags_off +
	card->intr_perm_off = 
			card->flags_off +
	card->wandev.ignore_front_end_status = conf->ignore_front_end_status;
	//ALEX_TODAY err=check_conf_hw_mismatch(card,conf->te_cfg.media);
	err = (card->hw_iface.check_mismatch) ? 
			card->hw_iface.check_mismatch(card->hw,conf->fe_cfg.media) : -EINVAL;
	if (IS_TE1_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_te_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg   = card->hw_iface.fe_write;
		card->fe.read_fe_reg	= card->hw_iface.fe_read;
		card->wandev.fe_enable_timer = ppp_enable_timer;
		card->wandev.te_link_state = ppp_handle_front_end_state;
		conf->electrical_interface = 
		conf->clocking = WANOPT_EXTERNAL;
	}else if (IS_56K_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_56k_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg   = card->hw_iface.fe_write;
		card->fe.read_fe_reg	= card->hw_iface.fe_read;
		conf->clocking = WANOPT_EXTERNAL;
		card->fe.fe_status = FE_CONNECTED;	
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
		return -EIO;
	printk(KERN_INFO "%s: running PPP firmware v%s\n",card->devname, u.str); 
		return -EIO;
	card->wandev.mtu = (conf->mtu) ?
		wp_min(conf->mtu, PPP_MAX_MTU) : PPP_DFLT_MTU;
	card->wandev.bps	= conf->bps;
	card->wandev.electrical_interface	= conf->electrical_interface;
	card->wandev.clocking	= conf->clocking;
	card->isr		= &wpp_isr;
	card->poll		= NULL; 
	card->exec		= NULL;
	card->wandev.update	= &update;
	card->wandev.new_if	= &new_if;
	card->wandev.del_if	= &del_if;
        card->wandev.udp_port   = conf->udp_port;
	card->wandev.ttl	= conf->ttl;
	card->wandev.state      = WAN_DISCONNECTED;
	card->disable_comm	= &disable_comm;
	card->irq_dis_if_send_count = 0;
        card->irq_dis_poll_count = 0;
	card->u.p.authenticator = conf->u.ppp.authenticator;
	card->u.p.ip_mode 	= conf->u.ppp.ip_mode ?
				 conf->u.ppp.ip_mode : WANOPT_PPP_STATIC;
        card->TracingEnabled    = 0;
	card->wandev.get_config_info 	= &ppp_get_config_info;
	card->wandev.get_status_info 	= &ppp_get_status_info;
	card->wandev.set_dev_config    	= &ppp_set_dev_config;
	card->wandev.set_if_info     	= &ppp_set_if_info;
	card->wan_debugging		= &ppp_debugging;
	card->get_crc_frames		= &ppp_crc_frames;
	card->get_abort_frames		= &ppp_abort_frames;
	card->get_tx_underun_frames	= &ppp_tx_underun_frames;
	card->get_snmp_data		= &ppp_snmp_data;
	if (!card->configured){
		card->timer_int_enabled = 0;
		if(err || (card->timer_int_enabled < MAX_INTR_TEST_COUNTER)) {
				card->devname, card->timer_int_enabled);
			printk( "%s: Please choose another interrupt\n",card->devname);
			return -EIO;
			card->devname, card->timer_int_enabled);
		card->configured = 1;
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, PPP_INTR_TIMER);
	sdla_t* card = wandev->priv;
	if ((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if (wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
		return -ENODEV;
	if (test_and_set_bit(0,&ppp_priv_area->update_comms_stats)){
		return -EBUSY;
	spin_lock_irqsave(&card->wandev.lock, smp_flags);
		card->wandev.fe_iface.read_alarm(&card->fe, 0); 
		card->wandev.fe_iface.read_pmon(&card->fe, 0); 
		card->wandev.fe_iface.read_alarm(&card->fe, 1); 
	ppp_priv_area->update_comms_stats=0;
	spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
 * new_if - Create new logical channel.
 * to dev->priv pointer.  
 * Also the dev->init pointer should also be initialized
 * o parse media- and hardware-specific configuration
	sdla_t *card = wandev->priv;
	if (wandev->ndev)
		return -EEXIST;
			card->devname, conf->name);
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
		WAN_MEM_ASSERT(card->devname);
		return	-ENOMEM;
	ppp_priv_area->card = card; 
	strcpy(ppp_priv_area->if_name, conf->name);
	ppp_priv_area->mc = conf->mc;
	ppp_priv_area->pap = conf->pap;
	ppp_priv_area->chap = conf->chap;
	if(strcmp(conf->usedby, "WANPIPE") == 0) {
				wandev->name);
		ppp_priv_area->common.usedby = WANPIPE;
		if (conf->if_down){
			set_bit(DYN_OPT_ON,&ppp_priv_area->interface_down);
				card->devname);
	}else if (strcmp(conf->usedby, "BRIDGE")==0){
				wandev->name,ppp_priv_area->if_name);
		ppp_priv_area->common.usedby = BRIDGE;
	}else if (strcmp(conf->usedby, "BRIDGE_N") == 0){
				wandev->name,ppp_priv_area->if_name);
		ppp_priv_area->common.usedby = BRIDGE_NODE;
					card->devname,ppp_priv_area->if_name);
		err=-EINVAL;
	if(!strlen(conf->userid) && (ppp_priv_area->pap||ppp_priv_area->chap)){
		err=-EINVAL;
	if(!strlen(conf->passwd) && (ppp_priv_area->pap||ppp_priv_area->chap)){
		err=-EINVAL;
	if(strlen(conf->sysname) > 31){
		err=-EINVAL;
	if(!strlen(conf->sysname) && (card->u.p.authenticator)){
		err=-EINVAL;
	memcpy(ppp_priv_area->userid, conf->userid, strlen(conf->userid));
	memcpy(ppp_priv_area->passwd, conf->passwd, strlen(conf->passwd));
	memcpy(ppp_priv_area->sysname, conf->sysname, strlen(conf->sysname));
	ppp_priv_area->enable_IPX = conf->enable_IPX;
	if (conf->network_number){
		ppp_priv_area->network_number = conf->network_number;
		ppp_priv_area->network_number = 0xDEADBEEF;
	if ((ppp_priv_area->gateway = conf->gateway) == WANOPT_YES){
			card->devname,ppp_priv_area->if_name);
	WAN_TASKQ_INIT((&ppp_priv_area->poll_task),0,ppp_poll,dev);
	init_timer(&ppp_priv_area->poll_delay_timer);
	ppp_priv_area->poll_delay_timer.data = (unsigned long)dev;
	ppp_priv_area->poll_delay_timer.function = ppp_poll_delay;
					   &ppp_priv_area->dent, 
					   ppp_priv_area->if_name, 
			card->devname, ppp_priv_area->if_name);
	dev->init = &if_init;
	dev->priv = ppp_priv_area;
	dev->mtu = wp_min(dev->mtu, card->wandev.mtu);
	ppp_priv_area->ppp_state=WAN_DISCONNECTED;
	dev->priv=NULL;
 * del_if - Delete logical channel.
	ppp_private_area_t* 	ppp_priv_area = dev->priv;
	wanrouter_proc_delete_interface(wandev, ppp_priv_area->if_name);
 * disable_comm - Main shutdown function
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
	ppp_private_area_t *ppp_priv_area = dev->priv;
	sdla_t *card = ppp_priv_area->card;
	wan_device_t *wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= TX_TIMEOUT;
	if (ppp_priv_area->common.usedby == BRIDGE || 
            ppp_priv_area->common.usedby == BRIDGE_NODE){
		memcpy(dev->dev_addr, "\x00\xFC\x00\x00\x00\x00", 6);
		*(int *)(dev->dev_addr + 2) += hw_addr;
		/* Initialize media-specific parameters */
		dev->type		= ARPHRD_PPP;	/* ARP h/w type */
		dev->flags		|= IFF_POINTOPOINT;
		dev->flags		|= IFF_NOARP;
		if (ppp_priv_area->mc == WANOPT_YES){
			dev->flags	|= IFF_MULTICAST;
		dev->mtu		= wandev->mtu;
		dev->hard_header_len	= 0; 	/* media header length */
	dev->irq		= wandev->irq;
	dev->dma		= wandev->dma;
	dev->base_addr		= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start); 
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end); 
        dev->tx_queue_len = 100;
	dev->do_ioctl	= if_do_ioctl;
	ppp_private_area_t *ppp_priv_area = dev->priv;
	sdla_t *card = ppp_priv_area->card;
		return -EBUSY;
	ppp_priv_area->router_start_time = tv.tv_sec;
	set_bit(0,&ppp_priv_area->config_ppp);
	ppp_priv_area->config_wait_timeout=jiffies;
	del_timer(&ppp_priv_area->poll_delay_timer);
	ppp_priv_area->poll_delay_timer.expires = jiffies+HZ;
	add_timer(&ppp_priv_area->poll_delay_timer);
	ppp_private_area_t *ppp_priv_area = dev->priv;
	sdla_t *card = ppp_priv_area->card;
	dev->start=0;
	del_timer (&ppp_priv_area->poll_delay_timer);
    	ppp_private_area_t* chan = dev->priv;
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++ chan->if_send_stat.if_send_tbusy;
	++card->wandev.stats.collisions;
	printk (KERN_INFO "%s: Transmit timed out on %s\n", card->devname,dev->name);
	++chan->if_send_stat.if_send_tbusy_timeout;
 * o set tbusy flag (marks start of the transmission) to block a timer-based
 *		non-0	packet may be re-transmitted (tbusy must be set)
	ppp_private_area_t *ppp_priv_area = dev->priv;
	sdla_t *card = ppp_priv_area->card;
	++ppp_priv_area->if_send_stat.if_send_entry;
		 * tx-done interrupt.
			card->devname, dev->name);
		++ppp_priv_area->if_send_stat.if_send_skb_null;
	if (dev->tbusy) {
		++ppp_priv_area->if_send_stat.if_send_tbusy;
        	++card->wandev.stats.collisions;
		if ((jiffies - ppp_priv_area->tick_counter) < (5*HZ)) {
	sendpacket = skb->data;
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, PPP_INTR_TIMER);
		++ppp_priv_area->if_send_stat.if_send_PIPE_request;
		++card->wandev.stats.tx_dropped;
 	if(card->type != SDLA_S514){
    	if (test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
				card->wandev.name,card->wandev.critical);
		++card->wandev.stats.tx_dropped;
		++ppp_priv_area->if_send_stat.if_send_critical_non_ISR;
	if (card->wandev.state != WAN_CONNECTED) {
		++ppp_priv_area->if_send_stat.if_send_wan_disconnected;
        	++card->wandev.stats.tx_dropped;
     	} else if (!skb->protocol) {
		++ppp_priv_area->if_send_stat.if_send_protocol_error;
        	++card->wandev.stats.tx_errors;
		if( skb->protocol == htons(ETH_P_IPX) ) {
			if(ppp_priv_area->enable_IPX) {
				switch_net_numbers( skb->data, 
					ppp_priv_area->network_number, 0);
				++card->wandev.stats.tx_dropped;
		err=ppp_send(card, skb->data, skb->len, skb->protocol);
			err=-1;
			++ppp_priv_area->if_send_stat.if_send_adptr_bfrs_full;
			++ppp_priv_area->if_send_stat.if_send_tx_int_enabled;
			++ppp_priv_area->if_send_stat.if_send_bfr_passed_to_adptr;
			++card->wandev.stats.tx_packets;
			card->wandev.stats.tx_bytes += skb->len;
			dev->trans_start = jiffies;
		ppp_priv_area->tick_counter = jiffies;
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, PPP_INTR_TXRDY);
	clear_bit(SEND_CRIT,&card->wandev.critical);
	if(card->type != SDLA_S514){	
 *	if_do_ioctl - Ioctl handler for fr
	ppp_private_area_t* chan= (ppp_private_area_t*)dev->priv;
		return -ENODEV;
	card=chan->card;
			if (atomic_read(&chan->udp_pkt_len) != 0){
				return -EBUSY;
			atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
			if (test_bit(0,&card->in_isr)){
				atomic_set(&chan->udp_pkt_len,0);
				return -EBUSY;
			wan_udp_pkt=(wan_udp_pkt_t*)chan->udp_pkt_data;
			if (copy_from_user(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,MAX_LGTH_UDP_MGNT_PKT)){
				atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			spin_lock_irqsave(&card->wandev.lock, smp_flags);
			if (test_bit(0,&card->in_isr)){
						card->devname,dev->name);
				atomic_set(&chan->udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
				return -EBUSY;
			spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
			if (atomic_read(&chan->udp_pkt_len) > MAX_LGTH_UDP_MGNT_PKT){
						card->devname,atomic_read(&chan->udp_pkt_len));
				atomic_set(&chan->udp_pkt_len,0);
				return -EINVAL;
			if (copy_to_user(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			atomic_set(&chan->udp_pkt_len,0);
			return -EOPNOTSUPP;
	if(!atomic_read(&ppp_priv_area->udp_pkt_len) && (skb->len<=MAX_LGTH_UDP_MGNT_PKT)){
		atomic_set(&ppp_priv_area->udp_pkt_len,skb->len);
		ppp_priv_area->udp_pkt_src = udp_pkt_src;
       		memcpy(ppp_priv_area->udp_pkt_data, skb->data, skb->len);
		ppp_priv_area->timer_int_enabled |= TMR_INT_ENABLED_UDP;
		ppp_priv_area->protocol = skb->protocol;
		if (skb->len > MAX_LGTH_UDP_MGNT_PKT){
				card->devname, skb->len);
				card->devname);
  	p_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY; 
	p_udp_pkt->wan_udp_len = temp;		
	temp = p_udp_pkt->wan_udp_sport;
	p_udp_pkt->wan_udp_sport = 
			p_udp_pkt->wan_udp_dport; 
	p_udp_pkt->wan_udp_dport = temp;
	*((unsigned short *)(p_udp_pkt->wan_udp_data+mbox_len+even_bound)) = temp;
	*((unsigned short *)(p_udp_pkt->wan_udp_data+mbox_len+even_bound+2)) = temp;
	p_udp_pkt->wan_udp_sum = 0;
	p_udp_pkt->wan_udp_sum = 
  	p_udp_pkt->wan_ip_len = temp;
	ip_temp = p_udp_pkt->wan_ip_src;
	p_udp_pkt->wan_ip_src = p_udp_pkt->wan_ip_dst;
	p_udp_pkt->wan_ip_dst = ip_temp;
	p_udp_pkt->wan_ip_sum = 0;
	p_udp_pkt->wan_ip_sum = calc_checksum(data,sizeof(struct iphdr));
   If incoming is 0 (outgoing)- if the net numbers is ours make it 0
   if incoming is 1 - if the net number is 0 make it ours 
 * Get ethernet-style interface statistics.
	ppp_private_area_t *ppp_priv_area = dev->priv;
	card = ppp_priv_area->card;
	return &card->wandev.stats;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	ppp_priv_area->timer_int_enabled |= TMR_INT_ENABLED_TE;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, PPP_INTR_TIMER);
	wan_mbox_t *mb = &card->wan_mbox;
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	mb->wan_command = PPP_READ_CODE_VERSION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		int len = mb->wan_data_len;
		memcpy(str, mb->wan_data, len);
 * Set Out-Bound Authentication.
	wan_mbox_t *mb = &card->wan_mbox;
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	memset(&mb->wan_data, 0, (strlen(ppp_priv_area->sysname) + strlen(ppp_priv_area->userid) + 
					strlen(ppp_priv_area->passwd) + 3));
	memcpy(mb->wan_data, ppp_priv_area->sysname, strlen(ppp_priv_area->sysname));
	memcpy((mb->wan_data + strlen(ppp_priv_area->sysname) + 1), 
			ppp_priv_area->userid, strlen(ppp_priv_area->userid));
	memcpy((mb->wan_data + strlen(ppp_priv_area->sysname) + strlen(ppp_priv_area->userid) + 2), 
		ppp_priv_area->passwd, strlen(ppp_priv_area->passwd));	
	mb->wan_data_len  = strlen(ppp_priv_area->sysname) + strlen(ppp_priv_area->userid) + 
					strlen(ppp_priv_area->passwd) + 3 ;
	mb->wan_command = PPP_SET_OUTBOUND_AUTH;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
 * Set In-Bound Authentication.
	wan_mbox_t *mb = &card->wan_mbox;
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	memset(&mb->wan_data, 0, 1008);
	memcpy(mb->wan_data, ppp_priv_area->sysname, 
						strlen(ppp_priv_area->sysname));
	userids = tokenize(ppp_priv_area->userid, user_tokens);
	passwds = tokenize(ppp_priv_area->passwd, pass_tokens);
			       		card->devname);
	add_ptr = strlen(ppp_priv_area->sysname) + 1;
		memcpy((mb->wan_data + add_ptr), user_tokens[i], 
		memcpy((mb->wan_data + add_ptr + strlen(user_tokens[i]) + 1), 
	mb->wan_data_len  = add_ptr + 1;
	mb->wan_command = PPP_SET_INBOUND_AUTH;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        while (tokens[cnt] && (cnt < 32 - 1))
        char *eos = str + strlen(str);          /* -> end of string */
        while ((eos > str) && strchr(s, *(eos - 1)))
                --eos                           /* strip trailing spaces */
	wan_mbox_t *mb = &card->wan_mbox;
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	memcpy(mb->wan_data, data, data_len);
	mb->wan_data_len  = data_len;
	mb->wan_command = PPP_SET_CONFIG;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t *mb = &card->wan_mbox;
        ppp_intr_info_t *ppp_intr_data = (ppp_intr_info_t *) &mb->wan_data[0];
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	ppp_intr_data->i_enable = mode;
	ppp_intr_data->irq = card->wandev.irq;	// ALEX_TODAY card->hw.irq;
	mb->wan_data_len = 2;
       		ppp_intr_data->timer_len = 20; //5;//100; //250;
                mb->wan_data_len = 4;
	mb->wan_command = PPP_SET_INTR_FLAGS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t *mb = &card->wan_mbox;
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	mb->wan_command = PPP_COMM_ENABLE;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->u.p.comm_enabled = 1;	
	wan_mbox_t *mb = &card->wan_mbox;
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	mb->wan_command = PPP_COMM_DISABLE;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->u.p.comm_enabled = 0;
	wan_mbox_t *mb = &card->wan_mbox;
	ppp_intr_data = (ppp_intr_info_t *) &mb->wan_data[0];
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	ppp_intr_data->i_enable = 0;
	ppp_intr_data->irq = card->wandev.irq;	// ALEX_TODAY card->hw.irq;
	mb->wan_data_len = 2;
	mb->wan_command = PPP_SET_INTR_FLAGS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	mb->wan_command = PPP_COMM_DISABLE;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card->u.p.comm_enabled = 0;
	wan_mbox_t *mb = &card->wan_mbox;
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	mb->wan_command = PPP_READ_ERROR_STATS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		ppp_err_stats_t* stats = (void*)mb->wan_data;
		card->wandev.stats.rx_over_errors    = stats->rx_overrun;
		card->wandev.stats.rx_crc_errors     = stats->rx_bad_crc;
		card->wandev.stats.rx_missed_errors  = stats->rx_abort;
		card->wandev.stats.rx_length_errors  = stats->rx_lost;
		card->wandev.stats.tx_aborted_errors = stats->tx_abort;
	wan_mbox_t *mb = card->mbox;
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	mb->wan_command = PPP_READ_STATISTICS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t *mb = &card->wan_mbox;
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	mb->wan_command = PPP_READ_PACKET_STATS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t *mb = &card->wan_mbox;
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	mb->wan_command = PPP_READ_LCP_STATS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
 *	Return:	0 - o.k.
 *		1 - no transmit buffers available
	card->hw_iface.peek(card->hw, card->u.p.txbuf_off, &txbuf, sizeof(txbuf));
	card->hw_iface.poke(card->hw, txbuf.buf.ptr, data, len);
	card->hw_iface.poke(card->hw, card->u.p.txbuf_off, &txbuf, sizeof(txbuf));
	card->hw_iface.poke(card->hw, card->u.p.txbuf_off, &txbuf, sizeof(txbuf));
	card->u.p.txbuf_off += sizeof(txbuf);
	if (card->u.p.txbuf_off > card->u.p.txbuf_last_off)
		card->u.p.txbuf_off = card->u.p.txbuf_base_off;
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_command;
				card->devname, cmd);
				, card->devname, cmd, err);
	if (!card->hw){
	set_bit(0,&card->in_isr);
	++card->statistics.isr_entry;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	if (test_bit(PERI_CRIT, (void*)&card->wandev.critical)) {
	if(card->type != SDLA_S514){
		if (test_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
			++card->statistics.isr_already_critical;
					card->devname);
			++card->statistics.isr_rx;
			++card->statistics.isr_tx;
			card->hw_iface.clear_bit(card->hw, card->intr_perm_off, PPP_INTR_TXRDY);
			++card->timer_int_enabled;
			++card->statistics.isr_intr_test;
			++card->statistics.isr_spurious;
				card->devname, flags.iflag);
			printk(KERN_INFO "%s: ID Bytes = ",card->devname);
				card->hw_iface.peek(card->hw, card->intr_type_off + 0x28, str, 8);
	clear_bit(0,&card->in_isr);
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	card->hw_iface.peek(card->hw, card->rxmb_off, &rxbuf, sizeof(rxbuf));
			card->devname, card->rxmb_off, rxbuf.flag);
		printk(KERN_INFO "%s: ID Bytes = ",card->devname);
			card->hw_iface.peek(card->hw, card->intr_type_off + 0x28, str, 8);
		++card->statistics.rx_intr_corrupt_rx_bfr;
		printk(KERN_INFO "%s: Critical router failure ...!!!\n", card->devname);
	if (dev && is_dev_running(dev) && dev->priv){
		ppp_priv_area = dev->priv;
			if ((addr + len) > card->u.p.rx_top_off + 1) {
				unsigned tmp = card->u.p.rx_top_off - addr + 1;
				card->hw_iface.peek(card->hw, addr, buf, tmp);
				addr = card->u.p.rx_base_off;
				len -= tmp;
			card->hw_iface.peek(card->hw, addr, buf, len);
					skb->protocol = htons(ETH_P_IP);
					skb->protocol = htons(ETH_P_IPX);
					skb->protocol = htons(ETH_P_IP);
					card->hw_iface.set_bit(card->hw, card->intr_perm_off, PPP_INTR_TIMER);
				++ppp_priv_area->rx_intr_stat.rx_intr_PIPE_request;
			} else if (handle_IPXWAN(skb->data,card->devname, 
						 ppp_priv_area->enable_IPX, 
						 ppp_priv_area->network_number, 
						 skb->protocol)) {
				if( ppp_priv_area->enable_IPX) {
					if (!test_bit(SEND_CRIT, &card->wandev.critical)){
					 	int err=ppp_send(card, skb->data, skb->len, 
							++card->wandev.stats.tx_dropped;
						++card->wandev.stats.tx_dropped;
					++card->wandev.stats.rx_dropped;
			}else if (ppp_priv_area->common.usedby == BRIDGE ||
				  ppp_priv_area->common.usedby == BRIDGE_NODE){
				if (skb->len <= ETH_ALEN) {
					++card->wandev.stats.rx_errors;
				++card->wandev.stats.rx_packets;
				card->wandev.stats.rx_bytes += skb->len;
		    		++ppp_priv_area->rx_intr_stat.rx_intr_bfr_passed_to_stack;
				skb->dev = dev;
				skb->protocol=eth_type_trans(skb,dev);
	    			skb->dev = dev;
			    	++card->wandev.stats.rx_packets;
				card->wandev.stats.rx_bytes += skb->len;
		    		++ppp_priv_area->rx_intr_stat.rx_intr_bfr_passed_to_stack;	
					card->devname);
			++card->wandev.stats.rx_dropped;
			++ppp_priv_area->rx_intr_stat.rx_intr_no_socket;
		++card->statistics.rx_intr_dev_not_started;
	card->hw_iface.poke(card->hw, card->rxmb_off, &rxbuf, sizeof(rxbuf));
	card->rxmb_off += sizeof(rxbuf);
	if (card->rxmb_off > card->u.p.rxbuf_last_off)
		card->rxmb_off = card->u.p.rxbuf_base_off;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
				card->hw_iface.peek(card->hw, FE_status_off, &FE_status, sizeof(FE_status));
				card->fe.fe_param.k56_param.RR8_reg_56k = 
				card->fe.fe_param.k56_param.RRA_reg_56k = 
				card->fe.fe_param.k56_param.RRC_reg_56k = 
				card->wandev.fe_iface.read_alarm(&card->fe, 0);
				card->hw_iface.poke(card->hw, FE_status_off, &FE_status, sizeof(FE_status));
				card->hw_iface.peek(card->hw, FE_status_off, &FE_status, sizeof(FE_status));
				card->wandev.fe_iface.isr(&card->fe);
				card->hw_iface.poke(card->hw, FE_status_off, &FE_status, sizeof(FE_status));
				card->fe.fe_status = FE_CONNECTED;			
				card->fe.fe_status = FE_DISCONNECTED;	
					card->devname, DCD(flags.mstatus), CTS(flags.mstatus));
					       card->devname);
				if (card->u.p.ip_mode == WANOPT_PPP_PEER) { 
				ppp_priv_area->ppp_state = WAN_DISCONNECTED;
				ppp_priv_area->timer_int_enabled |= TMR_INT_ENABLED_PPP_EVENT;
				card->hw_iface.set_bit(card->hw, card->intr_perm_off, PPP_INTR_TIMER);
					card->devname,LCP(flags.lcp_state),
					ppp_priv_area->ppp_state = WAN_DISCONNECTED;
					ppp_priv_area->timer_int_enabled |= 
					card->hw_iface.set_bit(card->hw, card->intr_perm_off, PPP_INTR_TIMER);
				card->state_tick = jiffies;
				ppp_priv_area->ppp_state = WAN_CONNECTED;
				if (card->wandev.ignore_front_end_status == WANOPT_YES || 
				    card->fe.fe_status == FE_CONNECTED){
					card->hw_iface.peek(card->hw, card->u.p.txbuf_next_off, &tmp, 4);
						card->u.p.txbuf_off, tmp,
						card->rxmb_off, card->u.p.rxbuf_next_off);
					ppp_priv_area->timer_int_enabled |= TMR_INT_ENABLED_PPP_EVENT;
					card->hw_iface.set_bit(card->hw, card->intr_perm_off, PPP_INTR_TIMER);
					if (card->u.p.ip_mode != WANOPT_PPP_PEER){	
			printk(KERN_INFO "%s: DTR Drop Timeout Interrupt \n",card->devname); 
			if (card->u.p.ip_mode == WANOPT_PPP_PEER) { 
			ppp_priv_area->ppp_state = WAN_DISCONNECTED;
			ppp_priv_area->timer_int_enabled |= TMR_INT_ENABLED_PPP_EVENT;
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, PPP_INTR_TIMER);
			printk(KERN_INFO "%s: Error, Invalid PPP Event\n",card->devname);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (ppp_priv_area->timer_int_enabled & TMR_INT_ENABLED_CONFIG){
		ppp_priv_area->timer_int_enabled &= 
	if (ppp_priv_area->timer_int_enabled & TMR_INT_ENABLED_UPDATE){
			card->wandev.fe_iface.read_alarm(&card->fe, 0); 
			card->wandev.fe_iface.read_pmon(&card->fe, 0); 
			card->wandev.fe_iface.read_alarm(&card->fe, 1);
                if(!(--ppp_priv_area->update_comms_stats)){
			ppp_priv_area->timer_int_enabled &= 
	if (ppp_priv_area->timer_int_enabled & TMR_INT_ENABLED_TE){
		card->wandev.fe_iface.polling(&card->fe);
		ppp_priv_area->timer_int_enabled &= ~TMR_INT_ENABLED_TE;
	if (ppp_priv_area->timer_int_enabled & TMR_INT_ENABLED_UDP){
		ppp_priv_area->timer_int_enabled &= ~TMR_INT_ENABLED_UDP;
	if (ppp_priv_area->timer_int_enabled & TMR_INT_ENABLED_PPP_EVENT){
		if (ppp_priv_area->ppp_state == WAN_DISCONNECTED){
				if (err != -EBUSY){
					ppp_priv_area->timer_int_enabled &= ~TMR_INT_ENABLED_PPP_EVENT;
		else if (ppp_priv_area->ppp_state == WAN_CONNECTING){
			ppp_priv_area->timer_int_enabled &= ~TMR_INT_ENABLED_PPP_EVENT;
		else if ((card->wandev.state == WAN_CONNECTED && 
		  	  card->u.p.ip_mode == WANOPT_PPP_PEER) && 
			card->state_tick = jiffies;
					card->devname);
			ppp_priv_area->timer_int_enabled &= ~TMR_INT_ENABLED_PPP_EVENT;
        if(!ppp_priv_area->timer_int_enabled) {
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, PPP_INTR_TIMER);
			sendpacket[57] = '-';
		//If we get here's its an IPX-data packet, so it'll get passed up the stack.
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	if ((card->u.p.ip_mode == WANOPT_PPP_PEER) &&
		if (ppp_priv_area->ip_local == 0) 
		printk(KERN_INFO "%s: IPCP State Opened.\n", card->devname);
				card->devname);
			struct in_device *in_dev = dev->ip_ptr;
				struct in_ifaddr *ifa = in_dev->ifa_list;
						card->devname, NIPQUAD(ifa->ifa_local));
							card->devname, NIPQUAD(ifa->ifa_address));
					card->devname,dev->name);	
 *  o if interface is up and the hold-down timeout has expired, then retry
	dev= WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if ((jiffies - card->state_tick) > HOLD_DOWN_TIME){
			ppp_priv_area->ppp_state = WAN_CONNECTING;
			ppp_priv_area->comm_busy_retry=0;
					card->devname,HOLD_DOWN_TIME);
			card->state_tick=jiffies;
			return -EBUSY;
			printk(KERN_INFO "%s: ERROR PPP Com-Enable failed: protocol not configured!\n",
					card->devname);
			return -EFAULT;
			printk(KERN_INFO "%s: ERROR PPP Com-Enable failed: already enabled!\n",
					card->devname);
			ppp_priv_area->ppp_state = WAN_CONNECTING;
			printk(KERN_INFO "%s: ERROR PPP Com-Enable failed: unknown rc=0x%X!\n",
					card->devname,err);
			return -EINVAL;
	ppp_private_area_t *ppp_priv_area = dev->priv;
	if (card->wandev.clocking)
		cfg.line_speed = card->wandev.bps;
	if (card->wandev.electrical_interface == WANOPT_RS232)
        cfg.conf_flags 	|= DONT_TERMINATE_LNK_MAX_CONFIG; /*send Configure-Request packets forever*/
	cfg.mtu_local		= card->wandev.mtu;
	cfg.mtu_remote		= card->wandev.mtu;                  /*    Default   */
	if( !card->u.p.authenticator ) {
				card->devname);
				card->devname);
	if( ppp_priv_area->pap == WANOPT_YES){
		printk(KERN_INFO "%s: Pap enabled\n", card->devname);
	if( ppp_priv_area->chap == WANOPT_YES){
		printk(KERN_INFO "%s: Chap enabled\n", card->devname);
	if (ppp_priv_area->enable_IPX == WANOPT_YES){
		printk(KERN_INFO "%s: Enabling IPX Protocol\n",card->devname);
	switch (card->u.p.ip_mode) {
			printk(KERN_INFO "%s: PPP IP Mode: STATIC\n",card->devname);
			cfg.ip_local		= ppp_priv_area->ip_local;
			cfg.ip_remote		= ppp_priv_area->ip_remote;
			printk(KERN_INFO "%s: PPP IP Mode: HOST\n",card->devname);
			cfg.ip_local		= ppp_priv_area->ip_local;
			cfg.ip_remote		= ppp_priv_area->ip_remote;
			printk(KERN_INFO "%s: PPP IP Mode: PEER\n",card->devname);
					card->devname);
					card->devname);	
			card->devname);
			card->devname);
		printk(KERN_INFO "%s: authentication failed\n", card->devname);
			card->devname);
		card->devname);
		card->devname);
		card->devname);
		card->devname);
		, card->devname);
			card->devname);
	wan_mbox_t *mb = &card->wan_mbox;
	memcpy(&buf2, &card->wandev.udp_port, 2 );
	wan_udp_pkt= (wan_udp_pkt_t*)&ppp_priv_area->udp_pkt_data;
		if(ppp_priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK) {
			switch(wan_udp_pkt->wan_udp_command) {
    	wan_udp_pkt->wan_udp_opp_flag = 0x00;
    		wan_udp_pkt->wan_udp_data_len = 0x00;
    		wan_udp_pkt->wan_udp_return_code = 0xCD; 
		++ppp_priv_area->pipe_mgmt_stat.UDP_PIPE_mgmt_direction_err;
			card->devname,wan_udp_pkt->wan_udp_command);
		switch (wan_udp_pkt->wan_udp_command){
			if (!card->TracingEnabled) {
    				mb->wan_command = PPP_DATALINE_MONITOR;
    				mb->wan_data_len = 0x01;
    				mb->wan_data[0] = wan_udp_pkt->wan_udp_data[0];
	    			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	        			card->TracingEnabled = 0;
		        		wan_udp_pkt->wan_udp_return_code = mb->wan_return_code;
					wan_udp_pkt->wan_udp_data_len=0;
				card->hw_iface.peek(card->hw, 0xC000, &buf2, 2);
				ppp_priv_area->curr_trace_addr = 0;
		    		memcpy(&ppp_priv_area->curr_trace_addr, &buf2, 2);
		    		ppp_priv_area->start_trace_addr = 
						ppp_priv_area->curr_trace_addr;
				ppp_priv_area->end_trace_addr = 
					ppp_priv_area->start_trace_addr + END_OFFSET;
				/* MAX_SEND_BUFFER_SIZE - 28 (IP header) 
				   - 32 (ppipemon CBLOCK) */
		    		available_buffer_space = MAX_LGTH_UDP_MGNT_PKT - 
							 sizeof(struct iphdr)-
							 sizeof(struct udphdr)-
							 sizeof(wan_mgmt_t)-
	       	  	wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len=0;
	       	  	card->TracingEnabled = 1;
			if(card->TracingEnabled) {
		    		mb->wan_command = 0x33;
		    		mb->wan_data_len = 1;
		    		mb->wan_data[0] = 0x00;
		    		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len=0;
			card->TracingEnabled = 0;
			if(!card->TracingEnabled) {
	    			wan_udp_pkt->wan_udp_return_code = 1;
				wan_udp_pkt->wan_udp_data_len=0;
						card->devname);
					&wan_udp_pkt->wan_udp_data[buffer_length];
				card->hw_iface.peek(card->hw, ppp_priv_area->curr_trace_addr, 
					wan_udp_pkt->wan_udp_data[0] |= 0x02;
				if ((available_buffer_space - buffer_length) 
					wan_udp_pkt->wan_udp_data[0] |= 0x02;
				trace_pkt->status = trace_element.trace_type;
				trace_pkt->time_stamp = trace_element.trace_time_stamp;
				trace_pkt->real_length = trace_element.trace_length;
					trace_pkt->data_avail = 0x00;
					if ((available_buffer_space - buffer_length)<
						wan_udp_pkt->wan_udp_data[0] |= 0x02;
					trace_pkt->data_avail = 0x01;
					card->hw_iface.peek(card->hw, data_ptr, 
						  &trace_pkt->data,
				card->hw_iface.poke_byte(card->hw, ppp_priv_area->curr_trace_addr, 0x00);
				ppp_priv_area->curr_trace_addr += sizeof(trace_element_t);
				if ( ppp_priv_area->curr_trace_addr >= 
					ppp_priv_area->end_trace_addr){
					ppp_priv_area->curr_trace_addr = 
						ppp_priv_area->start_trace_addr;
				if ( trace_pkt->data_avail == 0x01 ) {
					buffer_length += real_len - 1;
			wan_udp_pkt->wan_udp_data[0] |= (frames << 2);
			wan_udp_pkt->wan_udp_data_len = buffer_length;
			wan_udp_pkt->wan_udp_return_code = 0;
			card->hw_iface.peek(card->hw, 0xF003, &wan_udp_pkt->wan_udp_data, 
			wan_udp_pkt->wan_udp_data_len = 0x09;
			wan_udp_pkt->wan_udp_return_code = 0x00;
			wan_udp_pkt->wan_udp_return_code = 0;
			card->hw_iface.peek(card->hw, 0xF020, &wan_udp_pkt->wan_udp_data[0], 2);
			wan_udp_pkt->wan_udp_data_len = 2;
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len=0;
			ppp_priv_area->router_up_time = tv.tv_sec - 
					ppp_priv_area->router_start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data = ppp_priv_area->router_up_time;
			wan_udp_pkt->wan_udp_data_len=4;
			wan_udp_pkt->wan_udp_return_code = 0;
			memcpy(&wan_udp_pkt->wan_udp_data, &ppp_priv_area->if_send_stat, 
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len = sizeof(if_send_stat_t);
			memcpy(&wan_udp_pkt->wan_udp_data, &card->statistics, 
			memcpy(&wan_udp_pkt->wan_udp_data+sizeof(global_stats_t),
				&ppp_priv_area->rx_intr_stat,
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len = sizeof(global_stats_t)+
			memcpy( &wan_udp_pkt->wan_udp_data,
				&ppp_priv_area->pipe_mgmt_stat,
			memcpy(&wan_udp_pkt->wan_udp_data+sizeof(pipe_mgmt_stat_t), 
			       &card->statistics, sizeof(global_stats_t));
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len = sizeof(global_stats_t)+
			wan_udp_pkt->wan_udp_return_code = 0;
	        	if( wan_udp_pkt->wan_udp_data[0] == 1) {
				if(card->rCount++ != 0 ) {
		        		wan_udp_pkt->wan_udp_return_code = 0;
					wan_udp_pkt->wan_udp_data_len=1;
	      		if( wan_udp_pkt->wan_udp_data[0] == 0) {
	      	   		if(--card->rCount != 0) {
		  			wan_udp_pkt->wan_udp_return_code = 0;
					wan_udp_pkt->wan_udp_data_len=1;
				card->wandev.fe_iface.process_udp(
						&card->fe,
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				card->wandev.fe_iface.process_udp(
						&card->fe,
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				if (wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE){
		    			wan_udp_pkt->wan_udp_data_len = sizeof(wan_femedia_t); 
					wan_udp_pkt->wan_udp_return_code = CMD_OK;
					wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
		   	wan_udp_pkt->wan_udp_data[0] = card->wandev.config_id;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_LINUX_PLATFORM;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
			mb->wan_command = wan_udp_pkt->wan_udp_command;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
			if(mb->wan_data_len) {
				memcpy(&mb->wan_data,(unsigned char *)wan_udp_pkt->wan_udp_data,
				       mb->wan_data_len);
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
				wan_udp_pkt->wan_udp_return_code = mb->wan_return_code;
		    		++ppp_priv_area->pipe_mgmt_stat.
		  	++ppp_priv_area->pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_cmnd_OK;
			memcpy(&wan_udp_pkt->wan_udp_hdr.wan_cmd, mb, sizeof(wan_cmd_t)); 
			if(mb->wan_data_len) {
				memcpy(&wan_udp_pkt->wan_udp_data,&mb->wan_data,mb->wan_data_len);
			wan_udp_pkt->wan_udp_data_len = mb->wan_data_len;
     	wan_udp_pkt->wan_ip_ttl = card->wandev.ttl; 
		wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY; 
	len = reply_udp(ppp_priv_area->udp_pkt_data, wan_udp_pkt->wan_udp_data_len);
     	if (ppp_priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK) {
		if (!test_bit(SEND_CRIT,&card->wandev.critical)){
			++ppp_priv_area->pipe_mgmt_stat.UDP_PIPE_mgmt_passed_to_adptr;
			ppp_send(card,ppp_priv_area->udp_pkt_data,len,ppp_priv_area->protocol);
  	    		memcpy(buf,ppp_priv_area->udp_pkt_data, len);
	    		++ppp_priv_area->pipe_mgmt_stat.UDP_PIPE_mgmt_passed_to_stack;
	    		new_skb->protocol = ppp_priv_area->protocol;
            		new_skb->dev = dev;
			++ppp_priv_area->pipe_mgmt_stat.UDP_PIPE_mgmt_no_socket;
	atomic_set(&ppp_priv_area->udp_pkt_len,0);
	memset(&ppp_priv_area->if_send_stat, 0, sizeof(if_send_stat_t));
	memset(&ppp_priv_area->rx_intr_stat, 0, sizeof(rx_intr_stat_t));
	memset(&ppp_priv_area->pipe_mgmt_stat, 0, sizeof(pipe_mgmt_stat_t));	
	memset(&card->statistics, 0, sizeof(global_stats_t));
	card->hw_iface.peek(card->hw, info_off, &info, sizeof(info));
       	card->u.p.txbuf_base_off = info.txb_ptr;
	card->u.p.txbuf_last_off = 
		card->u.p.txbuf_base_off + 
		(info.txb_num - 1) * sizeof(ppp_buf_ctl_t);
	card->u.p.rxbuf_base_off = info.rxb_ptr;
        card->u.p.rxbuf_last_off = 
		card->u.p.rxbuf_base_off +
                (info.rxb_num - 1) * sizeof(ppp_buf_ctl_t);
	card->u.p.txbuf_next_off = info.txb_nxt; 
	card->u.p.rxbuf_next_off = info.rxb1_ptr;
	card->u.p.rx_base_off = info.rxb_base;
        card->u.p.rx_top_off  = info.rxb_end;
	card->u.p.txbuf_off = card->u.p.txbuf_base_off;
	card->rxmb_off = card->u.p.rxbuf_base_off;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	strcpy(if_info.ifr_name, dev->name);
	if_data1->sin_addr.s_addr = ppp_priv_area->ip_local;
	if_data1->sin_family = AF_INET;
	if_data2->sin_addr.s_addr = ppp_priv_area->ip_remote;
	if_data2->sin_family = AF_INET;
			card->devname,err);
			card->devname,NIPQUAD(ppp_priv_area->ip_local));
			card->devname,NIPQUAD(ppp_priv_area->ip_remote));
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	in_dev = dev->ip_ptr;
	if (!(ifa = in_dev->ifa_list))
	ip_addr = ifa->ifa_local;
	strcpy(if_info.ifr_name, dev->name);
	if_data1->sin_addr.s_addr = 0;
	if_data1->sin_family = AF_INET;
			 card->devname, err);
			card->devname, NIPQUAD(ip_addr));
	wan_mbox_t *mb = &card->wan_mbox;
			memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
			mb->wan_data_len  = 0;
			mb->wan_command = PPP_READ_CODE_VERSION;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	 wan_udp_pkt_t *wan_udp_pkt = (wan_udp_pkt_t *)skb->data;
	 if (skb->len < sizeof(wan_udp_pkt_t)){
				  wan_udp_pkt->wan_udp_signature,
				  wan_udp_pkt->wan_udp_dport,
				  ntohs(card->wandev.udp_port),
				  wan_udp_pkt->wan_ip_p,
				  wan_udp_pkt->wan_udp_request_reply,
				  skb->data[36], skb->data[37]);
	if ((wan_udp_pkt->wan_udp_dport == ntohs(card->wandev.udp_port)) &&
	   (wan_udp_pkt->wan_ip_p == UDPMGMT_UDP_PROTOCOL) &&
	   (wan_udp_pkt->wan_udp_request_reply == UDPMGMT_REQUEST)) {
		if (!strncmp(wan_udp_pkt->wan_udp_signature,UDPMGMT_SIGNATURE,8)){	
		if (!strncmp(wan_udp_pkt->wan_udp_signature,GLOBAL_UDP_SIGNATURE,8)){	
		if (!strncmp(wan_udp_pkt->wan_udp_signature,UDPDRV_SIGNATURE,8)){	
        src_ip_addr = *(u32 *)(skb->data + 12);
        in_dev = dev->ip_ptr;
                struct in_ifaddr *ifa= in_dev->ifa_list;
                        broadcast_ip_addr = ifa->ifa_broadcast;
        if((dev->flags & IFF_BROADCAST) && (src_ip_addr == broadcast_ip_addr)) {
				card->devname);
				card->devname);
	spin_lock_irqsave(&card->wandev.lock, *smp_flags);
        spin_unlock_irqrestore(&card->wandev.lock, *smp_flags);
	wan_mbox_t *mb = &card->wan_mbox;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	memset(&mb->wan_cmd, 0, sizeof(ppp_cmd_t));
	mb->wan_data_len  = 0;
	mb->wan_command = PPP_GET_CONNECTION_INFO;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		ppp_priv_area->ip_remote = 0;
		ppp_priv_area->ip_local = 0;
		ppp508_connect_info = (ppp508_connect_info_t *)mb->wan_data;
		ppp_priv_area->ip_remote = ppp508_connect_info->ip_remote;
		ppp_priv_area->ip_local = ppp508_connect_info->ip_local;
				ppp_priv_area->ip_remote,
				ppp_priv_area->ip_local);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (card->u.p.comm_enabled){
		if (ppp_priv_area->ip_local_tmp != ppp_priv_area->ip_local ||
		    ppp_priv_area->ip_remote_tmp != ppp_priv_area->ip_remote){
			ppp_priv_area->ppp_state = WAN_DISCONNECTED;
					card->devname);
					card->devname);
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
		int	err = -EINVAL;
			card->devname, 
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
					card->devname,
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
		int	err = -EINVAL;
			card->devname);
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
				card->devname);
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
	ppp_priv_area->ip_local = ppp_priv_area->ip_local_tmp;
	ppp_priv_area->ip_remote = ppp_priv_area->ip_remote_tmp;
			card->devname);
			card->devname);
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, (PPP_INTR_RXRDY|
	if ( !card->u.p.authenticator  && (ppp_priv_area->pap || ppp_priv_area->chap)) {
				card->devname);
	if (card->u.p.authenticator && (ppp_priv_area->pap || ppp_priv_area->chap)){
				card->devname);	
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, 
		ppp_priv_area->ppp_state = WAN_CONNECTING;
		card->wandev.fe_iface.read_alarm(&card->fe, 1);
	dev=ppp_priv_area->common.dev;
	if (!dev || (ppp_priv_area = dev->priv) == NULL)
	card = ppp_priv_area->card;
	if (test_bit(PERI_CRIT,&card->wandev.critical)){
		clear_bit(POLL_CRIT,&card->wandev.critical);
	if (test_bit(0,&ppp_priv_area->config_ppp)){
		ppp_priv_area->ip_local_tmp  = get_ip_address(dev,WAN_LOCAL_IP);
		ppp_priv_area->ip_remote_tmp = get_ip_address(dev,WAN_POINTOPOINT_IP);
		if (ppp_priv_area->ip_local_tmp == ppp_priv_area->ip_remote_tmp && 
	            card->u.p.ip_mode == WANOPT_PPP_HOST){
			if (++ppp_priv_area->ip_error > MAX_IP_ERRORS){
				printk(KERN_INFO "%s: --- WARNING ---\n",
						card->devname);
						card->devname);
				printk(KERN_INFO "%s: Point-to-Point IP address.\n",
						card->devname);
				printk(KERN_INFO "%s: --- WARNING ---\n\n",
						card->devname);
				clear_bit(POLL_CRIT,&card->wandev.critical);
				ppp_priv_area->poll_delay_timer.expires = jiffies+HZ;
				add_timer(&ppp_priv_area->poll_delay_timer);
		ppp_priv_area->timer_int_enabled |= TMR_INT_ENABLED_CONFIG;
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, PPP_INTR_TIMER);
		ppp_priv_area->ip_error=0;	
		clear_bit(0,&ppp_priv_area->config_ppp);
		clear_bit(POLL_CRIT,&card->wandev.critical);
	switch (card->wandev.state) {
		if (test_bit(DYN_OPT_ON,&ppp_priv_area->interface_down) &&
		    !test_bit(DEV_DOWN,&ppp_priv_area->interface_down)	&&	
		    dev->flags & IFF_UP){	
				card->devname, dev->name);
			change_dev_flags(dev, (dev->flags&~IFF_UP));
			set_bit(DEV_DOWN,&ppp_priv_area->interface_down);
			if (dev->flags & IFF_UP && 
		    	    card->u.p.ip_mode == WANOPT_PPP_PEER){ 
		if (test_bit(DYN_OPT_ON,&ppp_priv_area->interface_down) &&
	            test_bit(DEV_DOWN,  &ppp_priv_area->interface_down) &&
 		    !(dev->flags & IFF_UP)){
				card->devname,dev->name);
			change_dev_flags(dev,(dev->flags|IFF_UP));
			clear_bit(DEV_DOWN,&ppp_priv_area->interface_down);
		if ((card->u.p.ip_mode == WANOPT_PPP_PEER) && 
		if (ppp_priv_area->gateway && check_gateway)
	clear_bit(POLL_CRIT,&card->wandev.critical);
	if ((ppp_priv_area=dev->priv) != NULL){ 	
		sdla_t *card = ppp_priv_area->card;
		if (test_bit(PERI_CRIT,&card->wandev.critical)){
		if (test_and_set_bit(POLL_CRIT,&card->wandev.critical)){
		WAN_TASKQ_SCHEDULE((&ppp_priv_area->poll_task));
	if ((card->u.p.txbuf_base_off & 0xFFF) != (card->u.p.txbuf_next_off & 0xFFF)){
	wan_mbox_t * mb = &card->wan_mbox;
	ADAPTER_CONFIGURATION_STRUCT* cfg = (ADAPTER_CONFIGURATION_STRUCT*)mb->wan_data;
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &cfg->adapter_type); 
	cfg->adapter_config = 0x00; 
	cfg->operating_frequency = 00; 
	mb->wan_data_len = sizeof(ADAPTER_CONFIGURATION_STRUCT);
	mb->wan_command = SET_ADAPTER_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
#define PROC_CFG_FRM	"%-15s| %-12s|\n"
#define PROC_STAT_FRM	"%-15s| %-12s| %-14s|\n"
		return m->count;
	card = ppp_priv_area->card;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		PROC_CFG_FRM, ppp_priv_area->if_name, card->devname);
	return m->count;
		return m->count;
	card = ppp_priv_area->card;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		PROC_STAT_FRM, ppp_priv_area->if_name, card->devname, STATE_DECODE(card->wandev.state));
	return m->count;
#define PROC_DEV_PPP_S_FRM	"%-20s| %-14s|\n"
#define PROC_DEV_PPP_D_FRM	"%-20s| %-14d|\n"
	card = (sdla_t*)wandev->priv;
			wandev->name, buffer);
	if (dev == NULL || dev->priv == NULL)
		return -EFAULT;
	ppp_priv_area = (ppp_private_area_t*)dev->priv;
	if (card->wandev.update) {
		rslt = card->wandev.update(&card->wandev);
			return (rslt) ? (-EBUSY) : (-EINVAL);
	switch(snmp->snmp_magic){
            	return -EINVAL;
		snmp->snmp_val = card->wandev.stats.rx_length_errors;
            	return -EINVAL;
#define PROC_IF_FR_S_FRM	"%-30s\t%-14s\n"
#define PROC_IF_FR_D_FRM	"%-30s\t%-14d\n"
#define PROC_IF_FR_L_FRM	"%-30s\t%-14ld\n"
	if (dev == NULL || dev->priv == NULL)
	ppp_priv_area = (ppp_private_area_t*)dev->priv;
			ppp_priv_area->if_name, buffer);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (card->wandev.ignore_front_end_status == WANOPT_YES){
	if (ppp_priv_area->ppp_state != WAN_CONNECTED){
	if (card->fe.fe_status == FE_CONNECTED){
		if (ppp_priv_area->ppp_state == WAN_CONNECTED &&
		    card->wandev.state != WAN_CONNECTED){
			ppp_priv_area->timer_int_enabled |= TMR_INT_ENABLED_PPP_EVENT;
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, PPP_INTR_TIMER);
		ppp_priv_area->timer_int_enabled |= TMR_INT_ENABLED_PPP_EVENT;
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, PPP_INTR_TIMER);
		if (card->u.p.ip_mode == WANOPT_PPP_PEER) { 
	wan_mbox_t*		mb = &card->wan_mbox;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		pkt_stat = (ppp_pkt_stats_t*)mb->wan_data;
		rx_lcp = pkt_stat->rx_lcp;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		lcp_stat = (ppp_lcp_stats_t*)mb->wan_data;
		rx_conf_nak	= lcp_stat->rx_conf_nak;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	if (card->wan_debugging_state == WAN_DEBUGGING_CONT){
		card->wan_debugging_state = WAN_DEBUGGING_PROTOCOL;
			if (card->wan_debug_last_msg != WAN_DEBUG_PPP_LCP_MSG){
							card->devname);
							card->devname);
						card->devname);	
			card->wan_debug_last_msg = WAN_DEBUG_PPP_LCP_MSG;
			if (card->wan_debug_last_msg != WAN_DEBUG_PPP_NAK_MSG){
							card->devname);
							card->devname);	
			card->wan_debug_last_msg = WAN_DEBUG_PPP_NAK_MSG;
		if (card->wan_debug_last_msg != WAN_DEBUG_PPP_NEG_MSG){
						card->devname);
						card->devname);	
		card->wan_debug_last_msg = WAN_DEBUG_PPP_NEG_MSG;
	wan_mbox_t*	mb = &card->wan_mbox;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		ppp_err_stats_t* stats = (ppp_err_stats_t*)mb->wan_data;
		rx_bad_crc = stats->rx_bad_crc;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	wan_mbox_t*	mb = &card->wan_mbox;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		ppp_err_stats_t* stats = (ppp_err_stats_t*)mb->wan_data;
		rx_abort = stats->rx_abort;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	wan_mbox_t*	mb = &card->wan_mbox;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		ppp_err_stats_t* stats = (ppp_err_stats_t*)mb->wan_data;
		tx_underrun = stats->tx_missed_intr;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
./sdla_ppp.c
* Copyright:	(c) 1995-2004 Sangoma Technologies Inc.
#define GET_FIN_CRC_CNT(a)  { if (--a < 0) a=MAX_CRC_QUEUE-1; \
		              if (--a < 0) a=MAX_CRC_QUEUE-1; }
#define MAX_E1_CHAN_TX_UP_SIZE  40*(NUM_OF_E1_CHANNELS-1)	//1240 bytes
//(MAX_MTU_SIZE-100)
/* chan->tq_control fileds */
 *  o initialize protocol-specific fields of the adapter data space.
	if (conf->config_id != WANCONFIG_BITSTRM) {
				  card->devname, conf->config_id);
		return -EINVAL;
	if ((conf->comm_port == WANOPT_PRI) || (conf->comm_port == WANOPT_SEC)){
		if (card->next){
			if (conf->comm_port != card->next->u.b.comm_port){
				card->u.b.comm_port = conf->comm_port;
				DEBUG_EVENT( "%s: ERROR - %s port used!\n",
        		        	card->wandev.name, PORT(conf->comm_port));
				return -EINVAL;
			card->u.b.comm_port = conf->comm_port;
		DEBUG_EVENT( "%s: ERROR - Invalid Port Selected!\n",
                			card->wandev.name);
		return -EINVAL;
	/* Initialize protocol-specific fields */
	if (card->type != SDLA_S514){
		DEBUG_EVENT( "%s: ERROR - T1/E1 Bitstrm doesn't support S508 cards!\n",
				card->devname); 
		return -EOPNOTSUPP;
		if (card->u.b.comm_port == WANOPT_PRI){
			card->mbox_off = PRI_BASE_ADDR_MB_STRUCT;
			card->mbox_off = SEC_BASE_ADDR_MB_STRUCT;
	mb = &card->wan_mbox;
	mb1 = &card->wan_mbox;
	if (!card->configured){
			card->hw_iface.peek(card->hw, 
				card->mbox_off+offsetof(wan_mbox_t, wan_return_code),
			if ((jiffies - timeout) > 1*HZ) break;
				card->devname);
			return -EIO;
	card->wandev.ignore_front_end_status = conf->ignore_front_end_status;
	//ALEX_TODAY err=check_conf_hw_mismatch(card,conf->te_cfg.media);
	err = (card->hw_iface.check_mismatch) ? 
			card->hw_iface.check_mismatch(card->hw,conf->fe_cfg.media) : -EINVAL;
	card->u.b.serial=0;
	if (IS_TE1_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_te_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg = card->hw_iface.fe_write;
		card->fe.read_fe_reg	 = card->hw_iface.fe_read;
		card->wandev.fe_enable_timer = bstrm_enable_timer;
		card->wandev.te_link_state = bstrm_handle_front_end_state;
		conf->electrical_interface = 
		if (card->u.b.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
		if (IS_FR_FEUNFRAMED(&card->fe)){
			card->u.b.serial=1;
			card->devname, FE_MEDIA_DECODE(&card->fe));
	}else if (IS_56K_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_56k_iface_init(&card->fe, &card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg = card->hw_iface.fe_write;
		card->fe.read_fe_reg	 = card->hw_iface.fe_read;
		if (card->u.c.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
		card->u.b.serial=1;
			card->devname, FE_MEDIA_DECODE(&card->fe));
		card->u.b.serial=1;
		card->fe.fe_status = FE_CONNECTED;
			card->devname);
	if (card->u.b.serial){
				card->devname);
		return -EIO;
		card->devname, u.str); 
				card->devname);
		return -EIO;
	card->isr			= &wpbit_isr;
	card->poll			= NULL;
	card->exec			= NULL;
	card->wandev.update		= &update;
 	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= &del_if;
	card->wandev.udp_port   	= conf->udp_port;
	card->wandev.bind_annexg	= &bind_annexg;
	card->wandev.un_bind_annexg	= &un_bind_annexg;
	card->wandev.get_map		= &get_map;
	card->wandev.get_active_inactive= &get_active_inactive;
	card->wandev.new_if_cnt = 0;
	card->wandev.get_config_info 	= &bstrm_get_config_info;
	memcpy(&card->u.b.cfg,&conf->u.bitstrm,sizeof(wan_bitstrm_conf_t));
	card->u.b.sync_options = conf->sync_options;
	card->u.b.cfg.rx_sync_char = conf->rx_sync_char;
	card->u.b.cfg.monosync_tx_time_fill_char = conf->monosync_tx_time_fill_char;
	card->u.b.cfg.max_length_tx_data_block = conf->max_length_tx_data_block;
	card->u.b.cfg.rx_complete_length = conf->rx_complete_length;
	card->u.b.cfg.rx_complete_timer = conf->rx_complete_timer;
	card->u.b.update_call_count = 0;
	card->wandev.ttl = conf->ttl;
	card->wandev.electrical_interface = conf->electrical_interface; 
	card->wandev.clocking = conf->clocking;
	port_num = card->u.b.comm_port;
	if(card->wandev.clocking) {
				(card->type == SDLA_S514) ?
                               (card->type == SDLA_S514) ?
			if(conf->bps > max_permitted_baud) {
				conf->bps = max_permitted_baud;
					card->wandev.name);
					card->wandev.name, max_permitted_baud);
			card->wandev.bps = conf->bps;
        	card->wandev.bps = 0;
		card->wandev.mtu =  wp_min(conf->mtu, PRI_MAX_LENGTH_TX_DATA_BLOCK);
		card->wandev.mtu = wp_min(conf->mtu, SEC_MAX_LENGTH_TX_DATA_BLOCK);
         * Use this pointer to calculate the value of card->u.b.flags !
	mb1->wan_data_len = 0;
	mb1->wan_command = READ_BSTRM_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb1);
		return -EIO;
      	card->flags_off = 
       		(((BSTRM_CONFIGURATION_STRUCT *)mb1->wan_data)->
    	card->intr_type_off = 
		card->flags_off + 
	card->intr_perm_off = 
		card->flags_off +
	card->fe_status_off = 
		card->flags_off + 
	card->u.b.rx_discard_off =
		card->flags_off +
	card->u.b.tx_idle_off =
		card->flags_off +
	if (!card->wandev.piggyback){	
		card->wandev.state = WAN_DUALPORT;
		card->u.b.state = WAN_DISCONNECTED;
		if(err || (card->timer_int_enabled == 0 /* MAX_INTR_TEST_COUNTER*/)) { 
					card->devname, card->timer_int_enabled);
					card->devname);
			return -EIO;
				card->devname, card->timer_int_enabled);
		card->configured = 1;
	card->backup = conf->backup;
	DEBUG_EVENT( "%s: Initializing CRC tables\n",card->devname);
	card->u.b.tq_working=0;
	/* Add 1 to MAX_BH_BUFF so we don't have test with (MAX_BH_BUFF-1) */
	skb_queue_head_init(&card->u.b.rx_isr_queue);
	skb_queue_head_init(&card->u.b.rx_isr_free_queue);
	memset(card->u.b.time_slot_map,0,sizeof(card->u.b.time_slot_map));
	card->u.b.time_slots=NUM_OF_T1_CHANNELS;
		card->u.b.time_slots=NUM_OF_E1_CHANNELS;
	if (IS_TE1_MEDIA(&conf->fe_cfg)){
		int tx_time_slots=card->u.b.time_slots;
		if (IS_E1_CARD(card) && !IS_FR_FEUNFRAMED(&card->fe) && card->u.b.time_slots == 32){
		if (card->u.b.cfg.max_length_tx_data_block % tx_time_slots){
					card->devname,
					card->u.b.cfg.max_length_tx_data_block,
			card->u.b.cfg.max_length_tx_data_block-=
				(card->u.b.cfg.max_length_tx_data_block%
			card->u.b.cfg.max_length_tx_data_block+=tx_time_slots;
					card->devname,card->u.b.cfg.max_length_tx_data_block,
					card->u.b.time_slots);
			bstrm_skb_queue_purge(&card->u.b.rx_isr_free_queue);
			return -EINVAL;
					card->devname,card->u.b.cfg.max_length_tx_data_block);
		if (card->u.b.cfg.rx_complete_length % card->u.b.time_slots){
					card->devname,
					card->u.b.cfg.rx_complete_length,
				      	card->u.b.time_slots);
			card->u.b.cfg.rx_complete_length-=
				(card->u.b.cfg.rx_complete_length%
				 card->u.b.time_slots);
			card->u.b.cfg.rx_complete_length+=card->u.b.time_slots;
					card->devname,card->u.b.cfg.rx_complete_length);
		if (card->u.b.cfg.max_length_tx_data_block >= MAX_E1_CHANNELS*50){
					card->devname,MAX_E1_CHANNELS*50);
			return -EINVAL;
	card->u.b.tx_chan_multiple=
		card->u.b.cfg.max_length_tx_data_block/card->u.b.time_slots;
	DEBUG_EVENT( "%s: Configuring: \n",card->devname);
				card->devname, card->u.b.time_slots);
				card->devname, card->u.b.tx_chan_multiple);
			card->devname, card->u.b.cfg.max_length_tx_data_block);
			card->devname, card->u.b.cfg.rx_complete_length);
				card->devname,
				card->u.b.cfg.monosync_tx_time_fill_char);
	card->u.b.cfg.rbs_map&=0x00FFFFFF;
					card->devname,
					card->u.b.cfg.rbs_map?
					"ON":"OFF",card->u.b.cfg.rbs_map);
		if (card->u.b.cfg.rbs_map){
					card->devname);
			card->u.b.cfg.rbs_map=0;
	card->wandev.state = WAN_CONNECTING;
	card->u.b.state = WAN_DISCONNECTED;
	tasklet_init(&card->u.b.wanpipe_rx_task, bstrm_rx_bh, (unsigned long)card);
	tasklet_init(&card->u.b.wanpipe_tx_task, bstrm_tx_bh, (unsigned long)card);
		skb=dev_alloc_skb(card->u.b.cfg.rx_complete_length+50+sizeof(api_rx_hdr_t));
					card->devname);
			bstrm_skb_queue_purge(&card->u.b.rx_isr_free_queue);
			card->wandev.state = WAN_UNCONFIGURED;
			return -ENOMEM;
		skb_queue_tail(&card->u.b.rx_isr_free_queue,skb);
	card->u.b.tx_scratch_buf_len=1200;
	for (x=0;x<card->u.b.tx_scratch_buf_len;x++){
		card->u.b.tx_scratch_buf[x]=0x7E;//(x%32);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		DEBUG_EVENT( "%s: Failed to configure adapter!\n",card->devname);
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		bstrm_skb_queue_purge(&card->u.b.rx_isr_free_queue);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		card->wandev.state = WAN_UNCONFIGURED;
	set_bit(SEND_CRIT,&card->wandev.critical);
	card->disable_comm = &disable_comm;
	DEBUG_TEST("%s: Config DONE\n",card->devname);
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical))
                return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
	if((bstrm_priv_area=dev->priv) == NULL)
		return -ENODEV;
       	if(bstrm_priv_area->update_comms_stats){
		return -EAGAIN;
	bstrm_priv_area->ifstats.rx_fifo_errors=0;
	bstrm_priv_area->ifstats.rx_frame_errors=0;
	bstrm_priv_area->ifstats.tx_carrier_errors=0;
	bstrm_priv_area->ifstats.rx_bytes=0;
	bstrm_priv_area->ifstats.tx_bytes=0;
	bstrm_priv_area->ifstats.rx_packets=0;
	bstrm_priv_area->ifstats.tx_packets=0;
	bstrm_priv_area->ifstats.tx_fifo_errors=0;
	DEBUG_EVENT( "%s:%s: Tx B=%i:  Rx U=%i:  Rx F=%i:  Rx-U-BH=%i Rx-F-Bh=%i Idle 0x%x\n",
			card->devname,
			dev->name,
			skb_queue_len(&bstrm_priv_area->tx_queue),
			skb_queue_len(&bstrm_priv_area->rx_used_queue),
			skb_queue_len(&bstrm_priv_area->rx_free_queue),
			skb_queue_len(&card->u.b.rx_isr_queue),
			skb_queue_len(&card->u.b.rx_isr_free_queue),
			bstrm_priv_area->tx_idle_flag);
			card->devname, atomic_read(&tx_data),atomic_read(&rx_data)); 
			bstrm_priv_area->if_name,
			bstrm_priv_area->sw_dev ? 
			bstrm_priv_area->sw_dev->name : "None");
			card->devname,
			card->statistics.isr_entry,
			card->statistics.isr_rx,
			card->statistics.isr_tx,
			card->statistics.poll_entry,
			card->statistics.poll_tbusy_bad_status);	
	if (bstrm_priv_area->common.usedby == SWITCH && bstrm_priv_area->sw_dev){
			(bitstrm_private_area_t *)bstrm_priv_area->sw_dev->priv;	
		sdla_t *sw_card=sw_chan->card;
				card->statistics.isr_entry-sw_card->statistics.isr_entry,
				card->statistics.isr_rx-sw_card->statistics.isr_rx,
				card->statistics.isr_tx-sw_card->statistics.isr_tx,
				card->statistics.poll_entry-sw_card->statistics.poll_entry);
			card->devname,
			card->irq_equalize,
			card->u.b.wait_for_buffers);
	bstrm_priv_area->update_comms_stats = 
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	if (test_bit(0,&card->in_isr)){
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		return -EBUSY;
	bstrm_priv_area->update_comms_stats--;
	bstrm_priv_area->update_comms_stats--;
	bstrm_priv_area->update_comms_stats--;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
			card->devname, conf->name);
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
	if (card->u.b.serial && card->wandev.new_if_cnt){
				card->devname);
		return -EEXIST;
		return -ENOMEM;
	memcpy(&bstrm_priv_area->cfg, &conf->u.bitstrm, sizeof(wan_bitstrm_conf_if_t));
	bstrm_priv_area->card = card; 
	bstrm_priv_area->common.sk=NULL;
	bstrm_priv_area->common.state = WAN_DISCONNECTED;
	bstrm_priv_area->common.dev = dev;
	bstrm_priv_area->common.config_id=card->wandev.config_id;
	bstrm_priv_area->debug_stream=0;
	bstrm_priv_area->debug_char=0xFF;
	skb_queue_head_init(&bstrm_priv_area->rx_free_queue);
	skb_queue_head_init(&bstrm_priv_area->rx_used_queue);
	skb_queue_head_init(&bstrm_priv_area->tx_queue);
	strcpy(bstrm_priv_area->if_name, conf->name);
			err=-ENOMEM;
		skb_queue_tail(&bstrm_priv_area->rx_free_queue,skb);
	bstrm_priv_area->rx_skb=skb_dequeue(&bstrm_priv_area->rx_free_queue);
	if (!bstrm_priv_area->rx_skb){
		err=-ENOMEM;
		if (IS_E1_CARD(card) && !IS_FR_FEUNFRAMED(&card->fe)){
			conf->active_ch=conf->active_ch&0x7FFFFFFF;
		if ((bstrm_priv_area->time_slot_map=conf->active_ch) == 0){
					card->devname,bstrm_priv_area->time_slot_map);
			err=-EINVAL;
				card->devname,conf->name,bstrm_priv_area->time_slot_map);
		bstrm_priv_area->max_tx_up_size=MAX_T1_CHAN_TX_UP_SIZE;
			if (IS_FR_FEUNFRAMED(&card->fe)){
				bstrm_priv_area->max_tx_up_size=MAX_E1_UNFRM_CHAN_TX_UP_SIZE;
				bstrm_priv_area->max_tx_up_size=MAX_E1_CHAN_TX_UP_SIZE;
		if (bstrm_priv_area->cfg.max_tx_up_size){
			bstrm_priv_area->max_tx_up_size=bstrm_priv_area->cfg.max_tx_up_size;
		for (i=0;i<card->u.b.time_slots;i++){
			if (test_bit(i,&bstrm_priv_area->time_slot_map)){	
				bstrm_priv_area->time_slots++;
		if (bstrm_priv_area->max_tx_up_size % bstrm_priv_area->time_slots){
			bstrm_priv_area->max_tx_up_size-=
					bstrm_priv_area->max_tx_up_size % 
					bstrm_priv_area->time_slots;
			bstrm_priv_area->max_tx_up_size+=bstrm_priv_area->time_slots;
		bstrm_priv_area->max_tx_up_size=MAX_T1_CHAN_TX_UP_SIZE;
		if (bstrm_priv_area->cfg.max_tx_up_size){
			bstrm_priv_area->max_tx_up_size=bstrm_priv_area->cfg.max_tx_up_size;
	bstrm_priv_area->rx_max_timeout=HZ;
	bstrm_priv_area->rx_timeout=jiffies;
	bstrm_priv_area->tx_idle_flag=card->u.b.cfg.monosync_tx_time_fill_char;
	bstrm_priv_area->hdlc_eng=conf->hdlc_streaming;
	bstrm_priv_area->bits_in_byte=BITSINBYTE;
	if (bstrm_priv_area->hdlc_eng){
		bstrm_priv_area->tx_idle_flag=0x7E;
		bstrm_priv_area->seven_bit_hdlc = bstrm_priv_area->cfg.seven_bit_hdlc;
		if (bstrm_priv_area->seven_bit_hdlc){
			bstrm_priv_area->bits_in_byte = 7;
	bstrm_priv_area->max_tx_queue_sz=MAX_TX_QUEUE_SIZE;
	if (bstrm_priv_area->cfg.max_tx_queue_size){
		bstrm_priv_area->max_tx_queue_sz=bstrm_priv_area->cfg.max_tx_queue_size;
	if( strcmp(conf->usedby, "WANPIPE") == 0) {
		bstrm_priv_area->protocol=conf->protocol;
		bstrm_priv_area->common.usedby=WANPIPE;
		bstrm_priv_area->hdlc_eng=1;
		bstrm_priv_area->tx_idle_flag=0x7E;
			wandev->name);
		if (conf->protocol != WANOPT_NO){
			dev->priv=bstrm_priv_area;
			if (conf->ignore_dcd == WANOPT_YES || conf->ignore_cts == WANOPT_YES){
				DEBUG_EVENT( "%s: Ignore modem changes DCD/CTS\n",card->devname);
				bstrm_priv_area->ignore_modem=1;
						card->devname);
	} else if( strcmp(conf->usedby, "API") == 0) {
		bstrm_priv_area->common.usedby=API;
		bstrm_priv_area->protocol=0;
			wandev->name);
	} else if( strcmp(conf->usedby, "STACK") == 0) {
		bstrm_priv_area->common.usedby=STACK;
		bstrm_priv_area->protocol=0;
			wandev->name);
	}else if (strcmp(conf->usedby, "ANNEXG") == 0) {
			wandev->name,bstrm_priv_area->if_name);
		bstrm_priv_area->common.usedby=ANNEXG;	
		if (strlen(conf->label)){
			strncpy(bstrm_priv_area->label,conf->label,WAN_IF_LABEL_SZ);
	} else if( strcmp(conf->usedby, "SWITCH") == 0) {
		bstrm_priv_area->common.usedby=SWITCH;
		bstrm_priv_area->protocol=0;
			wandev->name);
		if (card->u.b.cfg.rx_complete_length != card->u.b.cfg.max_length_tx_data_block){
					card->devname,
					card->u.b.cfg.max_length_tx_data_block,
					card->u.b.cfg.rx_complete_length);
			err=-EINVAL;
		bstrm_priv_area->max_tx_up_size=card->u.b.cfg.rx_complete_length;
		set_bit(WAIT_DEVICE_BUFFERS,&bstrm_priv_area->tq_control);
						wandev->name);
		err=-EINVAL;
	dev->init = &if_init;
	dev->priv = bstrm_priv_area;
	bstrm_priv_area->common.dev = dev;
	bstrm_priv_area->hdlc_flag=0;
	set_bit(NO_FLAG,&bstrm_priv_area->hdlc_flag);
	bstrm_priv_area->rx_crc[0]=-1;
	bstrm_priv_area->rx_crc[1]=-1;
	bstrm_priv_area->rx_crc[2]=-1;
	bstrm_priv_area->tx_crc=-1;
	bstrm_priv_area->tx_flag= 0x7E; //card->u.b.cfg.monosync_tx_time_fill_char;
	bstrm_priv_area->tx_flag_idle= 0x7E; //card->u.b.cfg.monosync_tx_time_fill_char;
	if (bstrm_priv_area->common.usedby == SWITCH){
		strncpy(bstrm_priv_area->sw_if_name,conf->sw_dev_name,WAN_IFNAME_SZ);
		for (i=0;i<card->u.b.time_slots;i++){
			if (test_bit(i,&bstrm_priv_area->time_slot_map)){
						conf->name, i+1);
				bstrm_priv_area->rbs_chan=i+1;
					if (wan_test_bit(i,&card->u.b.cfg.rbs_map)){
						bstrm_priv_area->rbs_on=1;
					if (card->u.b.time_slot_map[i+1]){
								card->devname); 
								card->devname,dev->name,(i+1));
						err=-EEXIST;
					if (card->u.b.time_slot_map[i]){
								card->devname); 
								card->devname,dev->name,(i+1));
						err=-EEXIST;
		if (bstrm_priv_area->rbs_on){
			if (bstrm_priv_area->time_slots > 1){
						card->devname,bstrm_priv_area->if_name,
						bstrm_priv_area->time_slots);
						card->devname,bstrm_priv_area->if_name);
						card->devname,bstrm_priv_area->if_name);
				err = -EINVAL;
			if (bstrm_priv_area->hdlc_eng && !bstrm_priv_area->seven_bit_hdlc){
						card->devname,bstrm_priv_area->if_name);
				bstrm_priv_area->seven_bit_hdlc=1;
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		for (i=0;i<card->u.b.time_slots;i++){
			if (test_bit(i,&bstrm_priv_area->time_slot_map)){	
					card->u.b.time_slot_map[i+1] = bstrm_priv_area;
					card->u.b.time_slot_map[i] = bstrm_priv_area;
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
			card->devname,
			bstrm_priv_area->if_name);
			card->devname,
			bstrm_priv_area->time_slot_map);
			card->devname,
			bstrm_priv_area->tx_idle_flag);
			card->devname,
			bstrm_priv_area->max_tx_queue_sz);
			card->devname,
			bstrm_priv_area->max_tx_up_size);
			card->devname,
			bstrm_priv_area->hdlc_eng?"ON":"OFF",
			bstrm_priv_area->seven_bit_hdlc?7:8);
	card->wandev.new_if_cnt++;
		bstrm_skb_queue_purge(&bstrm_priv_area->rx_free_queue);
		if (bstrm_priv_area->rx_skb){
			dev_kfree_skb_any(bstrm_priv_area->rx_skb);
			bstrm_priv_area->rx_skb=NULL;
		bstrm_priv_area->common.dev=NULL;
	dev->priv=NULL;
	bitstrm_private_area_t* bstrm_priv_area = dev->priv;
	bitstrm_private_area_t* chan = dev->priv;
	sdla_t *card = wandev->priv;
	if (chan->common.usedby == ANNEXG && chan->annexg_dev){
		printk(KERN_INFO "%s: Unregistering Lapb Protocol\n",wandev->name);
			wan_spin_lock_irq(&wandev->lock, &smp_flags);
			chan->annexg_dev = NULL;
			wan_spin_unlock_irq(&wandev->lock, &smp_flags);
		wan_spin_lock_irq(&wandev->lock, &smp_flags);
		tmp_dev=chan->annexg_dev;
		chan->annexg_dev=NULL;
		wan_spin_unlock_irq(&wandev->lock, &smp_flags);
			wan_spin_lock_irq(&wandev->lock, &smp_flags);
			chan->annexg_dev=tmp_dev;
			wan_spin_unlock_irq(&wandev->lock, &smp_flags);
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	if (test_bit(0,&card->in_isr)){
				card->devname);
		for (i=0;i<card->u.b.time_slots;i++){
			if (test_bit(i,&bstrm_priv_area->time_slot_map)){
					card->u.b.time_slot_map[i+1] = NULL;
					card->u.b.time_slot_map[i] = NULL;
	if (bstrm_priv_area->rx_skb){
		dev_kfree_skb_any(bstrm_priv_area->rx_skb);
		bstrm_priv_area->rx_skb=NULL;
	if (bstrm_priv_area->tx_skb){
		dev_kfree_skb_any(bstrm_priv_area->tx_skb);
		bstrm_priv_area->tx_skb=NULL;
	bstrm_skb_queue_purge(&bstrm_priv_area->tx_queue);
	bstrm_skb_queue_purge(&bstrm_priv_area->rx_free_queue);
	bstrm_skb_queue_purge(&bstrm_priv_area->rx_used_queue);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
	card->wandev.new_if_cnt--;
	bitstrm_private_area_t* bstrm_priv_area = dev->priv;
	sdla_t* card = bstrm_priv_area->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= TX_TIMEOUT;
	dev->do_ioctl		= &if_do_ioctl;
	/* Initialize media-specific parameters */
	if (!bstrm_priv_area->protocol){
		dev->flags		|= IFF_POINTOPOINT;
		dev->flags		|= IFF_NOARP;
	if (!bstrm_priv_area->protocol && bstrm_priv_area->mc == WANOPT_YES){
		dev->flags 	|= IFF_MULTICAST;
	if (!bstrm_priv_area->protocol){
		dev->type	= ARPHRD_PPP;
	if (bstrm_priv_area->common.usedby == SWITCH){
		dev->mtu = card->u.b.cfg.max_length_tx_data_block;
		if (!bstrm_priv_area->protocol){
			dev->mtu = card->wandev.mtu;
	if(bstrm_priv_area->common.usedby == API) {
		dev->mtu += sizeof(api_tx_hdr_t);
	if (!bstrm_priv_area->protocol){
		dev->hard_header_len	= 0;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start); //ALEX_TODAY wandev->maddr;
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end); //ALEX_TODAY wandev->maddr + wandev->msize - 1;
        dev->tx_queue_len = 100;
 *	if_do_ioctl - Ioctl handler for fr
	bitstrm_private_area_t* chan= (bitstrm_private_area_t*)dev->priv;
		return -ENODEV;
	card=chan->card;
			err=card->u.b.time_slots;
			err=card->fe.fe_cfg.media;
				err= -EINVAL;
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			err=wan_bind_api_to_svc(chan,ifr->ifr_data);
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
				chan->ifstats.tx_fifo_errors=0;
				chan->ifstats.rx_errors=0;
				err= -EINVAL;
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			err=wan_unbind_api_from_svc(chan,ifr->ifr_data);
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
			if (chan->hdlc_eng){
			err = chan->common.state;
			DEBUG_DBG("%s: SIOC_WANPIPE_BITSTRM_T1E1_CFG\n", card->devname);
			if (card->comm_enabled){
				spin_lock_irqsave(&card->wandev.lock, smp_flags);
				spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
			if (copy_from_user(&card->fe.fe_cfg,ifr->ifr_data,sizeof(sdla_fe_cfg_t))){
						card->devname);
				return -EFAULT;
			spin_lock_irqsave(&card->wandev.lock, smp_flags);
					card->devname, 
					card->wandev.electrical_interface = WANOPT_V35;
					card->u.b.cfg.rx_complete_length = 720;
					card->u.b.cfg.max_length_tx_data_block = 720;
					card->u.b.time_slots = NO_ACTIVE_RX_TIME_SLOTS_T1;
					card->wandev.electrical_interface = WANOPT_RS232;
					card->u.b.cfg.rx_complete_length = 704;	 //divisible by 32
					card->u.b.cfg.max_length_tx_data_block = 682;//divisible by 31
					card->u.b.time_slots = NO_ACTIVE_RX_TIME_SLOTS_E1;
				if (card->wandev.fe_iface.pre_release){
					card->wandev.fe_iface.pre_release(&card->fe);
				if (card->wandev.fe_iface.unconfig){
					card->wandev.fe_iface.unconfig(&card->fe);
			spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
			if(copy_from_user(&custom_control_pkt, ifr->ifr_data, sizeof(custom_control_call_t)) ){
				return -EFAULT;
					val = card->fe.read_fe_reg(card->hw, 0, 1, custom_control_pkt.reg);
					DEBUG_DBG("%s: read val : 0x%02X\n", card->devname, val);
					err = card->fe.write_fe_reg(card->hw, 0, 1, custom_control_pkt.reg, new_val);
								card->devname, err);
					val = card->fe.read_fe_reg(card->hw, 0, 1, custom_control_pkt.reg);
					DEBUG_DBG("%s: read val after OR : 0x%02X\n", card->devname, val);
						card->devname);
					val = card->fe.read_fe_reg(card->hw, 0, 1, custom_control_pkt.reg);
					err = card->fe.write_fe_reg(card->hw, 0, 1, custom_control_pkt.reg, new_val);
						card->devname, err);
						card->devname);
			if (atomic_read(&chan->udp_pkt_len) != 0){
				return -EBUSY;
			atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
			if (test_bit(0,&card->in_isr)){
				atomic_set(&chan->udp_pkt_len,0);
				return -EBUSY;
			wan_udp_pkt=(wan_udp_pkt_t*)chan->udp_pkt_data;
			if (copy_from_user(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			spin_lock_irqsave(&card->wandev.lock, smp_flags);
			if (test_bit(0,&card->in_isr)) {
						card->devname,dev->name);
				atomic_set(&chan->udp_pkt_len,0);
				spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
				return -EBUSY;
			spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
			if (atomic_read(&chan->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						card->devname,atomic_read(&chan->udp_pkt_len));
				atomic_set(&chan->udp_pkt_len,0);
				return -EINVAL;
			if (copy_to_user(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			atomic_set(&chan->udp_pkt_len,0);
			if (!chan->rbs_on){
						chan->if_name);
				return -EINVAL;
			if (copy_from_user(&abcd_bits,ifr->ifr_data,1)){
				return -EFAULT;
			card->wandev.fe_iface.set_rbsbits(
						&card->fe,
						chan->rbs_chan,
			if (!chan->rbs_on){
						chan->if_name);
				return -EINVAL;
			if (copy_to_user(ifr->ifr_data,&chan->rbs_sig,1)){
				return -EFAULT;
			if (chan->protocol == WANCONFIG_PPP || 
			    chan->protocol == WANCONFIG_CHDLC){
			return -EOPNOTSUPP;
	bitstrm_private_area_t* bstrm_priv_area = dev->priv;
	sdla_t* card = bstrm_priv_area->card;
		return -EBUSY;
	bstrm_priv_area->router_start_time = tv.tv_sec;
	if (bstrm_priv_area->common.usedby == SWITCH){
		err=bstrm_bind_dev_switch(card,bstrm_priv_area,bstrm_priv_area->sw_if_name);
					card->devname,bstrm_priv_area->if_name,
					bstrm_priv_area->sw_if_name);
			if (bstrm_priv_area->sw_dev && 
			    bstrm_priv_area->common.state != WAN_CONNECTED){
				sw_chan=(bitstrm_private_area_t *)bstrm_priv_area->sw_dev->priv;
				sw_card=sw_chan->card;
				if (!sw_card->comm_enabled || !card->comm_enabled){
							bstrm_priv_area->common.dev->name,
							bstrm_priv_area->sw_dev->name);
							bstrm_priv_area->common.dev->name,
							bstrm_priv_area->sw_dev->name);
					wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
					sw_chan->common.state = WAN_CONNECTED;
					bstrm_priv_area->common.state=WAN_CONNECTED;
					set_bit(WAIT_DEVICE_BUFFERS,&bstrm_priv_area->tq_control);
					set_bit(WAIT_DEVICE_BUFFERS,&sw_chan->tq_control);
					wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		bstrm_priv_area->common.state=card->wandev.state;
				card->devname,
				dev->name,
				STATE_DECODE(bstrm_priv_area->common.state));
	bitstrm_private_area_t* bstrm_priv_area = dev->priv;
	sdla_t* card = bstrm_priv_area->card;
	if (bstrm_priv_area->common.usedby == SWITCH){
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	bstrm_priv_area->common.state=WAN_DISCONNECTED;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	wan_unbind_api_from_svc(bstrm_priv_area,bstrm_priv_area->common.sk);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	dev->start=0;
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	if (card->u.b.cfg.rbs_map){
		bstrm_disable_te_signaling(card,card->u.b.cfg.rbs_map);
	if (card->comm_enabled){
		card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);	
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
	tasklet_kill(&card->u.b.wanpipe_rx_task);
	tasklet_kill(&card->u.b.wanpipe_tx_task);
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	bstrm_skb_queue_purge(&card->u.b.rx_isr_queue);
	bstrm_skb_queue_purge(&card->u.b.rx_isr_free_queue);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
	/* TE1 - Unconfiging */
	if (card->wandev.fe_iface.pre_release){
		card->wandev.fe_iface.pre_release(&card->fe);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
    	bitstrm_private_area_t* chan = dev->priv;
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++card->wandev.stats.collisions;
	printk (KERN_INFO "%s: Transmit timed out on %s\n", card->devname,dev->name);
	if (chan->common.usedby == API){
	}else if (chan->common.usedby == STACK){
	if (chan->common.usedby == ANNEXG && 
			  chan->annexg_dev){
			lapb_protocol.lapb_mark_bh(chan->annexg_dev);
 * o set tbusy flag (marks start of the transmission) to block a timer-based
 *		non-0	packet may be re-transmitted (tbusy must be set)
	bitstrm_private_area_t *bstrm_priv_area = dev->priv;
	sdla_t *card = bstrm_priv_area->card;
		 * tx-done interrupt.
			card->devname, dev->name);
	spin_lock_irqsave(&card->wandev.lock,smp_flags);	
	if (skb_queue_len(&bstrm_priv_area->tx_queue) > bstrm_priv_area->max_tx_queue_sz){
		bstrm_priv_area->tick_counter = jiffies;
		if (card->u.b.serial){
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_BLOCK);
		spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
	spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
	if (dev->tbusy){
		 * kick start the device by making dev->tbusy = 0.  We expect 
                ++card->wandev.stats.collisions;
		if((jiffies - bstrm_priv_area->tick_counter) < (5 * HZ)) {
	if (test_bit(WAIT_DEVICE_BUFFERS,&bstrm_priv_area->tq_control) &&
	    skb_queue_len(&bstrm_priv_area->tx_queue) >= TX_QUEUE_MID){		
					bstrm_priv_area->if_name);
		if (bstrm_priv_area->sw_dev){
			sw_chan=(bitstrm_private_area_t *)bstrm_priv_area->sw_dev->priv;
				if (test_bit(WAIT_DEVICE_BUFFERS,&sw_chan->tq_control) &&
					skb_queue_len(&sw_chan->tx_queue) >= TX_QUEUE_MID){
							sw_chan->if_name,
							skb_queue_len(&bstrm_priv_area->tx_queue),
							skb_queue_len(&sw_chan->tx_queue));	
					sw_chan->tq_control=0;
					bstrm_priv_area->tq_control=0;
	}else if(card->u.b.state != WAN_CONNECTED || 
	   	bstrm_priv_area->common.state != WAN_CONNECTED){
       		++card->wandev.stats.tx_dropped;
		bstrm_priv_area->ifstats.tx_carrier_errors++;
	}else if(test_bit(SEND_CRIT,&card->wandev.critical)){
		++card->wandev.stats.tx_dropped;
		bstrm_priv_area->ifstats.tx_carrier_errors++;
		dev->trans_start = jiffies;
		if (bstrm_priv_area->common.usedby == SWITCH){
		if (bstrm_priv_area->common.usedby == API){
			if (skb->len <= sizeof(api_tx_hdr_t)){
				++card->wandev.stats.tx_dropped;
				bstrm_priv_area->ifstats.tx_dropped++;
		if (bstrm_priv_area->common.usedby != SWITCH &&
		    bstrm_priv_area->hdlc_eng){
				++card->wandev.stats.tx_dropped;
				bstrm_priv_area->ifstats.tx_dropped++;
			DEBUG_EVENT( "Tx Packet: idle 0x%02X \n",bstrm_priv_area->tx_flag_idle);
			for (i=0;i<skb->len;i++){
				printk("%02X ",skb->data[i]);
		card->wandev.stats.tx_packets++;
		card->wandev.stats.tx_bytes+=skb->len;
		bstrm_priv_area->ifstats.tx_packets++;
		bstrm_priv_area->ifstats.tx_bytes += skb->len;
		spin_lock_irqsave(&card->wandev.lock,smp_flags);
		if (bstrm_priv_area->common.usedby != SWITCH &&
		    bstrm_priv_area->hdlc_eng){
			bstrm_priv_area->tx_idle_flag = bstrm_priv_area->tx_flag_idle;
		skb_queue_tail(&bstrm_priv_area->tx_queue,skb);
		spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
		bstrm_priv_area->tick_counter = jiffies;
		if (card->u.b.serial && 
		    !test_bit(WAIT_DEVICE_BUFFERS,&bstrm_priv_area->tq_control)){
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_BLOCK);
	 	dev->trans_start = jiffies;
	spin_lock_irqsave(&card->wandev.lock,smp_flags);
	spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
 * Get ethernet-style interface statistics.
	if ((bstrm_priv_area=dev->priv) == NULL)
	return &bstrm_priv_area->ifstats;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_BSTRM_CODE_VERSION;
	rc = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			data_len = mb->wan_data_len;
			memcpy(str, mb->wan_data, data_len);
/*-----------------------------------------------------------------------------
	wan_mbox_t *mb = &card->wan_mbox;
	memcpy(mb->wan_data, data, sizeof(BSTRM_CONFIGURATION_STRUCT));
	mb->wan_command = SET_BSTRM_CONFIGURATION;
	mb->wan_data_len = sizeof(BSTRM_CONFIGURATION_STRUCT);  
	err=card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			card->devname,mb->wan_data_len,mb->wan_data[0]);		
 * Set interrupt mode -- HDLC Version.
	wan_mbox_t* mb = &card->wan_mbox;
		 (BSTRM_INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->BSTRM_interrupt_triggers 	= mode;
	int_data->IRQ				= card->wandev.irq;	//ALEX_TODAY card->hw.irq;
	int_data->interrupt_timer               = 1;
	mb->wan_data_len = sizeof(BSTRM_INT_TRIGGERS_STRUCT);
	mb->wan_command = SET_BSTRM_INTERRUPT_TRIGGERS;
	rc = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t* mb = &card->wan_mbox;
		 (BSTRM_INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->BSTRM_interrupt_triggers 	= 0;
	int_data->IRQ				= card->wandev.irq;	//ALEX_TODAY card->hw.irq;
	int_data->interrupt_timer               = 1;
	mb->wan_command = SET_BSTRM_INTERRUPT_TRIGGERS;
	mb->wan_data_len = sizeof(BSTRM_INT_TRIGGERS_STRUCT);
	rc = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	mb->wan_command = DISABLE_BSTRM_COMMUNICATIONS;
	mb->wan_data_len = 0;
	rc = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card->comm_enabled = 0;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = ENABLE_BSTRM_COMMUNICATIONS;
	rc = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->comm_enabled = 1;
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_COMMS_ERROR_STATS;
	rc = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_BSTRM_OPERATIONAL_STATS;
        rc = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
	if(bstrm_priv_area->update_comms_stats == 3) {
			card->wandev.fe_iface.read_alarm(&card->fe, 0);
			card->wandev.fe_iface.read_pmon(&card->fe, 0);
			card->wandev.fe_iface.read_alarm(&card->fe, 1); 
		if(bstrm_priv_area->update_comms_stats == 2) {
			err_stats = (COMMS_ERROR_STATS_STRUCT *)mb->wan_data;
			card->wandev.stats.rx_over_errors = 
				err_stats->Rx_overrun_err_count;
			card->wandev.stats.rx_fifo_errors = 
				err_stats->Rx_dis_pri_bfrs_full_count; 
			card->wandev.stats.rx_missed_errors =
				card->wandev.stats.rx_fifo_errors;
			op_stats = (BSTRM_OPERATIONAL_STATS_STRUCT *)mb->wan_data;
 *	Return:	0 - o.k.
 *		1 - no transmit buffers available
	card->hw_iface.peek(card->hw, card->u.b.txbuf_off, &txbuf, sizeof(txbuf));
	 * The txbuf->block_lenght and txbuf->opp_flag should
	card->hw_iface.poke(card->hw, txbuf.ptr_data_bfr, data, len);
	card->hw_iface.poke(card->hw, card->u.b.txbuf_off, &txbuf, sizeof(txbuf));
	card->u.b.txbuf_off += sizeof(txbuf);
	if (card->u.b.txbuf_off > card->u.b.txbuf_last_off)
		card->u.b.txbuf_off = card->u.b.txbuf_base_off;
	card->u.b.timer_int_enabled |= TMR_INT_ENABLED_TE;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_command;
			card->devname, cmd);
				card->devname);
				card->devname);
			card->devname, cmd, err);
	set_bit(8, &card->u.b.tq_working);
	if (test_bit(SEND_CRIT,&card->wandev.critical)){
		clear_bit(SEND_CRIT,&card->wandev.critical);
	card->hw_iface.peek(card->hw, card->u.b.txbuf_off, &txbuf, sizeof(txbuf));
				card->devname);
	card->u.b.tx_scratch_buf_len=0;
	if (card->u.b.serial){
		dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		if (!dev || !(dev->flags & IFF_UP)){
		if (chan->common.usedby == SWITCH && 
		    test_bit(WAIT_DEVICE_BUFFERS,&chan->tq_control)){
					chan->common.dev->name);
		if (is_queue_stopped(chan->common.dev)){	
			if (chan->common.usedby == API){
				start_net_queue(chan->common.dev);	
			}else if (chan->common.usedby == SWITCH){
				start_net_queue(chan->common.dev);
				wake_net_dev(chan->common.dev);
		skb=skb_dequeue(&chan->tx_queue);	
		if (bstrm_send(card,skb->data,skb->len,chan->hdlc_eng?skb->cb[0]:0)){
					card->devname);
		if (skb_queue_len(&chan->tx_queue)){
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_BLOCK);
		if (!IS_FR_FEUNFRAMED(&card->fe) && card->u.b.time_slots == NUM_OF_E1_CHANNELS && ch == 0){
		chan=(bitstrm_private_area_t*)card->u.b.time_slot_map[ch];
		if (!chan || !(chan->common.dev->flags & IFF_UP)){
					card->devname,(ch+1));
			card->u.b.tx_scratch_buf[card->u.b.tx_scratch_buf_len]=
			card->u.b.cfg.monosync_tx_time_fill_char;
			card->u.b.tx_scratch_buf_len++;
		if (!chan->tx_skb){
			if (is_queue_stopped(chan->common.dev)){	
				if (chan->common.usedby == API){
					start_net_queue(chan->common.dev);	
				}else if (chan->common.usedby == STACK){
					start_net_queue(chan->common.dev);	
				}else if (chan->common.usedby == ANNEXG && 
			  		chan->annexg_dev){
						lapb_protocol.lapb_mark_bh(chan->annexg_dev);
				}else if (chan->common.usedby == SWITCH){
					start_net_queue(chan->common.dev);
					wake_net_dev(chan->common.dev);
			if (chan->common.usedby == SWITCH &&
			    test_bit(WAIT_DEVICE_BUFFERS,&chan->tq_control)){
				card->u.b.tx_scratch_buf[card->u.b.tx_scratch_buf_len]=chan->tx_idle_flag;
				card->u.b.tx_scratch_buf_len++;
			chan->tx_skb = skb_dequeue(&chan->tx_queue);
			if (!chan->tx_skb){
						card->devname,chan->if_name);
				card->u.b.tx_scratch_buf[card->u.b.tx_scratch_buf_len]=chan->tx_idle_flag;
				card->u.b.tx_scratch_buf_len++;
				chan->ifstats.tx_fifo_errors++;
		if (!chan->tx_skb || chan->tx_skb->len == 0){
					card->devname,chan->if_name,ch+1);
			card->u.b.tx_scratch_buf[card->u.b.tx_scratch_buf_len]=chan->tx_idle_flag;
			card->u.b.tx_scratch_buf_len++;
			chan->ifstats.tx_fifo_errors++;
			if (chan->tx_skb){
				dev_kfree_skb_any(chan->tx_skb);
				chan->tx_skb=NULL;
		card->u.b.tx_scratch_buf[card->u.b.tx_scratch_buf_len]=chan->tx_skb->data[0];
		card->u.b.tx_scratch_buf_len++;
		skb_pull(chan->tx_skb,1);
		if (chan->tx_skb->len < 1){
			dev_kfree_skb_any(chan->tx_skb);
			chan->tx_skb=NULL;
		if (++ch >= card->u.b.time_slots){
			if (++frame_multiple >= card->u.b.tx_chan_multiple){ 
	if (bstrm_send(card,&card->u.b.tx_scratch_buf[0],card->u.b.tx_scratch_buf_len,0)){
				card->devname);
	clear_bit(8, &card->u.b.tq_working);
	if (!skb_queue_len(&card->u.b.rx_isr_queue)){
		card->statistics.poll_tbusy_bad_status++;
	card->statistics.poll_entry++;
	while ((skb=skb_dequeue(&card->u.b.rx_isr_queue)) != NULL){
		if (!skb->len){
			DEBUG_EVENT( "RX Error, skb=NULL or skb->len=0 \n");
		if (card->u.b.serial){
			dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
			if (!dev || !(dev->flags&IFF_UP)){
			if (chan->common.usedby == SWITCH){
			chan=(bitstrm_private_area_t*)card->u.b.time_slot_map[ch];
			if (!chan || !(chan->common.dev->flags & IFF_UP)){
						card->devname,(ch+1),ch);
				card->wandev.stats.rx_over_errors=ch;
				card->wandev.stats.rx_fifo_errors++;
			if (chan->rbs_on){
				if (chan->rbs_sig != card->u.b.rbs_sig[ch]){
					chan->rbs_sig=card->u.b.rbs_sig[ch];
							chan->if_name,chan->rbs_sig);
			if (!chan->rx_skb){
						card->devname,skb_queue_len(&chan->rx_free_queue));
				chan->rx_skb=skb_dequeue(&chan->rx_free_queue);
				if (!chan->rx_skb){
							card->devname,(ch+1));
					chan->ifstats.rx_dropped++;
				chan->rx_timeout=jiffies;
			if (skb_queue_len(&chan->rx_used_queue)){
			buf=skb_put(chan->rx_skb,1);
			buf[0]=skb->data[0];
				if (buf[0] == 0x20+(ch-1)){
					if (!chan->debug_stream){
								chan->common.dev->name,ch,buf[0],chan->rx_skb->len);
						chan->debug_stream=1;	
						chan->debug_char=buf[0];
					if (chan->debug_stream){
								chan->common.dev->name,ch,buf[0],chan->tx_idle_flag,
								chan->rx_skb->len);
						chan->debug_stream=0;	
			if (chan->rx_skb->len >= chan->max_tx_up_size){
				if (chan->common.usedby == SWITCH){
					//if (skb->len != 0){
					//	      card->devname,chan->rx_skb->len, skb->len);
					bstrm_switch_send(card,chan,chan->rx_skb);
					/* Re-initialize the buffer, to be reused */
					chan->rx_skb->data=(chan->rx_skb->head+16);
					chan->rx_skb->len=1;
					skb_trim(chan->rx_skb,0);
					skb_queue_tail(&chan->rx_used_queue,chan->rx_skb);
					chan->rx_skb=NULL;
					chan->rx_skb=skb_dequeue(&chan->rx_free_queue);
				chan->rx_timeout=jiffies;
				if (chan->rx_skb && chan->rx_skb->len){
							chan->common.dev->name,chan->rx_skb->len);
			if (skb->len < 1){
			if (++ch >= card->u.b.time_slots){
	if (chan->sw_dev && (chan->sw_dev->flags&IFF_UP)){
		if (is_queue_stopped(chan->sw_dev)){
					card->devname,chan->if_name,chan->sw_dev->name); 
		if (!test_bit(WAIT_DEVICE_BUFFERS,&chan->tq_control)){
			if (skb_queue_len(&chan->tx_queue) <  TX_QUEUE_LOW){
						chan->common.dev->name,
						skb_queue_len(&chan->tx_queue));
			}else if (skb_queue_len(&chan->tx_queue) > TX_QUEUE_HIGH){
						chan->common.dev->name,
						skb_queue_len(&chan->tx_queue));
					card->devname);
			card->wandev.stats.rx_errors++;
			chan->ifstats.rx_errors++;
			if (!chan->sw_dev->hard_start_xmit ||
			    chan->sw_dev->hard_start_xmit(new_skb,chan->sw_dev) != 0){
						chan->if_name,chan->sw_dev->name);
			card->wandev.stats.rx_packets++;
			card->wandev.stats.rx_bytes+=skb->len;
			chan->ifstats.rx_packets++;
			chan->ifstats.rx_bytes+=skb->len;
		chan->ifstats.rx_fifo_errors++;
		dev=chan->common.dev;
		if (dev && chan->common.usedby == SWITCH){
			if (chan->common.sk == NULL){
				if (card->u.b.serial){
					skb=chan->rx_skb;
					 * not to re-initialize this buffer */
	if (card->u.b.serial && non_te1_skb==NULL){
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (!card->u.b.serial){
			skb = skb_dequeue(&chan->rx_used_queue);
			if (skb_queue_len(&chan->rx_used_queue)){
		if (chan->common.usedby == SWITCH){
		}else if (chan->common.usedby == API){
			if (chan->common.sk == NULL){
				chan->ifstats.rx_errors++;
		if (chan->hdlc_eng){
				for (i=0;i<skb->len;i++){
					if (skb->data[i] != 0x7E){
						DEBUG_EVENT("%s: Data = 0x%X\n",card->devname,skb->data);
					//printk("%02X ",skb->data[i]);
				    (skb->data),
				    (skb->len));
						card->devname);
				++card->wandev.stats.rx_errors;
				chan->ifstats.rx_errors++;
			if (chan->debug_char == 0x25){
			for(i=0;i<new_skb->len;i++){	
				if (new_skb->data[i] == chan->debug_char){
					if (!chan->debug_stream_1){
								chan->common.dev->name,new_skb->data[i],i);
						chan->debug_stream_1=1;
								DEBUG_EVENT("0x%X\n",new_skb->data[x]);
					if (chan->debug_stream_1){
								chan->common.dev->name,new_skb->data[i],
								chan->tx_idle_flag,i);
						chan->debug_stream_1=0;	
				if (chan->common.usedby == STACK){	
						++card->wandev.stats.rx_dropped;
						++chan->ifstats.rx_dropped;
					new_skb->protocol = htons(PVC_PROT);
					new_skb->dev      = dev;
					new_skb->pkt_type = WAN_PACKET_DATA;
									card->devname,\
									chan->common.used,
									chan->common.sk);
						++card->wandev.stats.rx_dropped;
						++chan->ifstats.rx_dropped;
				++card->wandev.stats.rx_packets;
				card->wandev.stats.rx_bytes+=skb->len;
				chan->ifstats.rx_packets++;
				chan->ifstats.rx_bytes+=skb->len;
		if (!card->u.b.serial){
			skb->data=(skb->head+16);
			skb->len=1;
			skb_queue_tail(&chan->rx_free_queue,skb);
	skb->data = skb->head + 16;
	/* This is a trick. The skb_trim checks if the skb->len is greater
	 * than the new len.  Thus, fake the skb->len to 1 */
	skb->len=1;
	skb_queue_tail(&card->u.b.rx_isr_free_queue,skb);
	skb=skb_dequeue(&card->u.b.rx_isr_free_queue);
				card->devname);
	if (skb->len){
				card->devname,skb->len);
	int word_len=len-(len%4);
	sdla_t *card=chan->card;
		if (chan->seven_bit_hdlc && i==7){
			++chan->rx_decode_onecnt;
			if (!test_bit(NO_FLAG,&chan->hdlc_flag)){ 
				chan->rx_decode_buf[chan->rx_decode_len] |= (1 << chan->rx_decode_bit_cnt);
				if (++chan->rx_decode_bit_cnt >= BITSINBYTE){
					++chan->rx_decode_len;
					if (chan->rx_decode_len > HDLC_ENG_BUF_LEN){
									chan->if_name);
						++chan->ifstats.rx_frame_errors;
						++card->wandev.stats.rx_frame_errors;
						chan->rx_decode_buf[chan->rx_decode_len]=0;
						chan->rx_decode_bit_cnt=0;
						chan->hdlc_flag=0;
						set_bit(CLOSING_FLAG,&chan->hdlc_flag);
			if (chan->rx_decode_onecnt == 5){
			}else if (chan->rx_decode_onecnt == 6){
				if (test_bit(CLOSING_FLAG,&chan->hdlc_flag)){
					chan->hdlc_flag=0;
					set_bit(OPEN_FLAG,&chan->hdlc_flag);
					if (chan->rx_decode_len >= 3){
						GET_FIN_CRC_CNT(chan->crc_cur);
						FLIP_CRC(chan->rx_crc[chan->crc_cur],chan->crc_fin);
						DECODE_CRC(chan->crc_fin);
						if (chan->crc_fin==chan->rx_orig_crc){
									chan->if_name,chan->rx_decode_len);
							++chan->ifstats.rx_crc_errors;
							++card->wandev.stats.rx_crc_errors;
						DEBUG_TEST("%s: Rx abt error\n",chan->if_name);
						++chan->ifstats.rx_frame_errors;
						++card->wandev.stats.rx_frame_errors;	
				}else if (test_bit(NO_FLAG,&chan->hdlc_flag)){
					chan->hdlc_flag=0;	
					set_bit(OPEN_FLAG,&chan->hdlc_flag);
				if (!test_bit(NO_FLAG,&chan->hdlc_flag)){ 	
					if (++chan->rx_decode_bit_cnt >= BITSINBYTE){
						++chan->rx_decode_len;
						if (chan->rx_decode_len > HDLC_ENG_BUF_LEN){
									chan->if_name);
							++chan->ifstats.rx_frame_errors;
							++card->wandev.stats.rx_frame_errors;	
							chan->rx_decode_buf[chan->rx_decode_len]=0;
							chan->rx_decode_bit_cnt=0;
							chan->hdlc_flag=0;
							set_bit(CLOSING_FLAG,&chan->hdlc_flag);
			chan->rx_decode_onecnt=0;
	INC_CRC_CNT(chan->crc_cur);
	chan->rx_orig_crc = (((chan->rx_orig_crc<<8)&0xFF00) | chan->rx_decode_buf[chan->rx_decode_len]);
	chan->rx_crc_tmp = (chan->rx_decode_buf[chan->rx_decode_len] ^ chan->rx_crc[chan->crc_prv]) & 0xFF;
	chan->rx_crc[chan->crc_cur] =  chan->rx_crc[chan->crc_prv] >> 8;
	chan->rx_crc[chan->crc_cur] &= 0x00FF;
	chan->rx_crc[chan->crc_cur] ^= CRC_TABLE[chan->rx_crc_tmp];
	chan->rx_crc[chan->crc_cur] &= 0xFFFF;
	INC_CRC_CNT(chan->crc_prv);
	chan->tx_crc_tmp = (byte ^ chan->tx_crc) & 0xFF;
	chan->tx_crc =  chan->tx_crc >> 8;
	chan->tx_crc &= 0x00FF;
	chan->tx_crc ^= CRC_TABLE[chan->tx_crc_tmp];
	chan->tx_crc &= 0xFFFF;
	sdla_t *card = chan->card;
	struct sk_buff *skb = dev_alloc_skb(chan->rx_decode_len+sizeof(api_rx_hdr_t));
				chan->card->devname);
		chan->card->wandev.stats.rx_dropped++;
		chan->ifstats.rx_dropped++;
	if (chan->common.usedby==STACK){
		buf = skb_put(skb,chan->rx_decode_len-2);
		       chan->rx_decode_buf, 
		       chan->rx_decode_len-2);
			chan->card->wandev.stats.rx_dropped++;
			chan->ifstats.rx_dropped++;
			chan->card->wandev.stats.rx_packets++;
			chan->card->wandev.stats.rx_bytes += chan->rx_decode_len-2;
			chan->ifstats.rx_packets++;
			chan->ifstats.rx_bytes+=chan->rx_decode_len-2;
	} else if (chan->common.usedby == ANNEXG) {
		if (!chan->annexg_dev) {
			++card->wandev.stats.rx_dropped;	
			chan->ifstats.rx_dropped++;
		if ((chan->rx_decode_len) <= 2) {
					card->devname,chan->rx_decode_len);
			++card->wandev.stats.rx_dropped;
			chan->ifstats.rx_dropped++;
		buf = skb_put(skb,chan->rx_decode_len-2);
		       chan->rx_decode_buf, 
		       chan->rx_decode_len-2);
		skb->protocol = htons(ETH_P_X25);
		skb->dev = chan->annexg_dev;
			lapb_protocol.lapb_rx(chan->annexg_dev,skb);
			card->wandev.stats.rx_packets++;
			card->wandev.stats.rx_bytes += chan->rx_decode_len-2;
			chan->ifstats.rx_packets++;
			chan->ifstats.rx_bytes+=chan->rx_decode_len-2;
			++card->wandev.stats.rx_dropped;
	}else if (chan->common.usedby==API || chan->common.usedby==SWITCH){
		buf = skb_put(skb,chan->rx_decode_len);
		       chan->rx_decode_buf, 
		       chan->rx_decode_len);
		skb->protocol = htons(PVC_PROT);
		skb->dev      = chan->common.dev; 
		skb->pkt_type = WAN_PACKET_DATA;
			chan->card->wandev.stats.rx_dropped++;
			chan->ifstats.rx_dropped++;
			chan->card->wandev.stats.rx_packets++;
			chan->card->wandev.stats.rx_bytes += chan->rx_decode_len;
			chan->ifstats.rx_packets++;
			chan->ifstats.rx_bytes+=chan->rx_decode_len;
		if (chan->rx_decode_len <= 2){
			chan->card->wandev.stats.rx_frame_errors++;
			chan->ifstats.rx_frame_errors++;
			buf=skb_put(skb,(chan->rx_decode_len-2));
			       chan->rx_decode_buf, 
			       chan->rx_decode_len-2);
			chan->card->wandev.stats.rx_packets++;
			chan->card->wandev.stats.rx_bytes += chan->rx_decode_len;
			chan->ifstats.rx_packets++;
			chan->ifstats.rx_bytes+=chan->rx_decode_len;
			skb->dev      = chan->common.dev;
			if (chan->protocol == WANCONFIG_PPP || 
			    chan->protocol == WANCONFIG_CHDLC){
				skb->protocol = htons(ETH_P_WAN_PPP);
				wp_sppp_input(chan->common.dev,skb);
				skb->protocol = htons(ETH_P_IP);
		bstrm_priv_area->hdlc_flag=0;
		set_bit(NO_FLAG,&bstrm_priv_area->hdlc_flag);
	bstrm_priv_area->rx_decode_len=0;
	bstrm_priv_area->rx_decode_buf[bstrm_priv_area->rx_decode_len]=0;
	bstrm_priv_area->rx_decode_bit_cnt=0;
	bstrm_priv_area->rx_decode_onecnt=0;
	bstrm_priv_area->rx_crc[0]=-1;
	bstrm_priv_area->rx_crc[1]=-1;
	bstrm_priv_area->rx_crc[2]=-1;
	bstrm_priv_area->crc_cur=0; 
	bstrm_priv_area->crc_prv=0;
	chan->tx_decode_len=0;
			chan->tx_flag_idle,chan->tx_flag_offset_data,chan->tx_flag_offset);
	chan->tx_decode_buf[chan->tx_decode_len] = chan->tx_flag_idle;
	chan->tx_decode_len++;
	chan->tx_decode_buf[chan->tx_decode_len] = chan->tx_flag_idle;
	chan->tx_decode_len++;
	chan->tx_decode_buf[chan->tx_decode_len]=0;
	chan->tx_crc=-1;
	chan->tx_crc_fin=0;
	chan->tx_decode_bit_cnt=chan->tx_flag_offset;
	chan->tx_decode_buf[chan->tx_decode_len]=chan->tx_flag_offset_data;
	chan->tx_decode_onecnt=0;
	chan->tx_decode_len=0;
	chan->tx_crc=-1;
	chan->tx_crc_fin=0;
	chan->tx_decode_onecnt=0;
	memset(&chan->tx_decode_buf[0],0,3);
	chan->tx_decode_bit_cnt=0;
	chan->tx_flag_idle=0x7E;
	chan->tx_flag_offset_data=0;
	chan->tx_flag_offset=0;
	encode_byte(chan,&chan->tx_flag_idle,2);
	encode_byte(chan,&chan->tx_flag_idle,2);
	encode_byte(chan,&chan->tx_flag_idle,2);
	encode_byte(chan,&chan->tx_flag_offset_data,2);
	if (!chan->seven_bit_hdlc || chan->tx_flag_offset < 5){
		chan->tx_decode_len--;
			chan->tx_flag_idle,
			chan->tx_flag_offset_data,
			chan->tx_flag_offset,
			chan->tx_decode_bit_cnt);
	if (chan->seven_bit_hdlc){
		chan->tx_decode_bit_cnt=
			((chan->tx_flag_offset+2)%chan->bits_in_byte);
		chan->tx_decode_bit_cnt=chan->tx_flag_offset;
			chan->tx_decode_bit_cnt);
	chan->tx_decode_onecnt=0;
	for (i=0;i<skb->len;i++){
		calc_tx_crc(chan,skb->data[i]);
		encode_byte(chan,&skb->data[i],0);	
	FLIP_CRC(chan->tx_crc,chan->tx_crc_fin);
	DECODE_CRC(chan->tx_crc_fin);
	crc_tmp=(chan->tx_crc_fin>>8)&0xFF;	
	crc_tmp=(chan->tx_crc_fin)&0xFF;
	encode_byte(chan,&chan->tx_flag,1);
	chan->tx_flag_idle=0xFF;
	chan->tx_flag_offset_data=0;	
	encode_byte(chan,&chan->tx_flag_idle,2);
	/* We will re-use the incoming skb buffer to
	if (skb_tailroom(skb) < chan->tx_decode_len){
		skb2 = dev_alloc_skb(chan->tx_decode_len+15);
			return -ENOMEM;
	data_ptr=skb_put(skb,chan->tx_decode_len);
	memcpy(data_ptr,chan->tx_decode_buf,chan->tx_decode_len);
		for (i=0;i<chan->tx_decode_len;i++){
			printk("%02X ",	chan->tx_decode_buf[i]);		
	chan->tx_decode_len=0;
	skb->cb[0]=chan->tx_flag_idle;
			chan->tx_decode_buf[chan->tx_decode_len] |= (1<< chan->tx_decode_bit_cnt);		
			if (++chan->tx_decode_bit_cnt >= chan->bits_in_byte){
				++chan->tx_decode_len;
				chan->tx_decode_buf[chan->tx_decode_len]=0;
				chan->tx_decode_bit_cnt=0;
			if (++chan->tx_decode_onecnt == 5){
					if (++chan->tx_decode_bit_cnt >= chan->bits_in_byte){
						++chan->tx_decode_len;
						chan->tx_decode_buf[chan->tx_decode_len]=0;
						chan->tx_decode_bit_cnt=0;
				chan->tx_decode_onecnt=0;
			chan->tx_decode_onecnt=0;
			if (++chan->tx_decode_bit_cnt >= chan->bits_in_byte){
				++chan->tx_decode_len;
				chan->tx_decode_buf[chan->tx_decode_len]=0;
				chan->tx_decode_bit_cnt=0;
		chan->tx_flag_idle = FLAG[chan->tx_decode_bit_cnt];
		chan->tx_flag_offset=chan->tx_decode_bit_cnt;
		chan->tx_flag_offset_data=chan->tx_decode_buf[chan->tx_decode_len];
	if (!card->hw){
	card->statistics.isr_entry++;
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical)) {
	card->hw_iface.peek(card->hw, card->intr_type_off, &intr_type, 1);
		card->statistics.isr_rx++;
		card->statistics.isr_tx++;
		if(card->u.b.serial) {
			card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_BLOCK);
		if (!card->u.b.sw_card){
		 	tasklet_hi_schedule(&card->u.b.wanpipe_tx_task);
		++ card->timer_int_enabled;
			card->hw_iface.peek(card->hw, card->fe_status_off,
			card->hw_iface.poke(card->hw, card->fe_status_off,
		card->statistics.isr_spurious++;
				card->devname, intr_type);
		card->hw_iface.peek(card->hw, card->flags_off + offsetof(SHARED_MEMORY_INFO_STRUCT, global_info_struct),
	clear_bit(0,&card->in_isr);
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.peek(card->hw, card->u.b.rxmb_off, &rxbuf, sizeof(rxbuf));
		card->hw_iface.peek(card->hw, card->flags_off + offsetof(SHARED_MEMORY_INFO_STRUCT, global_info_struct),
			card->devname, (unsigned)card->u.b.rxmb_off, rxbuf.opp_flag);
		DEBUG_EVENT( "%s: Critical router failure ...!!!\n", card->devname);
	if (len != card->u.b.cfg.rx_complete_length){
				card->devname,len,card->u.b.cfg.rx_complete_length);
		++card->wandev.stats.rx_dropped;
					card->devname,
					wan_skb_queue_len(&card->u.b.rx_isr_queue),
					wan_skb_queue_len(&card->u.b.rx_isr_free_queue));
	card->hw_iface.peek(card->hw, addr, buf, len);
//	DEBUG_EVENT( "PKT (rxbug=%lX, addr=%X, len=%d): ", (unsigned long)card->u.b.rxmb, addr,len);
	if (card->u.b.cfg.rbs_map){
		int channel_range = GET_TE_CHANNEL_RANGE(&card->fe);
		card->hw_iface.peek(card->hw, card->fe.te_param.ptr_te_Rx_sig_off,
				&card->u.b.rbs_sig[0], channel_range);
		//card->hw_iface.peek(card->hw, card->u_fe.te_iface.ptr_te_Rx_sig_off,
		//		&card->u.b.rbs_sig[0], channel_range);
	skb_queue_tail(&card->u.b.rx_isr_queue,skb);
	if (!card->u.b.sw_card){
		tasklet_hi_schedule(&card->u.b.wanpipe_rx_task);
	card->hw_iface.poke(card->hw, card->u.b.rxmb_off, &rxbuf, sizeof(rxbuf));
	card->u.b.rxmb_off += sizeof(rxbuf);
	if (card->u.b.rxmb_off > card->u.b.rxbuf_last_off){
		card->u.b.rxmb_off = card->u.b.rxbuf_base_off;
 *    2) Reading board-level statistics for updating the proc file system.
	if (card->u.b.timer_int_enabled & TMR_INT_ENABLED_TE) {
		card->wandev.fe_iface.polling(&card->fe);
		card->u.b.timer_int_enabled &= ~TMR_INT_ENABLED_TE;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		card->u.b.timer_int_enabled = 0;
        bstrm_priv_area = dev->priv;
       	if(card->u.b.timer_int_enabled & TMR_INT_ENABLED_UDP) {
		card->u.b.timer_int_enabled &= ~TMR_INT_ENABLED_UDP;
	if(card->u.b.timer_int_enabled & TMR_INT_ENABLED_UPDATE) {
                if(!(--bstrm_priv_area->update_comms_stats)) {
			card->u.b.timer_int_enabled &= 
        if(!card->u.b.timer_int_enabled) {
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
/*------------------------------------------------------------------------------
	- set_bstrm_config() used to set configuration options on the board
------------------------------------------------------------------------------*/
	//wan_mbox_t* mb = &card->wan_mbox;
	if(card->wandev.clocking){
		cfg.baud_rate = card->wandev.bps;
	cfg.line_config_options = (card->wandev.electrical_interface == WANOPT_RS232) ?
			card->devname, card->u.b.cfg.sync_options);
	cfg.SYNC_options = card->u.b.cfg.sync_options;
	cfg.Rx_sync_char = card->u.b.cfg.rx_sync_char;
	cfg.monosync_Tx_time_fill_char = card->u.b.cfg.monosync_tx_time_fill_char;
	cfg.max_length_Tx_data_block =  card->u.b.cfg.max_length_tx_data_block;
	cfg.Rx_complete_length = card->u.b.cfg.rx_complete_length;
	cfg.Rx_complete_timer = card->u.b.cfg.rx_complete_timer;
	wan_mbox_t* mbox = &card->wan_mbox;
	mbox->wan_data_len = 0;
	mbox->wan_command = READ_GLOBAL_EXCEPTION_CONDITION;
	rc = card->hw_iface.cmd(card->hw, card->mbox_off, mbox);
		switch(mbox->wan_return_code) {
				card->wandev.fe_iface.isr(&card->fe);
				card->hw_iface.peek(card->hw, 
					    	    card->fe_status_off,
				card->fe.fe_param.k56_param.RR8_reg_56k = 
				card->fe.fe_param.k56_param.RRA_reg_56k = 
				card->fe.fe_param.k56_param.RRC_reg_56k = 
				card->wandev.fe_iface.read_alarm(&card->fe, 0); 
				card->devname);
			switch(mbox->wan_data[0] & (DCD_HIGH | CTS_HIGH)) {
					DEBUG_EVENT( "%s: DCD high, CTS low\n",card->devname);
                                        DEBUG_EVENT( "%s: DCD low, CTS high\n",card->devname); 
                                        DEBUG_EVENT( "%s: DCD high, CTS high\n",card->devname);
                                        DEBUG_EVENT( "%s: DCD low, CTS low\n",card->devname);
				card->devname, mbox->wan_return_code);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_BSTRM_EXCEPTION_CONDITION;
	rc = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
						card->devname);
				(RX_DISC_TX_IDLE_EXCEP_STRUCT *)mb->wan_data;			
			if (idle_strct->Rx_discard_count){
						card->devname,idle_strct->Rx_discard_count);
			if (idle_strct->Tx_idle_count){
						card->devname,idle_strct->Tx_idle_count);
			DEBUG_EVENT("%s: Bitstrm Exception: Sync Lost!\n",card->devname);
			DEBUG_EVENT("%s: Bitstrm Exception: Sync Achieved!\n",card->devname);
						card->devname,rc);
	wan_mbox_t *mb = &card->wan_mbox;
	wan_udp_pkt = (wan_udp_pkt_t *) bstrm_priv_area->udp_pkt_data;
		if(bstrm_priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK){
			switch(wan_udp_pkt->wan_udp_command){
		wan_udp_pkt->wan_udp_data_len = 0;
		wan_udp_pkt->wan_udp_return_code = 0xCD;
			card->devname,wan_udp_pkt->wan_udp_command);
		switch(wan_udp_pkt->wan_udp_command) {
			bstrm_priv_area->router_up_time = tv.tv_sec - 
					bstrm_priv_area->router_start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
					bstrm_priv_area->router_up_time;	
			mb->wan_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_return_code = 0;
				card->wandev.fe_iface.process_udp(
						&card->fe,
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				card->wandev.fe_iface.process_udp(
						&card->fe,
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				if (wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE){
		    			wan_udp_pkt->wan_udp_data_len = sizeof(wan_femedia_t); 
					wan_udp_pkt->wan_udp_return_code = CMD_OK;
					wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
 		   	wan_udp_pkt->wan_udp_chdlc_num_frames = card->wandev.config_id;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_LINUX_PLATFORM;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
			DEBUG_DBG("%s: process_udp_mgmt_pkt(): ENABLE_BSTRM_COMMUNICATIONS\n",card->devname);
				card->wandev.fe_iface.read_alarm(&card->fe, 1);
			wan_udp_pkt->wan_udp_return_code = api_enable_comms(card);
			DEBUG_DBG("%s: process_udp_mgmt_pkt():DISABLE_BSTRM_COMMUNICATIONS\n",card->devname);
			wan_udp_pkt->wan_udp_return_code = api_disable_comms(card);
			mb->wan_command = wan_udp_pkt->wan_udp_command;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
			if (mb->wan_data_len) {
				memcpy(&mb->wan_data, 
				       (unsigned char *)wan_udp_pkt->wan_udp_data, 
				       mb->wan_data_len);
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
				memcpy(&wan_udp_pkt->wan_udp_cmd, mb, sizeof(wan_cmd_t)); 
				if (mb->wan_data_len) {
					memcpy(&wan_udp_pkt->wan_udp_data, 
					       &mb->wan_data, 
					       mb->wan_data_len); 
	wan_udp_pkt->wan_ip_ttl= card->wandev.ttl; 
		wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
     	len = wan_reply_udp(card,bstrm_priv_area->udp_pkt_data, mb->wan_data_len);
     	if(bstrm_priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK){
	   	//if (!test_bit(SEND_CRIT,&card->wandev.critical)) {
		//	if(!bstrm_send(card, bstrm_priv_area->udp_pkt_data, len)) {
		//		++ card->wandev.stats.tx_packets;
		//		card->wandev.stats.tx_bytes += len;
  	    		memcpy(buf, bstrm_priv_area->udp_pkt_data, len);
	    		new_skb->protocol = htons(ETH_P_IP);
            		new_skb->dev = dev;
					card->devname);
	atomic_set(&bstrm_priv_area->udp_pkt_len,0);
		if (card->fe.fe_status == FE_CONNECTED) {
			if (card->u.b.state != WAN_CONNECTED) {
				if(card->comm_enabled == 0) {
		card->fe.fe_status = FE_CONNECTED;
		card->u.b.state = WAN_DISCONNECTED;
	if(card->comm_enabled != 0) {
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (!dev) return -EINVAL;
	bstrm_priv_area = dev->priv;
	memset(card->u.b.time_slot_map,0,sizeof(card->u.b.time_slot_map));
	bstrm_priv_area->time_slot_map = 0xFFFFFFFF;
	card->u.b.time_slots=NUM_OF_T1_CHANNELS;
		bstrm_priv_area->time_slot_map &= 0x7FFFFFFF;
		card->u.b.time_slots=NUM_OF_E1_CHANNELS;
	bstrm_priv_area->max_tx_up_size=MAX_T1_CHAN_TX_UP_SIZE;
		bstrm_priv_area->max_tx_up_size =
		       MAX_T1_CHAN_TX_UP_SIZE - (MAX_T1_CHAN_TX_UP_SIZE % (NUM_OF_E1_CHANNELS-1));//1178
	bstrm_priv_area->time_slots = 0;
	for (i=0;i<card->u.b.time_slots;i++){
		if (test_bit(i,&bstrm_priv_area->time_slot_map)){	
			bstrm_priv_area->time_slots++;
	if (bstrm_priv_area->max_tx_up_size % bstrm_priv_area->time_slots){
		bstrm_priv_area->max_tx_up_size-=
				bstrm_priv_area->max_tx_up_size % 
				bstrm_priv_area->time_slots;
		bstrm_priv_area->max_tx_up_size+=bstrm_priv_area->time_slots;
			card->devname,
			bstrm_priv_area->if_name);
			card->devname,
			bstrm_priv_area->tx_idle_flag);
			card->devname,
			bstrm_priv_area->max_tx_up_size);
			card->devname,
			bstrm_priv_area->hdlc_eng?"ON":"OFF",
			bstrm_priv_area->seven_bit_hdlc?7:8);
	bstrm_priv_area->hdlc_flag=0;
	set_bit(NO_FLAG,&bstrm_priv_area->hdlc_flag);
	bstrm_priv_area->rx_crc[0]=-1;
	bstrm_priv_area->rx_crc[1]=-1;
	bstrm_priv_area->rx_crc[2]=-1;
	bstrm_priv_area->tx_crc=-1;
	bstrm_priv_area->tx_flag= 0x7E; //card->u.b.cfg.monosync_tx_time_fill_char;
	bstrm_priv_area->tx_flag_idle= 0x7E; //card->u.b.cfg.monosync_tx_time_fill_char;
		DEBUG_DBG("%s: entering bind loop (card->u.b.time_slots : %d).\n",
				card->devname, card->u.b.time_slots);
		for (i=0;i<card->u.b.time_slots;i++){
			if (test_bit(i,&bstrm_priv_area->time_slot_map)){	
						bstrm_priv_area->if_name, i+1);
					card->u.b.time_slot_map[i+1] = bstrm_priv_area;
						bstrm_priv_area->if_name, i);
					card->u.b.time_slot_map[i] = bstrm_priv_area;
				bstrm_priv_area->time_slots++;
	card->u.b.tx_chan_multiple = 30;
	DEBUG_DBG("%s: Configuring: \n",card->devname);
				card->devname, card->u.b.time_slots);
				card->devname, card->u.b.tx_chan_multiple);
			card->devname, card->u.b.cfg.max_length_tx_data_block);
			card->devname, card->u.b.cfg.rx_complete_length);
				card->devname,
				card->u.b.cfg.monosync_tx_time_fill_char);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_BSTRM_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	tx_config_off = ((BSTRM_CONFIGURATION_STRUCT *)mb->wan_data)->
	card->hw_iface.peek(card->hw, tx_config_off, &tx_config, sizeof(tx_config));
       	rx_config_off = ((BSTRM_CONFIGURATION_STRUCT *)mb->wan_data)->
	card->hw_iface.peek(card->hw, rx_config_off, &rx_config, sizeof(rx_config));
       	card->u.b.txbuf_base_off = tx_config.base_addr_Tx_status_elements;
       	card->u.b.txbuf_last_off = 
	card->u.b.txbuf_base_off +
		(tx_config.number_Tx_status_elements - 1) * sizeof(BSTRM_DATA_TX_STATUS_EL_STRUCT);
       	card->u.b.rxbuf_base_off = rx_config.base_addr_Rx_status_elements;
       	card->u.b.rxbuf_last_off = 
              		card->u.b.rxbuf_base_off +
		(rx_config.number_Rx_status_elements - 1) * sizeof(BSTRM_DATA_RX_STATUS_EL_STRUCT);
       	card->u.b.txbuf_off = tx_config.next_Tx_status_element_to_use;
       	card->u.b.rxmb_off = rx_config.next_Rx_status_element_to_use;
        card->u.b.rx_base_off = rx_config.base_addr_Rx_status_elements;
	wan_mbox_t* mb = &card->wan_mbox;
	card->timer_int_enabled = 0;
			mb->wan_data_len  = 0;
			mb->wan_command = READ_BSTRM_CODE_VERSION;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        if (card->u.b.state != state)
                                card->devname);
                                card->devname);
                                card->devname);
                card->wandev.state = card->u.b.state = state;
		WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
			    bstrm_priv_area->common.usedby == SWITCH &&
				if (!bstrm_priv_area->sw_dev){
							bstrm_priv_area->common.dev->name);
				sw_chan=(bitstrm_private_area_t *)bstrm_priv_area->sw_dev->priv;
				sw_card=sw_chan->card;
				if (!sw_card->comm_enabled){
							bstrm_priv_area->common.dev->name,
							bstrm_priv_area->sw_dev->name);
							bstrm_priv_area->common.dev->name,
							bstrm_priv_area->sw_dev->name);
					set_bit(WAIT_DEVICE_SLOW,&bstrm_priv_area->tq_control);
					set_bit(WAIT_DEVICE_FAST,&sw_chan->tq_control);
					sw_chan->common.state = WAN_CONNECTED;		
			bstrm_priv_area->common.state = state;
			if (bstrm_priv_area->common.usedby == STACK){
			} else if (bstrm_priv_area->common.usedby == ANNEXG && 
			    	   bstrm_priv_area->annexg_dev){
						lapb_protocol.lapb_link_up(bstrm_priv_area->annexg_dev);
						lapb_protocol.lapb_link_down(bstrm_priv_area->annexg_dev);
			}else if (bstrm_priv_area->common.usedby == API){
			}else if (bstrm_priv_area->common.usedby == WANPIPE){
			if (bstrm_priv_area->hdlc_eng && state == WAN_DISCONNECTED){
				bstrm_priv_area->tx_idle_flag=0x7E;
			if (bstrm_priv_area->protocol == WANCONFIG_PPP && state == WAN_DISCONNECTED){
				bstrm_skb_queue_purge(&bstrm_priv_area->tx_queue);	
				while((skb = skb_dequeue(&bstrm_priv_area->rx_used_queue))!=NULL){
					skb->data=(skb->head+16);
					skb->len=1;
					skb_queue_tail(&bstrm_priv_area->rx_free_queue,skb);
				if (bstrm_priv_area->common.usedby==SWITCH){
					set_bit(WAIT_DEVICE_BUFFERS,&bstrm_priv_area->tq_control);
	if (card->comm_enabled){
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
			card->devname,err);
		return -EINVAL;
					card->devname);
			return -EINVAL;
		if (IS_T1_CARD(card) && card->u.b.cfg.rbs_map){
			err=bstrm_set_te_signaling_config(card,card->u.b.cfg.rbs_map);
				return -EINVAL;
				return -EINVAL;
			card->devname, 
		err = -EINVAL;
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
						card->devname,
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
			card->devname);
		err = -EINVAL;
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
				card->devname);
			return -EINVAL;
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
	if (card->u.b.serial){
					card->devname);
			return -EINVAL;	
					card->devname);
			return -EINVAL;	
	if(IS_TE1_CARD(card) && card->wandev.ignore_front_end_status == WANOPT_NO) {
	}else if (IS_56K_CARD(card) && card->wandev.ignore_front_end_status == WANOPT_NO) {
					card->devname);
			card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
			card->comm_enabled=0;
			return -EINVAL;
						card->devname);
		card->wandev.fe_iface.read_alarm(&card->fe, 1); 
	if (!card->u.b.serial){
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, 
	DEBUG_EVENT("%s: Config complete\n",card->devname);
	if (wandev == NULL || wandev->priv == NULL)
	card = (sdla_t*)wandev->priv;
	if (!card->comm_enabled){
	return m->count;
	wan_mbox_t* mb = &card->wan_mbox;
	ADAPTER_CONFIGURATION_STRUCT* cfg = (ADAPTER_CONFIGURATION_STRUCT*)mb->wan_data;
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &cfg->adapter_type); 
	if (IS_TE1_CARD(card) && card->u.b.serial){
				card->devname);
		cfg->adapter_type|=OPERATE_T1E1_AS_SERIAL;
	cfg->adapter_config = 0x00; 
	cfg->operating_frequency = 00; 
	mb->wan_data_len = sizeof(ADAPTER_CONFIGURATION_STRUCT);
	mb->wan_command = SET_ADAPTER_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	if (card->wandev.ignore_front_end_status == WANOPT_YES) {
	if (card->fe.fe_status == FE_CONNECTED) {
		if (card->u.b.state != WAN_CONNECTED) {
			if(card->comm_enabled == 0) {
							card->devname);
							card->devname);
		if(card->comm_enabled != 0) {
					card->devname);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_command = DISABLE_BSTRM_COMMUNICATIONS;
	mb->wan_data_len = 0;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card->comm_enabled = 0;
	wan_mbox_t* mb = &card->wan_mbox;
	if (IS_FR_FEUNFRAMED(&card->fe)){
		FE_str.lgth_Rx_disc_bfr = card->u.b.time_slots * WAN_BSTRM_CHUNK;
		FE_str.lgth_Tx_idle_bfr = card->u.b.time_slots * WAN_BSTRM_CHUNK;
		FE_str.lgth_Rx_disc_bfr = card->u.b.time_slots * WAN_BSTRM_CHUNK;
		FE_str.lgth_Tx_idle_bfr = (card->u.b.time_slots-1) * WAN_BSTRM_CHUNK;
	FE_str.Tx_idle_data_bfr[0]=card->u.b.cfg.monosync_tx_time_fill_char;
		FE_str.Tx_idle_data_bfr[i] = card->u.b.cfg.monosync_tx_time_fill_char; 
	mb->wan_data_len = sizeof(FE_RX_DISC_TX_IDLE_STRUCT);
	memcpy(mb->wan_data, &FE_str.lgth_Rx_disc_bfr, mb->wan_data_len);
	mb->wan_command = SET_FE_RX_DISC_TX_IDLE_CFG;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	if (chan->sw_dev){
				card->devname, chan->if_name,sw_dev_name);
				card->devname, sw_dev_name);
	if (!sw_dev->priv){
				card->devname, sw_dev->name);
		return -EINVAL;
	if (((wanpipe_common_t*)sw_dev->priv)->usedby != SWITCH){
				card->devname, sw_dev->name);
		return -EINVAL;
	if (((wanpipe_common_t*)sw_dev->priv)->config_id != card->wandev.config_id){
				card->devname, sw_dev->name,((wanpipe_common_t*)sw_dev->priv)->config_id);
		return -EINVAL;
	sw_chan = (bitstrm_private_area_t *)sw_dev->priv;
	sw_card = sw_chan->card;
	if ((strcmp(sw_chan->sw_if_name,chan->if_name)) != 0){
				card->devname, sw_chan->if_name);
		return -EINVAL;
			card->devname, chan->if_name, chan->time_slot_map,
			sw_chan->if_name, sw_chan->time_slot_map);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	if (!card->u.b.sw_card){
		sw_card->u.b.sw_card = card;
		card->u.b.sw_card=sw_card;
	sw_chan->sw_dev = chan->common.dev;
	chan->sw_dev = sw_dev;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	dev_hold(chan->common.dev);
	if (chan->sw_dev){
		bitstrm_private_area_t *sw_chan=chan->sw_dev->priv;
			if (sw_chan->sw_dev){
				card->devname, sw_chan->if_name, sw_chan->sw_dev->name);
				dev_put(sw_chan->sw_dev);	
				sw_chan->sw_dev=NULL;
				card->devname, chan->if_name, chan->sw_dev->name);
		dev_put(chan->sw_dev);
		chan->sw_dev=NULL;
	if (card->open_cnt == 1){
		if (card->u.b.sw_card){
			sdla_t *sw_card=card->u.b.sw_card;
			sw_card->u.b.sw_card=NULL;
			card->u.b.sw_card=NULL;
	if (chan->protocol != WANCONFIG_PPP && 
	    chan->protocol != WANCONFIG_CHDLC){
				card->devname,chan->if_name,chan->protocol);
		return -EPROTONOSUPPORT;
		chan->protocol=0;
		return -ENOMEM;
	chan->common.prot_ptr=(void*)pppdev;
	pppdev->dev=dev;
	if(conf->pap == WANOPT_YES){
		pppdev->sppp.myauth.proto = PPP_PAP;
	}else if(conf->chap == WANOPT_YES){
		pppdev->sppp.myauth.proto = PPP_CHAP;
		pppdev->sppp.myauth.proto = 0;
	if(pppdev->sppp.myauth.proto){
		memcpy(pppdev->sppp.myauth.name, conf->userid, AUTHNAMELEN);
		memcpy(pppdev->sppp.myauth.secret, conf->passwd, AUTHNAMELEN);
	pppdev->sppp.gateway = conf->gateway;
	if (conf->if_down){
		pppdev->sppp.dynamic_ip = 1;
	sprintf(pppdev->sppp.hwdevname,"%s",card->devname);
	sp = &pppdev->sppp;
	dev->type	= ARPHRD_PPP;
	if (chan->protocol == WANCONFIG_CHDLC){
				card->devname);
		sp->pp_flags |= PP_CISCO;
				card->devname);
		sp->pp_flags &= ~PP_CISCO;
	bitstrm_private_area_t *chan=dev->priv;
	if (chan->protocol == WANCONFIG_PPP ||
	    chan->protocol == WANCONFIG_CHDLC){
	bitstrm_private_area_t *chan=dev->priv;
	if (chan->protocol == WANCONFIG_PPP ||
	    chan->protocol == WANCONFIG_CHDLC){
	bitstrm_private_area_t *chan=dev->priv;
	if (chan->protocol == WANCONFIG_PPP || 
	    chan->protocol == WANCONFIG_CHDLC){
		dev->do_ioctl = NULL;
		if (chan->common.prot_ptr){
			kfree(chan->common.prot_ptr);
			chan->common.prot_ptr= NULL;
	bitstrm_private_area_t *chan=dev->priv;
	if (chan->ignore_modem)
	DEBUG_EVENT( "%s: (Debug) Wanpipe sending PPP TERM\n",dev->name);
		new_skb->protocol = htons(ETH_P_WAN_PPP);
		new_skb->dev = dev;
	sdla_t*card=chan->card;
	if (chan->common.sk == NULL){
				card->devname);
	buf->wan_hdr_bitstrm_direction = 1;
	new_skb->protocol = htons(PVC_PROT);
	new_skb->dev      = chan->common.dev;
	new_skb->pkt_type = WAN_PACKET_DATA;
	wan_mbox_t*	mb = &card->wan_mbox;
	char*		data = mb->wan_data;
			card->devname);
	memset((char *)&((te_signaling_cfg_t*)data)->sig_perm.time_slot[0], 
			((te_signaling_cfg_t*)data)->sig_perm.time_slot[i] 
	((te_signaling_cfg_t *)data)->sig_processing_counter = 1;
	mb->wan_data_len = sizeof(te_signaling_cfg_t);
	mb->wan_command = SET_TE1_SIGNALING_CFG;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
				card->devname,ts_sig_map,err);
	int		channel_range = GET_TE_CHANNEL_RANGE(&card->fe);
	DEBUG_EVENT("%s: Disableing Robbit Signalling\n", card->devname);
	if (card->fe.te_param.ptr_te_sig_perm_off){
		card->hw_iface.poke(card->hw, card->fe.te_param.ptr_te_sig_perm_off,
	//if (card->u_fe.te_iface.ptr_te_sig_perm_off){
	//	card->hw_iface.poke(card->hw, card->u_fe.te_iface.ptr_te_sig_perm_off,
	wan_mbox_t* mb = &card->wan_mbox;
	char* data = mb->wan_data;
	DEBUG_CFG("%s: Read TE Signalling config...\n", card->devname);
	((te_signaling_cfg_t *)data)->sig_processing_counter = 1;
	mb->wan_data_len = 0;
	mb->wan_command = READ_TE1_SIGNALING_CFG;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
				card->devname,err);
		//card->u_fe.te_iface.ptr_te_sig_perm_off = 
		card->fe.te_param.ptr_te_sig_perm_off = 
               		((te_signaling_cfg_t *)data)->ptr_te_sig_perm_struct;
		//card->u_fe.te_iface.ptr_te_Rx_sig_off =
		card->fe.te_param.ptr_te_Rx_sig_off =
        	       	((te_signaling_cfg_t *)data)->ptr_te_Rx_sig_struct;
		//card->u_fe.te_iface.ptr_te_Tx_sig_off =
		card->fe.te_param.ptr_te_Tx_sig_off =
     	          	((te_signaling_cfg_t *)data)->ptr_te_Tx_sig_struct;
	if (chan->common.usedby != API){
		return -ENODEV;
	if (!chan->common.sk){
		return -ENODEV;
		return -ENOMEM;
	api_rx_el->wan_hdr_bitstrm_channel=chan->rbs_chan;
		return -ENOMEM;
	buf[0]=chan->rbs_sig;
	skb->pkt_type = WAN_PACKET_ERR;
	skb->protocol=htons(PVC_PROT);
	skb->dev=chan->common.dev;
			chan->if_name,skb->len);
		err=-ENODEV;
	bitstrm_private_area_t* chan = dev->priv;
	sdla_t *card = chan->card;
		return -EINVAL;
	if (chan->common.usedby != ANNEXG)
		return -EPROTONOSUPPORT;
	if (chan->annexg_dev)
		return -EBUSY;
	spin_lock_irqsave(&card->wandev.lock,smp_flags);
	chan->annexg_dev = annexg_dev;
	spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
	sdla_t *card = wandev->priv;
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (!chan->annexg_dev || chan->common.usedby != ANNEXG)
		if (chan->annexg_dev == annexg_dev){
			spin_lock_irqsave(&card->wandev.lock,smp_flags);
			chan->annexg_dev = NULL;
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
	bitstrm_private_area_t* 	chan = dev->priv;
	if (chan->common.usedby == ANNEXG && chan->annexg_dev){
			lapb_protocol.lapb_get_active_inactive(chan->annexg_dev,wp_stats);
	if (chan->common.state == WAN_CONNECTED){
		wp_stats->fr_active++;
		wp_stats->fr_inactive++;
	bitstrm_private_area_t*	chan = dev->priv;
	if (!(dev->flags&IFF_UP)){
		return m->count;
	if (chan->common.usedby == ANNEXG && chan->annexg_dev){
			return lapb_protocol.lapb_get_map(chan->annexg_dev,
		chan->label, 
		wandev->name,(wandev->state == WAN_CONNECTED) ? '*' : ' ',
		dev->name,(chan->common.state == WAN_CONNECTED) ? '*' : ' ');
	return m->count;
./sdla_bitstrm.c
# include <zapcompat.h> /* Map of Zaptel -> DAHDI definitions */
# include <zapcompat.h> /* Map of Zaptel -> DAHDI definitions */
   zt_receive(&wpd->span);
   zt_transmit(&wpd->span);
   sprintf(wpd->span.name, "SDLA_DUMMY");
   snprintf(wpd->span.desc, sizeof(wpd->span.desc) - 1, "%s (source: AFT-HW) %d", wpd->span.name, 1);
   wpd->chan_ptr   = &wpd->chan;
   wpd->span.chans = &wpd->chan_ptr;
   wpd->span.chans = &wpd->chan;
   wpd->span.channels = 0;	/* no channels */
   wpd->span.deflaw = ZT_LAW_MULAW;
   wpd->span.pvt = wpd;
   wpd->chan.pvt = wpd;
   if (zt_register(&wpd->span, 0)) {
   zt_unregister(&wpd->span);
./sdla_tdmv_dummy.c
/*--------------------------------------------------------
 *-------------------------------------------------------*/
/*--------------------------------------------------------
 *-------------------------------------------------------*/
		return -EINVAL;
	chan->card->hw_iface.hw_lock(chan->card->hw,&flags);
	*rbs_bits = chan->card->wandev.fe_iface.read_rbsbits(
						&chan->card->fe,
						chan->logic_ch_num+1,
	chan->card->hw_iface.hw_unlock(chan->card->hw,&flags);
		return -EINVAL;
	chan->card->hw_iface.hw_lock(chan->card->hw,&flags);
	err = chan->card->wandev.fe_iface.set_rbsbits(&chan->card->fe,
					  chan->logic_ch_num+1,
	chan->card->hw_iface.hw_unlock(chan->card->hw,&flags);
	if (event->type == WAN_EVENT_EC_DTMF){
			card->devname,
			event->channel,
			event->digit,
			(event->dtmf_port == WAN_EC_CHANNEL_PORT_ROUT)?"ROUT":"SOUT",
			(event->dtmf_type == WAN_EC_TONE_PRESENT)?"PRESENT":"STOP");
	}else if (event->type == WAN_EVENT_RM_DTMF){
			card->devname,
			event->channel,
			event->digit);
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (wan_test_bit(i,&card->u.aft.logic_ch_map)){
			chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
			ts_map = chan->time_slot_map;
			if (wan_test_bit(event->channel,&ts_map)){
					card->devname, event->channel);
	rx_hdr->wp_api_rx_hdr_error_flag = 0;
	rx_hdr->wp_api_event_type	= WP_API_EVENT_DTMF;
	rx_hdr->wp_api_rx_hdr_event_channel	= event->channel;
	rx_hdr->wp_api_rx_hdr_event_dtmf_digit	= event->digit;
	rx_hdr->wp_api_rx_hdr_event_dtmf_type	= event->dtmf_type;
	rx_hdr->wp_api_rx_hdr_event_dtmf_port	= event->dtmf_port;
	new_skb->protocol = htons(PVC_PROT);
	new_skb->dev      = chan->common.dev;
	new_skb->pkt_type = WAN_PACKET_DATA;
						card->devname);
				card->devname, chan->if_name);
	if (event->type != WAN_EVENT_RM_LC){
				card->devname, event->type);
			card->devname,
			WAN_EVENT_RXHOOK_DECODE(event->rxhook), event->rxhook,
			event->channel);
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (wan_test_bit(i,&card->u.aft.logic_ch_map)){
			chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
			ts_map = chan->time_slot_map;
			if (wan_test_bit(event->channel,&ts_map)){
					card->devname, event->channel);
	rx_hdr->wp_api_rx_hdr_error_flag 			= 0;
	rx_hdr->wp_api_rx_hdr_event_type 			= WP_API_EVENT_RXHOOK;
	rx_hdr->wp_api_rx_hdr_event_channel	= event->channel;
	if (event->rxhook == WAN_EVENT_RXHOOK_OFF){
		rx_hdr->wp_api_rx_hdr_event_rxhook_state = WP_API_EVENT_RXHOOK_OFF;
	}else if (event->rxhook == WAN_EVENT_RXHOOK_ON){
		rx_hdr->wp_api_rx_hdr_event_rxhook_state = WP_API_EVENT_RXHOOK_ON;
	new_skb->protocol = htons(PVC_PROT);
	new_skb->dev      = chan->common.dev;
	new_skb->pkt_type = WAN_PACKET_DATA;
						card->devname);
				card->devname, chan->if_name);
	if (event->type != WP_API_EVENT_RING_TRIP_DETECT){
				card->devname, event->type);
			card->devname,
			WAN_EVENT_RING_DECODE(event->ring_mode), event->ring_mode,
			event->channel);
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (wan_test_bit(i,&card->u.aft.logic_ch_map)){
			chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
			ts_map = chan->time_slot_map;
			if (wan_test_bit(event->channel,&ts_map)){
					card->devname, event->channel);
	rx_hdr->wp_api_rx_hdr_error_flag 			= 0;
	rx_hdr->wp_api_rx_hdr_event_type 			= WP_API_EVENT_RING_TRIP_DETECT;
	rx_hdr->wp_api_rx_hdr_event_channel	= event->channel;
	if (event->ring_mode == WAN_EVENT_RING_PRESENT){
		rx_hdr->wp_api_rx_hdr_event_ringdetect_state = WAN_EVENT_RING_TRIP_PRESENT;
	}else if (event->ring_mode == WAN_EVENT_RING_STOP){
		rx_hdr->wp_api_rx_hdr_event_ringdetect_state = WAN_EVENT_RING_TRIP_STOP;
					card->devname, event->ring_mode);
	new_skb->protocol = htons(PVC_PROT);
	new_skb->dev      = chan->common.dev;
	new_skb->pkt_type = WAN_PACKET_DATA;
						card->devname);
				card->devname, chan->if_name);
	if (event->type != WAN_EVENT_RM_RING_DETECT){
				card->devname, event->type);
			card->devname,
			WAN_EVENT_RING_DECODE(event->ring_mode), event->ring_mode,
			event->channel);
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (wan_test_bit(i,&card->u.aft.logic_ch_map)){
			chan=(private_area_t*)card->u.aft.dev_to_ch_map[i];
			ts_map = chan->time_slot_map;
			if (wan_test_bit(event->channel,&ts_map)){
					card->devname, event->channel);
	rx_hdr->wp_api_rx_hdr_error_flag 			= 0;
	rx_hdr->wp_api_rx_hdr_event_type 			= WP_API_EVENT_RING_DETECT;
	rx_hdr->wp_api_rx_hdr_event_channel	= event->channel;
	if (event->ring_mode == WAN_EVENT_RING_PRESENT){
		rx_hdr->wp_api_rx_hdr_event_ringdetect_state = WAN_EVENT_RING_PRESENT;
	}else if (event->ring_mode == WAN_EVENT_RING_STOP){
		rx_hdr->wp_api_rx_hdr_event_ringdetect_state = WAN_EVENT_RING_STOP;
					card->devname, event->ring_mode);
	new_skb->protocol = htons(PVC_PROT);
	new_skb->dev      = chan->common.dev;
	new_skb->pkt_type = WAN_PACKET_DATA;
						card->devname);
				card->devname, chan->if_name);
	sdla_t *card=chan->card;
	int err=-EINVAL;
	if (!chan_ptr || !chan->common.dev || !card){
		return -EINVAL;
	if (wan_skb_len(skb) > chan->mtu) {
		return -EINVAL;
	if (card->u.aft.tdmv_dchan){
		top_chan=wan_netif_priv(chan->common.dev);
		if(chan->dchan_time_slot >= 0){
				return -EBUSY;
			card->hw_iface.hw_lock(card->hw,&smp_flags);
			card->hw_iface.hw_unlock(card->hw,&smp_flags);
				wan_capture_trace_packet(chan->card, &top_chan->trace_info,
				err = -EBUSY;
			/* On b-channel data is transmitted using AFT DMA. */
			DEBUG_EVENT("%s: Error: BRI TX on non-D-channel!!\n", card->devname);
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	if (wan_skb_queue_len(&chan->wp_tx_pending_list) > chan->max_tx_bufs){
		wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
		return -EBUSY;
	wan_skb_queue_tail(&chan->wp_tx_pending_list,skb);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
/*--------------------------------------------------------
 *-------------------------------------------------------*/
	int		err = -EINVAL;
	card = chan->card;
					card->devname);
		return -EFAULT;
	if (event_ctrl->type == WAN_EVENT_EC_DTMF && card->wandev.ec_dev){
					chan->if_name);
		err = wanpipe_ec_event_ctrl(card->wandev.ec_dev, card, event_ctrl);
	}else if (chan->card->wandev.fe_iface.event_ctrl){
					chan->if_name);
		err = chan->card->wandev.fe_iface.event_ctrl(
					&chan->card->fe, event_ctrl);
					chan->if_name, event_ctrl->type);
	int			err = -EINVAL;
					card->devname);
		return -EFAULT;
			card->devname,
			card->devname,
			card->devname,
			card->devname,
			card->devname,
						card->devname,
				return -EINVAL;
				card->devname,
				card->devname,
				card->devname,
				card->devname,
				card->devname,
				card->devname,
			card->devname,
			card->devname,
			card->devname,
				card->devname,
		err = -EINVAL;
	chan->wp_tdm_api_dev.event_ctrl		= aft_event_ctrl;
	chan->wp_tdm_api_dev.read_rbs_bits	= aft_read_rbs_bits;
	chan->wp_tdm_api_dev.write_rbs_bits	= aft_write_rbs_bits;
	chan->wp_tdm_api_dev.write_hdlc_frame	= aft_write_hdlc_frame;
	card->wandev.event_callback.dtmf	= wan_aft_api_dtmf;
	card->wandev.event_callback.hook	= wan_aft_api_hook;
	card->wandev.event_callback.ringtrip	= wan_aft_api_ringtrip;
	card->wandev.event_callback.ringdetect	= wan_aft_api_ringdetect;
./aft_core_api_events.c
	/* Hot-plug is not supported yet */
	if (card->wandev.config_id != WANCONFIG_USB_ANALOG) {
				  card->devname, card->wandev.config_id);
		return -EINVAL;
	memset(card->u.usb.dev_to_ch_map,0,sizeof(card->u.usb.dev_to_ch_map));
	memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
	wp_usb_remora_iface_init(&card->fe, &card->wandev.fe_iface);
	memcpy(&card->tdmv_conf,&conf->tdmv_conf,sizeof(wan_tdmv_conf_t));
	card->fe.name		= card->devname;
	card->fe.card		= card;
	card->fe.write_fe_reg	= card->hw_iface.fe_write;
	card->fe.read_fe_reg	= card->hw_iface.fe_read;
	card->fe.__read_fe_reg	= NULL;	//card->hw_iface.__fe_read;
	card->wandev.fe_enable_timer	= wp_usb_enable_timer;
	card->wandev.ec_enable_timer	= NULL;		// wp_usb_enable_ec_timer;
	card->wandev.te_link_state	= NULL;		// callback_front_end_state;
        card->wandev.new_if             = &wp_usb_new_if;
        card->wandev.del_if             = &wp_usb_del_if;
        card->disable_comm              = wp_usb_disable_comm;
	card->u.usb.num_of_time_slots	= 0x02;
	WAN_TASKQ_INIT((&card->u.usb.port_task),0,wp_usb_task,card);
	wan_clear_bit(CARD_DOWN,&card->wandev.critical);
			card->devname,card->devname,conf->pci_bus_no);
		return -EINVAL;
	DEBUG_EVENT("%s: Global Front End Configuraton!\n",card->devname);
	err = -EINVAL;
	if (card->wandev.fe_iface.config){
		err = card->wandev.fe_iface.config(&card->fe);
					card->devname);
		return -EINVAL;
	err = -EINVAL;
	if (card->wandev.fe_iface.post_init){
		err=card->wandev.fe_iface.post_init(&card->fe);
		DEBUG_EVENT("%s: Failed Post-Init Front End configuration!\n",
					card->devname);
		card->wandev.fe_iface.unconfig(&card->fe);
		return -EINVAL;
	DEBUG_EVENT("%s: Set USB softirq handler ...\n", card->devname);
	err = -EINVAL;
	if (card->hw_iface.set_intrhand){
		err = card->hw_iface.set_intrhand(card->hw, wp_usb_isr, (void*)card, 0);
		DEBUG_EVENT("%s: Failed to set softirq!\n", card->devname);
		card->wandev.fe_iface.unconfig(&card->fe);
		return -EINVAL;
	DEBUG_EVENT("%s: USB Remora config done!\n",card->devname);
	sdla_t		*card = wandev->priv;
		WAN_MEM_ASSERT(card->devname);
		return -ENOMEM;
	strncpy(chan->if_name, wan_netif_name(dev), WAN_IFNAME_SZ);
	chan->card		= card;
	chan->common.card	= card;
	WAN_IFQ_INIT(&chan->wp_tx_pending_list,0);
	WAN_IFQ_INIT(&chan->wp_tx_complete_list,0);
	WAN_IFQ_INIT(&chan->wp_rx_free_list,0);
	WAN_IFQ_INIT(&chan->wp_rx_complete_list,0);
	WAN_TASKLET_INIT((&chan->common.bh_task),0,wp_usb_bh,chan);
	chan->common.dev = dev;
	if (strcmp(conf->usedby, "TDM_VOICE") == 0){
		chan->common.usedby = TDM_VOICE;
		WAN_TDMV_CALL(check_mtu, (card, conf->active_ch, &chan->mtu), err);
			return -EINVAL;
				&conf->tdmv, 
				conf->active_ch, 
				conf->hwec.enable, 
				chan->common.dev), channel);
					chan->if_name);
			return -EINVAL;
		chan->tdmv_chan=channel;
		card->u.usb.dev_to_ch_map[channel] = chan;
		wan_set_bit(channel,&card->u.usb.tdm_logic_ch_map);
				card->devname,chan->if_name,channel, card->u.usb.tdm_logic_ch_map);
		card->hw_iface.usb_rxtx_data_init(card->hw, channel, &chan->rxdata, &chan->txdata);
		//sdla_usb_rxtx_data_init(card->hw, channel, &chan->rxdata, &chan->txdata);
					card->devname);
		return -EINVAL;
	}else if (strcmp(conf->usedby, "API") == 0) {
		chan->common.usedby = API;
			wandev->name,chan->if_name);
		wan_reg_api(chan, dev, card->devname);
		return -EINVAL;
		chan->channelized_cfg=1;
			for (cptr=wan_netif_priv(dev);cptr->next!=NULL;cptr=cptr->next);
			cptr->next=chan;
			chan->next=NULL;
		chan->channelized_cfg=0;
	chan->time_slot_map=conf->active_ch;
	dev->init = &wp_usb_if_init;
	if (chan->common.usedby != TDM_VOICE && 
	    chan->common.usedby != TDM_VOICE_API){
		chan->common.is_netdev = 1;
	chan->common.iface.open      = &wp_usb_if_open;
        chan->common.iface.close     = &wp_usb_if_close;
        chan->common.iface.output    = &wp_usb_if_send;
        chan->common.iface.ioctl     = &wp_usb_if_do_ioctl;
        chan->common.iface.tx_timeout= &wp_usb_if_tx_timeout;
			wan_iface.attach(dev, NULL, chan->common.is_netdev);
				card->devname, wan_netif_name(dev));
		return -EINVAL;
	wan_netif_set_mtu(dev, chan->mtu);
	chan->mru = chan->mtu;
	wan_set_bit(0,&chan->up);
	sdla_t	*card = wandev->priv;
	if (card->tdmv_conf.span_no){
		u32 active_ch=conf->active_ch;
		switch(card->wandev.config_id){
			err = wp_usb_tdmv_remora_init(&card->tdmv_iface);
					card->devname);
			return -EINVAL;
		WAN_TDMV_CALL(create, (card, &card->tdmv_conf), err);
					card->devname);
		if (card->wandev.fe_iface.active_map){
			conf->active_ch = card->wandev.fe_iface.active_map(&card->fe, 0);
			active_ch=conf->active_ch;
		for (i=0;i<card->u.usb.num_of_time_slots;i++){
				conf->active_ch=0;
				wan_set_bit(i,&conf->active_ch);
		WAN_TDMV_CALL(software_init, (&card->wan_tdmv), err);
		wan_set_bit(WP_USB_RXENABLE,&card->u.usb.port_task_cmd);
		WAN_TASKQ_SCHEDULE(&card->u.usb.port_task);
	//card->wandev.event_callback.dtmf	= wan_aft_api_dtmf; 
	//card->wandev.event_callback.hook	= wan_aft_api_hook; 
	//card->wandev.event_callback.ringtrip	= wan_aft_api_ringtrip; 
	//card->wandev.event_callback.ringdetect	= wan_aft_api_ringdetect; 
	sdla_t		*card = wandev->priv;
	if (strcmp(conf->usedby, "TDM_VOICE") == 0){
	}else if (strcmp(conf->usedby, "API") == 0) {
				card->devname,conf->usedby);
		err=-EINVAL;
				card->devname,conf->usedby);
		err=-EINVAL;
	wan_atomic_inc(&card->wandev.if_cnt);
	return -EINVAL;
	card = chan->card;
	wan_clear_bit(0,&chan->up);
	WAN_IFQ_DMA_PURGE(&chan->wp_rx_free_list);
	WAN_IFQ_DESTROY(&chan->wp_rx_free_list);
	WAN_IFQ_PURGE(&chan->wp_rx_complete_list);
	WAN_IFQ_DESTROY(&chan->wp_rx_complete_list);
	WAN_IFQ_PURGE(&chan->wp_tx_pending_list);
	WAN_IFQ_DESTROY(&chan->wp_tx_pending_list);
	WAN_IFQ_PURGE(&chan->wp_tx_complete_list);
	WAN_IFQ_DESTROY(&chan->wp_tx_complete_list);
	//WAN_TASKLET_KILL(&chan->common.bh_task);
	if (chan->common.usedby == API){
		wan_unreg_api(chan, card->devname);
	if (chan->common.usedby == TDM_VOICE){
		wan_spin_lock_irq(&card->wandev.lock,&flags);
		WAN_TDMV_CALL(unreg, (card, chan->time_slot_map), err);
		wan_spin_unlock_irq(&card->wandev.lock,&flags);
		wan_iface.detach(dev, chan->common.is_netdev);
	wan_atomic_dec(&card->wandev.if_cnt);
	sdla_t 		*card = chan->card;
		return -EBUSY;
        wan_spin_lock_irq(&card->wandev.lock,&flags);
	if (card->wan_tdmv.sc) {
       	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	if (chan->channelized_cfg) {
		sdla_t *card=chan->card;
		card->hw_iface.usb_rxdata_enable(card->hw, 0);
		//sdla_usb_rxdata_enable(card->hw, 0);
			chan->rxdata = NULL;
			chan->txdata = NULL;
			card->hw_iface.usb_rxevent_enable(card->hw, chan->tdmv_chan, 0);
			//sdla_usb_rxevent_enable(card->hw, chan->tdmv_chan, 0);
			card->u.usb.dev_to_ch_map[chan->tdmv_chan] = NULL;
			if (chan->next) {
				wan_netif_set_priv(dev, chan->next);
				 * in dev->priv.  It will get
	if (card->wan_tdmv.sc) {
		if (card->tdmv_conf.span_no && card->wan_tdmv.sc){
	if (!(card=chan->card)){
	wan_set_bit(CARD_DOWN,&card->wandev.critical);
	card->hw_iface.getcfg(card->hw, SDLA_HWCPU_USEDCNT, &card_use_cnt);
	if (chan->common.usedby == API){
	}else if (chan->common.usedby == TDM_VOICE){
	for (card = card_list; card; card = card->list) {
		if (strcmp(card->devname, devname) == 0){
		return -EINVAL;
		return -EINVAL;
	card->hw = hw;
	wan_clear_bit(CARD_DISCONNECT,&card->wandev.critical);
	for (card = card_list; card; card = card->list) {
		if (strcmp(card->devname, devname) == 0){
		return -EINVAL;
	DEBUG_EVENT("%s: Disable USB device...\n", card->devname); 
	wan_set_bit(CARD_DISCONNECT,&card->wandev.critical);
	DEBUG_EVENT("%s: Disable USB softirq handler ...\n", card->devname);
	if (card->hw_iface.restore_intrhand){
		card->hw_iface.restore_intrhand(card->hw, 0);
	card->hw = NULL;
	DEBUG_EVENT("%s: Disable USB softirq handler ...\n", card->devname);
	if (card->hw_iface.restore_intrhand){
		card->hw_iface.restore_intrhand(card->hw, 0);
	wan_set_bit(CARD_DOWN,&card->wandev.critical);
	if (card->wandev.fe_iface.pre_release){
		card->wandev.fe_iface.pre_release(&card->fe);
	if (card->wandev.fe_iface.unconfig){
		card->wandev.fe_iface.unconfig(&card->fe);
	dev->open		= &wp_usb_if_open;
	dev->stop		= &wp_usb_if_close;
	dev->hard_start_xmit	= &wp_usb_if_send;
	dev->get_stats		= &wp_usb_if_stats;
	if (chan->common.usedby == TDM_VOICE || 
	    chan->common.usedby == TDM_VOICE_API){
		dev->tx_timeout		= NULL;
		dev->tx_timeout		= &wp_usb_if_tx_timeout;
	dev->watchdog_timeo	= 2*HZ;
	dev->do_ioctl		= wp_usb_if_do_ioctl;
	dev->flags     |= IFF_POINTOPOINT;
	dev->flags     |= IFF_NOARP;
	dev->type	= ARPHRD_PPP;
	dev->mtu		= chan->mtu;
	dev->hard_header_len	= 0;
        dev->tx_queue_len = 100;
	sdla_t		*card = chan->card;
		return -EBUSY;
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
			card->devname,chan->if_name);	
		return -EINVAL;
	wan_getcurrenttime(&chan->start_time, NULL);
	if (card->wandev.state == WAN_CONNECTED){
	sdla_t		*card = chan->card;
	dev->start=0;
	card=chan->card;
      		if (card->wan_tdmv.sc &&
		    card->wandev.state == WAN_CONNECTED && 
		    chan->common.usedby == TDM_VOICE) {
			chan->common.if_stats.rx_packets = card->wandev.stats.rx_packets;
			chan->common.if_stats.tx_packets = card->wandev.stats.tx_packets;
	return &chan->common.if_stats;
	return -EINVAL;
	if (!chan || !chan->card){
		return -ENODEV;
	card=chan->card;
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
			card->devname);	
		return -ENODEV;
		if (wan_atomic_read(&chan->udp_pkt_len) != 0){
			return -EBUSY;
		wan_atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
		if (wan_test_bit(0,&card->in_isr)){
			wan_atomic_set(&chan->udp_pkt_len,0);
			return -EBUSY;
		wan_udp_pkt=(wan_udp_pkt_t*)chan->udp_pkt_data;
				&wan_udp_pkt->wan_udp_hdr,
				ifr->ifr_data,
			wan_atomic_set(&chan->udp_pkt_len,0);
			return -EFAULT;
		if (wan_test_bit(0,&card->in_isr)) {
					card->devname,
			wan_atomic_set(&chan->udp_pkt_len,0);
			return -EBUSY;
		if (wan_atomic_read(&chan->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
					card->devname,wan_atomic_read(&chan->udp_pkt_len));
			wan_atomic_set(&chan->udp_pkt_len,0);
			return -EINVAL;
				ifr->ifr_data,
				&wan_udp_pkt->wan_udp_hdr,
			wan_atomic_set(&chan->udp_pkt_len,0);
			return -EFAULT;
		wan_atomic_set(&chan->udp_pkt_len,0);
			card->devname,cmd);
		err = -EOPNOTSUPP;
 * "wanpipemon" utility is a user-space program that
	wan_udp_pkt = (wan_udp_pkt_t *)chan->udp_pkt_data;
	if (wan_atomic_read(&chan->udp_pkt_len) == 0){
		return -ENODEV;
//	trace_info=&chan->trace_info;
	wan_udp_pkt = (wan_udp_pkt_t *)chan->udp_pkt_data;
		wan_udp_pkt->wan_udp_opp_flag = 0;
		switch(wan_udp_pkt->wan_udp_command) {
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len=0;
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data[0]=card->u.usb.firm_ver;
			wan_udp_pkt->wan_udp_data_len=1;
			wan_udp_pkt->wan_udp_return_code = 0;
			if (card->wandev.state == WAN_CONNECTED){
				wan_udp_pkt->wan_udp_data[0]=1;
				wan_udp_pkt->wan_udp_data[0]=0;
			wan_udp_pkt->wan_udp_data_len=1;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			wan_udp_pkt->wan_udp_data_len = 0;
			if (!wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
				if (wan_udp_pkt->wan_udp_data[0] == 0){
					wan_clear_bit(1,&trace_info->tracing_enabled);
						card->devname);
				}else if (wan_udp_pkt->wan_udp_data[0] == 1){
					wan_clear_bit(2,&trace_info->tracing_enabled);
					wan_set_bit(1,&trace_info->tracing_enabled);
							card->devname);
					wan_clear_bit(1,&trace_info->tracing_enabled);
					wan_set_bit(2,&trace_info->tracing_enabled);
							card->devname);
				wan_set_bit (0,&trace_info->tracing_enabled);
						card->devname);
				wan_udp_pkt->wan_udp_return_code = 2;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			if(wan_test_bit(0,&trace_info->tracing_enabled)) {
				wan_clear_bit(0,&trace_info->tracing_enabled);
				wan_clear_bit(1,&trace_info->tracing_enabled);
				wan_clear_bit(2,&trace_info->tracing_enabled);
							card->devname);
				wan_udp_pkt->wan_udp_return_code = 1;
			if(wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
						card->devname);
				wan_udp_pkt->wan_udp_return_code = 1;
			wan_udp_pkt->wan_udp_atm_num_frames = 0;	
			wan_udp_pkt->wan_udp_atm_ismoredata = 0;
			while (wan_skb_queue_len(&trace_info->trace_queue)){
				WAN_IFQ_POLL(&trace_info->trace_queue, skb);
								card->devname);
				if ((WAN_MAX_DATA_SIZE - buffer_length) < skb->m_pkthdr.len){
					wan_udp_pkt->wan_udp_atm_ismoredata = 0x01;
					   skb->m_pkthdr.len, 
					   &wan_udp_pkt->wan_udp_data[buffer_length]);
				buffer_length += skb->m_pkthdr.len;
				WAN_IFQ_DEQUEUE(&trace_info->trace_queue, skb);
				wan_udp_pkt->wan_udp_atm_num_frames++;
			while ((skb=skb_dequeue(&trace_info->trace_queue)) != NULL){
				if((MAX_TRACE_BUFFER - buffer_length) < wan_skb_len(skb)){
					wan_udp_pkt->wan_udp_atm_ismoredata = 0x01;
						wan_skb_queue_head(&trace_info->trace_queue, skb);
						memcpy(&wan_udp_pkt->wan_udp_atm_data[buffer_length], 
						wan_udp_pkt->wan_udp_atm_num_frames++;
				memcpy(&wan_udp_pkt->wan_udp_atm_data[buffer_length], 
				wan_udp_pkt->wan_udp_atm_num_frames++;
			wan_udp_pkt->wan_udp_data_len = buffer_length;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			wan_getcurrenttime(&chan->current_time, NULL);
			chan->current_time -= chan->start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
					chan->current_time;	
			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_return_code = 0;
			memcpy(wan_udp_pkt->wan_udp_data,&chan->opstats,sizeof(wp_usb_op_stats_t));
			wan_udp_pkt->wan_udp_data_len=sizeof(wp_usb_op_stats_t);
			wan_udp_pkt->wan_udp_return_code = 0;
			memset(&chan->opstats,0,sizeof(wp_usb_op_stats_t));
			wan_udp_pkt->wan_udp_data_len=0;
			wan_udp_pkt->wan_udp_data_len = 0;
			err = card->hw_iface.usb_err_stats(card->hw, wan_udp_pkt->wan_udp_data, sizeof(wp_usb_comm_err_stats_t));
				wan_udp_pkt->wan_udp_data_len=sizeof(wp_usb_comm_err_stats_t);
				wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_return_code = 0;
			card->hw_iface.usb_flush_err_stats(card->hw);
			wan_udp_pkt->wan_udp_data_len=0;
			if (card->wandev.fe_iface.get_fe_media){
				wan_udp_pkt->wan_udp_data[0] = 
					card->wandev.fe_iface.get_fe_media(&card->fe);
				wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
				wan_udp_pkt->wan_udp_data_len = sizeof(unsigned char); 
				wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
		   	wan_udp_pkt->wan_udp_aft_num_frames = card->wandev.config_id;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_PLATFORM_ID;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
			wan_udp_pkt->wan_udp_data_len = 0;
			wan_udp_pkt->wan_udp_return_code = 0xCD;
			if ((wan_udp_pkt->wan_udp_command & 0xF0) == WAN_FE_UDP_CMD_START){
				card->hw_iface.hw_lock(card->hw,&smp_flags);
				wan_spin_lock_irq(&card->wandev.lock,&smp_flags1);
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				wan_spin_unlock_irq(&card->wandev.lock,&smp_flags1);
				card->hw_iface.hw_unlock(card->hw,&smp_flags);
			wan_udp_pkt->wan_udp_data_len = 0;
			wan_udp_pkt->wan_udp_return_code = 0xCD;
				card->devname,wan_udp_pkt->wan_udp_command);
	wan_udp_pkt->wan_ip_ttl= card->wandev.ttl;
	wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
                               card->devname,__FUNCTION__,__LINE__);
		return -EINVAL;
       	chan->common.state = state;
        if (card->wandev.state != state){
                card->wandev.state = state;
		WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
			card->devname);	
	DEBUG_EVENT("%s: Enable USB-FXO FE POll...\n", card->devname); 
	wan_set_bit(WP_USB_FE_POLL,&card->u.usb.port_task_cmd);
	WAN_TASKQ_SCHEDULE(&card->u.usb.port_task);
//	WAN_TASKLET_END((&gchan->common.bh_task));
//	WAN_TASKLET_SCHEDULE((&gchan->common.bh_task));	
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
	if (wan_test_bit(WP_USB_FE_POLL,&card->u.usb.port_task_cmd)){
		if (card->wandev.fe_iface.polling){
			DEBUG_EVENT("%s: Calling USB-FXO FE Polling...\n", card->devname); 
			card->wandev.fe_iface.polling(&card->fe);
		wan_clear_bit(WP_USB_FE_POLL,&card->u.usb.port_task_cmd);
	if (wan_test_bit(WP_USB_RXENABLE,&card->u.usb.port_task_cmd)){
		for (i=0; i<card->u.usb.num_of_time_slots;i++){
			if (!wan_test_bit(i,&card->u.usb.tdm_logic_ch_map)){
			chan=(wp_usb_softc_t*)card->u.usb.dev_to_ch_map[i];
						card->devname,i);
			if (!wan_test_bit(0,&chan->up)){
			card->hw_iface.usb_rxevent(card->hw, chan->tdmv_chan, &chan->regs_mirror[0], 1);
			card->hw_iface.usb_rxevent_enable(card->hw, chan->tdmv_chan, 1);
		card->hw_iface.usb_rxdata_enable(card->hw, 1);
		wan_clear_bit(WP_USB_RXENABLE,&card->u.usb.port_task_cmd);
		for (i=0; i<card->u.usb.num_of_time_slots;i++){
			if (!wan_test_bit(i,&card->u.usb.tdm_logic_ch_map)){
			chan=(wp_usb_softc_t*)card->u.usb.dev_to_ch_map[i];
						card->devname,i);
			if (!wan_test_bit(0,&chan->up)){
			chan->opstats.isr_no++;
			if (ii == 0 && chan->channelized_cfg){
				card->hw_iface.usb_rxevent(card->hw, chan->tdmv_chan, &chan->regs_mirror[0], 0);
				WAN_TDMV_CALL(update_regs, (card, chan->tdmv_chan, &chan->regs_mirror[0]), err);
			if (chan->rxdata == NULL || chan->txdata == NULL){
							card->devname,__FUNCTION__,__LINE__,
							chan->rxdata,chan->txdata);
					(&card->wan_tdmv,chan->tdmv_chan,
					&chan->rxdata[off],
					&chan->txdata[off]),
		if (card->wandev.state == WAN_CONNECTED){
			card->wandev.stats.rx_packets++;
			card->wandev.stats.tx_packets++;
	if (card->type != SDLA_USB){
					card->devname);
		return -EINVAL;
	if (api_cmd->ret == 1){
		DEBUG_EVENT("%s: Write USB-CPU CMD: Reg:%02X <- %02X\n",
				card->devname, 
				(unsigned char)api_cmd->offset,
				(unsigned char)api_cmd->data[0]);
		api_cmd->ret = card->hw_iface.usb_cpu_write(	
						card->hw, 
						(u_int8_t)api_cmd->offset, 
						(u_int8_t)api_cmd->data[0]);
		api_cmd->ret = -EBUSY;
	}else if (api_cmd->ret == 2){
		DEBUG_EVENT("%s: Write USB-FXO CMD: Module:%d Reg:%02X <- %02X\n",
				card->devname, api_cmd->bar,
				(unsigned char)api_cmd->offset,
				(unsigned char)api_cmd->data[0]);
		api_cmd->ret = card->hw_iface.fe_write(
						card->hw, api_cmd->bar, 
						(u_int8_t)api_cmd->offset, 
						(u_int8_t)api_cmd->data[0]);
		api_cmd->ret = -EBUSY;
	}else if (api_cmd->ret == 0){
		err = card->hw_iface.usb_write_poll(card->hw, (u_int8_t)api_cmd->offset, (u_int8_t)api_cmd->data[0]);
			api_cmd->ret = -EBUSY;
		DEBUG_EVENT("%s: WRITE USB CMD: Reg:%02X -> %02X\n",
				card->devname, 
				(unsigned char)api_cmd->offset,
				(unsigned char)api_cmd->data[0]);
		api_cmd->ret = 0;
		DEBUG_EVENT("%s: Unknown SDLA-USB command %d\n", 
				card->devname, api_cmd->len);
		api_cmd->ret = -EBUSY;
	if (card->type != SDLA_USB){
					card->devname);
		return -EINVAL;
	if (api_cmd->ret == 1){
		api_cmd->data[0] = 0xFF;
		err = card->hw_iface.usb_cpu_read(
						card->hw, 
						(u_int8_t)api_cmd->offset,
						(u_int8_t*)&api_cmd->data[0]);
			api_cmd->ret = -EBUSY;
		DEBUG_EVENT("%s: Read USB-CPU CMD: Reg:%02x -> %02X\n",
				card->devname, 
				(unsigned char)api_cmd->offset,
				(unsigned char)api_cmd->data[0]);
		api_cmd->ret = 0;
		api_cmd->len = 1;
	}else if (api_cmd->ret == 2){
		api_cmd->data[0] = card->hw_iface.fe_read(
						card->hw, 
						api_cmd->bar, 
						(u_int8_t)api_cmd->offset);
		DEBUG_EVENT("%s: Read USB-FXO CMD: Mod:%d Reg:%02X -> %02X\n",
				card->devname,  api_cmd->bar,
				(unsigned char)api_cmd->offset,
				(unsigned char)api_cmd->data[0]);
		api_cmd->ret = 0;
		api_cmd->len = 1;
	}else if (api_cmd->ret == 0){
		err = card->hw_iface.usb_read_poll(card->hw, (u_int8_t)api_cmd->offset, (u_int8_t*)&api_cmd->data[0]);
			api_cmd->ret = -EBUSY;
		DEBUG_EVENT("%s: Read USB CMD: Reg:%02X -> %02X\n",
				card->devname, 
				(unsigned char)api_cmd->offset,
				(unsigned char)api_cmd->data[0]);
		api_cmd->ret = 0;
		api_cmd->len = 1;
		DEBUG_EVENT("%s: Unknown SDLA-USB command %d\n", 
				card->devname, api_cmd->len);
		api_cmd->ret = -EINVAL;
	int 		err = -EINVAL;
	if (!ifr || !ifr->ifr_data){
		return -EFAULT;
	if (WAN_COPY_FROM_USER(&api_cmd,ifr->ifr_data,sizeof(wan_cmd_api_t))){
		return -EFAULT;
	if (WAN_COPY_TO_USER(ifr->ifr_data,&api_cmd,sizeof(wan_cmd_api_t))){
		return -EFAULT;
./wanpipe_usb.c
* Copyright:	(c) 2003-2007 Sangoma Technologies Inc.
		if (chan->num_of_time_slots == NUM_OF_T1_CHANNELS){
		}else if (chan->num_of_time_slots == 1){
		}else if (chan->num_of_time_slots == 2 || chan->num_of_time_slots == 3){
		}else if (chan->num_of_time_slots >= 4 && chan->num_of_time_slots<= 7){
		}else if (chan->num_of_time_slots >= 8 && chan->num_of_time_slots<= 15){
		}else if (chan->num_of_time_slots >= 16 && chan->num_of_time_slots<= 23){
					card->devname,chan->if_name,chan->num_of_time_slots);
			return -EINVAL;		
		if (chan->num_of_time_slots == (NUM_OF_E1_CHANNELS-1)){
                }else if (chan->num_of_time_slots == 1){
                }else if (chan->num_of_time_slots == 2 || chan->num_of_time_slots == 3){
                }else if (chan->num_of_time_slots >= 4 && chan->num_of_time_slots <= 7){
                }else if (chan->num_of_time_slots >= 8 && chan->num_of_time_slots <= 15){
                }else if (chan->num_of_time_slots >= 16 && chan->num_of_time_slots <= 31){
		}else if (WAN_FE_FRAME(&card->fe) == WAN_FR_UNFRAMED){
                                        card->devname,chan->if_name,chan->num_of_time_slots);
                        return -EINVAL;
		card->devname,chan->if_name,req_fifo_size,chan->num_of_time_slots);
	fifo_size=(u8)aft_map_fifo_baddr_and_size(card,req_fifo_size,&chan->fifo_base_addr);
	if (fifo_size == 0 || chan->fifo_base_addr == 31){
				card->devname,chan->if_name,fifo_size,chan->fifo_base_addr);
                return -EINVAL;
                card->devname,chan->if_name,req_fifo_size,chan->num_of_time_slots,fifo_size);
			chan->fifo_size_code=fifo_code_vector[i];
			card->devname,chan->if_name,req_fifo_size,fifo_size);
                card->devname,chan->if_name,fifo_size,
		chan->num_of_time_slots,chan->fifo_size_code,
		chan->fifo_base_addr);
	chan->fifo_size = fifo_size;
                        card->devname,reg,card->u.aft.fifo_addr_map);
		if (card->u.aft.fifo_addr_map & (reg<<i)){
		card->u.aft.fifo_addr_map |= reg<<i;
	                card->devname,card->u.aft.fifo_addr_map,i);
	for (i=0;i<chan->fifo_size;i++){
		card->devname,reg<<chan->fifo_base_addr, card->u.aft.fifo_addr_map);
	card->u.aft.fifo_addr_map &= ~(reg<<chan->fifo_base_addr);
                card->devname, card->u.aft.fifo_addr_map);
	chan->fifo_size=0;
	chan->fifo_base_addr=0;
	signed char logic_ch=-1;
	int if_cnt=wan_atomic_read(&card->wandev.if_cnt);
	if (IS_E1_CARD(card) && !(WAN_FE_FRAME(&card->fe) == WAN_FR_UNFRAMED)){
	DEBUG_TEST("-- Request_Xilinx_logic_channel_num:-- (if_offset=%i)\n",if_offset);
                card->u.aft.num_of_time_slots,
                card->u.aft.logic_ch_map);
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (wan_test_bit(i,&chan->time_slot_map)){
			if (chan->first_time_slot == -1){
						card->devname,i);
				chan->first_time_slot=i;
			chan->last_time_slot=i;
					card->devname, chan->if_name, 
			if (wan_test_bit(i,&card->u.aft.time_slot_map)){
						card->devname);
						card->devname,chan->if_name,(i+1));
				return -EEXIST;
		return -1;
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (card->u.aft.security_id == 0){
			if (chan->channelized_cfg) {
				if (card->tdmv_conf.dchan){
					if (i==0 && !chan->hdlc_eng){
					if (!chan->hdlc_eng && 
					    if_cnt < (card->u.aft.num_of_time_slots-if_offset)){ 
		if (!wan_test_and_set_bit(i,&card->u.aft.logic_ch_map)){
	if (logic_ch == -1){
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
	if (card->u.aft.dev_to_ch_map[(unsigned char)logic_ch]){
				card->devname,logic_ch);
		return -1;
	card->u.aft.dev_to_ch_map[(unsigned char)logic_ch]=(void*)chan;
	if (logic_ch >= card->u.aft.top_logic_ch){
		card->u.aft.top_logic_ch=logic_ch;
	int err=-EINVAL;
		card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG), &reg);
			err = -EINVAL;
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
				card->devname, card->wandev.comm_port+1);
		card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
				err=-1;
				err=-1;
			card->devname,i);
	if (card->adptr_subtype == AFT_SUBTYPE_SHARK){
				wan_clear_bit(0,&card->u.aft.led_ctrl);
				wan_set_bit(0,&card->u.aft.led_ctrl);
				wan_clear_bit(1,&card->u.aft.led_ctrl);
				wan_set_bit(1,&card->u.aft.led_ctrl);
			aft_56k_write_cpld(card,card->wandev.comm_port + 0x08,card->u.aft.led_ctrl);
			aft_te1_write_cpld(card,card->wandev.comm_port + 0x08,card->u.aft.led_ctrl);
		card->hw_iface.bus_read_4(card->hw,
		card->hw_iface.bus_write_4(card->hw,
	err = -EINVAL;
	if (card->wandev.fe_iface.global_config){
		err=card->wandev.fe_iface.global_config(&card->fe);
	DEBUG_CFG("--- AFT Chip Reset. -- \n");
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),reg);
				card->devname);
		return -EINVAL;
	DEBUG_CFG("--- Chip enable/config. -- \n");
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),reg);
	if (card->u.aft.firm_id == AFT_DS_FE_CORE_ID){
		card->hw_iface.hw_lock(card->hw,&smp_flags);
		wan_spin_lock_irq(&card->wandev.lock,&flags);
		wan_spin_unlock_irq(&card->wandev.lock,&flags);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
	}else if (card->adptr_subtype == AFT_SUBTYPE_SHARK){
		card->hw_iface.hw_lock(card->hw,&smp_flags);
		wan_spin_lock_irq(&card->wandev.lock,&flags);
		wan_spin_unlock_irq(&card->wandev.lock,&flags);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
					card->devname,reg);
		return -EINVAL;
                                        card->devname);
	err = -EINVAL;
	if (card->wandev.fe_iface.global_config){
		err=card->wandev.fe_iface.global_config(&card->fe);
	if (card->adptr_subtype == AFT_SUBTYPE_SHARK){
		card->hw_iface.getcfg(card->hw, SDLA_HWEC_NO, &max_ec_chans);  
					card->devname,card->wandev.comm_port+1); 
			card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),&reg); 
                 	aft_chipcfg_set_oct_clk_src(&reg,card->wandev.comm_port);  
			card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),reg); 
	if (card->wandev.fe_iface.global_unconfig){
		card->wandev.fe_iface.global_unconfig(&card->fe);
	if (card->wandev.fe_iface.global_unconfig){
		card->wandev.fe_iface.global_unconfig(&card->fe);
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG),reg);
	if (WAN_TE1_CLK(&card->fe) == WAN_MASTER_CLK) {  
		if (WAN_FE_LINENO(&card->fe) >= 4) {
					WAN_FE_LINENO(&card->fe)-4,
		if (WAN_FE_LINENO(&card->fe) >= 4) {
					WAN_FE_LINENO(&card->fe)-4,
	if (card->adptr_subtype == AFT_SUBTYPE_SHARK && card->hwec_conf.clk_src){
		card->hwec_conf.clk_src = WAN_FE_LINENO(&card->fe);
	                card->devname,
	                 card->hwec_conf.clk_src+1);
		card->hw_iface.hw_lock(card->hw,&smp_flags);
		wan_spin_lock_irq(&card->wandev.lock,&flags);
		card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG), &cfg_reg);
	     	aft_chipcfg_set_oct_clk_src(&cfg_reg,card->hwec_conf.clk_src);
		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG), cfg_reg);
		wan_spin_unlock_irq(&card->wandev.lock,&flags);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
				card->devname, card->wandev.comm_port+1);
		return -EBUSY;
	if (card->u.aft.firm_id == AFT_DS_FE_CORE_ID) {
		card->hw_iface.hw_lock(card->hw,&smp_flags);
		wan_spin_lock_irq(&card->wandev.lock,&flags);
		aft_ds_set_clock_ref(card,&reg,WAN_FE_LINENO(&card->fe));
		wan_spin_unlock_irq(&card->wandev.lock,&flags);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), reg);
	card->hw_iface.hw_lock(card->hw,&smp_flags);
	if(card->adptr_type == AFT_ADPTR_56K){
	err = -EINVAL;
	if (card->wandev.fe_iface.config){
		err=card->wandev.fe_iface.config(&card->fe);
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
                                	card->devname,
		return -EINVAL;
	if (card->wandev.fe_iface.post_init){
		err=card->wandev.fe_iface.post_init(&card->fe);
			card->devname);
	if (card->adptr_type == A104_ADPTR_4TE1 ||
	    card->u.aft.firm_id == AFT_DS_FE_CORE_ID) {
		if (WAN_TE1_CLK(&card->fe) == WAN_MASTER_CLK &&
		    WAN_TE1_REFCLK(&card->fe) > 0){
			if (card->adptr_subtype == AFT_SUBTYPE_SHARK){
			if (card->u.aft.firm_id == AFT_DS_FE_CORE_ID){
				switch(card->adptr_type){
			if (card->u.aft.firm_ver < mclk_ver){
						card->devname,mclk_ver,card->u.aft.firm_ver);
						card->devname,mclk_ver);
				return -EINVAL;
			if (WAN_TE1_REFCLK(&card->fe) == card->wandev.comm_port+1){
						card->devname,WAN_TE1_REFCLK(&card->fe),
						card->wandev.comm_port+1);
				return -EINVAL;
			if (WAN_TE1_REFCLK(&card->fe) > max_port){
						card->devname,WAN_TE1_REFCLK(&card->fe));
				return -EINVAL;
			card->hw_iface.bus_read_4(card->hw,
			if (card->u.aft.firm_id == AFT_DS_FE_CORE_ID){
				card->hw_iface.hw_lock(card->hw,&smp_flags);
	       			wan_spin_lock_irq(&card->wandev.lock,&flags);
				WAN_TE1_CLK(&card->fe) = WAN_NORMAL_CLK;
				aft_ds_set_clock_ref(card,&reg,WAN_TE1_REFCLK(&card->fe)-1);
				wan_spin_unlock_irq(&card->wandev.lock,&flags);
				card->hw_iface.hw_unlock(card->hw,&smp_flags); 
				aft_lcfg_fe_clk_source(&reg,WAN_TE1_REFCLK(&card->fe)-1);	
			card->hw_iface.bus_write_4(card->hw,
					card->devname,
					card->wandev.comm_port+1,
					WAN_TE1_REFCLK(&card->fe));
	card->hw_iface.bus_read_4(card->hw,
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),reg);
	if (IS_E1_CARD(card) && (WAN_FE_FRAME(&card->fe) == WAN_FR_UNFRAMED)){
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),reg);
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),&reg);
					card->devname,reg);
                                        card->devname,reg);
	card->wandev.ec_dev = NULL;
	card->wandev.hwec_reset = NULL;
	card->wandev.hwec_enable = NULL;
	if (card->adptr_subtype == AFT_SUBTYPE_SHARK){
		card->hw_iface.getcfg(card->hw, SDLA_HWEC_NO, &max_ec_chans);
		card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG), &cfg_reg); 
					card->devname);
					card->devname,
        		return -EINVAL;
			card->wandev.hwec_reset = aft_hwec_reset;
			card->wandev.hwec_enable = aft_hwec_enable;
			card->wandev.ec_dev = wanpipe_ec_register(
						WAN_FE_MAX_CHANNELS(&card->fe),
						(void*)&conf->oct_conf);
			if (!card->wandev.ec_dev) {
							card->devname);
				return -EINVAL;
						card->devname);
						card->devname);
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), reg);
	card->u.aft.lcfg_reg=reg;
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),reg);
		card->hw_iface.bus_write_4(card->hw, ctrl_ram_reg, reg);
	if (card->wandev.fe_iface.pre_release){
		card->wandev.fe_iface.pre_release(&card->fe);
	if (card->wandev.fe_iface.unconfig){
		card->wandev.fe_iface.unconfig(&card->fe);
	if (card->adptr_subtype == AFT_SUBTYPE_SHARK && card->wandev.ec_dev){
		if (card->wandev.ec_dev){
						card->devname);
			wanpipe_ec_unregister(card->wandev.ec_dev, card);
						card->devname);
		card->wandev.hwec_enable = NULL;
		card->wandev.ec_dev = NULL;
		if (card->wandev.fe_iface.pre_release){
			card->wandev.fe_iface.pre_release(&card->fe);
		card->hw_iface.hw_lock(card->hw,&smp_flags1);
		wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
		wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
		card->hw_iface.hw_unlock(card->hw,&smp_flags1);
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),reg);
	int chan_num=-EBUSY;
		return -EBUSY;
	chan->logic_ch_num = chan_num;
	dma_ram_reg+=(chan->logic_ch_num*4);
	card->hw_iface.bus_write_4(card->hw, dma_ram_reg, reg);
	card->hw_iface.bus_read_4(card->hw, dma_ram_reg, &reg);
	aft_dmachain_set_fifo_size(&reg, chan->fifo_size_code);
	aft_dmachain_set_fifo_base(&reg, chan->fifo_base_addr);
	if (chan->cfg.ss7_enable){
	if (chan->channelized_cfg && !chan->hdlc_eng){
		aft_dmachain_enable_tdmv_and_mtu_size(&reg,chan->mru);
	card->hw_iface.bus_write_4(card->hw, dma_ram_reg, reg);
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (wan_test_bit(i,&chan->time_slot_map)){
			wan_set_bit(i,&card->u.aft.time_slot_map);
			card->hw_iface.bus_read_4(card->hw, ctrl_ram_reg, &reg);
			aft_ctrlram_set_logic_ch(&reg,chan->logic_ch_num);
			if (i == chan->first_time_slot){
			aft_ctrlram_set_fifo_size(&reg,chan->fifo_size_code);
			aft_ctrlram_set_fifo_base(&reg,chan->fifo_base_addr);
			if (chan->hdlc_eng){
			if (chan->cfg.data_mux){
			if (0){ /* FIXME card->fe.fe_cfg.cfg.te1cfg.fcs == 32){ */
			if (chan->cfg.ss7_enable){
					card->devname, chan->if_name, i,
			card->hw_iface.bus_write_4(card->hw, ctrl_ram_reg, reg);
	if (chan->channelized_cfg && !chan->hdlc_eng){
		card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),&reg);
		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),reg);
		card->u.aft.lcfg_reg=reg;
		wan_set_bit(chan->logic_ch_num,&card->u.aft.tdm_logic_ch_map);
	if (chan->logic_ch_num != -1){
		dma_ram_reg+=(chan->logic_ch_num*4);
		card->hw_iface.bus_read_4(card->hw, dma_ram_reg, &reg);
		card->hw_iface.bus_write_4(card->hw, dma_ram_reg, reg);
	        for (i=0;i<card->u.aft.num_of_time_slots;i++){
        	        if (wan_test_bit(i,&chan->time_slot_map)){
				card->hw_iface.bus_write_4(card->hw, ctrl_ram_reg, reg);
		aft_free_logical_channel_num(card,chan->logic_ch_num);
		for (i=0;i<card->u.aft.num_of_time_slots;i++){
			if (wan_test_bit(i,&chan->time_slot_map)){
				wan_clear_bit(i,&card->u.aft.time_slot_map);
		if (chan->channelized_cfg && !chan->hdlc_eng){
			card->hw_iface.bus_read_4(card->hw,
			card->hw_iface.bus_write_4(card->hw,
			wan_clear_bit(chan->logic_ch_num,&card->u.aft.tdm_logic_ch_map);
	if (card->u.aft.firm_id == AFT_DS_FE_CORE_ID/*card->adptr_type == A108_ADPTR_8TE1*/) {
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_CHIP_CFG_REG), &cfg_reg);
   	card->hw_iface.bus_write_2(card->hw, AFT56K_MCPU_INTERFACE_ADDR, cpld_off);
   	card->hw_iface.bus_write_2(card->hw, AFT56K_MCPU_INTERFACE, cpld_data);
   	card->hw_iface.bus_write_2(card->hw, AFT56K_MCPU_INTERFACE_ADDR, cpld_off);
   	card->hw_iface.bus_read_4(card->hw, AFT56K_MCPU_INTERFACE, &cpld_data);
	int	err = -EINVAL;
	if (card->hw_iface.fe_test_and_set_bit(card->hw,0)){
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			card->devname, __FUNCTION__,__LINE__);
	if (card->hw_iface.read_cpld){
		err = card->hw_iface.read_cpld(card->hw, (u16)cpld_off, &tmp);
	card->hw_iface.fe_clear_bit(card->hw,0);
	int	err = -EINVAL;
	if (card->hw_iface.fe_test_and_set_bit(card->hw,0)){
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			card->devname, __FUNCTION__,__LINE__);
	if (card->hw_iface.write_cpld){
		err = card->hw_iface.write_cpld(card->hw, (u16)off, (u8)data);
	card->hw_iface.fe_clear_bit(card->hw,0);
	if (card->hw_iface.fe_test_and_set_bit(card->hw,0)){
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			card->devname, __FUNCTION__,__LINE__);
        card->hw_iface.bus_read_2(card->hw,
        card->hw_iface.bus_write_2(card->hw,
        card->hw_iface.bus_read_1(card->hw,AFT_MCPU_INTERFACE, &tmp);
        card->hw_iface.bus_write_2(card->hw,
	card->hw_iface.fe_clear_bit(card->hw,0);
	if (card->hw_iface.fe_test_and_set_bit(card->hw,0)){
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			card->devname, __FUNCTION__,__LINE__);
        card->hw_iface.bus_read_2(card->hw,
        card->hw_iface.bus_write_2(card->hw,
	card->hw_iface.bus_write_1(card->hw,
        card->hw_iface.bus_write_2(card->hw,
	card->hw_iface.fe_clear_bit(card->hw,0);
	card->hw_iface.bus_read_4(card->hw, AFT_PORT_REG(card,AFT_FIFO_MARK_REG), &fifo_size);
	card->hw_iface.bus_write_4(card->hw, AFT_PORT_REG(card,AFT_FIFO_MARK_REG), reg);		
	DEBUG_EVENT("%s:    Fifo Level Map:0x%08X\n",card->devname,reg);
	int		err = -EINVAL;
	card->hw_iface.hw_lock(card->hw,&smp_flags);
	wan_spin_lock_irq(&card->wandev.lock,&flags);
					card->devname);
		if (card->u.aft.firm_id == AFT_DS_FE_CORE_ID) {
					card->devname);
		if (card->u.aft.firm_id == AFT_DS_FE_CORE_ID/*card->adptr_type == A108_ADPTR_8TE1*/) {
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
** Return:	0   - success
**		1   - channel out of channel map
**		< 0 - failed
		hw_chan = fe_chan-1;
	card->hw_iface.bus_read_4(
			card->hw,
			card->devname,
	card->hw_iface.bus_write_4(
			card->hw,
./aft_a104.c
 * Copyright:	(c) 1995-2005 Sangoma Technologies Inc.
 /*Part 2 - this is the only part used. The 2 parts are switched
#define ZEROTRAP    /* turn on the trap as per the MIL-STD */
#define BIAS 0x84   /* define the add-in bias for 16 bit samples */
  /* Get the sample into sign-magnitude. */
  if (sign != 0) sample = -sample;              /* get magnitude */
        pcm_val = -pcm_val;
        i = (i + 0x100) << (seg - 1);
    return (short int) ((alaw & 0x80)  ?  i  :  -i);
	for(i = -32768; i < 32768; i += 4) {
		mu = 255-i;
		if (mu & 0x80) y = -y;
./wanpipe_codec_law.c
* Copyright:	(c) 2003-2005 Sangoma Technologies Inc.
#warning "BRI_DBG  - Debugging Enabled"
#warning "DEBUG_REG  - Debugging Enabled"
#warning "DEBUG_BRI  - Debugging Enabled"
#warning "BRI_FUNC  - Debugging Enabled"
		card->u.aft.fifo_addr_map_l2 |= map;
		card->u.aft.fifo_addr_map |= map;
	if (WAN_FE_LINENO(&card->fe) >= MAX_BRI_MODULES) {
		card->u.aft.fifo_addr_map_l2 &= map;
		card->u.aft.fifo_addr_map &= map;
	if (WAN_FE_LINENO(&card->fe) >= MAX_BRI_MODULES) {
		return card->u.aft.fifo_addr_map_l2;
	return card->u.aft.fifo_addr_map;
	if (chan->num_of_time_slots == 1) {
	} else if (chan->num_of_time_slots == 2 || chan->num_of_time_slots == 3) {
				card->devname,chan->if_name,chan->num_of_time_slots);
		return -EINVAL;		
	for (i=0;i<WAN_FE_LINENO(&card->fe);i++){
			card->devname,i,(0x03 << i%MAX_BRI_MODULES)*2);
		card->devname,chan->if_name,req_fifo_size,chan->num_of_time_slots,
	fifo_size=(u8)aft_map_fifo_baddr_and_size(card,req_fifo_size,&chan->fifo_base_addr);
	if (fifo_size == 0 || chan->fifo_base_addr == 31){
				card->devname,chan->if_name,fifo_size,chan->fifo_base_addr);
                return -EINVAL;
                card->devname,chan->if_name,req_fifo_size,chan->num_of_time_slots,fifo_size);
			chan->fifo_size_code=fifo_code_vector[i];
			card->devname,chan->if_name,req_fifo_size,fifo_size);
                card->devname,chan->if_name,fifo_size,
		chan->num_of_time_slots,chan->fifo_size_code,
		chan->fifo_base_addr);
	chan->fifo_size = fifo_size;
                        card->devname,reg,aft_get_bri_fifo_map(card));
		aft_set_bri_fifo_map(card, WAN_FE_LINENO(&card->fe), (reg<<i));
	                card->devname,aft_get_bri_fifo_map(card),i);
	for (i=0;i<chan->fifo_size;i++){
		card->devname,reg<<chan->fifo_base_addr, aft_get_bri_fifo_map(card));
	aft_clear_bri_fifo_map(card, ~(reg<<chan->fifo_base_addr));
                card->devname, aft_get_bri_fifo_map(card));
	chan->fifo_size=0;
	chan->fifo_base_addr=0;
	signed char logic_ch=-1;
	int if_cnt=wan_atomic_read(&card->wandev.if_cnt);
	DEBUG_TEST("-- Request_Xilinx_logic_channel_num:-- (if_offset=%i)\n",if_offset);
                card->u.aft.num_of_time_slots,
                card->u.aft.logic_ch_map);
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (wan_test_bit(i,&chan->time_slot_map)){
			if (chan->first_time_slot == -1){
						card->devname,i);
				chan->first_time_slot=i;
			chan->last_time_slot=i;
					card->devname, chan->if_name,i+1);
			if (wan_test_bit(i,&card->u.aft.time_slot_map)){
						card->devname);
						card->devname,chan->if_name,(i+1));
				return -EEXIST;
		return -1;
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (wan_test_bit(i,&chan->time_slot_map)){
			if (card->u.aft.security_id == 0){
				if (chan->channelized_cfg) {
					if (card->u.aft.tdmv_dchan){
						if (i==0 && !chan->hdlc_eng){
						if (!chan->hdlc_eng && 
						if_cnt < (card->u.aft.num_of_time_slots-if_offset)){ 
			if (!wan_test_and_set_bit(i,&card->u.aft.logic_ch_map)){
	if (logic_ch == -1){
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.aft.logic_ch_map)){
	if (card->u.aft.dev_to_ch_map[(unsigned char)logic_ch]){
				card->devname,logic_ch);
		return -1;
	card->u.aft.dev_to_ch_map[(unsigned char)logic_ch]=(void*)chan;
	if (logic_ch >= card->u.aft.top_logic_ch){
		card->u.aft.top_logic_ch=logic_ch;
	DEBUG_CFG("!!! %s: Binding logic ch %d  Ptr=%p\n",chan->if_name,logic_ch,chan);
		card->hw_iface.bus_read_4(card->hw,AFT_CHIP_CFG_REG, &reg);
			err = -EINVAL;
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
				card->devname, card->wandev.comm_port+1);
		card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
				err=-1;
				err=-1;
			card->devname,i, reg);
	card->hw_iface.bus_read_4(card->hw,AFT_CHIP_CFG_REG,&reg);
		card->devname,cpld_reg,reg);
	card->u.aft.firm_id = AFT_DS_FE_CORE_ID;
	card->hw_iface.getcfg(card->hw, SDLA_HWCPU_USEDCNT, &used_cnt);
		DEBUG_CFG("--- AFT Chip Reset. -- \n");
		card->hw_iface.bus_write_4(card->hw,AFT_CHIP_CFG_REG,reg);
		if (WAN_FE_NETWORK_SYNC(&card->fe)){	/*card->fe.fe_cfg.cfg.remora.network_sync*/
					card->devname);
		DEBUG_CFG("--- Chip enable/config. -- \n");
		card->hw_iface.bus_write_4(card->hw,AFT_CHIP_CFG_REG,reg);
		if (WAN_FE_NETWORK_SYNC(&card->fe)){
			DEBUG_EVENT("%s: Ignoring Network Sync\n", card->devname);
					card->devname);
			return -EINVAL;
		card->hw_iface.hw_lock(card->hw,&smp_flags);
		wan_spin_lock_irq(&card->wandev.lock,&flags);
		wan_spin_unlock_irq(&card->wandev.lock,&flags);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
					card->devname,reg);
		return -EINVAL;
                                        card->devname);
	err = -EINVAL;
	if (card->wandev.fe_iface.global_config){
		err=card->wandev.fe_iface.global_config(&card->fe);
	card->hw_iface.getcfg(card->hw, SDLA_HWCPU_USEDCNT, &used_cnt);
	if (card->wandev.fe_iface.global_unconfig){
		card->wandev.fe_iface.global_unconfig(&card->fe);
		card->hw_iface.bus_write_4(card->hw,AFT_CHIP_CFG_REG,reg);
	card->wandev.ec_dev = NULL;
	card->wandev.hwec_reset = NULL;
	card->wandev.hwec_enable = NULL;
	card->hw_iface.getcfg(card->hw, SDLA_HWEC_NO, &max_ec_chans);
	card->hw_iface.getcfg(card->hw, SDLA_CHANS_NO, &max_chans_no);
	card->hw_iface.getcfg(card->hw, SDLA_CHANS_MAP, &fe_chans_map);
	card->hw_iface.bus_read_4(card->hw,AFT_CHIP_CFG_REG, &cfg_reg); 
				card->devname);
				card->devname,
		return -EINVAL;
		card->wandev.ec_dev = wanpipe_ec_register(
						max_chans_no,	/* b-chans number is 2 */
						(void*)&conf->oct_conf);
		if (!card->wandev.ec_dev) {
							card->devname);
			return -EINVAL;
		card->wandev.hwec_reset  = aft_bri_hwec_reset;
		card->wandev.hwec_enable = aft_bri_hwec_enable;
				event->type=WAN_EVENT_EC_H100_REPORT;
				event->mode=WAN_EVENT_DISABLE;
				wanpipe_ec_event_ctrl(card->wandev.ec_dev,card,event);
						card->devname);
					card->devname);
					card->devname);
	card->hw_iface.getcfg(card->hw, SDLA_HWCPU_USEDCNT, &used_cnt);
	card->hw_iface.getcfg(card->hw, SDLA_HWTYPE_USEDCNT, &used_type_cnt);
	card->hw_iface.bus_read_4(card->hw,AFT_CHIP_CFG_REG,&reg);
		card->fe.fe_cfg.cfg.bri.clock_mode=0;
		card->hw_iface.hw_lock(card->hw,&smp_flags);
		err = -EINVAL;
		if (card->wandev.fe_iface.config){
			err=card->wandev.fe_iface.config(&card->fe);
		card->hw_iface.hw_unlock(card->hw,&smp_flags);
                                	card->devname);
		if (card->wandev.fe_iface.post_init){
			err=card->wandev.fe_iface.post_init(&card->fe);
	card->hw_iface.hw_lock(card->hw,&smp_flags);
	err = -EINVAL;
	if (card->wandev.fe_iface.config){
		err=card->wandev.fe_iface.config(&card->fe);
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
                                	card->devname);
		return -EINVAL;
	if (card->wandev.fe_iface.post_init){
		err=card->wandev.fe_iface.post_init(&card->fe);
			card->devname);
	card->hw_iface.bus_read_4(card->hw, AFT_PORT_REG(card,AFT_LINE_CFG_REG),&reg);
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),reg);
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),reg);
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),&reg);
					card->devname,reg);
                                        card->devname,reg);
	card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), &reg);
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG), reg);
	card->u.aft.lcfg_reg=reg;
	card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_DMA_CTRL_REG),reg);
		card->hw_iface.bus_write_4(card->hw, ctrl_ram_reg, reg);
	if (card->wandev.ec_dev){
						card->devname);
		wanpipe_ec_unregister(card->wandev.ec_dev, card);
					card->devname);
	card->wandev.hwec_enable = NULL;
	card->wandev.ec_dev = NULL;
	if (card->wandev.fe_iface.pre_release){
		card->wandev.fe_iface.pre_release(&card->fe);
	card->hw_iface.hw_lock(card->hw,&smp_flags1);
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	if (card->wandev.fe_iface.unconfig){
		card->wandev.fe_iface.unconfig(&card->fe);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
	card->hw_iface.hw_unlock(card->hw,&smp_flags1);
	int chan_num=-EBUSY;
	if(chan->dchan_time_slot >= 0){
 		chan->logic_ch_num = 2;
		card->u.aft.dev_to_ch_map[BRI_DCHAN_LOGIC_CHAN]=(void*)chan;
		return -EBUSY;
	chan->logic_ch_num = chan_num;
	dma_ram_reg+=(chan->logic_ch_num*4);
	card->hw_iface.bus_write_4(card->hw, dma_ram_reg, reg);
	card->hw_iface.bus_read_4(card->hw, dma_ram_reg, &reg);
	aft_dmachain_set_fifo_size(&reg, chan->fifo_size_code);
	aft_dmachain_set_fifo_base(&reg, chan->fifo_base_addr);
	if (chan->cfg.ss7_enable){
	if (chan->channelized_cfg && !chan->hdlc_eng){
		aft_dmachain_enable_tdmv_and_mtu_size(&reg,chan->mru);
	card->hw_iface.bus_write_4(card->hw, dma_ram_reg, reg);
	for (i=0;i<card->u.aft.num_of_time_slots;i++){
		if (wan_test_bit(i,&chan->time_slot_map)){
			wan_set_bit(i,&card->u.aft.time_slot_map);
			card->hw_iface.bus_read_4(card->hw, ctrl_ram_reg, &reg);
			aft_ctrlram_set_logic_ch(&reg,chan->logic_ch_num);
			if (i == chan->first_time_slot){
			aft_ctrlram_set_fifo_size(&reg,chan->fifo_size_code);
			aft_ctrlram_set_fifo_base(&reg,chan->fifo_base_addr);
			if (chan->hdlc_eng){
			if (chan->cfg.data_mux){
			if (0){ /* FIXME card->fe.fe_cfg.cfg.te1cfg.fcs == 32){ */
			if (chan->cfg.ss7_enable){
					card->devname, chan->if_name, chan->logic_ch_num, i,
			card->hw_iface.bus_write_4(card->hw, ctrl_ram_reg, reg);
	if (chan->channelized_cfg && !chan->hdlc_eng){
		card->hw_iface.bus_read_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),&reg);
		card->hw_iface.bus_write_4(card->hw,AFT_PORT_REG(card,AFT_LINE_CFG_REG),reg);
		card->u.aft.lcfg_reg=reg;
		wan_set_bit(chan->logic_ch_num,&card->u.aft.tdm_logic_ch_map);
				card->devname,
				card->devname, chan->logic_ch_num);
	if( chan->dchan_time_slot >= 0) {
				card->devname, chan->logic_ch_num);
 		chan->logic_ch_num = 2;
		card->u.aft.dev_to_ch_map[BRI_DCHAN_LOGIC_CHAN]=NULL;
	if (chan->logic_ch_num != -1){
				card->devname, chan->logic_ch_num);
		dma_ram_reg+=(chan->logic_ch_num*4);
		card->hw_iface.bus_read_4(card->hw, dma_ram_reg, &reg);
		card->hw_iface.bus_write_4(card->hw, dma_ram_reg, reg);
	        for (i=0;i<card->u.aft.num_of_time_slots;i++){
        	        if (wan_test_bit(i,&chan->time_slot_map)){
				card->hw_iface.bus_write_4(card->hw, ctrl_ram_reg, reg);
		aft_free_logical_channel_num(card,chan->logic_ch_num);
		for (i=0;i<card->u.aft.num_of_time_slots;i++){
			if (wan_test_bit(i,&chan->time_slot_map)){
				wan_clear_bit(i,&card->u.aft.time_slot_map);
		if (chan->channelized_cfg && !chan->hdlc_eng){
			card->hw_iface.bus_read_4(card->hw,
			card->hw_iface.bus_write_4(card->hw,
			wan_clear_bit(chan->logic_ch_num,&card->u.aft.tdm_logic_ch_map);
				card->devname,
    	card->hw_iface.bus_read_4(card->hw,AFT_CHIP_CFG_REG, &cfg_reg);
	int	err = -EINVAL;
	if (card->hw_iface.fe_test_and_set_bit(card->hw,0)){
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			card->devname, __FUNCTION__,__LINE__);
	if (card->hw_iface.read_cpld){
		err = card->hw_iface.read_cpld(card->hw, (u16)cpld_off, &tmp);
	card->hw_iface.fe_clear_bit(card->hw,0);
	int	err = -EINVAL;
	if (card->hw_iface.fe_test_and_set_bit(card->hw,0)){
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			card->devname, __FUNCTION__,__LINE__);
	if (card->hw_iface.write_cpld){
		err = card->hw_iface.write_cpld(card->hw, (u16)off, (u8)data);
	card->hw_iface.fe_clear_bit(card->hw,0);
	if (card->hw_iface.fe_test_and_set_bit(card->hw,0)){
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			card->devname, __FUNCTION__,__LINE__);
        card->hw_iface.bus_read_2(card->hw,
        card->hw_iface.bus_write_2(card->hw,
	card->hw_iface.bus_write_1(card->hw,
        card->hw_iface.bus_write_2(card->hw,
	card->hw_iface.fe_clear_bit(card->hw,0);
	card->hw_iface.bus_read_4(card->hw, AFT_FIFO_MARK_REG, &fifo_size);
	card->hw_iface.bus_write_4(card->hw, AFT_FIFO_MARK_REG, reg);		
	DEBUG_EVENT("%s:    Fifo Level Map:0x%08X\n",card->devname,reg);
	int		err = -EINVAL;
	card->hw_iface.hw_lock(card->hw,&smp_flags);
	wan_spin_lock_irq(&card->wandev.lock,&flags);
					card->devname);
					card->devname);
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	card->hw_iface.hw_unlock(card->hw,&smp_flags);
** Return:      0   - success
**              1   - channel out of channel map
**              < 0 - failed
			card->devname,
			fe_chan, WAN_FE_LINENO(&card->fe));
			card->devname, fe_chan);
		return -EINVAL;
	new_chan = 2 * WAN_FE_LINENO(&card->fe); /* 0, 2, 4...*/
	bri_chan = new_chan + (fe_chan-1); /* {0,1}, {2,3}, {4,5}... */
	card->hw_iface.bus_read_4(
			card->hw,
	DEBUG_HWEC("[HWEC BRI]: %s: writing: 0x%08X!\n",card->devname, value);
	card->hw_iface.bus_write_4(
			card->hw,
	WAN_ASSERT(card->hw_iface.bus_write_4 == NULL);
	WAN_ASSERT(card->hw_iface.bus_read_4 == NULL);
	if (card->hw_iface.fe_test_and_set_bit(card->hw,0)){
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE (%s:%d)!\n",
			card->devname, __FUNCTION__,__LINE__, fname, fline);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			card->devname, __FUNCTION__,__LINE__);
		return -EINVAL;
	card->hw_iface.fe_clear_bit(card->hw,0);
	WAN_ASSERT(card->hw_iface.bus_write_4 == NULL);
	WAN_ASSERT(card->hw_iface.bus_read_4 == NULL);
	if (card->hw_iface.fe_test_and_set_bit(card->hw,0)){
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE (%s:%d)!\n",
			card->devname, __FUNCTION__,__LINE__,fname,fline);
		DEBUG_EVENT("%s: %s:%d: Critical Error: Re-entry in FE!\n",
			card->devname, __FUNCTION__,__LINE__);
	card->hw_iface.fe_clear_bit(card->hw,0);
 * Read bri register - debugging version
	WAN_ASSERT(card->hw_iface.bus_write_4 == NULL);
	WAN_ASSERT(card->hw_iface.bus_read_4 == NULL);
	BRI_DBG("%s():%s\n", __FUNCTION__, card->devname);
			Calculate rm_no - should be between 0 and 3 (including). 
	if(rm_no > MAX_BRI_REMORAS - 1){
			card->devname, __FUNCTION__, __LINE__,	rm_no, mod_no);	
		card->hw_iface.bus_read_4(card->hw, SPI_INTERFACE_REG, dummy_ptr);
		DEBUG_EVENT("%s:%s(): Line:%d: SPI TIMEOUT!!\n", card->devname, __FUNCTION__, __LINE__);	
	card->hw_iface.bus_write_4(card->hw, SPI_INTERFACE_REG,	*data_ptr);	
		card->hw_iface.bus_read_4(card->hw, SPI_INTERFACE_REG, dummy_ptr);
		DEBUG_EVENT("%s:%s(): Line:%d: SPI TIMEOUT!!\n", card->devname, __FUNCTION__, __LINE__);	
		card->hw_iface.bus_read_4(card->hw, SPI_INTERFACE_REG, dummy_ptr);
		DEBUG_EVENT("%s:%s(): Line:%d: SPI TIMEOUT!!\n", card->devname, __FUNCTION__, __LINE__);	
	card->hw_iface.bus_write_4(card->hw, SPI_INTERFACE_REG, *data_ptr);	
		card->hw_iface.bus_read_4(card->hw, SPI_INTERFACE_REG, data_ptr);
		DEBUG_EVENT("%s:%s(): Line:%d: SPI TIMEOUT!!\n", card->devname, __FUNCTION__, __LINE__);	
		card->devname,
		card->devname,
		Calculate rm_no - should be between 0 and 3 (including). 
	if(rm_no > MAX_BRI_REMORAS - 1){
			card->devname, __FUNCTION__, __LINE__, rm_no, mod_no);	
		card->hw_iface.bus_read_4(card->hw, SPI_INTERFACE_REG, dummy_ptr);
		DEBUG_EVENT("%s:%s(): Line:%d: SPI TIMEOUT!!\n", card->devname, __FUNCTION__, __LINE__);	
	card->hw_iface.bus_write_4(	card->hw,	SPI_INTERFACE_REG,	*data_ptr);	
		card->hw_iface.bus_read_4(card->hw, SPI_INTERFACE_REG, dummy_ptr);
		DEBUG_EVENT("%s:%s(): Line:%d: SPI TIMEOUT!!\n", card->devname, __FUNCTION__, __LINE__);	
	card->hw_iface.bus_write_4(	card->hw,	SPI_INTERFACE_REG,	*data_ptr);	
	card->hw_iface.bus_read_4(card->hw, 0x40, dummy_ptr);
	card->hw_iface.bus_read_4(card->hw, SPI_INTERFACE_REG, dummy_ptr);
			card->devname, __FUNCTION__, __LINE__, *data_ptr, *dummy_ptr);			
	if (card->wandev.fe_iface.isdn_bri_dchan_tx){
		err = card->wandev.fe_iface.isdn_bri_dchan_tx(
					&card->fe,
			__FUNCTION__, card->devname);
	if (card->wandev.fe_iface.isdn_bri_dchan_rx){
		err = card->wandev.fe_iface.isdn_bri_dchan_rx(
					&card->fe, 
			__FUNCTION__, card->devname);
./aft_bri.c
	while ((jiffies-timeout)<(sec*HZ)){
 * wp_xilinx_init - Cisco HDLC protocol initialization routine.
 *  o initialize protocol-specific fields of the adapter data space.
	wan_clear_bit(CARD_DOWN,&card->wandev.critical);
	if (card->wandev.config_id != WANCONFIG_AFT_TE1_SS7) {
				  card->devname, card->wandev.config_id);
		return -EINVAL;
				card->devname);
		return -EINVAL;
	card->wandev.clocking 			= conf->clocking;
	card->wandev.ignore_front_end_status 	= conf->ignore_front_end_status;
	card->wandev.ttl 			= conf->ttl;
	card->wandev.electrical_interface 			= conf->electrical_interface;
	card->wandev.comm_port 			= conf->comm_port;
	card->wandev.udp_port   		= conf->udp_port;
	card->wandev.new_if_cnt 		= 0;
	wan_atomic_set(&card->wandev.if_cnt,0);
	memcpy(&card->u.xilinx.cfg,&conf->u.xilinx,sizeof(wan_xilinx_conf_t));
	card->u.xilinx.cfg.dma_per_ch = 10;
	if (IS_TE1_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_te_iface_init(&card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg	= card->hw_iface.fe_write;
		card->fe.read_fe_reg		= card->hw_iface.fe_read;
		card->wandev.fe_enable_timer = enable_timer;
		card->wandev.te_link_state = handle_front_end_state;
		conf->electrical_interface =
		if (card->wandev.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
	}else if (IS_56K_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_56k_iface_init(&card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg	= card->hw_iface.fe_write;
		card->fe.read_fe_reg		= card->hw_iface.fe_read;
		if (card->wandev.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
		card->fe.fe_status = FE_CONNECTED;
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
        card->wandev.update             = &update;
        card->wandev.new_if             = &new_if;
        card->wandev.del_if             = &del_if;
     	card->disable_comm              = &disable_comm;
	card->wandev.get_config_info 	= &get_config_info;
	card->wandev.get_status_info 	= &get_status_info;
	card->wandev.get_dev_config_info= &get_dev_config_info;
	card->wandev.get_if_info     	= &get_if_info;
	card->wandev.set_dev_config    	= &set_dev_config;
	card->wandev.set_if_info     	= &set_if_info;
	card->wandev.get_info		= &wan_aft_ss7_get_info;
	if(card->wandev.clocking) {
		card->wandev.bps = conf->bps;
        	card->wandev.bps = 0;
        card->wandev.mtu = conf->mtu;
        card->wandev.mtu =
                (conf->mtu >= MIN_WP_PRI_MTU) ?
                 wp_min(conf->mtu, MAX_WP_PRI_MTU) : DEFAULT_WP_PRI_MTU;
	if (!card->u.xilinx.cfg.mru){
		card->u.xilinx.cfg.mru = card->wandev.mtu;
	card->hw_iface.getcfg(card->hw, SDLA_BASEADDR, &card->u.xilinx.bar);
        card->isr = &wp_xilinx_isr;
	wan_init_timer(&card->u.xilinx.led_timer, 
	wan_add_timer(&card->u.xilinx.led_timer,HZ);
	DEBUG_EVENT("%s: Config:\n",card->devname);
			card->devname, 
			card->wandev.mtu);
			card->devname, 
			card->u.xilinx.cfg.mru);
 * update - Update wanpipe device status & statistics
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
	if(wan_test_bit(PERI_CRIT, (void*)&card->wandev.critical))
                return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
	if((chan=dev->priv) == NULL)
		return -ENODEV;
       	if(card->update_comms_stats){
		return -EAGAIN;
		DEBUG_EVENT("%s: Starting up Interfaces\n",card->devname);
		for (dev=card->wandev.dev;dev;dev=wan_next_dev(dev)){
			chan=dev->priv;
						dev->name,
		                wan_skb_queue_len(&chan->wp_tx_pending_list));
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
 * new_if - Create new logical channel.
 * to dev->priv pointer.
 * Also the dev->init pointer should also be initialized
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
			card->devname, dev->name);
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)){
			card->devname);
		return -EINVAL;
		WAN_MEM_ASSERT(card->devname);
		return -ENOMEM;
	chan->first_time_slot=-1;
	strncpy(chan->if_name, dev->name, WAN_IFNAME_SZ);
	chan->common.card = card;
	WAN_IFQ_INIT(&chan->wp_tx_free_list, 0);
	WAN_IFQ_INIT(&chan->wp_tx_pending_list,0);
	WAN_IFQ_INIT(&chan->wp_tx_complete_list,0);
	WAN_IFQ_INIT(&chan->wp_rx_free_list,0);
	WAN_IFQ_INIT(&chan->wp_rx_complete_list,0);
	wan_trace_info_init(&chan->trace_info,MAX_TRACE_QUEUE);
	WAN_TASKLET_INIT((&chan->common.bh_task), 0, wp_bh, chan);
	chan->common.dev = dev;
	chan->tracing_enabled = 0;
	chan->route_status = NO_ROUTE;
	chan->route_removed = 0;
	if(strcmp(conf->usedby, "WANPIPE") == 0) {
			wandev->name);
		chan->common.usedby = WANPIPE;
		if (conf->if_down){
			wan_set_bit(DYN_OPT_ON,&chan->interface_down);
			   card->devname,chan->if_name);
	} else if( strcmp(conf->usedby, "API") == 0) {
		chan->common.usedby = API;
			wandev->name,chan->if_name);
		wan_reg_api(chan, dev, card->devname);
	}else if (strcmp(conf->usedby, "BRIDGE") == 0) {
		chan->common.usedby = BRIDGE;
				card->devname,chan->if_name);
	}else if (strcmp(conf->usedby, "BRIDGE_N") == 0) {
		chan->common.usedby = BRIDGE_NODE;
				card->devname,chan->if_name);
	}else if (strcmp(conf->usedby, "TDM_VOICE") == 0) {
		chan->common.usedby = TDM_VOICE;
				card->devname,chan->if_name);
	}else if (strcmp(conf->usedby, "STACK") == 0) {
		chan->common.usedby = STACK;
				card->devname,chan->if_name);
				card->devname,chan->if_name);
		err=-EINVAL;
	if (chan->common.usedby == TDM_VOICE){
			err = -EINVAL;
	chan->hdlc_eng = conf->hdlc_streaming;
	if (!chan->hdlc_eng){
		if (card->u.xilinx.cfg.mru&0x03){
					card->devname,chan->if_name);
			err = -EINVAL;
	chan->time_slot_map=conf->active_ch;
	if (!chan->hdlc_eng){
		if (!chan->max_idle_size){
			chan->max_idle_size=card->u.xilinx.cfg.mru;
			card->devname,chan->if_name);
				card->devname,chan->if_name,
				chan->idle_flag);
				card->devname,chan->if_name,
				chan->max_idle_size);
		//chan->idle_flag=0x7E;     
		chan->idle_flag=0;     
		if (chan->common.usedby == TDM_VOICE){
			chan->idle_flag = WAN_TDMV_IDLE_FLAG;
		chan->tx_idle_skb = wan_skb_alloc(chan->max_idle_size); 
		if (!chan->tx_idle_skb){
			err=-ENOMEM;
		buf=skb_put(chan->tx_idle_skb,chan->max_idle_size);
		memset(buf,chan->idle_flag,chan->max_idle_size);
	chan->dma_mru = card->u.xilinx.cfg.mru;
	chan->dma_mru = xilinx_valid_mtu(chan->dma_mru+100);
	if (!chan->dma_mru){
			card->devname,
			chan->if_name,
			card->wandev.mtu,card->u.xilinx.cfg.mru);
		err= -EINVAL;
			card->devname,chan->if_name,
			card->u.xilinx.cfg.dma_per_ch,
			chan->dma_mru);
	err=aft_alloc_rx_dma_buff(card, chan, card->u.xilinx.cfg.dma_per_ch);
	 *      is brought back up, we must know to re-astablish the
	if ((chan->gateway = conf->gateway) == WANOPT_YES){
			card->devname,chan->if_name);
	chan->mc = conf->mc;
	 * 	dev->if_init : function that will be called
	 * 	dev->priv    : private structure allocated above
					   &chan->dent,
					   chan->if_name,
			card->devname, chan->if_name);
	dev->init = &if_init;
	dev->priv = chan;
	wan_atomic_inc(&card->wandev.if_cnt);
	chan->common.state = WAN_CONNECTING;
	while ((skb=wan_skb_dequeue(&chan->wp_tx_free_list)) != NULL){
	while ((skb=wan_skb_dequeue(&chan->wp_rx_free_list)) != NULL){
	WAN_TASKLET_KILL(&chan->common.bh_task);
	if (chan->common.usedby == API){
		wan_unreg_api(chan, card->devname);
	if (chan->tx_idle_skb){
		wan_skb_free(chan->tx_idle_skb);
		chan->tx_idle_skb=NULL;
	dev->priv=NULL;
 * del_if - Delete logical channel.
 * NOTE: DO NOT deallocate dev->priv here! It will be
	private_area_t* 	chan = dev->priv;
	sdla_t*			card = (sdla_t*)chan->common.card;
	if (chan->common.usedby == TDM_VOICE){
	WAN_TASKLET_KILL(&chan->common.bh_task);
	if (chan->common.usedby == API){
		wan_unreg_api(chan, card->devname);
	while ((skb=wan_skb_dequeue(&chan->wp_rx_free_list)) != NULL){
	while ((skb=wan_skb_dequeue(&chan->wp_rx_complete_list)) != NULL){
	while ((skb=wan_skb_dequeue(&chan->wp_tx_free_list)) != NULL){
	while ((skb=wan_skb_dequeue(&chan->wp_tx_pending_list)) != NULL){
        if (chan->tx_dma_addr && chan->tx_dma_len){
                                 chan->tx_dma_addr,
                                 chan->tx_dma_len,
                chan->tx_dma_addr=0;
                chan->tx_dma_len=0;
	if (chan->tx_dma_skb){
		wan_skb_free(chan->tx_dma_skb);
		chan->tx_dma_skb=NULL;
	if (chan->tx_idle_skb){
		wan_skb_free(chan->tx_idle_skb);
		chan->tx_idle_skb=NULL;
	if (chan->rx_dma_skb){
		netskb_t *skb=chan->rx_dma_skb;
		chan->rx_dma_skb=NULL;
		rx_el=(wp_rx_element_t *)&skb->cb[0];
			 rx_el->dma_addr,
			 chan->dma_mru,
	wanrouter_proc_delete_interface(wandev, chan->if_name);
	wan_atomic_dec(&card->wandev.if_cnt);
 * if_init - Initialize Linux network interface.
	private_area_t* chan = dev->priv;
	sdla_t*		card = (sdla_t*)chan->common.card;
	wan_device_t* 	wandev = &card->wandev;
	dev->open		= &wanpipe_xilinx_open;
	dev->stop		= &wanpipe_xilinx_close;
	dev->hard_start_xmit	= &wanpipe_xilinx_send;
	dev->get_stats		= &wanpipe_xilinx_ifstats;
	dev->tx_timeout		= &wanpipe_xilinx_tx_timeout;
	dev->watchdog_timeo	= TX_TIMEOUT;
	dev->do_ioctl		= wanpipe_xilinx_ioctl;
	if (chan->common.usedby == BRIDGE ||
       	    chan->common.usedby == BRIDGE_NODE){
		memcpy(dev->dev_addr, "\xFE\xFC\x00\x00\x00\x00", 6);
		*(int *)(dev->dev_addr + 2) += hw_addr;
		if (chan->protocol != WANCONFIG_PPP &&
		    chan->protocol != WANCONFIG_CHDLC){
			dev->flags     |= IFF_POINTOPOINT;
			dev->flags     |= IFF_NOARP;
			dev->type	= ARPHRD_PPP;
			dev->mtu		= card->wandev.mtu;
			dev->hard_header_len	= 0;
			dev->hard_header	= NULL; 
			dev->rebuild_header	= NULL;
		if (chan->mc == WANOPT_YES){
			dev->flags 	|= IFF_MULTICAST;
		if (chan->true_if_encoding){
			dev->type	= ARPHRD_HDLC; /* This breaks the tcpdump */
			dev->type	= ARPHRD_PPP;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start);
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end);
        dev->tx_queue_len = 100;
 * if_open - Open network interface.
	private_area_t* chan = dev->priv;
	sdla_t* card = (sdla_t*)chan->common.card;
		return -EBUSY;
	chan->router_start_time = tv.tv_sec;
	if (card->wandev.state == WAN_CONNECTED){
	if (!chan->hdlc_eng){
			dev->name);
        	card->hw_iface.bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
        	card->hw_iface.bus_write_4(card->hw,
                        (reg|(chan->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));
		card->hw_iface.bus_read_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG,&reg1);
			dev->name,reg,reg1);
                                       chan->first_time_slot,
	chan->ignore_modem=0x0F;
        if (card->wandev.state == WAN_CONNECTED){
	DEBUG_TEST("%s: Opened!\n",dev->name);
 * if_close - Close network interface.
	private_area_t* chan = dev->priv;
	sdla_t* card = (sdla_t*)chan->common.card;
	dev->start=0;
	chan->common.state = WAN_DISCONNECTED;
	chan->ignore_modem=0x00;
 * disable_comm - Main shutdown function
	wan_set_bit(CARD_DOWN,&card->wandev.critical);
	wan_del_timer(&card->u.xilinx.led_timer);
	/* TE1 - Unconfiging, only on shutdown */
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
	wan_spin_lock_irq(&card->wandev.lock,&flags);
	card->isr=NULL;
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
    	private_area_t* chan = dev->priv;
	sdla_t *card = (sdla_t*)chan->common.card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++chan->if_stats.collisions;
	DEBUG_EVENT( "%s: Transmit timed out on %s\n", card->devname,dev->name);
			chan->if_name,
			chan->dma_status,
			chan->tx_dma_addr,
			chan->tx_dma_len);
 * if_send - Send a packet on a network interface.
 * 	Return a non-zero value to tell the stack
 *		non-0	packet may be re-transmitted
	private_area_t *chan = dev->priv;
	sdla_t *card = (sdla_t*)chan->common.card;
			card->devname, dev->name);
	if (dev->tbusy){
		 * kick start the device by making dev->tbusy = 0.  We expect
                ++chan->if_stats.collisions;
		if((jiffies - chan->tick_counter) < (5 * HZ)) {
	if (chan->common.state != WAN_CONNECTED){
		++chan->if_stats.tx_carrier_errors;
	}else if (chan->protocol == WANCONFIG_FR && chan->prot_state != WAN_CONNECTED){
		++chan->if_stats.tx_carrier_errors;
		if (chan->common.usedby == API){
			api_tx_hdr_t *api_tx_hdr = (api_tx_hdr_t *)skb->data;
			if (sizeof(api_tx_hdr_t) >= skb->len){
				++chan->if_stats.tx_dropped;
			skb->csum=api_tx_hdr->ss7_prot_len;
		if (wan_skb_queue_len(&chan->wp_tx_pending_list) > MAX_TX_BUF){
			chan->if_stats.tx_errors++;
			wan_skb_queue_tail(&chan->wp_tx_pending_list,skb);
		 	dev->trans_start = jiffies;
 * chk_bcast_mcast_addr - Check for source broadcast addresses
	private_area_t *chan=dev->priv;
        src_ip_addr = *(u32 *)(skb->data + 12);
	if (chan->common.usedby != WANPIPE){
        in_dev = dev->ip_ptr;
                struct in_ifaddr *ifa= in_dev->ifa_list;
                        broadcast_ip_addr = ifa->ifa_broadcast;
        if((dev->flags & IFF_BROADCAST) && (src_ip_addr == broadcast_ip_addr)) {
				card->devname);
				card->devname);
	if ((chan=dev->priv) == NULL)
                        dev->name,
                        wan_skb_queue_len(&chan->wp_rx_complete_list),
                        wan_skb_queue_len(&chan->wp_rx_free_list),
                        wan_skb_queue_len(&chan->wp_tx_pending_list));
	return &chan->if_stats;
 * if_do_ioctl - Ioctl handler for fr
	private_area_t* chan= (private_area_t*)dev->priv;
		return -ENODEV;
	card=(sdla_t*)chan->common.card;
				err= -EINVAL;
			wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
			err=wan_bind_api_to_svc(chan,ifr->ifr_data);
			wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
			chan->if_stats.tx_errors=0;
				err= -EINVAL;
			wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
			err=wan_unbind_api_from_svc(chan,ifr->ifr_data);
			wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
			err = chan->common.state;
			if (wan_atomic_read(&chan->udp_pkt_len) != 0){
				return -EBUSY;
			wan_atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
			if (wan_test_bit(0,&card->in_isr)){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EBUSY;
			wan_udp_pkt=(wan_udp_pkt_t*)chan->udp_pkt_data;
			if (copy_from_user(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			if (wan_test_bit(0,&card->in_isr)) {
						card->devname,dev->name);
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EBUSY;
			if (wan_atomic_read(&chan->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						card->devname,wan_atomic_read(&chan->udp_pkt_len));
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EINVAL;
			if (copy_to_user(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			wan_atomic_set(&chan->udp_pkt_len,0);
				card->devname,cmd);
			return -EOPNOTSUPP;
    	DEBUG_CFG("Xilinx Chip Configuration. -- \n");
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
		card->u.xilinx.num_of_time_slots=NUM_OF_T1_CHANNELS;
		card->u.xilinx.num_of_time_slots=NUM_OF_E1_CHANNELS;
				card->devname);
		return -EINVAL;
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
        card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
        card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
        card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	DEBUG_CFG("--- Chip Reset. -- \n");
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &adapter_type);
            card->wandev.S514_cpu_no[0] == SDLA_CPU_B){
			card->devname);
		//return -ENODEV;
			card->devname,adapter_type);
			card->devname);
                        card->devname);
                        card->devname);
                        card->devname);
                        card->devname,adptr_security);
		//return -EINVAL;
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);		
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
                                        card->devname);
                	        card->devname);
	err = -EINVAL;
	if (card->wandev.fe_iface.config){
		err = card->wandev.fe_iface.config(&card->fe);
                                	card->devname,
               	return -EINVAL;
					card->devname);
		card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
		card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
                                        card->devname,reg);
    	DEBUG_CFG("--- Setup DMA control Reg. -- \n");
	card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
	DEBUG_CFG("--- Tx/Rx global enable. -- \n");
	card->hw_iface.bus_write_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG,reg);
	card->hw_iface.bus_read_4(card->hw, XILINX_DMA_RX_INTR_PENDING_REG, &tmp);
	card->hw_iface.bus_read_4(card->hw, XILINX_DMA_TX_INTR_PENDING_REG, &tmp);
	card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_RX_INTR_PENDING_REG, &tmp);
	card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_TX_INTR_PENDING_REG, &tmp);
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, (u32*)&reg);
					card->devname);
		card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
					card->devname);
		card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
    	DEBUG_CFG("--- Set Global Interrupts (0x%X)-- \n",reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	DEBUG_CFG("--- Set Global Interrupt enabled. -- \n");
        card->hw_iface.bus_write_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG,reg);
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
    	DEBUG_TEST("-- Configure Xilinx. --\n");
	chan->logic_ch_num=-1;
		return -EINVAL;
			chan->if_name,
			chan->time_slot_map,
			chan->time_slot_map<<1);
		chan->time_slot_map=chan->time_slot_map<<1;
		wan_clear_bit(0,&chan->time_slot_map);
	if (chan->time_slot_map == 0){
				card->devname,chan->time_slot_map);
		return -EINVAL;
		card->devname,chan->if_name,chan->time_slot_map);
	for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
		if (wan_test_bit(i,&chan->time_slot_map)){
			if (chan->first_time_slot == -1){
						card->devname,chan->if_name,i);
				chan->first_time_slot=i;
					card->devname, chan->if_name, 
			if (wan_test_bit(i,&card->u.xilinx.time_slot_map)){
						card->devname);
						card->devname,chan->if_name,(i+1));
				return -EEXIST;
			++chan->num_of_time_slots;
	chan->logic_ch_num=request_xilinx_logical_channel_num(card, chan, &free_logic_ch);
	if (chan->logic_ch_num == -1){
		return -EBUSY;
		__FUNCTION__,__LINE__,chan->logic_ch_num,free_logic_ch);
	for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
		if (wan_test_bit(i,&chan->time_slot_map)){
			wan_set_bit(i,&card->u.xilinx.time_slot_map);
			card->hw_iface.bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
			card->hw_iface.bus_write_4(card->hw,
			reg=chan->logic_ch_num&CONTROL_RAM_DATA_MASK;
			reg|=(chan->fifo_size_code&HDLC_FIFO_SIZE_MASK)<<HDLC_FIFO_SIZE_SHIFT;
			reg|=(chan->fifo_base_addr&HDLC_FIFO_BASE_ADDR_MASK)<<
			if (!chan->hdlc_eng){
				        i, chan->logic_ch_num,reg);
	if (free_logic_ch != -1){
		if (wan_atomic_read(&card->wandev.if_cnt)==3){
		for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
			if (!wan_test_bit(i,&card->u.xilinx.time_slot_map)){
				card->hw_iface.bus_read_4(card->hw, 
				card->hw_iface.bus_write_4(card->hw,
					chan->if_name,free_logic_ch);
			card->hw_iface.bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
			card->hw_iface.bus_write_4(card->hw,
                                               chan->first_time_slot,
	card->hw_iface.bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
	card->hw_iface.bus_write_4(card->hw,
			(reg|(chan->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));
	if (chan->hdlc_eng){
                        card->devname,chan->if_name);
                                       chan->first_time_slot,
                               chan->first_time_slot,
	DEBUG_CFG("\n-- Unconfigure Xilinx. --\n");
	if (chan->logic_ch_num != -1){
		card->hw_iface.bus_read_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
		card->hw_iface.bus_write_4(card->hw,
				(reg|(chan->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));
                               chan->first_time_slot,
	        for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
        	        if (wan_test_bit(i,&chan->time_slot_map)){
                        	card->hw_iface.bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
                        	card->hw_iface.bus_write_4(card->hw,
		wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		free_xilinx_logical_channel_num(card,chan->logic_ch_num);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		chan->logic_ch_num=-1;
		for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
			if (wan_test_bit(i,&chan->time_slot_map)){
				wan_clear_bit(i,&card->u.xilinx.time_slot_map);
        dma_descr=(unsigned long)(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
                                __FUNCTION__,chan->if_name,
       	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
			card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
				card->devname,chan->if_name,i*FIFO_RESET_TIMEOUT_US);
				card->devname,chan->if_name,i*FIFO_RESET_TIMEOUT_US); 
        dma_descr=(unsigned long)(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
                                __FUNCTION__,chan->if_name,
        card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
                	card->hw_iface.bus_read_4(card->hw,dma_descr,&reg);
                                card->devname,chan->if_name,i*FIFO_RESET_TIMEOUT_US);
                                card->devname,chan->if_name,i*FIFO_RESET_TIMEOUT_US);
	DEBUG_TEST("%s: Enabling Global Inter Mask !\n",chan->if_name);
	card->hw_iface.bus_read_4(card->hw,
	wan_set_bit(chan->logic_ch_num,&reg);
	card->hw_iface.bus_write_4(card->hw,
	wan_set_bit(chan->logic_ch_num,&card->u.xilinx.active_ch_map);
//    	DEBUG_RX("%s: Setup Rx DMA descriptor \n",chan->if_name);
	dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
	card->hw_iface.bus_read_4(card->hw,dma_descr, &reg);
				card->devname);
		return -EFAULT;
	if (chan->rx_dma_skb){
		DEBUG_EVENT("%s: Critial Error: Rx Dma Buf busy!\n",chan->if_name);
		return -EINVAL;
	chan->rx_dma_skb = wan_skb_dequeue(&chan->wp_rx_free_list);
	if (!chan->rx_dma_skb){
				chan->if_name,wan_skb_queue_len(&chan->wp_rx_free_list),
				wan_skb_queue_len(&chan->wp_rx_complete_list));
		chan->rx_dma_skb = wan_skb_dequeue(&chan->wp_rx_free_list);
		if (!chan->rx_dma_skb){
			return -ENOMEM;
		chan->rx_dma_skb = wan_skb_dequeue(&chan->wp_rx_free_list);
		if (!chan->rx_dma_skb){
					chan->if_name);
			return -ENOMEM;
	rx_el = (wp_rx_element_t *)&chan->rx_dma_skb->cb[0];
		      	       		chan->rx_dma_skb->tail,
					chan->dma_mru,
				chan->if_name,__FUNCTION__);
		return -EINVAL;
	rx_el->dma_addr=bus_addr;
    	dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_LO;
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	dma_descr=(unsigned long)(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
	if (chan->hdlc_eng){
		reg|=(chan->dma_mru>>2)&RxDMA_HI_DMA_DATA_LENGTH_MASK;
		reg|=(card->u.xilinx.cfg.mru>>2)&RxDMA_HI_DMA_DATA_LENGTH_MASK;
	reg|=(chan->fifo_size_code&DMA_FIFO_SIZE_MASK)<<DMA_FIFO_SIZE_SHIFT;
        reg|=(chan->fifo_base_addr&DMA_FIFO_BASE_ADDR_MASK)<<
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	wan_set_bit(0,&chan->rx_dma);
    	DEBUG_CFG("-- Close Xilinx device. --\n");
        card->hw_iface.bus_read_4(card->hw,
        wan_clear_bit(chan->logic_ch_num,&reg);
	wan_clear_bit(chan->logic_ch_num,&card->u.xilinx.active_ch_map);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
        card->hw_iface.bus_write_4(card->hw,
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
 	card->hw_iface.bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
       	card->hw_iface.bus_write_4(card->hw,
                       (reg|(chan->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));
                               chan->first_time_slot,
	dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
    	DEBUG_TX("------ Setup Tx DMA descriptor. --\n");
	if (wan_test_and_set_bit(TX_BUSY,&chan->dma_status)){
		return -EBUSY;
         * and we must re-transmit.*/
        if (chan->tx_dma_addr && chan->tx_dma_len){
                                 chan->tx_dma_addr,
                                 chan->tx_dma_len,
                                chan->if_name,__FUNCTION__);
                chan->tx_dma_addr=0;
		chan->tx_dma_len=0;
	if (chan->tx_dma_skb){
				chan->if_name,__FUNCTION__);
		wan_skb_free(chan->tx_dma_skb);
		chan->tx_dma_skb=NULL;
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
                        __FUNCTION__,__LINE__,chan->logic_ch_num,dma_descr);
	card->hw_iface.bus_read_4(card->hw,dma_descr, &reg);
				card->devname,reg);
		wan_clear_bit(TX_BUSY,&chan->dma_status);
		return -EFAULT;
	if (chan->common.usedby == TDM_VOICE){
		skb=wan_skb_dequeue(&chan->wp_tx_pending_list);
		if (chan->hdlc_eng){
			wan_clear_bit(TX_BUSY,&chan->dma_status);
			return -ENOBUFS;
		len=chan->tx_idle_skb->len;
		chan->tx_dma_addr = pci_map_single(NULL,
					  chan->tx_idle_skb->data,
					  chan->tx_idle_skb->len,
		chan->tx_dma_len = chan->tx_idle_skb->len;
		chan->if_stats.tx_errors++;
		len=skb->len;
		if (skb->len > MAX_XILINX_TX_DMA_SIZE){
			wan_clear_bit(TX_BUSY,&chan->dma_status);
			return -EINVAL;
		chan->tx_dma_addr = pci_map_single(NULL,
					  skb->data,
					  skb->len,
		chan->tx_dma_len=skb->len;
		ss7_len=skb->csum;
		if ((chan->tx_dma_addr + (skb->len-ss7_len)) & 0x03){
					card->devname);
                        	         chan->tx_dma_addr,
                                	 chan->tx_dma_len,
			chan->tx_dma_addr=0;
			chan->tx_dma_len=0;
			wan_clear_bit(TX_BUSY,&chan->dma_status);
			return -EINVAL;
	if (chan->tx_dma_addr & 0x03){
				card->devname);
                                 chan->tx_dma_addr,
                                 chan->tx_dma_len,
		chan->tx_dma_addr=0;
		chan->tx_dma_len=0;
		wan_clear_bit(TX_BUSY,&chan->dma_status);
		return -EINVAL;
		chan->tx_dma_skb=skb;
			*(unsigned int*)&skb->data[0],
			*(unsigned int*)&skb->data[4],
			*(unsigned int*)&skb->data[8],
			*(unsigned int*)&skb->data[12]);
			skb,skb->list,skb->data,chan->tx_dma_addr);
		chan->tx_dma_skb=NULL;
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_LO;
	reg=chan->tx_dma_addr;
			__FUNCTION__,reg,chan->tx_dma_addr,dma_descr);
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
        reg|=(chan->fifo_size_code&DMA_FIFO_SIZE_MASK)<<DMA_FIFO_SIZE_SHIFT;
        reg|=(chan->fifo_base_addr&DMA_FIFO_BASE_ADDR_MASK)<<
	if (chan->hdlc_eng){
                 * non-transparent hdlc configuration */
	card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
	++chan->if_stats.tx_fifo_errors;
	++chan->if_stats.tx_carrier_errors;
//      card->hw_iface.bus_read_4(card->hw,0x78, &tmp1); 
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
	card->hw_iface.bus_read_4(card->hw,dma_descr, &reg);
    	if (!chan->tx_dma_skb){
		if (chan->hdlc_eng){
                    			card->devname);
			wan_clear_bit(TX_BUSY,&chan->dma_status);
				 chan->tx_dma_addr,
				 chan->tx_dma_len,
			chan->tx_dma_addr=0;
			chan->tx_dma_len=0;
        		wan_set_bit(0,&chan->idle_start);
			wan_clear_bit(TX_BUSY,&chan->dma_status);
				 chan->tx_dma_addr,
				 chan->tx_dma_len,
		chan->tx_dma_addr=0;
		chan->tx_dma_len=0;
		if (chan->hdlc_eng){
                                        card->devname,chan->if_name,reg);
				if (++chan->pci_retry < 3){
        				card->hw_iface.bus_write_4(card->hw,dma_descr,reg);
			chan->pci_retry=0;
			chan->tx_dma_skb->csum = reg;	
			wan_skb_queue_tail(&chan->wp_tx_complete_list,chan->tx_dma_skb);	
			chan->tx_dma_skb=NULL;
			wan_clear_bit(TX_BUSY,&chan->dma_status);
			WAN_TASKLET_SCHEDULE(&chan->common.bh_task);
			netskb_t *skb = chan->tx_dma_skb;
			chan->tx_dma_skb=NULL;
			skb->csum = reg;
			wan_clear_bit(TX_BUSY,&chan->dma_status);
//	card->hw_iface.bus_read_4(card->hw,0x78, &tmp1); 
	unsigned long reg = skb->csum;
			card->devname,chan->if_name,reg);
                   		card->devname,chan->if_name);
                   		card->devname,chan->if_name);
                	     		card->devname,chan->if_name);
                	     		card->devname,chan->if_name);
                	     		card->devname,chan->if_name);
                	     		card->devname,chan->if_name);
		chan->if_stats.tx_dropped++;
	chan->if_stats.tx_packets++;
	chan->if_stats.tx_bytes+=skb->len;
        wan_set_bit(0,&chan->idle_start);
	if (WAN_NETIF_QUEUE_STOPPED(chan->common.dev)){
		WAN_NETIF_WAKE_QUEUE(chan->common.dev);
		if (chan->common.usedby == API){
		}else if (chan->common.usedby == STACK){
	wan_clear_bit(0,&chan->rx_dma);
	if (!chan->rx_dma_skb){
		DEBUG_EVENT("%s: Critical Error: rx_dma_skb\n",chan->if_name);
	rx_el=(wp_rx_element_t *)&chan->rx_dma_skb->cb[0];
	chan->if_stats.rx_frame_errors++;
//    	card->hw_iface.bus_read_4(card->hw,0x80, &rx_empty); 
	dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_LO;
	card->hw_iface.bus_read_4(card->hw,dma_descr, &rx_el->align);
	rx_el->align&=RxDMA_LO_ALIGNMENT_BIT_MASK;
    	dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
	card->hw_iface.bus_read_4(card->hw,dma_descr, &rx_el->reg);
	rx_el->pkt_error = chan->pkt_error;
	chan->pkt_error=0;
			 rx_el->dma_addr,
			 chan->dma_mru,
		__FUNCTION__,chan->if_name,rx_el->reg,rx_el->align,rx_el->dma_addr);   
	skb=chan->rx_dma_skb;
	chan->rx_dma_skb=NULL;
	wan_skb_queue_tail(&chan->wp_rx_complete_list,skb);
	WAN_TASKLET_SCHEDULE(&chan->common.bh_task);
	WAN_TASKLET_SCHEDULE(&chan->common.bh_task);
//    	card->hw_iface.bus_read_4(card->hw,0x80, &rx_empty); 
	wp_rx_element_t *rx_el=(wp_rx_element_t *)&skb->cb[0];
		__FUNCTION__,chan->if_name,rx_el->reg,rx_el->align,rx_el->dma_addr);   
	chan->if_stats.rx_errors++;
	rx_el->align&=RxDMA_LO_ALIGNMENT_BIT_MASK;
	if (wan_test_bit(RxDMA_HI_DMA_GO_READY_BIT,&rx_el->reg)){
				card->devname,chan->if_name);
		chan->if_stats.rx_errors++;
	if (rx_el->reg&RxDMA_HI_DMA_PCI_ERROR_MASK){
		if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_M_ABRT){
                                   card->devname,chan->if_name);
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_T_ABRT){
                                   card->devname,chan->if_name);
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_DS_TOUT){
                                    card->devname,chan->if_name);
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_RETRY_TOUT){
                                    card->devname,chan->if_name);
		DEBUG_EVENT("%s: RXDMA PCI ERROR = 0x%x\n",chan->if_name,rx_el->reg);
		chan->if_stats.rx_errors++;
	if (chan->hdlc_eng){
		if (!wan_test_bit(RxDMA_HI_DMA_FRAME_START_BIT,&rx_el->reg)){
					card->devname,chan->if_name,rx_el->reg);
			chan->if_stats.rx_frame_errors++;
		if (!wan_test_bit(RxDMA_HI_DMA_FRAME_END_BIT,&rx_el->reg)){
					card->devname,chan->if_name,rx_el->reg);
			chan->if_stats.rx_frame_errors++;
			if (wan_test_bit(RxDMA_HI_DMA_CRC_ERROR_BIT,&rx_el->reg)){
                                		card->devname,chan->if_name,rx_el->reg);
				chan->if_stats.rx_errors++;
				wan_set_bit(WP_CRC_ERROR_BIT,&rx_el->pkt_error);	
			if (wan_test_bit(RxDMA_HI_DMA_FRAME_ABORT_BIT,&rx_el->reg)){
						card->devname,chan->if_name,rx_el->reg);
				chan->if_stats.rx_frame_errors++;
				wan_set_bit(WP_ABORT_ERROR_BIT,&rx_el->pkt_error);
			if (chan->common.usedby != API && data_error){
	len=rx_el->reg&RxDMA_HI_DMA_DATA_LENGTH_MASK;
	if (chan->hdlc_eng){
		len=(((chan->dma_mru>>2)-len)<<2) - (~(rx_el->align)&RxDMA_LO_ALIGNMENT_BIT_MASK);
		len=(((card->u.xilinx.cfg.mru>>2)-len)<<2) - (~(0x03)&RxDMA_LO_ALIGNMENT_BIT_MASK);
	*pkt_error=rx_el->pkt_error;
	if (wan_test_bit(WP_FIFO_ERROR_BIT,&rx_el->pkt_error)){
		if (++chan->rx_fifo_err_cnt >= WP_MAX_FIFO_FRAMES){
			chan->rx_fifo_err_cnt=0;
		if (chan->rx_fifo_err_cnt){
			if (++chan->rx_fifo_err_cnt >= WP_MAX_FIFO_FRAMES){
                        	chan->rx_fifo_err_cnt=0;
		memset(&skb->cb[0],0,sizeof(wp_rx_element_t));
				card->devname,chan->if_name,(len+20));
			chan->if_stats.rx_dropped++;
		memcpy(buf,skb->tail,len);
	char logic_ch=-1, free_logic_ch=-1;
	*free_ch=-1;
	DEBUG_TEST("-- Request_Xilinx_logic_channel_num:--\n");
                card->u.xilinx.num_of_time_slots,
                card->u.xilinx.logic_ch_map);
		return -1;
	for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
		if (!wan_test_and_set_bit(i,&card->u.xilinx.logic_ch_map)){
	if (logic_ch == -1){
	for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
		if (!wan_test_bit(i,&card->u.xilinx.logic_ch_map)){
	if (card->u.xilinx.dev_to_ch_map[(unsigned char)logic_ch]){
				card->devname,logic_ch);
		return -1;
	card->u.xilinx.dev_to_ch_map[(unsigned char)logic_ch]=(void*)chan;
	if (logic_ch > card->u.xilinx.top_logic_ch){
		card->u.xilinx.top_logic_ch=logic_ch;
	clear_bit (logic_ch,&card->u.xilinx.logic_ch_map);
	card->u.xilinx.dev_to_ch_map[logic_ch]=NULL;
	if (logic_ch >= card->u.xilinx.top_logic_ch){
		card->u.xilinx.top_logic_ch=XILINX_DEFLT_ACTIVE_CH;
		for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
			if (card->u.xilinx.dev_to_ch_map[logic_ch]){
				card->u.xilinx.top_logic_ch=i;
	DEBUG_CFG("-- Xilinx_dma_max_logic_ch :--\n");
	card->hw_iface.bus_read_4(card->hw,XILINX_DMA_CONTROL_REG, &reg);
        reg|=(card->u.xilinx.top_logic_ch << DMA_ACTIVE_CHANNEL_BIT_SHIFT);
        card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
	memset(&skb->cb[0],0,sizeof(wp_rx_element_t));
	wan_skb_queue_tail(&chan->wp_rx_free_list,skb);
	while((skb=wan_skb_dequeue(&chan->wp_rx_complete_list)) != NULL){
		chan->if_stats.rx_dropped++;
		skb=wan_skb_alloc(chan->dma_mru);
					chan->if_name,__FUNCTION__);
			return -ENOMEM;
		wan_skb_queue_tail(&chan->wp_rx_free_list,skb);
	DEBUG_TEST("%s: %s Sdla Polling!\n",__FUNCTION__,card->devname);
	wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
	card->wandev.fe_iface.polling(&card->fe);
	wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
	if (!(chan->common.dev->flags&IFF_UP)){
                                chan->if_name);
	while((skb=wan_skb_dequeue(&chan->wp_rx_complete_list)) != NULL){
		chan->if_stats.rx_errors++;
		if (chan->common.usedby == API && chan->common.sk == NULL){
				chan->if_name);
			chan->if_stats.rx_fifo_errors++;
		xilinx_rx_post_complete (chan->common.card, chan,
			int len=new_skb->len;
			capture_trace_packet(chan->common.card,chan,
			if (chan->common.usedby == API){
					rx_hdr->error_flag=pkt_error;
							chan->if_name,
					++chan->if_stats.rx_dropped;
				new_skb->protocol = htons(PVC_PROT);
				new_skb->mac.raw  = new_skb->data;
				new_skb->dev      = chan->common.dev;
				new_skb->pkt_type = WAN_PACKET_DATA;	
				chan->if_stats.rx_frame_errors++;
							chan->if_name);
					++chan->if_stats.rx_dropped;
			}else if (chan->common.usedby == TDM_VOICE){
				++chan->if_stats.rx_dropped;
			}else if (chan->common.usedby == STACK){
					++chan->if_stats.rx_dropped;
				new_skb->protocol = htons(ETH_P_IP);
				new_skb->dev = chan->common.dev;
				new_skb->mac.raw  = new_skb->data;
			chan->if_stats.rx_packets++;
			chan->if_stats.rx_bytes+=len;
	while((skb=wan_skb_dequeue(&chan->wp_tx_complete_list)) != NULL){
		xilinx_tx_post_complete (chan->common.card,chan,skb);
	if ((len=wan_skb_queue_len(&chan->wp_rx_complete_list))){
		DEBUG_TEST("%s: Triggering from bh rx=%i\n",chan->if_name,len); 
		WAN_TASKLET_SCHEDULE(&chan->common.bh_task);
	}else if ((len=wan_skb_queue_len(&chan->wp_tx_complete_list))){
                DEBUG_TEST("%s: Triggering from bh tx=%i\n",chan->if_name,len); 
		WAN_TASKLET_SCHEDULE(&chan->common.bh_task);
        card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_TX_INTR_PENDING_REG,&tx_status);
        card->hw_iface.bus_read_4(card->hw,XILINX_HDLC_RX_INTR_PENDING_REG,&rx_status);
	if (card->wandev.state != WAN_CONNECTED){
                                  card->devname);
	tx_status&=card->u.xilinx.active_ch_map;
	rx_status&=card->u.xilinx.active_ch_map;
		for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
			if (wan_test_bit(i,&tx_status) && test_bit(i,&card->u.xilinx.logic_ch_map)){
				chan=(private_area_t*)card->u.xilinx.dev_to_ch_map[i];
				if (!(chan->common.dev->flags&IFF_UP)){
						chan->common.dev->name,chan->common.state,chan->ignore_modem);
				if (chan->common.state != WAN_CONNECTED){
                                                chan->common.dev->name);
				if (!chan->hdlc_eng && !wan_test_bit(0,&chan->idle_start)){
                                                chan->common.dev->name);
					if (chan->hdlc_eng){
                           		card->devname,chan->if_name,chan->logic_ch_num,i);
				err=-EINVAL;
		for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
			if (wan_test_bit(i,&rx_status) && test_bit(i,&card->u.xilinx.logic_ch_map)){
				chan=(private_area_t*)card->u.xilinx.dev_to_ch_map[i];
				if (!(chan->common.dev->flags&IFF_UP)){
						chan->common.dev->name,chan->common.state,chan->ignore_modem);
				if (chan->common.state != WAN_CONNECTED){
                                                chan->common.dev->name);
                           		card->devname,chan->if_name,chan->logic_ch_num,i,
					wan_skb_queue_len(&chan->wp_rx_complete_list),
					wan_skb_queue_len(&chan->wp_rx_free_list),
					chan->rx_dma);
			     	dma_descr=(chan->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
			        card->hw_iface.bus_read_4(card->hw, dma_descr, &reg);
				DEBUG_EVENT("%s: Hi Descriptor 0x%X\n",chan->if_name,reg);
				wan_set_bit(WP_FIFO_ERROR_BIT, &chan->pkt_error);
				err=-EINVAL;
	DEBUG_TEST("%s: front_end_interrupt!\n",card->devname);
	card->wandev.fe_iface.isr(&card->fe);
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
			card->devname);	
    	wan_set_bit(0,&card->in_isr);
       /* -----------------2/6/2003 9:02AM------------------
     	*  -- "Transmit/Receive DMA Engine"  interrupt disable
     	*  -- "FiFo/Line Abort Error"        interrupt disable
     	* --------------------------------------------------*/
        card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
			card->devname,XILINX_CHIP_CFG_REG,reg);
			card->devname);
			card->devname);
			if (card->u.xilinx.state_change_exit_isr){
				card->u.xilinx.state_change_exit_isr=0;
			DEBUG_EVENT("%s: ERR INTR (0x%X)\n",card->devname,reg);
       /* -----------------2/6/2003 9:37AM------------------
      	* --------------------------------------------------*/
		card->hw_iface.bus_read_4(card->hw,
				card->devname,
		dma_rx_reg&=card->u.xilinx.active_ch_map;
		for (i=0; i<card->u.xilinx.num_of_time_slots ;i++){
			if (wan_test_bit(i,&dma_rx_reg) && test_bit(i,&card->u.xilinx.logic_ch_map)){
				chan=(private_area_t*)card->u.xilinx.dev_to_ch_map[i];
							card->devname,i);
				if (!(chan->common.dev->flags&IFF_UP)){
                                                        card->devname,i);
				chan->if_stats.rx_frame_errors++;
						card->devname);
	        card->hw_iface.bus_read_4(card->hw,
		dma_tx_reg&=card->u.xilinx.active_ch_map;
				card->devname,
		for (i=0; i<card->u.xilinx.num_of_time_slots ;i++){
			if (wan_test_bit(i,&dma_tx_reg) && test_bit(i,&card->u.xilinx.logic_ch_map)){
				chan=(private_area_t*)card->u.xilinx.dev_to_ch_map[i];
							card->devname,i);
				if (!(chan->common.dev->flags&IFF_UP)){
                                                        card->devname,i);
             			DEBUG_ISR("---- TX Interrupt pend. --\n");
	/* -----------------2/6/2003 10:36AM-----------------
	 * --------------------------------------------------*/
    	DEBUG_ISR("---- ISR end.-------------------\n");
    	wan_clear_bit(0,&card->in_isr);
 * "wanpipemon" utility is a user-space program that
	wan_udp_pkt = (wan_udp_pkt_t *)chan->udp_pkt_data;
	if (wan_atomic_read(&chan->udp_pkt_len) == 0){
		return -ENODEV;
	trace_info=&chan->trace_info;
	wan_udp_pkt = (wan_udp_pkt_t *)chan->udp_pkt_data;
		wan_udp_pkt->wan_udp_opp_flag = 0;
		switch(wan_udp_pkt->wan_udp_command) {
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len=0;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			wan_udp_pkt->wan_udp_data_len = 0;
			if (!wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
				if (wan_udp_pkt->wan_udp_data[0] == 0){
					wan_clear_bit(1,&trace_info->tracing_enabled);
						card->devname);
				}else if (wan_udp_pkt->wan_udp_data[0] == 1){
					wan_clear_bit(2,&trace_info->tracing_enabled);
					wan_set_bit(1,&trace_info->tracing_enabled);
							card->devname);
					wan_clear_bit(1,&trace_info->tracing_enabled);
					wan_set_bit(2,&trace_info->tracing_enabled);
							card->devname);
				set_bit (0,&trace_info->tracing_enabled);
						card->devname);
				wan_udp_pkt->wan_udp_return_code = 2;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			if(wan_test_bit(0,&trace_info->tracing_enabled)) {
				wan_clear_bit(0,&trace_info->tracing_enabled);
				wan_clear_bit(1,&trace_info->tracing_enabled);
				wan_clear_bit(2,&trace_info->tracing_enabled);
							card->devname);
				wan_udp_pkt->wan_udp_return_code = 1;
			if(wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
						card->devname);
				wan_udp_pkt->wan_udp_return_code = 1;
			wan_udp_pkt->wan_udp_atm_num_frames = 0;	
			wan_udp_pkt->wan_udp_atm_ismoredata = 0;
				WAN_IFQ_POLL(&trace_info->trace_queue, skb);
								card->devname);
				if ((WAN_MAX_DATA_SIZE - buffer_length) < skb->m_pkthdr.len){
					wan_udp_pkt->wan_udp_atm_ismoredata = 0x01;
					   skb->m_pkthdr.len, 
					   &wan_udp_pkt->wan_udp_data[buffer_length]);
				buffer_length += skb->m_pkthdr.len;
				WAN_IFQ_DEQUEUE(&trace_info->trace_queue, skb);
				wan_udp_pkt->wan_udp_atm_num_frames++;
			while ((skb=skb_dequeue(&trace_info->trace_queue)) != NULL){
				if((MAX_TRACE_BUFFER - buffer_length) < wan_skb_len(skb)){
					wan_udp_pkt->wan_udp_atm_ismoredata = 0x01;
						wan_skb_queue_head(&trace_info->trace_queue, skb);
						memcpy(&wan_udp_pkt->wan_udp_atm_data[buffer_length], 
						wan_udp_pkt->wan_udp_atm_num_frames++;
				memcpy(&wan_udp_pkt->wan_udp_atm_data[buffer_length], 
				wan_udp_pkt->wan_udp_atm_num_frames++;
			wan_udp_pkt->wan_udp_data_len = buffer_length;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			chan->router_up_time = tv.tv_sec - 
					chan->router_start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
					chan->router_up_time;	
			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_return_code = 0;
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				if (wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE){
		    			wan_udp_pkt->wan_udp_data_len = sizeof(wan_femedia_t); 
					wan_udp_pkt->wan_udp_return_code = CMD_OK;
					wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
		   	wan_udp_pkt->wan_udp_aft_num_frames = card->wandev.config_id;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_LINUX_PLATFORM;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
			wan_udp_pkt->wan_udp_data_len = 0;
			wan_udp_pkt->wan_udp_return_code = 0xCD;
				card->devname,wan_udp_pkt->wan_udp_command);
	wan_udp_pkt->wan_ip_ttl= card->wandev.ttl;
	wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
        if (card->wandev.state != state)
                                card->devname);
			card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_ON);
                                card->devname);
			card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_OFF);
                                card->devname);
			card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_OFF);
                card->wandev.state = state;
		WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
 * S514-1/2/3:		V32/RS232/FT1 Front End
 * S514-4/5/7/8:	56K/T1/E1 Front End
 * 1. Front End State (card->wandev.front_end_status)
 * 2. Protocol State  (card->wandev.state)
 * 3. Interface State (dev->flags & IFF_UP)
	if (card->wandev.ignore_front_end_status == WANOPT_YES){
	if (card->fe.fe_status == FE_CONNECTED){
		if (card->wandev.state != WAN_CONNECTED){
			card->u.xilinx.state_change_exit_isr=1;
		card->u.xilinx.state_change_exit_isr=1;
        card->hw_iface.bus_read_2(card->hw,
        card->hw_iface.bus_write_2(card->hw,
        card->hw_iface.bus_read_1(card->hw,XILINX_MCPU_INTERFACE, &tmp);
        card->hw_iface.bus_write_2(card->hw,
        card->hw_iface.bus_read_2(card->hw,
	card->hw_iface.bus_write_2(card->hw,
	card->hw_iface.bus_write_1(card->hw,
        card->hw_iface.bus_write_2(card->hw,
	if (!ifr || !ifr->ifr_data){
		return -EFAULT;
	if (copy_from_user(&api_cmd,ifr->ifr_data,sizeof(struct sdla_hdlc_api))){
		return -EFAULT;
		 card->hw_iface.pci_read_config_dword(card->hw,
		card->hw_iface.peek(card->hw, api_cmd.offset, &api_cmd.data[0], api_cmd.len);
			card->devname,api_cmd.bar,api_cmd.offset,api_cmd.len);
	if (copy_to_user(ifr->ifr_data,&api_cmd,sizeof(struct sdla_hdlc_api))){
		return -EFAULT;
	if (!ifr || !ifr->ifr_data){
		return -EFAULT;
	if (copy_from_user(&api_cmd,ifr->ifr_data,sizeof(struct sdla_hdlc_api))){
		return -EFAULT;
			card->devname,
	card->hw_iface.poke(card->hw, api_cmd.offset, &api_cmd.data[0], api_cmd.len);
		card->hw_iface.bus_write_1(
			card->hw,
		card->hw_iface.bus_write_2(
			card->hw,
		card->hw_iface.bus_write_4(
			card->hw,
		card->hw_iface.poke(
			card->hw, 
	if (copy_to_user(ifr->ifr_data,&api_cmd,sizeof(struct sdla_hdlc_api))){
		return -EFAULT;
	if (!ifr || !ifr->ifr_data){
		return -EINVAL;
	if (copy_from_user(&api_cmd,ifr->ifr_data,sizeof(struct sdla_hdlc_api))){
		return -EFAULT;
			(card->wandev.S514_cpu_no[0] == SDLA_CPU_A) ? 0x10 : 0x14,
			card->u.xilinx.bar,card->wandev.irq);
	card->hw_iface.pci_write_config_dword(card->hw, 
			(card->wandev.S514_cpu_no[0] == SDLA_CPU_A) ? 0x10 : 0x14,
			card->u.xilinx.bar);
	card->hw_iface.pci_write_config_dword(card->hw, 0x3C, card->wandev.irq);
	card->hw_iface.pci_write_config_dword(card->hw, 0x0C, 0x0000ff00);
	if (copy_to_user(ifr->ifr_data,&api_cmd,sizeof(struct sdla_hdlc_api))){
		return -EFAULT;
	card->hw_iface.bus_read_4(card->hw,
        card->hw_iface.bus_read_4(card->hw,
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		DEBUG_TEST("%s: Init interface fifo no wait %s\n",__FUNCTION__,chan->if_name);
        card->hw_iface.bus_read_4(card->hw,XILINX_DMA_CONTROL_REG,&reg);
        card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		DEBUG_TEST("%s: Init interface fifo %s\n",__FUNCTION__,chan->if_name);
				card->devname,chan->if_name);
		wan_clear_bit(0,&chan->idle_start);
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		DEBUG_TEST("%s: Init interface %s\n",__FUNCTION__,chan->if_name);
		if (chan->rx_dma_skb){
			netskb_t *skb=chan->rx_dma_skb;
			chan->rx_dma_skb=NULL;
			rx_el=(wp_rx_element_t *)&skb->cb[0];
				 rx_el->dma_addr,
				 chan->dma_mru,
	        if (chan->tx_dma_addr && chan->tx_dma_len){
                	                 chan->tx_dma_addr,
                        	         chan->tx_dma_len,
           	     	chan->tx_dma_addr=0;
                	chan->tx_dma_len=0;
		if (chan->tx_dma_skb){
			wan_skb_free(chan->tx_dma_skb);
			chan->tx_dma_skb=NULL;
		wan_clear_bit(TX_BUSY,&chan->dma_status);
                wan_clear_bit(0,&chan->idle_start);
                                card->devname,chan->if_name);
     	card->hw_iface.bus_read_4(card->hw,
        card->hw_iface.bus_read_4(card->hw,
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	card->hw_iface.bus_read_4(card->hw,XILINX_DMA_CONTROL_REG,&reg);
        card->hw_iface.bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
	card->hw_iface.bus_write_4(card->hw,dma_descr, reg);
                card->wandev.fe_iface.read_alarm(&card->fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE); 
                card->wandev.fe_iface.read_pmon(&card->fe); 
	DEBUG_TEST("%s:%s: Tx Fifo Recovery \n",card->devname,chan->if_name);
	if (chan->hdlc_eng){
        	dma_descr=(chan->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
        	card->hw_iface.bus_write_4(card->hw,dma_descr, reg);
        if (chan->tx_dma_addr && chan->tx_dma_len){
                                 chan->tx_dma_addr,
                                 chan->tx_dma_len,
                chan->tx_dma_addr=0;
                chan->tx_dma_len=0;
         * re-transmission */
	if (chan->tx_dma_skb){
		wan_skb_queue_head(&chan->wp_tx_pending_list, chan->tx_dma_skb);		
		chan->tx_dma_skb=NULL;
	if (WAN_NETIF_QUEUE_STOPPED(chan->common.dev)){
                WAN_NETIF_WAKE_QUEUE(chan->common.dev);
                if (chan->common.usedby == API){
	if (!chan->hdlc_eng){
		if (wan_test_bit(0,&chan->idle_start)){
			++chan->if_stats.tx_fifo_errors;
		++chan->if_stats.tx_fifo_errors;
                                card->devname,chan->if_name);
	/* Re-start transmission */
	wan_clear_bit(TX_BUSY,&chan->dma_status);
		timeslot=card->u.xilinx.num_of_time_slots-2;
		timeslot=card->u.xilinx.num_of_time_slots-1;
		timeslot-=2;
		card->hw_iface.bus_read_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG,&reg);	
			card->hw_iface.bus_write_4(card->hw,reg_off,data);			
		if ((jiffies-timeout) > 1){
				card->devname,ts_orig);
			return -EIO;
	return -EIO;
	private_area_t *chan = dev->priv;
	chan->common.state = state;
		       chan->if_name);
	       wan_clear_bit(0,&chan->idle_start);
	if (chan->common.usedby == API){
	if (chan->common.usedby == STACK){
		if (chan->num_of_time_slots == NUM_OF_T1_CHANNELS){
		}else if (chan->num_of_time_slots == 1){
		}else if (chan->num_of_time_slots == 2 || chan->num_of_time_slots == 3){
		}else if (chan->num_of_time_slots >= 4 && chan->num_of_time_slots<= 7){
		}else if (chan->num_of_time_slots >= 8 && chan->num_of_time_slots<= 15){
		}else if (chan->num_of_time_slots >= 16 && chan->num_of_time_slots<= 23){
					card->devname,chan->if_name,chan->num_of_time_slots);
			return -EINVAL;		
		if (chan->num_of_time_slots == (NUM_OF_E1_CHANNELS-1)){
                }else if (chan->num_of_time_slots == 1){
                }else if (chan->num_of_time_slots == 2 || chan->num_of_time_slots == 3){
                }else if (chan->num_of_time_slots >= 4 && chan->num_of_time_slots <= 7){
                }else if (chan->num_of_time_slots >= 8 && chan->num_of_time_slots <= 15){
                }else if (chan->num_of_time_slots >= 16 && chan->num_of_time_slots <= 31){
                                        card->devname,chan->if_name,chan->num_of_time_slots);
                        return -EINVAL;
		card->devname,chan->if_name,req_fifo_size,chan->num_of_time_slots);
	fifo_size=map_fifo_baddr_and_size(card,req_fifo_size,&chan->fifo_base_addr);
	if (fifo_size == 0 || chan->fifo_base_addr == 31){
				card->devname,chan->if_name,fifo_size,chan->fifo_base_addr);
                return -EINVAL;
                card->devname,chan->if_name,req_fifo_size,chan->num_of_time_slots,fifo_size);
			chan->fifo_size_code=fifo_code_vector[i];
			card->devname,chan->if_name,req_fifo_size,fifo_size);
                card->devname,chan->if_name,fifo_size,
		chan->num_of_time_slots,chan->fifo_size_code,
		chan->fifo_base_addr);
	chan->fifo_size = fifo_size;
                        card->devname,reg,card->u.xilinx.fifo_addr_map);
		if (card->u.xilinx.fifo_addr_map & (reg<<i)){
		card->u.xilinx.fifo_addr_map |= reg<<i;
	                card->devname,card->u.xilinx.fifo_addr_map,i);
	for (i=0;i<chan->fifo_size;i++){
		card->devname,reg<<chan->fifo_base_addr, card->u.xilinx.fifo_addr_map);
	card->u.xilinx.fifo_addr_map &= ~(reg<<chan->fifo_base_addr);
                card->devname, card->u.xilinx.fifo_addr_map);
	chan->fifo_size=0;
	chan->fifo_base_addr=0;
	card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &led);
	card->hw_iface.bus_write_4(card->hw,XILINX_CHIP_CFG_REG, led);
	if (wan_test_bit(CARD_DOWN,&card->wandev.critical)){
		wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
         	te_alarm = card->wandev.fe_iface.read_alarm(&card->fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE);
		//			card->devname,te_alarm);
			if (card->wandev.state == WAN_CONNECTED){
				card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_ON);
				card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_TOGGLE);
			card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_OFF);
			card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_OFF);
			/* AIS - Blue Alarm flasing RED and GREEN */
			card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_TOGGLE);
			card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_ON);
			DEBUG_EVENT("%s: Unknown Alarm 0x%X\n",card->devname,te_alarm);
			card->wandev.fe_iface.led_ctrl(&card->fe, AFT_LED_ON);
		wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
		wan_add_timer(&card->u.xilinx.led_timer,HZ);
                card->hw_iface.bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
                                return  -EINVAL;
	return -EINVAL;
	wan_trace_t     *trace_info = &chan->trace_info;
			return -1;
	for (val = 0; len && is_digit(*str); ++str, --len)
		val = (val * 10) + (*str - (unsigned)'0');
	if (card->wandev.fe_iface.update_alarm_info){
		m->count = 
				&card->wandev, 
				(&card->fe, m, stop_cnt)); 
	if (card->wandev.fe_iface.update_pmon_info){
		m->count = 
				&card->wandev, 
				(&card->fe, m, stop_cnt)); 
	return m->count;
./sdla_aft_te1_ss7.c
	unsigned char tmp_tx_buff_state; //0 - free, 1 - busy
 *  o initialize protocol-specific fields of the adapter data space.
	DEBUG_CFG("%s: %s\n", __FUNCTION__, card->devname);
	if (conf->config_id != WANCONFIG_EDUKIT) {
					card->devname, conf->config_id);
		return -EINVAL;
	if(card->type != SDLA_S514){
					card->devname , card->type);
		return -EFAULT;
	card->u.c.comm_port = 0;
	/* Initialize protocol-specific fields */
	card->mbox_off  = PRI_BASE_ADDR_MB_STRUCT;
	mb = mb1 = &card->wan_mbox;
	card->isr			= NULL;
	card->poll			= NULL;
	card->exec			= &wpedu_exec;
	card->wandev.update		= NULL;
 	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= &del_if;
	card->wandev.state		= WAN_DUALPORT;
	card->wandev.udp_port   	= conf->udp_port;
	card->wandev.new_if_cnt = 0;
	card->u.c.state = WAN_DISCONNECTED;
	card->u.c.update_call_count = 0;
	DEBUG_CFG("conf->ttl: %d\n", conf->ttl);
	DEBUG_CFG("conf->mtu: %d\n", conf->mtu);
	if(conf->ttl == 0){
		card->wandev.ttl = 0x7F;
		card->wandev.ttl = conf->ttl;
	if(conf->mtu == 0){
		card->wandev.mtu = 1500;
		card->wandev.mtu = conf->mtu;
	card->wandev.electrical_interface = 0; 
	card->wandev.clocking = 0;
	port_num = card->u.c.comm_port;
       	card->wandev.bps = 0;
	card->wandev.state = WAN_FT1_READY;
	DEBUG_EVENT("%s: Educational Kit Module Ready!\n",card->devname);
 * new_if - Create new logical channel.
 * to dev->priv pointer.  
 * Also the dev->init pointer should also be initialized
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
			__FUNCTION__, card->devname, conf->name);
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
		DEBUG_EVENT("%s: Invalid interface name!\n", card->devname);
		return -EINVAL;
		WAN_MEM_ASSERT(card->devname);
		return -ENOMEM;
	edu_private_area->card = card; 
	strcpy(edu_private_area->if_name, conf->name);
	//edukit always has only one interface, re-use 'tty_buf'
	card->tty_buf = (unsigned char*)edu_private_area;
	if (atomic_read(&card->wandev.if_cnt) > 0){
		err=-EEXIST;
	if( strcmp(conf->usedby, "WANPIPE") == 0) {
		DEBUG_EVENT("%s: Running in WANPIPE mode!\n", wandev->name);
	}else if( strcmp(conf->usedby, "API") == 0) {
		DEBUG_EVENT("%s: Running in API mode!\n", wandev->name);
				card->devname,edu_private_area->if_name);
		err=-EINVAL;
					   &edu_private_area->dent, 
					   edu_private_area->if_name, 
			card->devname, edu_private_area->if_name);
	dev->init = &if_init;
	dev->priv = edu_private_area;
	edu_private_area->net_dev = dev;//pointer back to network device
	atomic_inc(&card->wandev.if_cnt);
	dev->priv=NULL;
 * del_if - Delete logical channel.
	edu_private_area_t* 	edu_priv_area = dev->priv;
	sdla_t*			card = edu_priv_area->card;
			card->devname, dev->name);
	wanrouter_proc_delete_interface(wandev, edu_priv_area->if_name);
	atomic_dec(&card->wandev.if_cnt);
 * if_init - Initialize Linux network interface.
	edu_private_area_t* edu_private_area = dev->priv;
	sdla_t* card = edu_private_area->card;
	//wan_device_t* wandev = &card->wandev;
			card->devname, dev->name);
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= TX_TIMEOUT;
	dev->do_ioctl		= if_do_ioctl;
	/* Initialize media-specific parameters */
	dev->flags		|= IFF_POINTOPOINT;
	dev->flags		|= IFF_NOARP;
	if (edu_private_area->mc == WANOPT_YES){
		dev->flags 	|= (IFF_MULTICAST|IFF_ALLMULTI);
	if (edu_private_area->true_if_encoding){
		dev->type	= ARPHRD_HDLC; /* This breaks the tcpdump */
		dev->type	= ARPHRD_PPP;
	dev->mtu		= card->wandev.mtu;
	dev->hard_header_len	= 0;
        dev->tx_queue_len = 100;
 * if_open - Open network interface.
	edu_private_area_t* edu_priv_area = dev->priv;
	sdla_t* card = edu_priv_area->card;
			card->devname, dev->name);
		DEBUG_CFG("%s: if_open(): open_dev_check() failed!\n", dev->name);
		return -EBUSY;
	edu_priv_area->router_start_time = tv.tv_sec;
 * if_close - Close network interface.
	edu_private_area_t* edu_priv_area = dev->priv;
	sdla_t* card = edu_priv_area->card;
			card->devname, dev->name);
	dev->start=0;
 *	if_do_ioctl - Ioctl handler for fr
	DEBUG_EVENT("%s: ioctl for: %s - Not implemented.\n",
			__FUNCTION__, dev->name);
 * Get ethernet-style interface statistics.
	DEBUG_CFG("%s: stats for: %s\n", __FUNCTION__, dev->name);
	if ((edu_priv_area=dev->priv) == NULL){
	my_card = edu_priv_area->card;
	return &my_card->wandev.stats; 
 * if_send - Send a packet on a network interface.
 *   block a timer-based transmit from overlapping.
 *		non-0	packet may be re-transmitted (tbusy must be set)
	edu_private_area_t *edu_priv_area = dev->priv;
	sdla_t *card = edu_priv_area->card;
	void* data = skb->data;
	unsigned len = skb->len;
			card->devname, dev->name);
		 * tx-done interrupt.
			card->devname, dev->name);
	if (dev->tbusy){
		 ++card->wandev.stats.collisions;
		if((jiffies - edu_priv_area->tick_counter) < (5 * HZ)) {
    	if(test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)) {
					card->wandev.name,card->wandev.critical);
                ++card->wandev.stats.tx_dropped;
		err=-1;
		dev->trans_start = jiffies;
		edu_priv_area->tick_counter = jiffies;
	clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
 *	Return:	0 - o.k.
 *		1 - no transmit buffers available
	DEBUG_TX("%s: called for: %s.\n", __FUNCTION__, card->devname);
			card->devname, len, MAX_TX_RX_DATA_SIZE);
	if(edu_priv_area->tmp_tx_buff_state == 1){
		DEBUG_TX("%s: tx buff busy!!\n", card->devname);
	edu_priv_area->tmp_tx_buff_state = 1;
	memcpy(edu_priv_area->tmp_tx_data.data, data, len);
	edu_priv_area->tmp_tx_data.buffer_length = len;
    	edu_private_area_t* chan = dev->priv;
	sdla_t *card = chan->card;
			card->devname, dev->name);
	chan->tmp_tx_buff_state = 0;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++card->wandev.stats.collisions;
	DEBUG_EVENT("%s: Transmit timed out on %s\n", card->devname,dev->name);
	edu_private_area_t* edu_private_area = (edu_private_area_t*)card->tty_buf;
	edu_exec_cmd_t* ioctl_cmd = &edu_private_area->ioctl_cmd;
	unsigned char* data_buffer = edu_private_area->data_buffer;
		return -EFAULT;
		return -EFAULT;
		return -EFAULT;
		return -EFAULT;
	edu_private_area = (edu_private_area_t*)card->tty_buf;
	dev = edu_private_area->net_dev;
	skb = dev_alloc_skb(rx_data->buffer_length + 2);
					card->devname);
		++card->wandev.stats.rx_dropped;
	buf = skb_put(skb, rx_data->buffer_length);
	memcpy(buf, rx_data->data, rx_data->buffer_length);
	skb->protocol = htons(ETH_P_IP);
	card->wandev.stats.rx_packets ++;
	card->wandev.stats.rx_bytes += skb->len;
	skb->protocol = htons(ETH_P_IP);
        skb->dev = dev;
	edu_private_area_t* edu_private_area = (edu_private_area_t*)card->tty_buf;
	edu_exec_cmd_t* ioctl_cmd = &edu_private_area->ioctl_cmd;
	TX_RX_DATA* tx_data = (TX_RX_DATA*)edu_private_area->data_buffer;
	TX_RX_DATA* rx_data = (TX_RX_DATA*)edu_private_area->data_buffer;
	switch(ioctl_cmd->ioctl)
		if(card->wandev.electrical_interface == 0)
		{	card->wandev.electrical_interface = 1;
			ioctl_cmd->return_code = 0;			
			ioctl_cmd->return_code = 1;
		card->wandev.electrical_interface = 0;
		ioctl_cmd->return_code = 0;
		card->hw_iface.start(card->hw, 0x100);
		// ALEX writeb (S514_CPU_START, card->hw.vector);
		ioctl_cmd->return_code = card->hw_iface.hw_halt(card->hw);
		if(edu_private_area->tmp_tx_buff_state == 1){
			tx_data->status = TX_SUCCESS;
			tx_data->buffer_length = edu_private_area->tmp_tx_data.buffer_length;
			memcpy(tx_data->data, edu_private_area->tmp_tx_data.data, 
				edu_private_area->tmp_tx_data.buffer_length);
		if(edu_private_area->tmp_tx_buff_state == 1){
			++card->wandev.stats.tx_packets;
                        card->wandev.stats.tx_bytes += edu_private_area->tmp_tx_data.buffer_length;
			edu_private_area->tmp_tx_buff_state = 0;
			netif_wake_queue (edu_private_area->net_dev);
		card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &adapter_type);
		*(unsigned short*)edu_private_area->data_buffer = adapter_type;
			*(unsigned short*)edu_private_area->data_buffer);
			card->devname, ioctl_cmd->ioctl);	
		ioctl_cmd->return_code = 1;
	edu_private_area_t* edu_private_area = (edu_private_area_t*)card->tty_buf;
	edu_exec_cmd_t* ioctl_cmd = &edu_private_area->ioctl_cmd;
	unsigned char* data_buffer = edu_private_area->data_buffer;
	if(ioctl_cmd->buffer_length <= MAX_TX_RX_DATA_SIZE){
		card->hw_iface.peek(card->hw, ioctl_cmd->offset, data_buffer, ioctl_cmd->buffer_length);
		ioctl_cmd->return_code = 0;
			  card->devname, 
			  ioctl_cmd->buffer_length
		ioctl_cmd->return_code = 1;
	edu_private_area_t* edu_private_area = (edu_private_area_t*)card->tty_buf;
	edu_exec_cmd_t* ioctl_cmd = &edu_private_area->ioctl_cmd;
	unsigned char* data_buffer = edu_private_area->data_buffer;
	if( ioctl_cmd->buffer_length <= MAX_TX_RX_DATA_SIZE){
		card->hw_iface.poke(card->hw, ioctl_cmd->offset, data_buffer, ioctl_cmd->buffer_length);
		ioctl_cmd->return_code = 0;
			card->devname, 
			ioctl_cmd->buffer_length
		ioctl_cmd->return_code = 1;
./sdla_edu.c
 * 4. Neither the name of the author nor the names of any co-contributors
 *	$Id: wanpipe_utils.c,v 1.101 2008-02-04 18:02:20 sangoma Exp $
	/* generate the bit-reversing table for all unsigned characters */
		      	/* corresponding 'bit-flipped' character */
				misc_status_byte |= (1 << (7 - i));
		/* insert the 'bit-flipped' character into the table 
	for (val = 0; len && is_digit(*str); ++str, --len)
		val = (val * 10) + (*str - (unsigned)'0');
	switch(card->wandev.state){
	return card->wandev.state;
	card->wandev.bps=baud*1000;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (card->wandev.state != state){ 
			DEBUG_EVENT("%s: Link connected!\n", card->devname);
			card->wan_debugging_state = WAN_DEBUGGING_NONE;
			DEBUG_EVENT("%s: Link connecting...\n", card->devname);
			DEBUG_EVENT("%s: Link disconnected!\n", card->devname);
		card->wandev.state = state;
		if (card->wandev.config_id == WANCONFIG_ADSL) {
	card->state_tick = SYSTEM_TICKS;
	unsigned int 	udp_port = card->wandev.udp_port;
					card->devname,
					wan_udp_pkt->wan_ip_v,
					wan_udp_pkt->wan_ip_p,
					wan_udp_pkt->wan_udp_dport,
					wan_udp_pkt->wan_udp_request_reply);
	if (wan_udp_pkt->wan_ip_v == 0x04 &&
	    wan_udp_pkt->wan_ip_p == UDPMGMT_UDP_PROTOCOL &&
	    wan_udp_pkt->wan_udp_dport == ntohs(udp_port) &&  
	    wan_udp_pkt->wan_udp_request_reply == UDPMGMT_REQUEST){
		if (!strncmp(wan_udp_pkt->wan_udp_signature,
 *	mbox_len - includes data length and trace_info_t (chdlc and dsl).
	udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	if (card->wandev.config_id == WANCONFIG_CHDLC || 
	    card->wandev.config_id == WANCONFIG_SDLC){
	udp_pkt->wan_udp_len = temp;
	temp = udp_pkt->wan_udp_sport;
	udp_pkt->wan_udp_sport = udp_pkt->wan_udp_dport;
	udp_pkt->wan_udp_dport = temp;
	*((unsigned short*)(udp_pkt->wan_udp_data + mbox_len + even_bound)) = temp;
	*((unsigned short*)(udp_pkt->wan_udp_data + mbox_len + even_bound + 2)) = temp;
	udp_pkt->wan_udp_sum = 0;
	udp_pkt->wan_udp_sum = 
	udp_pkt->wan_ip_len = temp;
	ip_temp = udp_pkt->wan_ip_src;
	udp_pkt->wan_ip_src = udp_pkt->wan_ip_dst;
	udp_pkt->wan_ip_dst = ip_temp;
	udp_pkt->wan_ip_sum = 0;
	udp_pkt->wan_ip_sum = wan_calc_checksum(data, sizeof(struct ip)); 
	udp_pkt->wan_ip_sum = wan_calc_checksum(data, sizeof(struct iphdr)); 
 *	mbox_len - includes data length and trace_info_t (chdlc and dsl).
	rtp_pkt->wan_udp_len = temp;
	temp = rtp_pkt->wan_udp_sport;
	rtp_pkt->wan_udp_sport = htons(rtp_conf->rtp_port+chan);
	rtp_pkt->wan_udp_dport = htons(rtp_conf->rtp_port+chan);
	rtp_pkt->wan_udp_sum = 0;
	rtp_pkt->wan_udp_sum = 0;
	rtp_pkt->wan_ip_len = temp;
	rtp_pkt->wan_ip_src = rtp_conf->rtp_local_ip;
	rtp_pkt->wan_ip_dst = rtp_conf->rtp_ip;
	rtp_pkt->wan_ip_v  = 4;
	rtp_pkt->wan_ip_hl = 5;
	rtp_pkt->wan_ip_len = htons(ip_length);
	rtp_pkt->wan_ip_tos = 1;
	rtp_pkt->wan_ip_ttl = 255;
	rtp_pkt->wan_ip_p = IPPROTO_UDP;
	memcpy(rtp_pkt->wan_eth_dest,rtp_conf->rtp_mac,ETH_ALEN);
	memcpy(rtp_pkt->wan_eth_src,rtp_conf->rtp_local_mac,ETH_ALEN);
	rtp_pkt->wan_eth_proto=0x0008;
	rtp_pkt->wan_ip_sum = 0;
	rtp_pkt->wan_ip_sum = wan_calc_checksum(&data[sizeof(ethhdr_t)], sizeof(iphdr_t)); 
	wan_init_timer(&card->debug_timer, 
	debug_task = &card->debug_task;
	if (card->wandev.state == WAN_UNCONFIGURED){
	if (card->wandev.state == WAN_UNCONFIGURED){
	if (card->wandev.state == WAN_CONNECTED){
					card->devname);
	if (card->wan_debugging_state == WAN_DEBUGGING_NONE ||
	    card->wan_debugging_state == WAN_DEBUGGING_AGAIN){
					card->devname,
					(card->wan_debugging_state == WAN_DEBUGGING_NONE) ? "Start":"Again");
		card->wan_debugging_state = WAN_DEBUGGING_START;
		if (card->wandev.fe_iface.read_alarm){ 
			card->wandev.fe_iface.read_alarm(&card->fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE);
		if (card->wandev.fe_iface.read_alarm && 
		    (status = card->wandev.fe_iface.read_alarm(&card->fe, WAN_FE_ALARM_READ|WAN_FE_ALARM_UPDATE))){
						card->devname);
			if (card->wan_debug_last_msg != WAN_DEBUG_ALARM_MSG){
				card->wandev.fe_iface.print_fe_alarm(&card->fe, status);
						card->devname);
						card->devname);
						card->devname);
						card->devname);
			card->wan_debug_last_msg = WAN_DEBUG_ALARM_MSG;
			switch(card->wan_debugging_state){
						card->devname);
				CRC_frames		= card->get_crc_frames(card);
				abort_frames		= card->get_abort_frames(card);
				tx_underun_frames 	= card->get_tx_underun_frames(card);
				card->wan_debugging_state = WAN_DEBUGGING_CONT;
				wan_add_timer(&card->debug_timer, 15*HZ);
				    ((card->get_crc_frames(card) != CRC_frames) ||
				     (card->get_abort_frames(card) != abort_frames))){
						card->devname);
					if (card->wan_debug_last_msg != WAN_DEBUG_TE1_MSG){
						DEBUG_EVENT("%s: T1/E1 channel set-up is wrong!\n",
								card->devname);
								card->devname,
								card->wandev.fe_iface.print_fe_act_channels(&card->fe));
								card->devname);
								card->devname);
					card->wan_debug_last_msg = WAN_DEBUG_TE1_MSG;
							card->devname);
				if (card->wan_debugging){
					delay = card->wan_debugging(card);
		switch(card->wan_debugging_state){
						card->devname);
			CRC_frames	= card->get_crc_frames(card);
			abort_frames	= card->get_abort_frames(card);
			tx_underun_frames = card->get_tx_underun_frames(card);
			card->wan_debugging_state = WAN_DEBUGGING_CONT;
			wan_add_timer(&card->debug_timer, 15*HZ);
			if ((card->get_crc_frames(card) != CRC_frames) ||
			    (card->get_abort_frames(card) != abort_frames)){
						card->devname);
				if (card->wandev.clocking == WANOPT_EXTERNAL){
					if (card->wan_debug_last_msg != WAN_DEBUG_LINERROR_MSG){
									card->devname);
									card->devname);
									card->devname);
					card->wan_debug_last_msg = WAN_DEBUG_LINERROR_MSG;
					if (card->wan_debug_last_msg != WAN_DEBUG_CLK_MSG){
									card->devname);
									card->devname);
									card->devname);
						DEBUG_EVENT("%s:    back-to-back testing!\n",
									card->devname);
					card->wan_debug_last_msg = WAN_DEBUG_CLK_MSG;
							card->devname);
			if (card->wan_debugging){
				delay = card->wan_debugging(card);
	/* Link is down (no DSU/CSU errors) - may be protocol problem */	
	if (card->get_tx_underun_frames(card) != tx_underun_frames){ 
					card->devname);
		if (card->wan_debug_last_msg != WAN_DEBUG_TX_MSG){
						card->devname);
						card->devname);
						card->devname);
		card->wan_debug_last_msg = WAN_DEBUG_TX_MSG;
		if (card->wan_debugging){
			delay = card->wan_debugging(card);
		if (card->wan_debugging_state == WAN_DEBUGGING_PROTOCOL){
			wan_add_timer(&card->debug_timer, delay*HZ);
	card->wan_debugging_state = WAN_DEBUGGING_NONE;
	debug_task = &card->debug_task;
	if (card->wandev.state != WAN_CONNECTED && card->wandev.state != WAN_UNCONFIGURED){
		card->wan_debugging_state = WAN_DEBUGGING_AGAIN;
		wan_add_timer(&card->debug_timer, WAN_DEBUGGING_DELAY*HZ);
		card->wan_debug_last_msg = WAN_DEBUG_NONE_MSG;
		wan_set_bit(WAN_DEBUG_TRIGGER, &wanpipe_debug->u.debug.status);
		wan_clear_bit(WAN_DEBUG_TRIGGER, &wanpipe_debug->u.debug.status);
	if (wanpipe_debug == NULL || !wanpipe_debug->configured){
	if (!wan_test_bit(WAN_DEBUG_TRIGGER, &wanpipe_debug->u.debug.status)){
	if (wan_test_bit(WAN_DEBUG_READING, &wanpipe_debug->u.debug.status) ||
	    wan_test_bit(WAN_DEBUG_FULL, &wanpipe_debug->u.debug.status)){
	wan_spin_lock_irq(&wanpipe_debug->wandev.lock, &smp_flags);
	wanpipe_debug->hw_iface.peek(wanpipe_debug->hw, 0, &wan_debug_info, sizeof(wanpipe_kernel_msg_info_t));
	if (wan_debug_info.magic != ROUTER_MAGIC || wanpipe_debug->u.debug.total_len == 0){
		wanpipe_debug->hw_iface.poke(wanpipe_debug->hw, 0, 
		wanpipe_debug->u.debug.total_len = 0;
		wanpipe_debug->u.debug.total_num = 0;
		wanpipe_debug->u.debug.current_offset = sizeof(wanpipe_kernel_msg_info_t);
		wan_set_bit(WAN_DEBUG_FULL, &wanpipe_debug->u.debug.status);
	wanpipe_debug->hw_iface.poke(wanpipe_debug->hw, 
		  wanpipe_debug->u.debug.total_len+sizeof(wanpipe_kernel_msg_info_t), 
	wanpipe_debug->u.debug.total_len += sizeof(wanpipe_kernel_msg_hdr_t);
	wanpipe_debug->hw_iface.poke(wanpipe_debug->hw, 
		  wanpipe_debug->u.debug.total_len+sizeof(wanpipe_kernel_msg_info_t), 
	wanpipe_debug->u.debug.total_len += len;
	wanpipe_debug->u.debug.total_num ++;
	wan_debug_info.total_len = wanpipe_debug->u.debug.total_len;
	wanpipe_debug->hw_iface.poke(wanpipe_debug->hw, 
	wan_spin_unlock_irq(&wanpipe_debug->wandev.lock, &smp_flags);
	if (!wanpipe_debug || wanpipe_debug->wandev.state == WAN_UNCONFIGURED){
		return -EINVAL;
	wan_spin_lock_irq(&wanpipe_debug->wandev.lock, &smp_flags);
	if (!wan_test_bit(WAN_DEBUG_READING, &wanpipe_debug->u.debug.status)){
		wan_set_bit(WAN_DEBUG_READING, &wanpipe_debug->u.debug.status);
				wanpipe_debug->u.debug.total_num);
		wan_clear_bit(WAN_DEBUG_READING, &wanpipe_debug->u.debug.status);
		err = -EFAULT;
		wan_clear_bit(WAN_DEBUG_READING, &wanpipe_debug->u.debug.status);
		err = -EINVAL;
		wan_clear_bit(WAN_DEBUG_READING, &wanpipe_debug->u.debug.status);
		err = -ENOMEM;
	wanpipe_debug->hw_iface.peek(wanpipe_debug->hw, 0, 
					wanpipe_debug->devname);
	next_offset = wanpipe_debug->u.debug.current_offset;
	if (wan_debug_info.total_len-next_offset > dbg_msg.max_len){
		wanpipe_debug->hw_iface.peek(wanpipe_debug->hw, next_offset, 
		if (wan_dbg->len == 0){
		if (offset + sizeof(wanpipe_kernel_msg_hdr_t) + wan_dbg->len < dbg_msg.max_len){
			wanpipe_debug->hw_iface.peek(wanpipe_debug->hw, next_offset, &data[offset], wan_dbg->len);
			next_offset += wan_dbg->len;
			offset += wan_dbg->len;
	wanpipe_debug->u.debug.current_offset = next_offset;
			err = -EFAULT;
					wanpipe_debug->devname);
		wanpipe_debug->u.debug.current_offset = 
		wanpipe_debug->u.debug.total_len = 0;
		wanpipe_debug->u.debug.total_num = 0;
		wanpipe_debug->hw_iface.poke(wanpipe_debug->hw, 0, 
		if (wan_test_bit(WAN_DEBUG_FULL, &wanpipe_debug->u.debug.status)){
			wan_clear_bit(WAN_DEBUG_FULL, &wanpipe_debug->u.debug.status);
		wan_clear_bit(WAN_DEBUG_READING, &wanpipe_debug->u.debug.status);
		err = -EFAULT;
	wan_spin_unlock_irq(&wanpipe_debug->wandev.lock, &smp_flags);
	if (wan_test_bit(0,&trace_info->tracing_enabled)){
		if ((SYSTEM_TICKS - trace_info->trace_timeout) > WAN_MAX_TRACE_TIMEOUT){
			wan_clear_bit(0,&trace_info->tracing_enabled);
			wan_clear_bit(1,&trace_info->tracing_enabled);
			return -EINVAL;
		if (wan_skb_queue_len(&trace_info->trace_queue) < trace_info->max_trace_queue){
			if(wan_test_bit(3,&trace_info->tracing_enabled)){
				if (wan_skb_queue_len(&trace_info->trace_queue) < trace_info->max_trace_queue / 2){
					return -ENOBUFS; 
			if (wan_test_bit(1,&trace_info->tracing_enabled)){
			if (wan_test_bit(2,&trace_info->tracing_enabled)){
					wan_skb_queue_len(&trace_info->trace_queue),
					trace_info->max_trace_queue);
		return -ENOBUFS;
	return -EINVAL;
			return -1;
		wan_skb_queue_tail(&trace_info->trace_queue, new_skb);
			return -EINVAL;
			return -1;
		for (i=(off-1);i<wan_skb_len(skb);){	
			if (i==(off-1)){
		trc_el_ptr->real_length = trc_el.real_length;		
		wan_skb_queue_tail(&trace_info->trace_queue, new_skb);
	trace_queue = &trace->trace_queue;
	trace->trace_timeout	= SYSTEM_TICKS;
	trace->tracing_enabled	= 0;
	trace->max_trace_queue	= max_trace_queue;
	trace_queue = &trace->trace_queue;
	trace_queue = &trace->trace_queue;
		if (WAN_COPY_TO_USER(ifr->ifr_data, &card->wandev.bps, sizeof(card->wandev.bps))){
				card->devname, __FUNCTION__, __LINE__);
			return -EFAULT;
	if (WAN_COPY_FROM_USER(&snmp, ifr->ifr_data, sizeof(wanpipe_snmp_t))){
				card->devname);
		return -EFAULT;
					card->devname);
		if(card->wandev.fe_iface.get_snmp_data){
			card->wandev.fe_iface.get_snmp_data(&card->fe, dev, &snmp);
				card->devname);
			DEBUG_SNMP("%s: Get Frame Relay SNMP data\n", card->devname);
			DEBUG_SNMP("%s: Get PPP SNMP data\n", card->devname);
			DEBUG_SNMP("%s: Get X.25 SNMP data\n", card->devname);
		if (card->get_snmp_data){
			card->get_snmp_data(card, dev, &snmp);
			DEBUG_SNMP("%s: get_snmp_data() ptr is NULL!!\n", card->devname);
	if (WAN_COPY_TO_USER(ifr->ifr_data, &snmp, sizeof(wanpipe_snmp_t))){
				card->devname);
		return -EFAULT;
	wan_spin_lock_irq(&card->wandev.lock, (wan_smp_flag_t*)flags);	
	wan_spin_unlock_irq(&card->wandev.lock,(wan_smp_flag_t*)flags);	
	trace_queue = &trace->trace_queue;
	dma_descr->max_length = max_length;
	card->hw_iface.getcfg(card->hw, SDLA_DMATAG, &dma_descr->dmat);
	if (wan_dma_alloc_org(card->hw, dma_descr)){
	err=wan_dma_free_org(card->hw, (wan_dma_descr_org_t*)dma_descr);
	empty_space = wan_skb_len(tx_idle_skb) - wan_skb_len(skb);
	m->msg_name = NULL;
	size = m->msg_iovlen * sizeof(struct iovec);
	if (copy_from_user(iov, m->msg_iov, size))
		return -EFAULT;
	m->msg_iov = iov;
	for (ct = 0; ct < m->msg_iovlen; ct++) {
			return -EMSGSIZE;
 *	Copy iovec to kernel. Returns -EFAULT on error.
		if (iov->iov_len) {
			int copy = min_t(unsigned int, len, iov->iov_len);
			if (copy_from_user(kdata, iov->iov_base, copy))
				return -EFAULT;
			len -= copy;
			iov->iov_base += copy;
			iov->iov_len -= copy;
 *	Copy kernel to iovec. Returns -EFAULT on error.
		if (iov->iov_len) {
			int copy = min_t(unsigned int, iov->iov_len, len);
			if (copy_to_user(iov->iov_base, kdata, copy))
				return -EFAULT;
			len -= copy;
			iov->iov_len -= copy;
			iov->iov_base += copy;
			res=len-(sizeof(struct iphdr)+sizeof(struct udphdr)+
			res=len-(sizeof(struct iphdr)+sizeof(struct udphdr)+
./wanpipe_utils.c
* Copyright:	(c) 1995-2002 Sangoma Technologies Inc.
*-----------------------------------------------------------------------------
* the restrictions contained in a BSD-style copyright.)
#define MAX_TRACE_BUFFER	(MAX_LGTH_UDP_MGNT_PKT - 	\
	sizeof(iphdr_t) - 		\
	sizeof(udphdr_t) - 		\
	sizeof(wan_mgmt_t) - 		\
	sizeof(wan_trace_info_t) - 	\
# define ETHER_IOCTL(ifp, cmd, data)    -EOPNOTSUPP
# define LIST_FIRST_MCLIST(dev)		dev->mc_list
# define LIST_NEXT_MCLIST(mclist)	mclist->next
# define LIST_FIRST_MCLIST(dev)		dev->mc_list
# define LIST_NEXT_MCLIST(mclist)	mclist->next
# define LIST_FIRST_MCLIST(dev)		LIST_FIRST(&dev->if_multiaddrs)
# define LIST_NEXT_MCLIST(mclist)	mclist->ifma_link.le_next
		card->devname);
	card->isr			= &wpa_isr;
	card->poll			= NULL;
	card->exec			= NULL;
	card->wandev.update		= NULL; /*&update; */
	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= &del_if;
	card->wandev.udp_port   	= conf->udp_port;
	card->wandev.new_if_cnt = 0;
	card->wandev.ttl = conf->ttl;
	card->wandev.electrical_interface = conf->electrical_interface; 
	conf->u.adsl.tty_minor = (unsigned char)conf->tty_minor;
	switch (conf->u.adsl.EncapMode){
			if (conf->mtu > 9188){
				conf->mtu = 9188;
			if (conf->mtu > 1500){
				conf->mtu = 1500;
	conf->u.adsl.mtu = (unsigned short)conf->mtu;
	card->wandev.mtu = conf->mtu;
	card->u.adsl.adapter = adsl_create(&conf->u.adsl, 
		card->devname);
	if (card->u.adsl.adapter == NULL){
		return -EINVAL;
	card->u.adsl.EncapMode = conf->u.adsl.EncapMode;
	card->wandev.station = conf->u.adsl.EncapMode;
	if (adsl_wan_interface_type(card->u.adsl.adapter)){
		int err=adsl_wan_init(card->u.adsl.adapter);
			adsl_disable_comm(card->u.adsl.adapter);
	card->disable_comm		= &disable_comm;
	if (adsl_wan_interface_type(card->u.adsl.adapter)){
		card->disable_comm	= &disable_comm;
	card->wandev.state = WAN_CONNECTING;	
	card = dsl->common.card;
* o parse media- and hardware-specific configuration
	sdla_t*			card = wandev->priv;
	if ((ifp->name[0] == '\0') || (strlen(ifp->name) > WAN_IFNAME_SZ)) {
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
	if (adsl_wan_interface_type(card->u.adsl.adapter)){
		return -EINVAL;
		if (card->u.adsl.EncapMode == RFC_MODE_PPP_VC || 
			card->u.adsl.EncapMode == RFC_MODE_PPP_LLC){
					card->devname);
				return -EINVAL;
			card->devname);
		return -ENOMEM;
		card->devname, conf->name);
	memcpy(adsl->if_name, conf->name, strlen(conf->name));
	if (wan_netif_init(ifp, adsl->if_name)){
			conf->name);
		return -ENOMEM;
	ifp->if_softc	 = adsl;
	ifp->if_output   = adsl_output;
	ifp->if_start    = adsl_tx;
	ifp->if_watchdog = adsl_watchdog;
	ifp->if_ioctl	 = adsl_ioctl;
	ifp->if_init     = adsl_init;
	ifp->if_snd.ifq_len    = 0;
	WAN_TASKQ_INIT((&adsl->common.wanpipe_task), 0, process_bh, ifp);
	WAN_TASKQ_INIT((&adsl->common.wanpipe_task), 0, process_bh, ifp);
	WAN_TASKQ_INIT((&adsl->adsl_if_send_task), 0, adsl_if_send_task_func, ifp);
	ifp->priv	= adsl;
	ifp->irq        = card->wandev.irq;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &ifp->mem_start);
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &ifp->mem_end);
	ifp->open               = &adsl_open;
	ifp->stop               = &adsl_close;
	ifp->hard_start_xmit    = &adsl_if_send;/* will call adsl_output() */
	ifp->udp_mgmt			= &process_udp_mgmt_pkt;
	ifp->init				= &adsl_init;
	adsl->common.card = card;
	adsl->card = card;
	wpabs_trace_info_init(&adsl->trace_info, MAX_TRACE_QUEUE);
	ifp->trace_info = &adsl->trace_info;
	adsl->sdla_net_dev = ifp;
	ifp->hard_start_xmit    = &adsl_output;
	ifp->get_stats          = &adsl_stats;
	ifp->set_multicast_list = &adsl_multicast;
	ifp->tx_timeout		= &adsl_tx_timeout;
	ifp->watchdog_timeo     = (1*HZ);
	ifp->do_ioctl		= adsl_ioctl;
	adsl->common.card	= card;
	adsl->pAdapter	= adsl_new_if(card->u.adsl.adapter, adsl->macAddr, ifp);
	if (adsl->pAdapter == NULL){
			card->devname);
		return -EINVAL;
		card->init_flag = 0;
	if(strcmp(conf->usedby, "STACK") == 0) {
		adsl->common.usedby = STACK;
			card->devname,adsl->if_name);
		card->u.adsl.EncapMode=RFC_MODE_STACK_VC;
		adsl->common.usedby = WANPIPE;
			card->devname,adsl->if_name);
	/*TASK_INIT(&adsl->tq_atm_task, 0, &adsl_atm_tasklet, adsl->pAdapter);*/
	switch (card->u.adsl.EncapMode)
			card->devname, wan_netif_name(ifp));
		ifp->if_flags  |= (IFF_DRV_RUNNING|IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST);
		bcopy(adsl->macAddr, 
			WAN_IFP2ENADDR(ifp)/*(WAN_IFP2AC(ifp))->ac_enaddr*/,
		bcopy(adsl->macAddr, wandev->macAddr, ETHER_ADDR_LEN); 
		memcpy(ifp->dev_addr, adsl->macAddr, 6);
			card->devname, wan_netif_name(ifp));
		ifp->if_mtu	= card->wandev.mtu; /* ETHERMTU */
		ifp->if_type    = IFT_OTHER;
		ifp->if_flags  |= (IFF_POINTOPOINT|IFF_DRV_RUNNING);
		/*ifp->if_flags  |= IFF_NOARP;*/
		ifp->if_hdrlen	= 0;
		ifp->type = ARPHRD_PPP; 
		ifp->flags |= IFF_POINTOPOINT;
		ifp->flags |= IFF_NOARP;
		ifp->mtu = card->wandev.mtu;
		ifp->hard_header_len=0; /* ETH_HLEN;*/
		ifp->addr_len=0; 	/* ETH_ALEN;*/
		ifp->tx_queue_len = 100;
		DEBUG_EVENT("%s: Attaching SPPP protocol \n", card->devname);
		ifp->if_start = adsl_sppp_tx;
		ifp->type = ARPHRD_PPP; 
		ifp->flags |= IFF_POINTOPOINT;
		ifp->flags |= IFF_NOARP;
		ifp->mtu = card->wandev.mtu;
		ifp->hard_header_len=0; 
		ifp->addr_len=0; 	
		ifp->tx_queue_len = 100;
		ifp->open               = &adsl_open;
		ifp->stop               = &adsl_close;
		ifp->hard_start_xmit    = &adsl_output;
		ifp->get_stats          = &adsl_stats;
		ifp->set_multicast_list = &adsl_multicast;
		ifp->tx_timeout		= &adsl_tx_timeout;
		ifp->watchdog_timeo     = (1*HZ);
		ifp->do_ioctl		= adsl_ioctl;
			card->devname,card->u.adsl.EncapMode);
		return -EINVAL;
	wan_getcurrenttime(&adsl->router_start_time, NULL);
	sdla_t*			card = wandev->priv;
		card->devname, wan_netif_name(ifp));
	if (adsl->pAdapter != NULL){
		adsl_del_if(adsl->pAdapter);	
			card->devname);
		adsl_disable_comm(adsl->pAdapter);
	card->u.adsl.adapter 	= NULL;
	adsl->pAdapter 		= NULL;
	card->isr = NULL;
	if (card->u.adsl.EncapMode == RFC_MODE_PPP_VC ||
		card->u.adsl.EncapMode == RFC_MODE_PPP_LLC){
			DEBUG_EVENT("%s: Detaching SPPP protocol \n", card->devname);
			if (adsl->common.prot_ptr){
				ifp->do_ioctl = NULL;
				wan_free(adsl->common.prot_ptr);
				adsl->common.prot_ptr= NULL;
	ifp->if_output 	= NULL;
	ifp->if_start 	= NULL;
	ifp->if_ioctl 	= NULL;
	ifp->if_watchdog= NULL;
	ifp->if_init 	= NULL;
	ifp->if_flags 	&= ~(IFF_UP | IFF_DRV_RUNNING | IFF_DRV_OACTIVE);
	if (ifp->if_softc){ 
		wan_free(ifp->if_softc);
		ifp->if_softc = NULL;
	ifp->irq        = 0;
	ifp->mem_start  = 0;
	ifp->mem_end    = 0;
*-F*************************************************************************/
*-F*************************************************************************/
	wan_adsl_conf_t*	adsl_conf = &conf->u.adsl;
		adsl_conf->vcivpi_list[x].vci = adsl_vcivpi_list[x].vci;
		adsl_conf->vcivpi_list[x].vpi = adsl_vcivpi_list[x].vpi;
	adsl_conf->vcivpi_num = (unsigned short)adsl_vcivpi_num;
*-F*************************************************************************/
	if (!card->u.adsl.adapter)
	wan = (char)adsl_wan_interface_type(card->u.adsl.adapter);
	adsl_disable_comm(card->u.adsl.adapter);
	card->u.adsl.adapter 	= NULL;
*-F*************************************************************************/
	sdla_t*			card = adsl->common.card;
	* kick start the device by making dev->tbusy = 0.  We expect
	dev->trans_start = SYSTEM_TICKS;
	card->wandev.stats.collisions++;
	adsl_timeout(card->u.adsl.adapter);
*-F*************************************************************************/
	sdla_t* card = adsl->common.card;
	if (adsl->common.prot_ptr){
			return -EIO;
	if (card->wandev.state == WAN_CONNECTED) {
	if (adsl->common.usedby == STACK){
*-F*************************************************************************/
	if (adsl->common.prot_ptr){
			return -EIO;
*-F*************************************************************************/
	sdla_t*			card = adsl->common.card;
	* kick start the device by making dev->tbusy = 0.  We expect
	dev->trans_start = SYSTEM_TICKS;
	card->wandev.stats.collisions++;
	adsl_timeout(card->u.adsl.adapter);
*-F*************************************************************************/
*-F*************************************************************************/
*-F*************************************************************************/
	if (!card->u.adsl.adapter){
	/*WAN_ASSERT1(card->u.adsl.adapter == NULL);*/
	ret=adsl_isr((void*)card->u.adsl.adapter);
*-F*************************************************************************/
	card = (sdla_t*)adsl->common.card;
	if (card->u.adsl.EncapMode == RFC_MODE_PPP_VC	||
		card->u.adsl.EncapMode == RFC_MODE_PPP_LLC	||
		card->u.adsl.EncapMode == RFC_MODE_STACK_VC	){
	card->wandev.stats.rx_packets ++;
	card->wandev.stats.rx_bytes += wan_skb_len(rx_skb);
	switch(card->u.adsl.EncapMode){
			card->wandev.stats.rx_packets--;
			card->wandev.stats.rx_bytes -= wan_skb_len(rx_skb);
				card->devname);
			/* oh, no - IP queue is full - well - we'll
			card->wandev.stats.rx_packets--;
			card->wandev.stats.rx_bytes -= wan_skb_len(rx_skb);
		dev->if_input(dev, rx_skb);
	card->wandev.stats.rx_packets ++;
	card->wandev.stats.rx_bytes += wan_skb_len(rx_skb);
	switch (card->u.adsl.EncapMode){
			card->wandev.stats.rx_packets--;
			card->wandev.stats.rx_bytes -= wan_skb_len(rx_skb);
		rx_skb->protocol = eth_type_trans(rx_skb, rx_skb->dev);
		rx_skb->protocol = htons(ETH_P_IP);
		rx_skb->protocol = htons(ETH_P_WAN_PPP);
		rx_skb->dev = dev;
		wp_sppp_input(rx_skb->dev,rx_skb);
	adsl_rx_complete(adsl->pAdapter);
*-F*************************************************************************/
	card = (sdla_t*)adsl->common.card;
	switch (card->u.adsl.EncapMode)
			card->wandev.stats.tx_errors++;
	if (adsl_can_tx(adsl->pAdapter)){
		card->wandev.stats.tx_carrier_errors++;
		dev->trans_start = SYSTEM_TICKS;
		return -EINVAL;
		card->devname, wan_skb_len(skb));
	DBG_ASSERT(skb->len < GSI_LAN_NDIS_BUFFER_SIZE);
		printk(KERN_INFO "TX RAW : %i: ",skb->len);
		//memcpy(skb->data,tmp_frame,sizeof(tmp_frame));
		for (r=0;r<skb->len;r++){
			printk("%02X ",skb->data[r]);
	dev->trans_start = SYSTEM_TICKS;
	status = adsl_send(adsl->pAdapter, skb, 0);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);	
		wan_set_bit(TX_BUSY_SET,&card->wandev.critical);
			card->wandev.stats.rx_dropped++;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);	
	dev->trans_start = SYSTEM_TICKS;
	status = adsl_send(adsl->pAdapter, skb, 0);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		wan_set_bit(TX_BUSY_SET,&card->wandev.critical);
			card->wandev.stats.rx_dropped++;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);	
	if (dst->sa_family != AF_INET){
			card->devname); 
		return -EAFNOSUPPORT;
	if (card->wandev.state != WAN_CONNECTED){
		DEBUG_TX("%s: Device is not connected!\n", card->devname);
		return -EINVAL;
	switch (card->u.adsl.EncapMode){
		/* classify the packet before prepanding link-headers */
		WAN_IFQ_CLASSIFY(&dev->if_snd, skb, dst->sa_family, &pktattr);
		WAN_IFQ_ENQUEUE(&dev->if_snd, skb, &pktattr, status);
				card->devname);
		if ((dev->if_flags & IFF_DRV_OACTIVE) == 0){ 
		status = dev->if_output(dev, skb, dst, rt0); 
*-F*************************************************************************/
	if (adsl_can_tx(adsl->pAdapter)){
		if (adsl_send(adsl->pAdapter, tx_mbuf, 0)){
			ifp->if_iqdrops++;
*-F*************************************************************************/
	WAN_ASSERT1(adsl->common.card == NULL);
	card = adsl->card;
	while(!WAN_IFQ_IS_EMPTY(&card->xmitq_hipri)){
		WAN_IFQ_POLL(&card->xmitq_hipri, tx_mbuf);
		if (adsl_send(adsl->pAdapter, tx_mbuf, 0)){
		WAN_IFQ_DEQUEUE(&card->xmitq_hipri, tx_mbuf);
	while(!WAN_IFQ_IS_EMPTY(&ifp->if_snd)){
		WAN_IFQ_DEQUEUE(&ifp->if_snd, tx_mbuf);
		if (adsl_send(adsl->pAdapter, tx_mbuf, 0)){
			ifp->if_iqdrops++;
*-F*************************************************************************/
	card = (sdla_t*)adsl->common.card;
		ifp->if_opackets++;
		ifp->if_obytes += length;
		card->wandev.stats.tx_packets ++;
		card->wandev.stats.tx_bytes += length;
		ifp->if_oerrors++;
	ifp->trans_start = SYSTEM_TICKS;
	wan_clear_bit(TX_BUSY_SET,&card->wandev.critical);
		wan_test_bit(TX_BUSY_SET,&card->wandev.critical)){
			wan_clear_bit(TX_BUSY_SET,&card->wandev.critical);
				card->devname, wan_netif_name(ifp));
			if (adsl->common.usedby == STACK){
*-F*************************************************************************/
		adsl->if_name,
		(flags & IFF_ALLMULTI)	? "All-Multicast" : "");
		adsl->if_name,
		adsl->macAddr[0], adsl->macAddr[1], 
		adsl->macAddr[2], adsl->macAddr[3],
		adsl->macAddr[4], adsl->macAddr[5]);
				memcpy(&(mcaddrs[x * 6]), (void*)mclist->ifma_addr, 6);
				memcpy(&(mcaddrs[x * 6]), mclist->dmi_addr, 6);
	/*adsl_lan_multicast(adsl->pAdapter, flags, mcaddrs, mcount);
*-F*************************************************************************/
	card = (sdla_t*)adsl->common.card;
	return &card->wandev.stats;
	card = (sdla_t*)adsl->common.card;
	return &card->wandev.stats;
*-F*************************************************************************/
	if (wan_test_bit(0,&trace_info->tracing_enabled)){
		if ((SYSTEM_TICKS - trace_info->trace_timeout) > MAX_TRACE_TIMEOUT){
			wan_clear_bit(0,&trace_info->tracing_enabled);
			wan_clear_bit(1,&trace_info->tracing_enabled);
			return -EINVAL;
		if (adsl_trace_queue_len(trace_info) < trace_info->max_trace_queue){
			if (wan_test_bit(1,&trace_info->tracing_enabled)){
			}else if (wan_test_bit(2,&trace_info->tracing_enabled)){
			trace_info->max_trace_queue);
		return -ENOBUFS;
	return -EINVAL;
	trace_queue = &trace->trace_queue;
	trace->trace_timeout	= SYSTEM_TICKS;
	trace->tracing_enabled	= 0;
	trace->max_trace_queue	= MAX_TRACE_QUEUE;
	trace_queue = &trace->trace_queue;
	trace_queue = &trace->trace_queue;
	trace_queue = &trace->trace_queue;
*-F*************************************************************************/
	sdla_t*			card = (sdla_t*)adsl->common.card;
			DEBUG_IOCTL("%s - ioctl(WANPIPE_PIPEMON) called.\n", card->devname);
			if (wan_atomic_read(&adsl->udp_pkt_len) != 0){
				error = -EBUSY;
			wan_atomic_set(&adsl->udp_pkt_len,sizeof(wan_udp_hdr_t));
			if (wan_test_bit(0,&card->in_isr)){
				wan_atomic_set(&adsl->udp_pkt_len,0);
				error = -EBUSY;
			wan_udp_pkt=(wan_udp_pkt_t*)&adsl->udp_pkt_data[0];
			if (WAN_COPY_FROM_USER(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
					card->devname);
				wan_atomic_set(&adsl->udp_pkt_len,0);
				error = -EFAULT;
			error = process_udp_cmd(ifp, &wan_udp_pkt->wan_udp_hdr);
			if (wan_atomic_read(&adsl->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
					card->devname,wan_atomic_read(&adsl->udp_pkt_len));
				wan_atomic_set(&adsl->udp_pkt_len,0);
				error = -EINVAL;
			if (WAN_COPY_TO_USER(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
					card->devname);
				wan_atomic_set(&adsl->udp_pkt_len,0);
				error = -EFAULT;
			wan_atomic_set(&adsl->udp_pkt_len,0);
			switch (card->u.adsl.EncapMode){
			ifmr->ifm_current = IFM_ETHER;
			error = -EOPNOTSUPP;
			ifmr->ifm_active = ifmr->ifm_current;
			ifmr->ifm_mask = 0;
			ifmr->ifm_status = 0;
			ifmr->ifm_count = 1;
			sprintf(ifs->ascii + strlen(ifs->ascii),
			ifp->if_mtu = ifr->ifr_mtu;
			if (card->u.adsl.EncapMode == RFC_MODE_BRIDGED_ETH_LLC || 
				card->u.adsl.EncapMode == RFC_MODE_BRIDGED_ETH_VC){
			} else if (card->u.adsl.EncapMode == RFC_MODE_ROUTED_IP_LLC || 
				card->u.adsl.EncapMode == RFC_MODE_ROUTED_IP_VC){
					if (ifa->ifa_addr->sa_family == AF_INET){
			if (card->u.adsl.EncapMode == RFC_MODE_PPP_VC ||
				card->u.adsl.EncapMode == RFC_MODE_PPP_LLC){
					error = -EOPNOTSUPP;
			}else if (card->u.adsl.EncapMode == RFC_MODE_BRIDGED_ETH_LLC || 
				card->u.adsl.EncapMode == RFC_MODE_BRIDGED_ETH_VC){
					error = -EOPNOTSUPP;
	dev = adsl->common.dev;
	card = adsl->common.card;  
	wan_udp_pkt = (wan_udp_pkt_t*)chan->udp_pkt_data;
	//trace_info = &chan->trace_info;
	wanif_conf = netdev->wanif_conf;
	wpabs_memcpy(&wan_udp_pkt->wan_udp_hdr, netdev->mgmt_userbfr,
		netdev->mgmt_userbfr_len);
	wan_udp_pkt->wan_udp_opp_flag = 0;
	switch(wan_udp_pkt->wan_udp_command) {
			if_cfg_t *if_cfg = (if_cfg_t*)wan_udp_pkt->wan_udp_data;
			DEBUG_UDP("usedby: %s\n", wanif_conf->usedby);
			DEBUG_UDP("active_ch: 0x%08X\n", wanif_conf->active_ch);
			//wpabs_memcpy(wan_udp_pkt->wan_udp_data, wanif_conf, sizeof(wanif_conf_t));//WRONG!!!
			_snprintf(if_cfg->usedby, USED_BY_FIELD, "%s", wanif_conf->usedby);
			if_cfg->active_ch = wanif_conf->active_ch;
			if_cfg->media = WAN_FE_MEDIA(&card->fe);
			if_cfg->interface_number = netdev->interface_number;
		wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
		wan_udp_pkt->wan_udp_data_len = sizeof(wanif_conf_t);
		wpabs_memcpy(wan_udp_pkt->wan_udp_data, &drv_version, sizeof(DRIVER_VERSION));
		wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
		wan_udp_pkt->wan_udp_data_len = sizeof(DRIVER_VERSION);
		*(int*)&wan_udp_pkt->wan_udp_data[0] = netdev->open_handle_counter;
		wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
		wan_udp_pkt->wan_udp_data_len = sizeof(int);
		chan->router_up_time = tv - chan->router_start_time;
		*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
			chan->router_up_time;	
		wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
		wan_udp_pkt->wan_udp_return_code = 0;
		DEBUG_UDP("%s: READ_OPERATIONAL_STATS\n",	netdev->name);
		wpabs_memcpy(wan_udp_pkt->wan_udp_data, &chan->if_stats, sizeof(net_device_stats_t));
		wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
		wan_udp_pkt->wan_udp_data_len = sizeof(net_device_stats_t);
		DEBUG_UDP("%s: FLUSH_OPERATIONAL_STATS\n",	netdev->name);
		memset(&chan->if_stats, 0x00, sizeof(net_device_stats_t));
		wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
		wan_udp_pkt->wan_udp_data_len = sizeof(net_device_stats_t);
		wan_udp_pkt->wan_udp_data[0] = WAN_MEDIA_NONE;
		wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
		wan_udp_pkt->wan_udp_data_len = sizeof(unsigned char); 
		DEBUG_UDP("%s: WAN_GET_PROTOCOL\n",	netdev->name);
		wan_udp_pkt->wan_udp_data[0] = (unsigned char)card->wandev.config_id;
		wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
		wan_udp_pkt->wan_udp_data_len = 1;
		wan_udp_pkt->wan_udp_data[0] = WAN_WIN2K_PLATFORM;
		wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
		wan_udp_pkt->wan_udp_data_len = 1;
		wan_udp_pkt->wan_udp_data_len = 0;
		wan_udp_pkt->wan_udp_return_code = 0xCD;
			netdev->name, wan_udp_pkt->wan_udp_command);
	wpabs_memcpy(netdev->mgmt_userbfr, &wan_udp_pkt->wan_udp_hdr,
		netdev->mgmt_userbfr_len);
	wan_udp_pkt = (wan_udp_pkt_t*)adsl->udp_pkt_data;
	error = process_udp_cmd(dev, &wan_udp_pkt->wan_udp_hdr);	
	wan_udp_pkt->wan_ip_ttl = card->wandev.ttl; 
	len = wan_reply_udp(card, adsl->udp_pkt_data, wan_udp_pkt->wan_udp_data_len);
	if (card->u.adsl.EncapMode == RFC_MODE_BRIDGED_ETH_LLC ||
		card->u.adsl.EncapMode == RFC_MODE_BRIDGED_ETH_VC){
		if (card->u.adsl.EncapMode == RFC_MODE_BRIDGED_ETH_LLC ||
			card->u.adsl.EncapMode == RFC_MODE_BRIDGED_ETH_VC){
				if (adsl->udp_pkt_src == UDP_PKT_FRM_NETWORK){
						&adsl->macAddr[0]);
						&adsl->remote_eth_addr[0]);
						&adsl->remote_eth_addr[0]);
						&adsl->macAddr[0]);
				len -= sizeof(ethhdr_t);
			adsl->udp_pkt_data);
		if (card->u.adsl.EncapMode == RFC_MODE_BRIDGED_ETH_LLC ||
			card->u.adsl.EncapMode == RFC_MODE_BRIDGED_ETH_VC){
				new_skb->protocol = eth_type_trans(new_skb, new_skb->dev);
			new_skb->protocol = htons(ETH_P_IP);
		if (adsl->udp_pkt_src == UDP_PKT_FRM_NETWORK){
		if (adsl->udp_pkt_src == UDP_PKT_FRM_NETWORK){
			wan_spin_lock_irq(&card->wandev.lock, &s);
			WAN_IFQ_ENQUEUE(&dev->if_snd, new_skb, NULL, error);
				dev->if_obytes += wan_skb_len(new_skb) + sizeof(ethhdr_t);
				if ((dev->if_flags & IFF_DRV_OACTIVE) == 0){
					(*dev->if_start)(dev);
			wan_spin_unlock_irq(&card->wandev.lock, &s);
			dev->if_input(dev, new_skb);
			card->devname);
	wan_atomic_set(&adsl->udp_pkt_len,0);
	sdla_t* 		card = adsl->common.card;
	adsl_trace_info_t *trace_info = adsl_get_trace_ptr(adsl->pAdapter);
	udp_hdr->wan_udphdr_return_code=0;
	if (card->u.adsl.adapter == NULL){
	switch(udp_hdr->wan_udphdr_command){
		udp_hdr->wan_udphdr_adsl_num_frames = WANCONFIG_ADSL;
		udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
		udp_hdr->wan_udphdr_data_len = 2;
		udp_hdr->wan_udphdr_data[0] = WAN_FREEBSD_PLATFORM;
		udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
		udp_hdr->wan_udphdr_data_len = 1;
		udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
		udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
		sprintf(udp_hdr->wan_udphdr_data, "%s", WANPIPE_VERSION);
		udp_hdr->wan_udphdr_data_len = (unsigned short)strlen(udp_hdr->wan_udphdr_data);
		wan_getcurrenttime(&adsl->router_up_time, NULL);
		adsl->router_up_time -= adsl->router_start_time;
		*(unsigned long *)&udp_hdr->wan_udphdr_data = 
			adsl->router_up_time;	
		udp_hdr->wan_udphdr_data_len = sizeof(unsigned long);
		udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
		udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
		udp_hdr->wan_udphdr_data_len = 0;
		if (!wan_test_bit(0,&trace_info->tracing_enabled)){
			trace_info->trace_timeout = SYSTEM_TICKS;
			if (udp_hdr->wan_udphdr_data[0] == 0){
				wan_clear_bit(1,&trace_info->tracing_enabled);
					card->devname);
			}else if (udp_hdr->wan_udphdr_data[0] == 1){
				wan_clear_bit(2,&trace_info->tracing_enabled);
				wan_set_bit(1,&trace_info->tracing_enabled);
					card->devname);
				wan_clear_bit(1,&trace_info->tracing_enabled);
				wan_set_bit(2,&trace_info->tracing_enabled);
					card->devname);
			wan_set_bit (0,&trace_info->tracing_enabled);
				card->devname);
			udp_hdr->wan_udphdr_return_code = 2;
		udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
		if(wan_test_bit(0,&trace_info->tracing_enabled)) {
			wan_clear_bit(0,&trace_info->tracing_enabled);
			wan_clear_bit(1,&trace_info->tracing_enabled);
			wan_clear_bit(2,&trace_info->tracing_enabled);
				card->devname);
			udp_hdr->wan_udphdr_return_code = 1;
		if(wan_test_bit(0,&trace_info->tracing_enabled)){
			trace_info->trace_timeout = SYSTEM_TICKS;
				card->devname);
			udp_hdr->wan_udphdr_return_code = 1;
		udp_hdr->wan_udphdr_adsl_num_frames = 0;	
		udp_hdr->wan_udphdr_adsl_ismoredata = 0;
			WAN_IFQ_POLL(&trace_info->trace_queue, skb);
					card->devname);
			if ((WAN_MAX_DATA_SIZE - buffer_length) < skb->m_pkthdr.len){
				udp_hdr->wan_udphdr_adsl_ismoredata = 0x01;
				skb->m_pkthdr.len, 
				&udp_hdr->wan_udphdr_data[buffer_length]);
			buffer_length += skb->m_pkthdr.len;
			WAN_IFQ_DEQUEUE(&trace_info->trace_queue, skb);
			udp_hdr->wan_udphdr_adsl_num_frames++;
		while ((skb=skb_dequeue(&trace_info->trace_queue)) != NULL){
			if((MAX_TRACE_BUFFER - buffer_length) < wan_skb_len(skb)){
				udp_hdr->wan_udphdr_adsl_ismoredata = 0x01;
					skb_queue_head(&trace_info->trace_queue, skb);
					memcpy(&udp_hdr->wan_udphdr_adsl_data[buffer_length], 
					udp_hdr->wan_udphdr_adsl_num_frames++;
			memcpy(&udp_hdr->wan_udphdr_adsl_data[buffer_length], 
			udp_hdr->wan_udphdr_adsl_num_frames++;
		udp_hdr->wan_udphdr_data_len = (unsigned short)buffer_length;
		udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
			card->u.adsl.adapter, 
			udp_hdr->wan_udphdr_command,
			&udp_hdr->wan_udphdr_data[0],
			&udp_hdr->wan_udphdr_data_len);
		udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
	wan_atomic_set(&adsl->udp_pkt_len, 
		sizeof(wan_cmd_t) + udp_hdr->wan_udphdr_data_len);
	udp_hdr->wan_udphdr_request_reply = UDPMGMT_REPLY;
	adsl_private_area_t *adsl=dev->priv;
		return -ENOMEM;
	adsl->common.prot_ptr=(void*)pppdev;
	pppdev->dev=dev;
	if(conf->pap == WANOPT_YES){
		pppdev->sppp.myauth.proto = PPP_PAP;
			card->devname); 
	}else if(conf->chap == WANOPT_YES){
		pppdev->sppp.myauth.proto = PPP_CHAP;
			card->devname); 
		pppdev->sppp.myauth.proto = 0;
			card->devname);
	if(pppdev->sppp.myauth.proto){
		memcpy(pppdev->sppp.myauth.name, conf->userid, AUTHNAMELEN);
		memcpy(pppdev->sppp.myauth.secret, conf->passwd, AUTHNAMELEN);
			card->devname, 
			(pppdev->sppp.myauth.proto==PPP_PAP)?"PAP":"CHAP",
			conf->userid);
	pppdev->sppp.gateway = conf->gateway;
	if (conf->if_down){
		pppdev->sppp.dynamic_ip = 1;
	sprintf(pppdev->sppp.hwdevname,"%s",card->devname);
	sp = &pppdev->sppp;
	if (conf->protocol == WANCONFIG_CHDLC){
			card->devname);
		sp->pp_flags |= PP_CISCO;
		conf->ignore_dcd = WANOPT_YES;
		conf->ignore_cts = WANOPT_YES;
			card->devname);
		sp->pp_flags &= ~PP_CISCO;
		dev->type	= ARPHRD_PPP;
	sdla_t				*card = (sdla_t*)chan->common.card;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
		//At this point all the data in per-Logic Channel RX queue.
		if(KeInsertQueueDpc(&card->rx_dpc_obj, NULL, NULL) == FALSE){
			DBG_ADSL_RX("ADSL:Failed to 'queue rx_dpc_obj' - Not critical.\n");
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	sdla_t				*card = (sdla_t*)chan->common.card;
	api_header_t		*api_header = &rx_data_struct->api_header;
	unsigned char		*rx_data	= rx_data_struct->data;
	DBG_ADSL_RX("%s: api_header->data_length: %d\n",
		chan->if_name, api_header->data_length);
	for(i = 0; i < api_header->data_length; i++){
	if(sdla_net_dev->open_handle_counter == 0){
			chan->if_name);
	if(api_header->data_length > ((DATA_QUEUE*)sdla_net_dev->rx_user_info.queue)->max_data_length){
		DBG_ADSL_RX("api_header->data_length > DATA_BUFFER_LEN!!\n");
		chan->if_stats.rx_packets_discarded_excessive_length++;
	if(api_header->data_length < 1){
		DBG_ADSL_RX("api_header->data_length < 1!!\n");
		chan->if_stats.rx_packets_discarded_too_short++;
	rc = enqueue(sdla_net_dev->rx_user_info.queue, &tmp_rx_q_el);
		if(((DATA_QUEUE*)sdla_net_dev->rx_user_info.queue)->q_full_message_printed == 0){
			((DATA_QUEUE*)sdla_net_dev->rx_user_info.queue)->q_full_message_printed = 1;
				DEBUG_EVENT("%s: Warning: Discarding Rx data - rx queue is full!!\n", 
					sdla_net_dev->name);
				DEBUG_EVENT("%s: Warning: Discarding Rx data - data too long!!\n", 
					sdla_net_dev->name);
		chan->if_stats.rx_packets_discarded_rx_q_full++;
		((DATA_QUEUE*)sdla_net_dev->rx_user_info.queue)->q_full_message_printed = 0;
	chan->if_stats.rx_packets++;
	chan->if_stats.rx_bytes += tmp_rx_q_el.api_header.data_length;
	//arr_q_size(sdla_net_dev->rx_queue);
	sdla_t				*card = (sdla_t*)chan->common.card;
	if(wan_test_bit(TX_BUSY_SET,&card->wandev.critical)){
		DBG_ADSL_FAST_TX("%s: return 'SANG_STATUS_DEVICE_BUSY'\n", sdla_net_dev->name);
	if(sdla_net_dev->open_handle_counter == 0){
				sdla_net_dev->name);
		((DATA_QUEUE*)sdla_net_dev->tx_queue)->current_num_of_elements_in_q);
	wpabs_tasklet_schedule(&chan->adsl_if_send_task);
	sdla_t				*card = (sdla_t*)chan->common.card;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);	
	tmp_tx_q_el	= dequeue(sdla_net_dev->tx_queue);
		DBG_ADSL_TX("%s():%s: tx queue is empty!\n", __FUNCTION__, sdla_net_dev->name);
		wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);	
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);	
		DEBUG_EVENT("%s():Warning: %s: skb is NULL!\n", __FUNCTION__, sdla_net_dev->name);
				__FUNCTION__, sdla_net_dev->name);
		chan->if_stats.tx_packets++;
		chan->if_stats.tx_bytes += tmp_tx_q_el->api_header.data_length;
./sdla_adsl.c
# include "zapcompat.h" /* Map of Zaptel -> DAHDI definitions */
#define IS_TDMV_RUNNING(wr)	wan_test_bit(WP_TDMV_RUNNING, &(wr)->flags)
#define IS_TDMV_UP(wr)		wan_test_bit(WP_TDMV_UP, &(wr)->flags)
	wp_tdmv_remora_t	*wr = chan->pvt;
	WAN_ASSERT(wr->card == NULL);
	card	= wr->card;
	fe	= &card->fe;
		if (fe->rm_param.mod[chan->chanpos - 1].type != MOD_TYPE_FXS) {
			return -EINVAL;
		if (err) return -EFAULT;
		wr->mod[chan->chanpos - 1].fxs.ohttimer = x << 3;
		if (fe->fe_cfg.cfg.remora.reversepolarity){
			fe->rm_param.mod[chan->chanpos - 1].u.fxs.idletxhookstate  = 0x6;
			fe->rm_param.mod[chan->chanpos - 1].u.fxs.idletxhookstate  = 0x2;
		if (wr->mod[chan->chanpos - 1].fxs.lasttxhook == 0x1) {
			if (fe->fe_cfg.cfg.remora.reversepolarity){
				wr->mod[chan->chanpos - 1].fxs.lasttxhook = 0x6;
				wr->mod[chan->chanpos - 1].fxs.lasttxhook = 0x2;
			wr->mod[chan->chanpos-1].fxs.lasttxhook_update = 1;
			WRITE_RM_REG(chan->chanpos - 1, 64, wr->mod[chan->chanpos - 1].fxs.lasttxhook);
		if (err) return -EFAULT;
		if (fe->rm_param.mod[chan->chanpos - 1].type != MOD_TYPE_FXS) {
			return -EINVAL;
		if ((wr->mod[chan->chanpos - 1].fxs.lasttxhook == 0x04) ||
		    (wr->mod[chan->chanpos - 1 ].fxs.lasttxhook == 0x00)){
			return -EINVAL;
		if ((x && !fe->fe_cfg.cfg.remora.reversepolarity) || (!x && fe->fe_cfg.cfg.remora.reversepolarity)){
			wr->mod[chan->chanpos - 1].fxs.lasttxhook |= 0x04;
			wr->mod[chan->chanpos - 1].fxs.lasttxhook &= ~0x04;
		wr->mod[chan->chanpos-1].fxs.lasttxhook_update = 1;
		WRITE_RM_REG(chan->chanpos - 1, 64, wr->mod[chan->chanpos - 1].fxs.lasttxhook);
		if (fe->rm_param.mod[chan->chanpos - 1].type == MOD_TYPE_FXO) {
					&wr->mod[chan->chanpos-1].fxo.echoregs,
			if (err) return -EFAULT;
			wr->mod[chan->chanpos-1].fxo.echotune = 1;
					wr->devname, chan->chanpos-1);
			WRITE_RM_REG(chan->chanpos - 1, 30, echoregs.acim);
			WRITE_RM_REG(chan->chanpos - 1, 45, echoregs.coef1);
			WRITE_RM_REG(chan->chanpos - 1, 46, echoregs.coef2);
			WRITE_RM_REG(chan->chanpos - 1, 47, echoregs.coef3);
			WRITE_RM_REG(chan->chanpos - 1, 48, echoregs.coef4);
			WRITE_RM_REG(chan->chanpos - 1, 49, echoregs.coef5);
			WRITE_RM_REG(chan->chanpos - 1, 50, echoregs.coef6);
			WRITE_RM_REG(chan->chanpos - 1, 51, echoregs.coef7);
			WRITE_RM_REG(chan->chanpos - 1, 52, echoregs.coef8);
					wr->devname, chan->chanpos-1);
			return -EINVAL;
			return -EFAULT;
		if (wr->dtmfsupport != WANOPT_YES || card->wandev.ec_dev == NULL){
			return -ENOSYS;
			wr->devname,
			(x & ZT_TONEDETECT_ON) ? "ON" : "OFF", chan->chanpos - 1,
			wr->dtmfmask |= (1 << (chan->chanpos - 1));
			wr->dtmfmask &= ~(1 << (chan->chanpos - 1));
			wr->dtmfmutemask |= (1 << (chan->chanpos - 1));
			wr->dtmfmutemask &= ~(1 << (chan->chanpos - 1));
						wr->devname);
			return -EFAULT;
		event_ctrl->type = WAN_EVENT_EC_CHAN_MODIFY;
		event_ctrl->channel = chan->chanpos-1;
		event_ctrl->mode = (x & ZT_TONEDETECT_MUTE) ? WAN_EVENT_ENABLE : WAN_EVENT_DISABLE;
		if (wanpipe_ec_event_ctrl(card->wandev.ec_dev, card, event_ctrl)){
		err = -EINVAL;
		return -ENOTTY;
	wp_tdmv_remora_t	*wr = chan->pvt;
	WAN_ASSERT(wr->card == NULL);
	card	= wr->card;
	fe	= &card->fe;
	if (fe->rm_param.mod[chan->chanpos - 1].type == MOD_TYPE_FXO) {
			DEBUG_TDMV("%s: Module %d: goes off-hook (txsig %d)\n", 
					wr->devname, chan->chanpos, txsig);
			wr->mod[chan->chanpos - 1].fxo.offhook = 1;
			wr->reg0shadow[chan->chanpos-1] = 0x09;
			wr->reg0shadow_update[chan->chanpos-1] = 1;
			WRITE_RM_REG(chan->chanpos - 1, 5, 0x9);
			DEBUG_TDMV("%s: Module %d: goes on-hook (txsig %d)\n", 
					wr->devname, chan->chanpos, txsig);
			wr->mod[chan->chanpos - 1].fxo.offhook = 0;
			wr->reg0shadow[chan->chanpos-1] = 0x08;
			wr->reg0shadow_update[chan->chanpos-1] = 1;
			WRITE_RM_REG(chan->chanpos - 1, 5, 0x8);
					wr->devname, txsig, chan->chanpos);
	}else if (fe->rm_param.mod[chan->chanpos - 1].type == MOD_TYPE_FXS) {
			DEBUG_TDMV("ADBG> %s: Module %d: goes on-hook (txsig %d).\n",
					wr->devname, chan->chanpos, txsig);
			switch(chan->sig) {
				wr->mod[chan->chanpos-1].fxs.lasttxhook =
					fe->rm_param.mod[chan->chanpos-1].u.fxs.idletxhookstate;
				wr->mod[chan->chanpos-1].fxs.lasttxhook = 3;
			DEBUG_TDMV("ADBG> %s: Module %d: goes off-hook (txsig %d).\n",
					wr->devname, chan->chanpos, txsig);
			switch(chan->sig) {
				wr->mod[chan->chanpos-1].fxs.lasttxhook = 5;
				wr->mod[chan->chanpos-1].fxs.lasttxhook =
					fe->rm_param.mod[chan->chanpos-1].u.fxs.idletxhookstate;
					wr->devname, chan->chanpos, txsig);
			wr->mod[chan->chanpos-1].fxs.lasttxhook = 4;
			wr->mod[chan->chanpos-1].fxs.lasttxhook = 0;
					wr->devname, txsig);
		wr->mod[chan->chanpos-1].fxs.lasttxhook_update = 1;
		WRITE_RM_REG(chan->chanpos - 1, 64, wr->mod[chan->chanpos-1].fxs.lasttxhook);
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wr = chan->pvt;
	wr->usecount++;
	wan_set_bit(WP_TDMV_RUNNING, &wr->flags);
				wr->devname,
				wr->usecount,
				chan->channo,
				chan->chanpos);
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wr	= chan->pvt;
	card	= wr->card;
	fe	= &card->fe;
	wr->usecount--;
	wan_clear_bit(WP_TDMV_RUNNING, &wr->flags);
	if (fe->rm_param.mod[chan->chanpos - 1].type == MOD_TYPE_FXS) {
		if (fe->fe_cfg.cfg.remora.reversepolarity)
			fe->rm_param.mod[chan->chanpos - 1].u.fxs.idletxhookstate = 5;
			fe->rm_param.mod[chan->chanpos - 1].u.fxs.idletxhookstate = 1;
	wctdm_restart_dma(span->pvt);
** wp_remora_zap_hwec() - 
	int			fe_chan = chan->chanpos;
	int			err = -ENODEV;
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wr = chan->pvt;
	WAN_ASSERT2(wr->card == NULL, -ENODEV);
	card = wr->card;
	fe_chan--;
		wan_set_bit(fe_chan,&card->wandev.rtp_tap_call_map);
		wan_clear_bit(fe_chan,&card->wandev.rtp_tap_call_map);
	if (card->wandev.ec_enable){
		if (card->hwec_conf.persist_disable) {
			err = card->wandev.ec_enable(card, enable, fe_chan);
				wr->devname,
	WAN_ASSERT1(wr->card == NULL);
	card	= wr->card;
	fe	= &card->fe;
	res = wr->reg2shadow[mod_no];
		"%s: Module %d: Ouch, part reset, quickly restoring reality (%02X) -- Comment out\n",
				wr->devname, mod_no, res);
	res = wr->reg1shadow[mod_no];
	if (!res && (res != wr->mod[mod_no].fxs.lasttxhook)) {
		res = wr->reg2shadow[mod_no];
					wr->devname, mod_no+1);
			if (wr->mod[mod_no].fxs.palarms++ < MAX_ALARMS) {
					wr->devname, mod_no + 1);
				if (wr->mod[mod_no].fxs.lasttxhook == 4)
					wr->mod[mod_no].fxs.lasttxhook = 1;
				WRITE_RM_REG(mod_no, 64, wr->mod[mod_no].fxs.lasttxhook);
				if (wr->mod[mod_no].fxs.palarms == MAX_ALARMS)
						wr->devname, mod_no + 1);
	WAN_ASSERT1(wr->card == NULL);
	card	= wr->card;
	fe	= &card->fe;
	res = wr->reg2shadow[mod_no];
					wr->devname, mod_no+1);
	WAN_ASSERT1(wr->card == NULL);
	card	= wr->card;
	fe	= &card->fe;
	b = wr->reg0shadow[mod_no];
		/* Not good -- don't look at anything else */
				wr->devname, mod_no + 1, b); 
	if (wr->mod[mod_no].fxo.offhook) {
	if (!wr->mod[mod_no].fxo.offhook) {
		res = wr->reg0shadow[mod_no];
		if ((res & 0x60) && wr->mod[mod_no].fxo.battery) {
			wr->mod[mod_no].fxo.ringdebounce += (ZT_CHUNKSIZE * 16);
			if (wr->mod[mod_no].fxo.ringdebounce >= ZT_CHUNKSIZE * 64) {
				if (!wr->mod[mod_no].fxo.wasringing) {
					wr->mod[mod_no].fxo.wasringing = 1;
					zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_RING);
							wr->devname,
							wr->span.spanno);
				wr->mod[mod_no].fxo.ringdebounce = ZT_CHUNKSIZE * 64;
			wr->mod[mod_no].fxo.ringdebounce -= ZT_CHUNKSIZE * 4;
			if (wr->mod[mod_no].fxo.ringdebounce <= 0) {
				if (wr->mod[mod_no].fxo.wasringing) {
					wr->mod[mod_no].fxo.wasringing = 0;
					wr->mod[mod_no].fxo.readcid = 0;
 					wr->mod[mod_no].fxo.cidtimer = wr->intcount;
					zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_OFFHOOK);
							wr->devname,
							wr->span.spanno);
				wr->mod[mod_no].fxo.ringdebounce = 0;
	b = wr->reg1shadow[mod_no];
			       b, wr->mod[mod_no].fxo.battdebounce);
		fe->rm_param.mod[mod_no].u.fxo.statusdebounce--;
		if (fe->rm_param.mod[mod_no].u.fxo.statusdebounce <= 0) {
			if (fe->rm_param.mod[mod_no].u.fxo.status != FE_CONNECTED){
								wr->devname,
								wr->span.spanno);
				fe->rm_param.mod[mod_no].u.fxo.status = FE_CONNECTED;
			fe->rm_param.mod[mod_no].u.fxo.statusdebounce = 0;
	}else if (!wr->mod[mod_no].fxo.wasringing){
		fe->rm_param.mod[mod_no].u.fxo.statusdebounce ++;
		if (fe->rm_param.mod[mod_no].u.fxo.statusdebounce >= FXO_LINK_DEBOUNCE){
			if (fe->rm_param.mod[mod_no].u.fxo.status != FE_DISCONNECTED){
								wr->devname,
								wr->span.spanno);
				fe->rm_param.mod[mod_no].u.fxo.status = FE_DISCONNECTED;
				zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_INITIAL);
			fe->rm_param.mod[mod_no].u.fxo.statusdebounce = FXO_LINK_DEBOUNCE;
	if (abs(b) < wr->battthresh) {
		wr->mod[mod_no].fxo.nobatttimer++;
		if (wr->mod[mod_no].fxo.battery)
				b, wr->mod[mod_no].fxo.battdebounce);
		if (wr->mod[mod_no].fxo.battery && !wr->mod[mod_no].fxo.battdebounce) {
						wr->devname,
						wr->span.spanno);
			wr->mod[mod_no].fxo.battery =  0;
			if ((!wr->mod[mod_no].fxo.ohdebounce) &&
		            wr->mod[mod_no].fxo.offhook) {
				zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_ONHOOK);
							wr->devname,
							wr->span.spanno);
				wr->mod[mod_no].fxo.onhook++;
							wr->devname,
							wr->span.spanno);
			zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_ONHOOK);
			wr->mod[mod_no].fxo.battdebounce = wr->battdebounce;
		} else if (!wr->mod[mod_no].fxo.battery)
			wr->mod[mod_no].fxo.battdebounce = wr->battdebounce;
	} else if (abs(b) > wr->battthresh) {
		if (!wr->mod[mod_no].fxo.battery && !wr->mod[mod_no].fxo.battdebounce) {
						wr->devname,
						wr->span.spanno,
						(b < 0) ? "-" : "+");			    
			if (wr->mod[mod_no].fxo.onhook) {
				wr->mod[mod_no].fxo.onhook = 0;
				zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_OFFHOOK);
							wr->devname,
							wr->span.spanno);
			zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_OFFHOOK);
							wr->devname,
							wr->span.spanno);
			wr->mod[mod_no].fxo.battery = 1;
			wr->mod[mod_no].fxo.nobatttimer = 0;
			wr->mod[mod_no].fxo.battdebounce = wr->battdebounce;
		} else if (wr->mod[mod_no].fxo.battery)
			wr->mod[mod_no].fxo.battdebounce = wr->battdebounce;
		if (wr->mod[mod_no].fxo.lastpol >= 0) {
				wr->mod[mod_no].fxo.lastpol = -1;
				wr->mod[mod_no].fxo.polaritydebounce = POLARITY_DEBOUNCE;
		if (wr->mod[mod_no].fxo.lastpol <= 0) {
				wr->mod[mod_no].fxo.lastpol = 1;
				wr->mod[mod_no].fxo.polaritydebounce = POLARITY_DEBOUNCE;
		wr->mod[mod_no].fxo.battdebounce = wr->battdebounce;
	if (wr->mod[mod_no].fxo.battdebounce)
		wr->mod[mod_no].fxo.battdebounce--;
	if (wr->mod[mod_no].fxo.polaritydebounce) {
	        wr->mod[mod_no].fxo.polaritydebounce--;
		if (wr->mod[mod_no].fxo.polaritydebounce < 1) {
			if (wr->mod[mod_no].fxo.lastpol != wr->mod[mod_no].fxo.polarity) {
				"%s: Module %d: Polarity reversed %d -> %d (%u)\n",
						wr->devname,
						wr->mod[mod_no].fxo.polarity, 
						wr->mod[mod_no].fxo.lastpol,
				if (wr->mod[mod_no].fxo.polarity){
					zt_qevent_lock(&wr->chans[mod_no],
				wr->mod[mod_no].fxo.polarity =
						wr->mod[mod_no].fxo.lastpol;
	WAN_ASSERT1(wr->card == NULL);
	card	= wr->card;
	fe	= &card->fe;
	res = wr->reg0shadow[mod_no];
	if (hook != wr->mod[mod_no].fxs.lastrxhook) {
		wr->mod[mod_no].fxs.debounce = 4 * (4 * 8);
				wr->devname, mod_no + 1, hook,
				wr->mod[mod_no].fxs.debounce);
		if (wr->mod[mod_no].fxs.debounce > 0) {
			wr->mod[mod_no].fxs.debounce-= 16 * ZT_CHUNKSIZE;
					wr->devname, mod_no + 1,
					hook, wr->mod[mod_no].fxs.debounce);
			if (!wr->mod[mod_no].fxs.debounce) {
							wr->devname,
				wr->mod[mod_no].fxs.debouncehook = hook;
			if (!wr->mod[mod_no].fxs.oldrxhook && wr->mod[mod_no].fxs.debouncehook) {
							wr->devname, mod_no + 1);
				zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_OFFHOOK);
				wr->mod[mod_no].fxs.oldrxhook = 1;
			} else if (wr->mod[mod_no].fxs.oldrxhook && !wr->mod[mod_no].fxs.debouncehook) {
							wr->devname, mod_no + 1);
				zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_ONHOOK);
				wr->mod[mod_no].fxs.oldrxhook = 0;
	wr->mod[mod_no].fxs.lastrxhook = hook;
	sdla_t			*card = fe->card;
	wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr	= wan_tdmv->sc;
	if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS) {
	} else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO) {
	sdla_t			*card = fe->card;
	wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr	= wan_tdmv->sc;
		zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_OFFHOOK);
		zt_hooksig(&wr->chans[mod_no], ZT_RXSIG_ONHOOK);
	wr->mod[mod_no].fxs.lastrxhook = off_hook;
** wp_tdmv_remora_init() - 
	iface->check_mtu	= wp_tdmv_remora_check_mtu;
	iface->create		= wp_tdmv_remora_create;
	iface->remove		= wp_tdmv_remora_remove;
	iface->reg		= wp_tdmv_remora_reg;
	iface->unreg		= wp_tdmv_remora_unreg;
	iface->software_init	= wp_tdmv_remora_software_init;
	iface->state		= wp_tdmv_remora_state;
	iface->running		= wp_tdmv_remora_running;
	iface->is_rbsbits	= wp_tdmv_remora_is_rbsbits;
	iface->rx_tx_span	= wp_tdmv_remora_rx_tx_span;
	iface->rx_chan		= wp_tdmv_remora_rx_chan;
	iface->ec_span		= wp_tdmv_remora_ec_span;  
	WAN_ASSERT2(chan == NULL, -ENODEV);
	WAN_ASSERT2(chan->pvt == NULL, -ENODEV);
	wr = chan->pvt;
	card = wr->card;
	DEBUG_TDMV("%s: Configuring chan %d SigType %i..\n", wr->devname, chan->chanpos, sigtype);
	if (WAN_FE_NETWORK_SYNC(&card->fe)) {
		chan->txbufpolicy = ZT_POLICY_WHEN_FULL;
		chan->txdisable = 1;
	wp_tdmv_remora_t	*wr = wan_tdmv->sc;
	WAN_ASSERT(wr->card == NULL);
	card = wr->card;
	fe = &card->fe;
	if (wan_test_bit(WP_TDMV_REGISTER, &wr->flags)){
					wr->devname, wr->span.spanno);
	sprintf(wr->span.name, "WRTDM/%d", wr->num);
	sprintf(wr->span.desc, "wrtdm Board %d", wr->num + 1);
	switch(fe->fe_cfg.tdmv_law){
					wr->devname);
		wr->span.deflaw = ZT_LAW_ALAW;
		wr->span.deflaw = ZT_LAW_MULAW;
	wr->dtmfsupport = card->u.aft.tdmv_hw_dtmf;
	wr->battthresh	= DEFAULT_BATT_THRESH;
	wr->battdebounce= DEFAULT_BATT_DEBOUNCE;
	if (fe->fe_cfg.cfg.remora.battthresh && 
	    fe->fe_cfg.cfg.remora.battthresh != DEFAULT_BATT_THRESH){
		wr->battthresh = fe->fe_cfg.cfg.remora.battthresh;
		DEBUG_EVENT("%s: A200/A400 Remora Battery Threshhold changed %d -> %d\n", 
					wr->devname, DEFAULT_BATT_THRESH, wr->battthresh);
	if (fe->fe_cfg.cfg.remora.battdebounce && 
            fe->fe_cfg.cfg.remora.battdebounce != DEFAULT_BATT_DEBOUNCE){
		wr->battdebounce = fe->fe_cfg.cfg.remora.battdebounce;
		DEBUG_EVENT("%s: A200/A400 Remora Battery Debounce changed %d -> %d\n", 
					wr->devname, DEFAULT_BATT_DEBOUNCE, wr->battdebounce);
		if (wan_test_bit(x, &fe->rm_param.module_map)){
			sprintf(wr->chans[x].name, "WRTDM/%d/%d", wr->num, x);
					wr->devname, 
					wr->chans[x].name,
					WP_REMORA_DECODE_TYPE(fe->rm_param.mod[x].type));
			if (fe->rm_param.mod[x].type == MOD_TYPE_FXO){
				wr->chans[x].sigcap =	ZT_SIG_FXSKS |
			}else if (fe->rm_param.mod[x].type == MOD_TYPE_FXS){
				wr->chans[x].sigcap =	ZT_SIG_FXOKS |
			wr->chans[x].chanpos = x+1;
			wr->chans[x].pvt = wr;
			sprintf(wr->chans[x].name, "WRTDM/%d/%d", wr->num, x);
					wr->devname, 
			wr->chans[x].sigcap = ZT_SIG_CLEAR;
			wr->chans[x].chanpos = x+1;
			wr->chans[x].pvt = wr;
	wr->span.pvt = wr;
	wr->span.chans		= wr->chans_ptrs;
	wr->span.chans		= wr->chans;
	wr->span.channels	= num/*wr->max_timeslots*/;
	wr->span.hooksig	= wp_remora_zap_hooksig;
	wr->span.open		= wp_remora_zap_open;
	wr->span.close		= wp_remora_zap_close;
	wr->span.flags		= ZT_FLAG_RBS;
	wr->span.ioctl		= wp_remora_zap_ioctl;
	wr->span.watchdog	= wp_remora_zap_watchdog;
	wr->span.chanconfig 	= wp_remora_chanconfig;
	if (wr->hwec == WANOPT_YES && card->wandev.ec_dev){
		wr->span.echocan = wp_remora_zap_hwec;
	init_waitqueue_head(&wr->span.maintq);
	if (zt_register(&wr->span, 0)) {
				wr->devname);
		return -EINVAL;
	if (wr->span.spanno != wr->spanno +1){
						wr->spanno + 1);
						wr->devname,wr->span.spanno);
		wr->spanno = wr->span.spanno-1;
					wr->devname, wr->span.spanno);
	wp_tdmv_remora_check_mtu(card, wr->reg_module_map, &wr->max_rxtx_len);
	wan_set_bit(WP_TDMV_REGISTER, &wr->flags);
	if (wr->dtmfsupport == WANOPT_YES){
		DEBUG_EVENT("%s: Enable HW DTMF detection!\n", wr->devname);
		card->wandev.event_callback.dtmf = wp_tdmv_remora_dtmf;
	if (fe->fe_cfg.cfg.remora.fxs_pulsedialing == WANOPT_YES){
					wr->devname);
** wp_tdmv_release() - 
	if (wan_test_bit(WP_TDMV_REGISTER, &wr->flags)){
				wr->devname);
		wan_clear_bit(WP_TDMV_REGISTER, &wr->flags);
		zt_unregister(&wr->span);
		wan_clear_bit(WP_TDMV_REGISTER, &wr->flags);
** wp_tdmv_remora_check_mtu() - 
	max_channels = WAN_FE_MAX_CHANNELS(&card->fe);
** wp_tdmv_remora_create() - 
	WAN_ASSERT(tdmv_conf->span_no == 0);
					card->devname);
		return -EINVAL;
		if (tmp->spanno == tdmv_conf->span_no){
					card->devname);
					card->devname, tdmv_conf->span_no);
			return -EINVAL;
	memset(&card->wan_tdmv, 0x0, sizeof(wan_tdmv_t));
	card->wan_tdmv.max_timeslots			= card->fe.rm_param.max_fe_channels;
	card->wan_tdmv.spanno				= tdmv_conf->span_no;
	card->wandev.fe_notify_iface.hook_state		= wp_tdmv_remora_hook;
	card->wandev.fe_notify_iface.check_hook_state	= wp_tdmv_remora_check_hook;
		return -ENOMEM;
	card->wan_tdmv.sc	= wr;
	wr->spanno		= tdmv_conf->span_no-1;
	wr->num			= wp_remora_no++;
	wr->card		= card;
	wr->devname		= card->devname;
	wr->max_timeslots	= card->fe.rm_param.max_fe_channels;
	wr->max_rxtx_len	= 0;
	wan_spin_lock_irq_init(&wr->lockirq, "wan_rmtdmv_lock");
	wan_spin_lock_irq_init(&wr->tx_rx_lockirq, "wan_rmtdmv_txrx_lock");
	for (i = 0; i < sizeof(wr->chans)/sizeof(wr->chans[0]); i++) {
		wr->chans_ptrs[i] = &wr->chans[i];
		WAN_LIST_INSERT_AFTER(tmp, &card->wan_tdmv, next);
		WAN_LIST_INSERT_HEAD(&wan_tdmv_head, &card->wan_tdmv, next);
** wp_tdmv_reg() - 
** Returns: 	0-31	- Return TDM Voice channel number.
**		-EINVAL - otherwise
	sdla_fe_t		*fe = &card->fe;
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = wan_tdmv->sc;
	if (wan_test_bit(WP_TDMV_REGISTER, &wr->flags)){
				card->devname);
		return -EINVAL;
	for(i = 0; i < wr->max_timeslots; i++){
		    wan_test_bit(i, &fe->rm_param.module_map)){
			if (tdmv_conf->tdmv_echo_off){
				wan_set_bit(i, &wr->echo_off_map);
	if (i == wr->max_timeslots){
					card->devname,
		return -EINVAL;
			card->devname,
			WP_REMORA_DECODE_TYPE(fe->rm_param.mod[channo].type),
	wan_set_bit(channo, &wr->reg_module_map);
	if (tdmv_conf->tdmv_echo_off){
				wr->devname);
	memset(wr->chans[channo].sreadchunk, WAN_TDMV_IDLE_FLAG, ZT_CHUNKSIZE);
	memset(wr->chans[channo].swritechunk, WAN_TDMV_IDLE_FLAG, ZT_CHUNKSIZE);
	wr->chans[channo].readchunk = wr->chans[channo].sreadchunk;
	wr->chans[channo].writechunk = wr->chans[channo].swritechunk;
	wr->channelized = WAN_TRUE;
	wr->hwec = ec_enable;
	wp_tdmv_remora_check_mtu(card, active_ch, &wr->max_rxtx_len);
** wp_tdmv_unreg() - 
	sdla_fe_t		*fe = &card->fe;
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = wan_tdmv->sc;
	for(channo = 0; channo < wr->max_timeslots; channo++){
		if (wan_test_bit(channo, &wr->reg_module_map)){
				card->devname,
				WP_REMORA_DECODE_TYPE(fe->rm_param.mod[channo].type),
			wan_clear_bit(channo, &wr->reg_module_map);
			wan_clear_bit(channo, &wr->echo_off_map);
			memset(wr->chans[channo].sreadchunk, 
			memset(wr->chans[channo].swritechunk, 
			wr->chans[channo].readchunk = 
					wr->chans[channo].sreadchunk;
			wr->chans[channo].writechunk = 
					wr->chans[channo].swritechunk;
** wp_tdmv_remove() - 
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	if (!card->wan_tdmv.sc){
	wr = wan_tdmv->sc;
	if (wr && wr->reg_module_map){
				card->devname,
				wr->reg_module_map);
		return -EINVAL;
	if (wr && wr->usecount){
				card->devname);
		return -EINVAL;
		wan_clear_bit(WP_TDMV_RUNNING, &wr->flags);
		wan_clear_bit(WP_TDMV_UP, &wr->flags);
		wan_tdmv->sc = NULL;
		wan_tdmv->sc = NULL;
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = (wp_tdmv_remora_t*)wan_tdmv->sc;
					wr->devname);
		wan_set_bit(WP_TDMV_UP, &wr->flags);
					wr->devname);
		wan_clear_bit(WP_TDMV_UP, &wr->flags);
** wp_tdmv_running() - 
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	wr = wan_tdmv->sc;
	if (wr && wr->usecount){
				card->devname);
		return -EINVAL;
** wp_tdmv_remora_is_rbsbits() - 
	sdla_t		*card = wr->card;
	sdla_fe_t	*fe = &card->fe;
	if (!dtmf || !(fe->rm_param.mod[channo].type == MOD_TYPE_FXO) || wr->mod[channo].fxo.offhook) {
	if(!wr->mod[channo].fxo.readcid && !wr->mod[channo].fxo.wasringing  &&
		wr->intcount > wr->mod[channo].fxo.cidtimer + 400 ) {
		sample = ZT_XLAW((*rxbuf), (&(wr->chans[channo])));
		if (sample > 16000 || sample < -16000) {
			wr->mod[channo].fxo.readcid = 1;
			wr->mod[channo].fxo.cidtimer = wr->intcount;
			zt_qevent_lock(&wr->chans[channo], ZT_EVENT_POLARITY);
	} else if(wr->mod[channo].fxo.readcid && wr->intcount > wr->mod[channo].fxo.cidtimer + 2000) {
		wr->mod[channo].fxo.cidtimer = wr->intcount;
		wr->mod[channo].fxo.readcid = 0;
** wp_tdmv_rx_chan() - 
	wp_tdmv_remora_t	*wr = wan_tdmv->sc;
	WAN_ASSERT2(wr == NULL, -EINVAL);
	WAN_ASSERT2(channo < 0, -EINVAL);
	WAN_ASSERT2(channo > 31, -EINVAL);
		return -EINVAL;
	card = wr->card;
	pwr_rxtx = &wan_tdmv->chan_pwr[channo];
	if (WAN_FE_NETWORK_SYNC(&card->fe) == WANOPT_YES && 
	    wr->chans[channo].txbufpolicy != ZT_POLICY_WHEN_FULL) {
			card->devname,channo);
		wr->chans[channo].txbufpolicy = ZT_POLICY_WHEN_FULL;
	wr->chans[channo].readchunk = rxbuf;	
	wr->chans[channo].writechunk = txbuf;	
	if (card->fe.fe_cfg.cfg.remora.fake_polarity == WANOPT_YES){
	wp_tdmv_echo_check(wan_tdmv, &wr->chans[channo], channo);
	if ((!card->wandev.ec_enable || card->wandev.ec_enable_map == 0) && 
	     !wan_test_bit(channo, &wr->echo_off_map)) {
		if(pwr_rxtx->current_state != ECHO_ABSENT){
		if (wan_test_bit(AFT_TDM_SW_RING_BUF,&card->u.aft.chip_cfg_status)) {
				&wr->chans[channo], 
				wr->chans[channo].readchunk, 
				wr->chans[channo].writechunk);
				&wr->chans[channo], 
				wr->chans[channo].readchunk, 
				wr->ec_chunk1[channo]);
				wr->ec_chunk1[channo],
				wr->chans[channo].writechunk,
				&wr->chans[channo], 
				wr->chans[channo].readchunk, 
				wr->ec_chunk1[channo]);
				wr->ec_chunk1[channo],
				wr->ec_chunk2[channo],
				wr->ec_chunk2[channo],
				wr->chans[channo].writechunk,
		} /*if(pwr_rxtx->current_state != ECHO_ABSENT) */
	} /* if (!wan_test_bit(channo, &wr->echo_off_map)) */
	sdla_fe_t		*fe = &card->fe;
	wan_tdmv_t		*wan_tdmv = &card->wan_tdmv;
	WAN_ASSERT(wan_tdmv->sc == NULL);
	wr = wan_tdmv->sc;
	wr->intcount++;
	for (x = 0; x < wr->max_timeslots; x++) {
		if (!wan_test_bit(x, &wr->reg_module_map)){
		if (fe->rm_param.mod[x].type == MOD_TYPE_FXS){
			if (wr->mod[x].fxs.lasttxhook_update){
				WRITE_RM_REG(x, 64, wr->mod[x].fxs.lasttxhook);
				wr->mod[x].fxs.lasttxhook_update = 0;
			if (wr->mod[x].fxs.lasttxhook == 0x4) {
				wr->mod[x].fxs.ohttimer = OHT_TIMER << 3;
				if (fe->fe_cfg.cfg.remora.reversepolarity){
					fe->rm_param.mod[x].u.fxs.idletxhookstate = 0x6;
					fe->rm_param.mod[x].u.fxs.idletxhookstate = 0x2; 
				if (wr->mod[x].fxs.ohttimer) {
					wr->mod[x].fxs.ohttimer-= ZT_CHUNKSIZE;
					if (!wr->mod[x].fxs.ohttimer) {
						if (fe->fe_cfg.cfg.remora.reversepolarity){
							fe->rm_param.mod[x].u.fxs.idletxhookstate = 0x5;
							fe->rm_param.mod[x].u.fxs.idletxhookstate = 0x1;
						if ((wr->mod[x].fxs.lasttxhook == 0x2) || (wr->mod[x].fxs.lasttxhook == 0x6)) {
							if (fe->fe_cfg.cfg.remora.reversepolarity){ 
								wr->mod[x].fxs.lasttxhook = 0x5;
								wr->mod[x].fxs.lasttxhook = 0x1;
							WRITE_RM_REG(x, 64, wr->mod[x].fxs.lasttxhook);
		} else if (fe->rm_param.mod[x].type == MOD_TYPE_FXO) {
			if (wr->mod[x].fxo.echotune){
							fe->name, x);
				WRITE_RM_REG(x, 30, wr->mod[x].fxo.echoregs.acim);
				WRITE_RM_REG(x, 45, wr->mod[x].fxo.echoregs.coef1);
				WRITE_RM_REG(x, 46, wr->mod[x].fxo.echoregs.coef2);
				WRITE_RM_REG(x, 47, wr->mod[x].fxo.echoregs.coef3);
				WRITE_RM_REG(x, 48, wr->mod[x].fxo.echoregs.coef4);
				WRITE_RM_REG(x, 49, wr->mod[x].fxo.echoregs.coef5);
				WRITE_RM_REG(x, 50, wr->mod[x].fxo.echoregs.coef6);
				WRITE_RM_REG(x, 51, wr->mod[x].fxo.echoregs.coef7);
				WRITE_RM_REG(x, 52, wr->mod[x].fxo.echoregs.coef8);
						fe->name, x);
				wr->mod[x].fxo.echotune = 0;
			if (wr->reg0shadow_update[x]){
				WRITE_RM_REG(x, 5, wr->reg0shadow[x]);
				wr->reg0shadow_update[x] = 0;
		if (fe->fe_cfg.cfg.remora.fxs_pulsedialing == WANOPT_YES){
	x = wr->intcount % MAX_REMORA_MODULES;
	if (wan_test_bit(x, &wr->reg_module_map)) {
		if (fe->rm_param.mod[x].type == MOD_TYPE_FXS) {
			wr->reg0shadow[x] = READ_RM_REG(x, 68);
			wr->reg1shadow[x] = READ_RM_REG(x, 64);
			wr->reg2shadow[x] = READ_RM_REG(x, 8);
		}else if (fe->rm_param.mod[x].type == MOD_TYPE_FXO) {
			wr->reg0shadow[x] = READ_RM_REG(x, 5);
			wr->reg1shadow[x] = READ_RM_REG(x, 29);
			wr->reg2shadow[x] = READ_RM_REG(x, 34);
		if (fe->fe_cfg.cfg.remora.fxs_pulsedialing != WANOPT_YES){
		if (!(wr->intcount & 0xf0)){
			if (fe->rm_param.mod[x].type == MOD_TYPE_FXS) {
			}else if (fe->rm_param.mod[x].type == MOD_TYPE_FXO) {
	if (!(wr->intcount % 10000)) {
		for (x = 0; x < wr->max_timeslots; x++) 
			if (wan_test_bit(x, &wr->reg_module_map) &&
			    (fe->rm_param.mod[x].type == MOD_TYPE_FXS)) {
				if (wr->mod[x].fxs.palarms){
					wr->mod[x].fxs.palarms--;
	zt_receive(&wr->span);
	zt_transmit(&wr->span);
        wan_tdmv_t      *wan_tdmv = &card->wan_tdmv;
        WAN_ASSERT(wan_tdmv->sc == NULL);
        wr = wan_tdmv->sc;
	zt_ec_span(&wr->span);
        wan_tdmv_t      *wan_tdmv = &card->wan_tdmv;
        WAN_ASSERT1(wan_tdmv->sc == NULL);
        wr = wan_tdmv->sc;
	if (event->type == WAN_EVENT_EC_DTMF){
			card->devname,
			event->channel,
			event->digit,
			(event->dtmf_port == WAN_EC_CHANNEL_PORT_ROUT)?"ROUT":"SOUT",
			(event->dtmf_type == WAN_EC_TONE_PRESENT)?"PRESENT":"STOP");
	}else if (event->type == WAN_EVENT_RM_DTMF){
			card->devname,
			event->channel,
			event->digit);	
	if (!(wr->dtmfmask & (1 << (event->channel-1)))){
					card->devname,
					event->channel);
	if (event->dtmf_type == WAN_EC_TONE_PRESENT){
		wr->dtmfactive |= (1 << event->channel);
				wr->span.chans[event->channel-1],
				(ZT_EVENT_DTMFDOWN | event->digit));
				&wr->span.chans[event->channel-1],
				(ZT_EVENT_DTMFDOWN | event->digit));
		wr->dtmfactive &= ~(1 << event->channel);
				wr->span.chans[event->channel-1],
				(ZT_EVENT_DTMFUP | event->digit));
				&wr->span.chans[event->channel-1],
				(ZT_EVENT_DTMFUP | event->digit));
	if (1 || wan_test_bit(channo,&card->wandev.rtp_tap_call_map)) {
		if (*(unsigned int*)&wr->chans[channo].writechunk[0] == 0xD5D5D5D5 &&
		    *(unsigned int*)&wr->chans[channo].writechunk[4] == 0xD5D5D5D5) {
					card->devname,channo);
					card->devname,channo, card->wandev.rtp_tap_call_map);
				if (wr->chans[channo].writechunk[i] == 0x01) {
					gstat_tx_chan[channo]=wr->chans[channo].writechunk[i];
						card->devname,channo,wr->chans[channo].writechunk[i],i);
				if (gstat_tx_chan[channo] !=  wr->chans[channo].writechunk[i]) {
							card->devname,channo,
							gstat_tx_chan[channo],wr->chans[channo].writechunk[i],i);
					gstat_tx_chan[channo] = wr->chans[channo].writechunk[i];
						DEBUG_EVENT("chan=%i off=%i data=%i\n",channo,x,wr->chans[channo].writechunk[x]);
./sdla_remora_tdmv.c
 * Copyright:	(c) 1995-2005 Sangoma Technologies Inc.
** wp_tdmv_echo_check() - check the channel for echo
        wan_tdmv_rxtx_pwr_t *pwr_rxtx = &wan_tdmv->chan_pwr[channo];
        if(thechan->echo_detect_struct.echo_detection_state !=
           thechan->echo_detect_struct.echo_detection_state_old){
                        thechan->echo_detect_struct.echo_detection_state);
                switch(thechan->echo_detect_struct.echo_detection_state)
                        thechan->echo_detect_struct.echo_detection_state_old =
                                thechan->echo_detect_struct.echo_detection_state;
                                channo, thechan->echo_detect_struct.echo_detection_state);
        if(thechan->echo_detect_struct.echo_detection_state != ECHO_DETECT_ON){
        if(pwr_rxtx->current_state != INDETERMINATE){
	wp_tdmv_calc_echo(pwr_rxtx, (thechan->xlaw == __zt_mulaw), 
			  channo, thechan->readchunk, thechan->writechunk,
./sdla_edac.c
 * 4. Neither the name of the author nor the names of any co-contributors
 *	$Id: sdla_8te1.c,v 1.121 2008-04-25 16:23:20 sangoma Exp $
** 02-18-06	Alex Feldman		Initial version.
** 07-10-07	Alex Feldman	EBIT	Enable auto E-bit support.
** Nov 23, 2007 Alex Feldman	TXTRI	Add support for TX Tri-state.
/* Read/Write to front-end register */
	fe->write_fe_reg(						\
		((sdla_t*)fe->card)->hw,			\
		(int)(((sdla_t*)fe->card)->wandev.state==WAN_CONNECTED),		\
		(int)fe->fe_cfg.line_no,					\
		(int)sdla_ds_te1_address(fe,fe->fe_cfg.line_no,(reg)),	\
	fe->write_fe_reg(						\
		((sdla_t*)fe->card)->hw,			\
		(int)(((sdla_t*)fe->card)->wandev.state==WAN_CONNECTED),		\
	fe->read_fe_reg(						\
		((sdla_t*)fe->card)->hw,			\
		(int)(((sdla_t*)fe->card)->wandev.state==WAN_CONNECTED),		\
		(int)fe->fe_cfg.line_no,					\
		(int)sdla_ds_te1_address(fe,fe->fe_cfg.line_no,(reg)))
	fe->__read_fe_reg(						\
		((sdla_t*)fe->card)->hw,			\
		(int)(((sdla_t*)fe->card)->wandev.state==WAN_CONNECTED),		\
		(int)fe->fe_cfg.line_no,					\
		(int)sdla_ds_te1_address(fe,fe->fe_cfg.line_no,(reg)))
	fe->read_fe_reg(						\
		((sdla_t*)fe->card)->hw,			\
		(int)(((sdla_t*)fe->card)->wandev.state==WAN_CONNECTED),		\
#define WAN_DS_REGBITMAP(fe)	(((fe)->fe_chip_id==DEVICE_ID_DS26521)?0:WAN_FE_LINENO((fe)))
	"> -2.5db",	
	"-2.5db to -5db",	
	"-5db to -7.5db",	
	"-7.5db to -10db",	
	"-10db to -12.5db",	
	"-12.5db to -15db",	
	"-15db to -17.5db",	
	"-17.5db to -20db",	
	"-20db to -23db",	
	"-23db to -26db",	
	"-26db to -29db",	
	"-29db to -32db",	
	"-32db to -36db",	
	"< -36db",	
	"> -2.5db",	
	"-2.5db to -5db",	
	"-5db to -7.5db",	
	"-7.5db to -10db",	
	"-10db to -12.5db",	
	"-12.5db to -15db",	
	"-15db to -17.5db",	
	"-17.5db to -20db",	
	"-20db to -23db",	
	"-23db to -26db",	
	"-26db to -29db",	
	"-29db to -32db",	
	"-32db to -36db",	
	"-36db to -40db",	
	"-40db to -44db",	
	"< -44db"
	return ("AFT-A108 T1/E1");
	return fe->fe_cfg.media;
* Description	: Get current FE line state - is it Connected or Disconnected
* Arguments	: fe - pointer to Front End structure.	
*		  status - pointer to location where the FE line state will
*		  notused - ignored 
	*status = fe->fe_status;
	/* for a102, replace port number of second chip to 1 (1->0) */
	if (fe->fe_chip_id == DEVICE_ID_DS26521){
		value &= ~(1 << (bit-1));
		value |= (1 << (bit-1));
		value &= ~(1 << (bit-1));
		value |= (1 << (bit-1));
	fe_iface->reset			= &sdla_ds_te1_reset;
	fe_iface->global_config		= &sdla_ds_te1_global_config;
	fe_iface->global_unconfig	= &sdla_ds_te1_global_unconfig;
	fe_iface->chip_config		= &sdla_ds_te1_chip_config;
	fe_iface->config		= &sdla_ds_te1_config;
	fe_iface->post_init		= &sdla_ds_te1_post_init;
	fe_iface->reconfig		= &sdla_ds_te1_reconfig;
	fe_iface->unconfig		= &sdla_ds_te1_unconfig;
	fe_iface->pre_release		= &sdla_ds_te1_pre_release;
	fe_iface->disable_irq		= &sdla_ds_te1_disable_irq;
	fe_iface->isr			= &sdla_ds_te1_intr;
	fe_iface->check_isr		= &sdla_ds_te1_check_intr;
	fe_iface->intr_ctrl		= &sdla_ds_te1_intr_ctrl;
	fe_iface->polling		= &sdla_ds_te1_polling;
	fe_iface->process_udp		= &sdla_ds_te1_udp;
	fe_iface->print_fe_alarm	= &sdla_ds_te1_print_alarms;
	/*fe_iface->print_fe_act_channels	= &sdla_te_print_channels;*/
	fe_iface->read_alarm		= &sdla_ds_te1_read_alarms;
	/*fe_iface->set_fe_alarm		= &sdla_te_set_alarms;*/
	fe_iface->read_pmon		= &sdla_ds_te1_pmon;
	fe_iface->flush_pmon		= &sdla_ds_te1_flush_pmon;
	fe_iface->get_fe_status		= &sdla_ds_te1_get_fe_status;
	fe_iface->get_fe_media		= &sdla_ds_te1_get_fe_media;
	fe_iface->get_fe_media_string	= &sdla_ds_te1_get_fe_media_string;
	fe_iface->update_alarm_info	= &sdla_ds_te1_update_alarm_info;
	fe_iface->update_pmon_info	= &sdla_ds_te1_update_pmon_info;
	fe_iface->set_fe_lbmode		= &sdla_ds_te1_set_lb;
	fe_iface->read_rbsbits		= &sdla_ds_te1_read_rbsbits;
	fe_iface->check_rbsbits		= &sdla_ds_te1_check_rbsbits;
	fe_iface->report_rbsbits	= &sdla_ds_te1_rbs_report;
	fe_iface->set_rbsbits		= &sdla_ds_te1_set_rbsbits;
	fe_iface->set_fe_sigctrl	= &sdla_ds_te1_sigctrl;
	fe_iface->led_ctrl		= &sdla_te_led_ctrl;
	fe->fe_status = FE_UNITIALIZED;	//FE_DISCONNECTED;
	WAN_LIST_INIT(&fe->event);
	wan_spin_lock_irq_init(&fe->lockirq, "wan_8te1_lock");
* Returns:	0 - device is supported, otherwise - device is not supported
//	fe->fe_chip_id = DEVICE_ID_DS(value);
	fe->fe_chip_id = WAN_TE1_DEVICE_ID;
	switch(fe->fe_chip_id){
		fe->fe_max_ports = 8;
		fe->fe_max_ports = 4;
		fe->fe_max_ports = 1;
		fe->fe_max_ports = 2;
				fe->name, 
				fe->fe_chip_id,
		return -EINVAL;
 * 		Note: 	These register should be program only once for AFT-QUAD
 * Arguments:	fe	- front-end structure
 *		port_no	- 0 - global set/clear reset, 1-8 - set/clear reset per port
 *		reset	- 0 - clear reset, 1 - set reset
 * Returns:	WANTRUE - TE1 configred successfully, otherwise WAN_FALSE.
	if (sdla_ds_te1_device_id(fe)) return -EINVAL;
					fe->name,
				fe->name, (reset) ? "Set" : "Clear");
		for(i=0;i<fe->fe_max_ports;i++){
	if (fe->fe_chip_id == DEVICE_ID_DS26521 && !port_no){
		if (fe->fe_chip_id == DEVICE_ID_DS26521 && !port_no){
							fe->name);
							fe->name);
 * 		Note: 	These register should be program only once for AFT-OCTAL
 * Returns:	WANTRUE - TE1 configred successfully, otherwise WAN_FALSE.
	if (sdla_ds_te1_device_id(fe)) return -EINVAL;
				fe->name, FE_MEDIA_DECODE(fe));
 * 		Note: 	These register should be program only once for AFT-QUAD
 * Returns:	WANTRUE - TE1 configred successfully, otherwise WAN_FALSE.
				fe->name, FE_MEDIA_DECODE(fe));
** Description: Verify T1 Front-End configuration
** Returns:     0 - successfully, otherwise -EINVAL.
						fe->name);
						fe->name,
		return -EINVAL;
						fe->name);
						fe->name,
		return -EINVAL;
						fe->name);
						fe->name,
		return -EINVAL;
		switch(fe->fe_cfg.cfg.te_cfg.rx_slevel){
						fe->name);
			fe->fe_cfg.cfg.te_cfg.rx_slevel = WAN_TE1_RX_SLEVEL_30_DB;
					fe->name,
					fe->fe_cfg.cfg.te_cfg.rx_slevel);
			return -EINVAL;
		switch(fe->fe_cfg.cfg.te_cfg.rx_slevel){
							fe->name);
			fe->fe_cfg.cfg.te_cfg.rx_slevel = WAN_TE1_RX_SLEVEL_36_DB;
					fe->name,
					fe->fe_cfg.cfg.te_cfg.rx_slevel);
			return -EINVAL;
** Description: Verify E1 Front-End configuration
** Returns:     0 - successfully, otherwise -EINVAL.
					fe->name);
					fe->name,
		return -EINVAL;
					fe->name);
					fe->name,
		return -EINVAL;
					fe->name);
					fe->name,
		return -EINVAL;
					fe->name);
					fe->name,
		return -EINVAL;
		switch(fe->fe_cfg.cfg.te_cfg.rx_slevel){
							fe->name);
			fe->fe_cfg.cfg.te_cfg.rx_slevel = WAN_TE1_RX_SLEVEL_30_DB;
					fe->name,
					fe->fe_cfg.cfg.te_cfg.rx_slevel);
			return -EINVAL;
		switch(fe->fe_cfg.cfg.te_cfg.rx_slevel){
							fe->name);
			fe->fe_cfg.cfg.te_cfg.rx_slevel = WAN_TE1_RX_SLEVEL_43_DB;
					fe->name,
					fe->fe_cfg.cfg.te_cfg.rx_slevel);
			return -EINVAL;
** Description: Configure Dallas Front-End chip
** Returns:	0 - successfully, otherwise -EINVAL.
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
		/* EBIT: Enable auto E-bit support */
				fe->name, WAN_FE_FRAME(fe));
		return -EINVAL;
				fe->name, WAN_FE_LCODE(fe));
		return -EINVAL;
		switch(fe->fe_cfg.cfg.te_cfg.rx_slevel){
			fe->fe_cfg.cfg.te_cfg.rx_slevel = WAN_TE1_RX_SLEVEL_30_DB;
			fe->name, 
			WAN_TE1_RX_SLEVEL_DECODE(fe->fe_cfg.cfg.te_cfg.rx_slevel),
			(fe->fe_cfg.cfg.te_cfg.rx_slevel==WAN_TE1_RX_SLEVEL_30_DB)?
		switch(fe->fe_cfg.cfg.te_cfg.rx_slevel){
			fe->name, 
			WAN_TE1_RX_SLEVEL_DECODE(fe->fe_cfg.cfg.te_cfg.rx_slevel),
			((IS_T1_FEMEDIA(fe) && (fe->fe_cfg.cfg.te_cfg.rx_slevel==WAN_TE1_RX_SLEVEL_36_DB)) ||
			 (IS_E1_FEMEDIA(fe) && (fe->fe_cfg.cfg.te_cfg.rx_slevel==WAN_TE1_RX_SLEVEL_43_DB))) ?
		** Adjust DAC gain (-4.88%) */
	/* Additional front-end settings */
					fe->name,
			if (!(active_ch & (1 << (i-1)))){
		DEBUG_EVENT("%s:    Disable TX (tri-state mode)\n",
						fe->name);
 * Returns:	WANTRUE - TE1 configred successfully, otherwise WAN_FALSE.
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
			fe->name, (rmmr & BIT_RMMR_T1E1) ? "E1" : "T1");
			fe->name, (tmmr & BIT_TMMR_T1E1) ? "E1" : "T1");
					fe->name, rmmr, tmmr);
		return -EINVAL;	
				fe->name,
				fe->name,
				fe->name,
				fe->name,
				fe->name,
 * Returns:	WANTRUE - TE1 configred successfully, otherwise WAN_FALSE.
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	if (sdla_ds_te1_device_id(fe)) return -EINVAL;
	switch(fe->fe_chip_id){
					fe->name,
			return -EINVAL;
					fe->name,
			return -EINVAL;
					fe->name,
			return -EINVAL;
					fe->name,
		err =-EINVAL;
	if (err) return -EINVAL;
				fe->name, 
				DECODE_CHIPID(fe->fe_chip_id),
				fe->name, 
				fe->name, 
					fe->name, 
	if (fe->fe_cfg.poll_mode == WANOPT_YES){
		sdla_t	*card = (sdla_t*)fe->card;
					fe->name); 
		card->fe_no_intr = 1;	/* disable global front interrupt */
	if (fe->fe_cfg.cfg.te_cfg.ignore_yel_alarm == WANOPT_YES){
					fe->name); 
		return -EINVAL;
	fe->te_param.max_channels = 
	fe->fe_alarm = WAN_TE_BIT_LIU_ALARM;
	wan_set_bit(TE_CONFIGURED,(void*)&fe->te_param.critical);
	wan_set_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical);
		&fe->timer, 
	wan_clear_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical);
	wan_set_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical);
	if (wan_test_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical)){
		wan_del_timer(&fe->timer);
	wan_clear_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical);
		wan_spin_lock_irq(&fe->lockirq,&smp_flags);
		if (!WAN_LIST_EMPTY(&fe->event)){
			fe_event = WAN_LIST_FIRST(&fe->event);
		wan_spin_unlock_irq(&fe->lockirq,&smp_flags);
	if (!wan_test_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical)){
		DEBUG_EVENT("%s: %s(): Front-End timer is not stopped!\n",
					fe->name, __FUNCTION__);
		return -EINVAL;
				fe->name, FE_MEDIA_DECODE(fe));	
	wan_clear_bit(TE_CONFIGURED,(void*)&fe->te_param.critical);
	//if (fe->fe_chip_id == DEVICE_ID_DS26521/* && fe->fe_cfg.line_no == 1*/){
	if (fe->fe_cfg.poll_mode == WANOPT_NO){
					fe->name,
		return -EINVAL;
** Returns:	1 - the port is connected
**		0 - the port is disconnected
	if (fe->fe_cfg.cfg.te_cfg.ignore_yel_alarm == WANOPT_NO){
** Returns:	1 - the port is connected
**		0 - the port is disconnected
		if (!fe->te_param.lb_mode_map){
	sdla_t		*card = (sdla_t*)fe->card;
	unsigned char	curr_fe_status = fe->fe_status;
		if (fe->fe_status != FE_DISCONNECTED){
			fe->fe_status = FE_DISCONNECTED;
		}else if (fe->te_param.tx_yel_alarm && valid_rx_alarms & WAN_TE_BIT_RAI_ALARM){
		if (fe->fe_status != FE_CONNECTED){
			if (fe->te_param.tx_yel_alarm){
			fe->fe_status = FE_CONNECTED;
		if (fe->fe_status != FE_DISCONNECTED){
			fe->fe_status = FE_DISCONNECTED;
		if (fe->fe_status != FE_CONNECTED){
			if (fe->te_param.tx_yel_alarm){
			fe->fe_status = FE_CONNECTED;
	if (curr_fe_status != fe->fe_status){
		if (fe->fe_status == FE_CONNECTED){
			if (fe->te_param.status_cnt > WAN_TE1_STATUS_THRESHOLD){
						fe->name,
				if (card->wandev.te_report_alarms){
					card->wandev.te_report_alarms(
							fe->fe_alarm);
				if (!fe->te_param.status_cnt){
							fe->name,
				fe->te_param.status_cnt ++;
				fe->fe_status = FE_DISCONNECTED;
							fe->name,
							fe->te_param.status_cnt);
					fe->name,
			fe->fe_status = FE_DISCONNECTED;
			fe->te_param.status_cnt = 0;
			if (card->wandev.te_report_alarms){
				card->wandev.te_report_alarms(card, fe->fe_alarm);
		fe->te_param.status_cnt = 0;	
					fe->name,
					fe->te_param.status_cnt);
		alarms = fe->fe_alarm; 
				fe->name,
			fe->name,
		DEBUG_EVENT("%s:    RAI : ON\n", fe->name);
		DEBUG_EVENT("%s:    LOS : ON\n", fe->name);
		DEBUG_EVENT("%s:    OOF : ON\n", fe->name);
		DEBUG_EVENT("%s:    RED : ON\n", fe->name);
			fe->name,
				fe->name);
				fe->name, __LINE__);
				fe->name);
	u_int32_t	alarm = fe->fe_alarm;
				fe->name, rrts1, alarm);
							fe->name);
							fe->name);
						fe->name);
						fe->name);
						fe->name);
						fe->name);
						fe->name);
						fe->name);
						fe->name);
						fe->name);
	unsigned int	alarm = fe->fe_alarm;
				fe->name, lrsr, alarm);
					fe->name);
					fe->name);
					fe->name, __LINE__);
					fe->name, __LINE__);
					fe->name);
					fe->name);
	u_int32_t alarm = fe->fe_alarm;
		fe->fe_alarm = alarm;
	return fe->fe_alarm;
		fe->te_param.crit_alarm_start = SYSTEM_TICKS;
		if (WAN_STIMEOUT(fe->te_param.crit_alarm_start, WAN_TE_CRIT_ALARM_TIMEOUT)){
	    fe->fe_cfg.cfg.te_cfg.ignore_yel_alarm == WANOPT_NO){
								fe->name);
				fe->te_param.tx_yel_alarm = 1;
								fe->name);
				fe->te_param.tx_yel_alarm = 1;
	    fe->fe_cfg.cfg.te_cfg.ignore_yel_alarm == WANOPT_NO){
							fe->name);
				fe->te_param.tx_yel_alarm = 0;
							fe->name);
				fe->te_param.tx_yel_alarm = 0;
	sdla_t*		card = (sdla_t*)fe->card;
	max_channels = fe->te_param.max_channels;
		if (wan_test_bit(ch, &fe->te_param.rx_rbs_status)){
			if (card->wandev.te_report_rbsbits){
				card->wandev.te_report_rbsbits(
					fe->te_param.rx_rbs[ch]);
			wan_clear_bit(ch, &fe->te_param.rx_rbs_status);
 * Arguments:	channo: 1-24 for T1
 *			1-32 for E1
	sdla_t*		card = (sdla_t*)fe->card;
		rs_offset = (channo - 1) % 12;
	if ((mode & WAN_TE_RBS_REPORT) && card->wandev.te_report_rbsbits){
		card->wandev.te_report_rbsbits(
	if (fe->fe_debug & WAN_FE_DEBUG_RBS_RX_ENABLE && 
	    fe->te_param.rx_rbs[channo] != status){
		"%s: %s:%-3d RX RBS A:%1d B:%1d C:%1d D:%1d\n",
					fe->name,
	wan_set_bit(channo, &fe->te_param.rx_rbs_status);
	fe->te_param.rx_rbs[channo] = status;
			(unsigned long*)&fe->te_param.rx_rbs_A);
			(unsigned long*)&fe->te_param.rx_rbs_A);
			(unsigned long*)&fe->te_param.rx_rbs_B);
			(unsigned long*)&fe->te_param.rx_rbs_B);
			(unsigned long*)&fe->te_param.rx_rbs_C);
			(unsigned long*)&fe->te_param.rx_rbs_C);
			(unsigned long*)&fe->te_param.rx_rbs_D);
			(unsigned long*)&fe->te_param.rx_rbs_D);
	sdla_t*		card = (sdla_t*)fe->card;
			rs_offset = (channel - 1) % 16;
			rs_offset = (channel - 1) % 12;
		if (!wan_test_bit(channel-1, &ts_map)){
					fe->name, channel, REG_RS1, rs_offset, rbsbits);
				channel--;
			if (report && card->wandev.te_report_rbsbits){
				card->wandev.te_report_rbsbits(
 * Arguments:	T1: 1-24 E1: 0-31
	if ((unsigned int)channel > fe->te_param.max_channels){
				fe->name, channel, fe->te_param.max_channels);
		return -EINVAL;
				fe->name, channel);
	if (fe->fe_debug & WAN_FE_DEBUG_RBS_TX_ENABLE){
		DEBUG_EVENT("%s: %s:%-3d TX RBS A:%1d B:%1d C:%1d D:%1d\n",
				fe->name,
		wan_set_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_A);
		wan_clear_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_A);
		wan_set_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_B);
		wan_clear_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_B);
		wan_set_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_C);
		wan_clear_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_C);
		wan_set_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_D);
		wan_clear_bit(channel,(unsigned long*)&fe->te_param.tx_rbs_D);
		ts_off	= (channel - 1) % 12;
				fe->name, 
					fe->name);
					fe->name);
		DEBUG_EVENT("%s:       ------------------------\n",
					fe->name);
					fe->name);
					fe->name);
		DEBUG_EVENT("%s:       --------------------------------\n",
					fe->name);
	int 	i, max_channels = fe->te_param.max_channels;
	_DEBUG_EVENT("%s: %s ", fe->name, msg);
		rx_a = fe->te_param.rx_rbs_A;	
		rx_b = fe->te_param.rx_rbs_B;
		rx_c = fe->te_param.rx_rbs_C;
		rx_d = fe->te_param.rx_rbs_D;
					fe->name);
		sdla_ds_te1_rbs_print_bits(fe, fe->te_param.tx_rbs_A, "TX A:");
		sdla_ds_te1_rbs_print_bits(fe, fe->te_param.tx_rbs_B, "TX B:");
		sdla_ds_te1_rbs_print_bits(fe, fe->te_param.tx_rbs_C, "TX C:");
		sdla_ds_te1_rbs_print_bits(fe, fe->te_param.tx_rbs_D, "TX D:");
		DEBUG_EVENT("%s:\n", fe->name);
		for(i = 1; i <= fe->te_param.max_channels; i++) {
			chan = (IS_E1_FEMEDIA(fe))? i - 1 : i;
					fe->name);
 * Arguments: 	card 		- pointer to device structure.
 * 		write_register 	- write register function.
 * 		read_register	- read register function.
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	WAN_ASSERT(fe->fe_cfg.poll_mode == WANOPT_YES);
	if (!wan_test_bit(TE_CONFIGURED,(void*)&fe->te_param.critical)){
			/* In-band loop codes */
		for(ch = 1; ch <= fe->te_param.max_channels; ch++){
				bit = (ch-1) % 8;
				off = (ch-1) / 8;
					fe->name, ch, REG_RSCSE1+off, rscse);
					fe->fe_alarm |= WAN_TE_BIT_RAI_ALARM;		
								fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_RAI_ALARM;		
								fe->name);
				fe->fe_alarm |= WAN_TE_BIT_AIS_ALARM;		
							fe->name);
				fe->fe_alarm &= ~WAN_TE_BIT_AIS_ALARM;		
							fe->name);
				fe->fe_alarm |= WAN_TE_BIT_LOS_ALARM;		
							fe->name);
				fe->fe_alarm &= ~WAN_TE_BIT_LOS_ALARM;		
							fe->name);
					fe->fe_alarm |= WAN_TE_BIT_OOF_ALARM;		
								fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_OOF_ALARM;		
								fe->name);
			if (IS_TE_OOF_ALARM(fe->fe_alarm) &&
			    IS_TE_LOS_ALARM(fe->fe_alarm)){
				if (!(fe->fe_alarm & WAN_TE_BIT_RED_ALARM)){
							fe->name);
					fe->fe_alarm |= WAN_TE_BIT_RED_ALARM;
				if (fe->fe_alarm & WAN_TE_BIT_RED_ALARM){
								fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_RED_ALARM;
					fe->name, rls2);
						fe->name);
						fe->name);
						fe->name);
						fe->name);
					fe->fe_alarm |= WAN_TE_BIT_RAI_ALARM;		
								fe->name);
					fe->fe_alarm &= ~WAN_TE_BIT_RAI_ALARM;		
								fe->name);
					fe->name, rls3);
						fe->name);
						fe->name);
					"%s: Loop-Up Code Detected Condition Detect!\n",
							fe->name);
					"%s: Loop-Up Code Detected Condition Clear!\n",
							fe->name);
					"%s: Loop-Down Code Detected Condition Detect!\n",
							fe->name);
					"%s: Loop-Down Code Detected Condition Clear!\n",
							fe->name);
						fe->name);
						fe->name);
					fe->name, rls4);
					fe->name);
					fe->name);
					fe->name, rls5);
					fe->name);
					fe->name);
					fe->name);
					fe->name);
					fe->name);
					fe->name);
						fe->name, rls7);
				if (!silent) DEBUG_EVENT("%s: Receive RAI-CI Detect!\n",
						fe->name);
				if (!silent) DEBUG_EVENT("%s: Receive RAI-CI Detect!\n",
						fe->name);
				if (!silent) DEBUG_EVENT("%s: Receive SLC-96 Alignment Event!\n",
						fe->name);
						fe->name);
						fe->name);
						fe->name);
					fe->name);
					fe->name);
					fe->name);
					fe->name);
			if (!(fe->fe_alarm & WAN_TE_BIT_LIU_ALARM_OC)){
					fe->name);
				fe->fe_alarm |= WAN_TE_BIT_LIU_ALARM_OC;
			if (fe->fe_alarm & WAN_TE_BIT_LIU_ALARM_OC){
					fe->name);
				fe->fe_alarm &= ~WAN_TE_BIT_LIU_ALARM_OC;
			if (!(fe->fe_alarm & WAN_TE_BIT_LIU_ALARM_SC)){
					fe->name, __LINE__);
				fe->fe_alarm |= WAN_TE_BIT_LIU_ALARM_SC;
			if (fe->fe_alarm & WAN_TE_BIT_LIU_ALARM_SC){
					fe->name, __LINE__);
				fe->fe_alarm &= ~WAN_TE_BIT_LIU_ALARM_SC;	
			if (!(fe->fe_alarm & WAN_TE_BIT_LIU_ALARM_LOS)){
					fe->name);
				fe->fe_alarm |= WAN_TE_BIT_LIU_ALARM_LOS;
			if (fe->fe_alarm & WAN_TE_BIT_LIU_ALARM_LOS){
					fe->name);
				fe->fe_alarm &= ~WAN_TE_BIT_LIU_ALARM_LOS;	
					fe->name);
					fe->name);
					fe->name);
		if (!silent) DEBUG_EVENT("%s: BERT Receive All-Ones Condition!\n",
					fe->name);
		if (!silent) DEBUG_EVENT("%s: BERT Receive All-Zeros Condition!\n",
					fe->name);	
					fe->name);
		wan_clear_bit(WAN_TE_BERT_FLAG_INLOCK, &fe->te_param.bert_flag);
					fe->name);	
		wan_set_bit(WAN_TE_BERT_FLAG_INLOCK, &fe->te_param.bert_flag);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	WAN_ASSERT(fe->fe_cfg.poll_mode == WANOPT_YES);
					fe->name, WAN_FE_LINENO(fe));
					fe->name, WAN_FE_LINENO(fe));
					fe->name, WAN_FE_LINENO(fe));
				fe->name,
	u_int8_t	status = fe->fe_status;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
				fe->name);
			fe->name,fe->fe_alarm);
	if (fe->fe_alarm & WAN_TE_BIT_LIU_ALARM_SC){
	sdla_ds_te1_set_status(fe, fe->fe_alarm);
	if (status != fe->fe_status){
		if (fe->fe_status != FE_CONNECTED){
	sdla_t 		*card = (sdla_t*)fe->card;
	wan_device_t	*wandev = &card->wandev;
	DEBUG_TEST("[TE1] %s: TE1 timer!\n", fe->name);
	if (wan_test_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical)){
		wan_clear_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical);
	if (!wan_test_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical)){
					fe->name);
	wan_clear_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical);
	wan_spin_lock_irq(&fe->lockirq,&smp_flags);	
	empty = WAN_LIST_EMPTY(&fe->event);
	wan_spin_unlock_irq(&fe->lockirq,&smp_flags);	
		if (wan_test_and_set_bit(TE_TIMER_EVENT_PENDING,(void*)&fe->te_param.critical)){
			DEBUG_EVENT("%s: RM timer event is pending!\n", fe->name);
		if (wandev->fe_enable_timer){
			wandev->fe_enable_timer(fe->card);
	if (wan_test_bit(TE_TIMER_KILL,(void*)&fe->te_param.critical) ||
	    wan_test_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical)) {
	err = wan_add_timer(&fe->timer, delay);
	err = wan_add_timer(&fe->timer, delay * HZ / 1000);
		return -EINVAL;
	wan_set_bit(TE_TIMER_RUNNING,(void*)&fe->te_param.critical);
	sdla_t			*card = (sdla_t*)fe->card;
	WAN_ASSERT_RC(card == NULL, -EINVAL);
			fe->name, event->type);
					fe->name);
		return -EINVAL;
	DEBUG_EVENT("%s: %s:%d: ---------------START ----------------------\n",
				fe->name, __FUNCTION__,__LINE__);
	DEBUG_EVENT("%s: %s:%d: ---------------STOP ----------------------\n",
				fe->name, __FUNCTION__,__LINE__);
	wan_spin_lock_irq(&fe->lockirq,&smp_flags);
	if (wan_test_and_set_bit(event->type,(void*)&fe->event_map)){
							fe->name, event->type);
		wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
		return -EINVAL;
	if (WAN_LIST_EMPTY(&fe->event)){
		WAN_LIST_INSERT_HEAD(&fe->event, tevent, next);
		WAN_LIST_FOREACH(tmp, &fe->event, next){
			DEBUG_EVENT("%s: ERROR: Internal Error!!!\n", fe->name);
			wan_clear_bit(event->type,(void*)&fe->event_map);
			wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
			return -EINVAL;
							fe->name);
							fe->name, event->type);
			wan_clear_bit(event->type,(void*)&fe->event_map);
			wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
			return -EINVAL;
	wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
** Returns:     0 - There are no more event. Do not need to schedule sw timer
**              number - delay to schedule next event.  
	sdla_t			*card = (sdla_t*)fe->card;
	WAN_ASSERT_RC(fe->write_fe_reg == NULL, 0);
	WAN_ASSERT_RC(fe->read_fe_reg == NULL, 0);
	DEBUG_EVENT("%s: %s:%d: ---------------START ----------------------\n",
				fe->name, __FUNCTION__,__LINE__);
	DEBUG_EVENT("%s: %s:%d: ---------------STOP ----------------------\n",
				fe->name, __FUNCTION__,__LINE__);
	wan_spin_lock_irq(&fe->lockirq,&smp_flags);			
	if (WAN_LIST_EMPTY(&fe->event)){
		wan_clear_bit(TE_TIMER_EVENT_PENDING,(void*)&fe->te_param.critical);
		wan_spin_unlock_irq(&fe->lockirq,&smp_flags);	
					fe->name);
	event = WAN_LIST_FIRST(&fe->event);
	wan_clear_bit(event->type,(void*)&fe->event_map);
	wan_spin_unlock_irq(&fe->lockirq,&smp_flags);
			fe->name, WAN_FE_STATUS_DECODE(fe), event->type);	
	switch(event->type){
			event->type	= TE_LINKDOWN_TIMER;
			event->type	= TE_LINKCRIT_TIMER;
		event->delay	= POLLING_TE1_TIMER;
		if (fe->fe_alarm & WAN_TE_BIT_LIU_ALARM_SC){
			event->type	= TE_LINKCRIT_TIMER;
			event->delay	= POLLING_TE1_TIMER;
		sdla_ds_te1_set_status(fe, fe->fe_alarm);
		if (fe->fe_status == FE_CONNECTED){
			event->type	= TE_LINKUP_TIMER;
			event->delay	= POLLING_TE1_TIMER;
			event->type	= TE_LINKDOWN_TIMER;
			event->delay	= POLLING_TE1_TIMER;
		if (fe->fe_status == FE_CONNECTED){
			if (card->wandev.te_link_state){
				card->wandev.te_link_state(card);
			if (fe->fe_cfg.poll_mode == WANOPT_YES){
				event->type	= WAN_TE_POLL_LINKREADY;
				event->delay	= POLLING_TE1_TIMER;
			event->type	= TE_LINKDOWN_TIMER;
			event->delay	= POLLING_TE1_TIMER;
		/* Only used in no interrupt driven front-end mode */
		if (fe->fe_alarm & WAN_TE_BIT_LIU_ALARM_SC){
			event->type	= TE_LINKCRIT_TIMER;
			event->delay	= POLLING_TE1_TIMER;
		sdla_ds_te1_set_status(fe, fe->fe_alarm);
		if (fe->fe_status == FE_CONNECTED){
			event->type	= TE_LINKDOWN_TIMER;
			event->delay	= POLLING_TE1_TIMER;
						fe->name,
						event->te_event.rbs_abcd,
						event->te_event.rbs_channel);
					event->te_event.rbs_channel,
					event->te_event.rbs_abcd);
			if (event->type == TE_RBS_ENABLE){		
			if (event->type == TE_RBS_ENABLE){		
		for(ch = 1; ch <= fe->te_param.max_channels; ch++){
			if (!wan_test_bit(ch, &event->te_event.ch_map)){
				bit = (ch-1) % 8;
				off = (ch-1) / 8;
			if (event->type == TE_RBS_ENABLE){
					fe->name, ch, REG_SSIE1+off, value);
		sdla_ds_te1_set_lb(fe, event->te_event.lb_type, event->mode, ENABLE_ALL_CHANNELS); 
		DEBUG_EVENT("%s: Re-configuring %s Front-End chip...\n",
						fe->name, FE_MEDIA_DECODE(fe));
			DEBUG_EVENT("%s: Failed to re-configuring Front-End chip!\n",
					fe->name);
		event->type	= TE_LINKDOWN_TIMER;
		event->delay	= POLLING_TE1_TIMER;
		DEBUG_EVENT("%s: Verifing %s Front-End chip configuration...\n",
						fe->name, FE_MEDIA_DECODE(fe));
			DEBUG_EVENT("%s: Failed to verify Front-End chip configuration!\n",
					fe->name);
		fe->te_param.reg_dbg_value = READ_REG(event->te_event.reg);
		DEBUG_TE1("%s: Read %s Front-End Reg:%04X=%02X\n",
					fe->name, FE_MEDIA_DECODE(fe),
					event->te_event.reg,
					fe->te_param.reg_dbg_value);
		fe->te_param.reg_dbg_ready = 1;		
		DEBUG_EVENT("%s: Reading %s Front-End Registers:\n",
					fe->name, FE_MEDIA_DECODE(fe));
						fe->name, reg, READ_REG(reg));
		DEBUG_EVENT("%s: Reading %s Front-End LIU  Registers:\n",
					fe->name, FE_MEDIA_DECODE(fe));
						fe->name, reg, READ_REG(reg));
		DEBUG_EVENT("%s: Reading %s Front-End BERT Registers:\n",
					fe->name, FE_MEDIA_DECODE(fe));
						fe->name, reg, READ_REG(reg));
		DEBUG_EVENT("%s: Write %s Front-End Reg:%04X=%02X\n",
					fe->name, FE_MEDIA_DECODE(fe),
					event->te_event.reg,
					event->te_event.value);
		WRITE_REG(event->te_event.reg, event->te_event.value);
			event->type	= TE_LINELB_TIMER;
			event->delay	= LINELB_TE1_TIMER;
				fe->name, event->type);
	wan_clear_bit(TE_TIMER_EVENT_PENDING,(void*)&fe->te_param.critical);
	event = WAN_LIST_FIRST(&fe->event);
		sdla_ds_te1_add_timer(fe, event->delay);
		if (fe->te_param.lb_tx_cnt--){
			if (fe->te_param.lb_tx_cmd == WAN_TE1_LB_ENABLE){
		if (fe->te_param.lb_tx_cnt --){
			WRITE_REG(REG_T1TBOC, fe->te_param.lb_tx_code); 
			/* still in-progress */
					fe->name,	
					WAN_TE1_BOC_LB_CODE_DECODE(fe->te_param.lb_tx_code));
		if (fe->te_param.lb_tx_cmd == WAN_TE1_LB_ENABLE){
			wan_set_bit(fe->te_param.lb_tx_mode, &fe->te_param.lb_mode_map);
			wan_clear_bit(fe->te_param.lb_tx_mode, &fe->te_param.lb_mode_map);
		fe->te_param.lb_tx_cmd	= 0x00;
		fe->te_param.lb_tx_code = 0x00;
	wan_clear_bit(LINELB_WAITING,(void*)&fe->te_param.critical);
	sdla_te_pmon_t	*pmon = &fe->fe_stats.te_pmon;
	pmon->lcv_errors	= 0;	
	pmon->oof_errors	= 0;
	pmon->bee_errors	= 0;
	pmon->crc4_errors	= 0;
	pmon->feb_errors	= 0;
	pmon->fas_errors	= 0;
	sdla_te_pmon_t	*pmon = &fe->fe_stats.te_pmon;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
		pmon->mask = 0x00;
			/* E-bit counter (Far End Block Errors) for CRC4 */
		pmon->lcv_diff = pmon1;
		pmon->lcv_errors = pmon->lcv_errors + pmon1;	
			pmon->mask =	WAN_TE_BIT_PMON_LCV |
			pmon->bee_diff = pmon2;
			pmon->bee_errors = pmon->bee_errors + pmon2;
			pmon->oof_diff = pmon3;
			pmon->oof_errors = pmon->oof_errors + pmon3;
			pmon->mask =	WAN_TE_BIT_PMON_LCV |
			pmon->crc4_diff = pmon2;
			pmon->crc4_errors = pmon->crc4_errors + pmon2;
			pmon->fas_diff = pmon3;
			pmon->fas_errors = pmon->fas_errors + pmon3;
			pmon->feb_diff = pmon4;
			pmon->feb_errors = pmon->feb_errors + pmon4;
				fe->name, pmon->lcv_errors);
					fe->name, pmon->bee_errors);
					fe->name, pmon->oof_errors);
					fe->name, pmon->crc4_errors);
					fe->name, pmon->fas_errors);
					fe->name, pmon->feb_errors);
					fe->name, boc);
					fe->name, boc);
				fe->name, 
				fe->name, WAN_TE1_BOC_LB_CODE_DECODE(boc),fe->te_param.lb_mode_map);
		if (wan_test_bit(WAN_TE1_LINELB_MODE, &fe->te_param.lb_mode_map)){
		if (wan_test_bit(WAN_TE1_PAYLB_MODE, &fe->te_param.lb_mode_map)){
		DEBUG_TE1("%s: Received Unsupport Bit-Oriented code %02X!\n", 
							fe->name, boc);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	memset(fe->fe_stats.u.te1_stats.rxlevel, 0, WAN_TE_RXLEVEL_LEN);
		memcpy(	fe->fe_stats.u.te1_stats.rxlevel,
		memcpy(	fe->fe_stats.u.te1_stats.rxlevel,
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	if (!IS_T1_FEMEDIA(fe) || (fe->fe_status != FE_CONNECTED)){
		return -EINVAL;
	if (wan_test_bit(LINELB_WAITING,(void*)&fe->te_param.critical)){
				fe->name);
		return -EBUSY;			
	fe->te_param.lb_tx_mode	= mode;
	fe->te_param.lb_tx_cmd	= cmd;
			fe->te_param.lb_tx_code = LINELB_ACTIVATE_CODE;
			fe->te_param.lb_tx_code = LINELB_DEACTIVATE_CODE;
			fe->te_param.lb_tx_code = PAYLB_ACTIVATE_CODE;
			fe->te_param.lb_tx_code = PAYLB_DEACTIVATE_CODE;
		fe->te_param.lb_tx_cnt	= LINELB_CODE_CNT + 1;
		fe->te_param.lb_tx_cnt	= 5;	// repeat inband code for 5s
		fe->name, WAN_TE1_BOC_LB_CODE_DECODE(fe->te_param.lb_tx_code));
	wan_set_bit(LINELB_WAITING,(void*)&fe->te_param.critical);
	wan_set_bit(LINELB_CODE_BIT,(void*)&fe->te_param.critical);
	wan_set_bit(LINELB_CHANNEL_BIT,(void*)&fe->te_param.critical);
			off = (chan-1) / 8;
			shift = (chan-1) % 8;
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
				fe->name,
		return -EINVAL;
			wan_set_bit(mode, &fe->te_param.lb_mode_map);
			wan_clear_bit(mode, &fe->te_param.lb_mode_map);
				fe->name,
	WAN_ASSERT(fe->write_fe_reg == NULL);
	WAN_ASSERT(fe->read_fe_reg == NULL);
	if (wan_test_bit(WAN_TE1_TX_PAYLB_MODE, &fe->te_param.lb_mode_map)){
	if (wan_test_bit(WAN_TE1_TX_LINELB_MODE, &fe->te_param.lb_mode_map)){
	if (lb->cmd == WAN_FE_LBMODE_CMD_SET){
		if (sdla_ds_te1_set_lb(fe, lb->type, lb->mode, lb->chan_map)){
			lb->rc = WAN_FE_LBMODE_RC_FAILED;
	}else if (lb->cmd == WAN_FE_LBMODE_CMD_GET){
		lb->type_map = sdla_ds_te1_get_lbmode(fe);
	if (wan_test_bit(LINELB_WAITING,(void*)&fe->te_param.critical)){
		lb->rc = WAN_FE_LBMODE_RC_PENDING;
	lb->rc = WAN_FE_LBMODE_RC_SUCCESS;
	DEBUG_TE1("%s: Reading BERT status ...\n", fe->name);
	DEBUG_TE1("%s: BERT Bit Count (diff)  : %08X\n", fe->name, count);
	fe->te_param.bert_stats.bit_cnt += count;
	DEBUG_TE1("%s: BERT Error Count (diff): %08X\n", fe->name, count);
	fe->te_param.bert_stats.err_cnt += count;
		fe->te_param.bert_stats.err_sec++;
		fe->te_param.bert_stats.err_free_sec++;
	fe->te_param.bert_stats.avail_sec++;
	if (!wan_test_bit(WAN_TE_BERT_FLAG_READY, &fe->te_param.bert_flag)){
		return -EINVAL;
	memset(&fe->te_param.bert_stats, 0, sizeof(sdla_te_bert_stats_t));
	if (!wan_test_bit(WAN_TE_BERT_FLAG_READY, &fe->te_param.bert_flag)){
		return -EINVAL;
	if (!wan_test_bit(WAN_TE_BERT_FLAG_INLOCK, &fe->te_param.bert_flag)){
	if (fe->fe_status != FE_CONNECTED){
	if (!wan_test_bit(WAN_TE_BERT_FLAG_READY, &fe->te_param.bert_flag)){
		return -EINVAL;
	if (wan_test_bit(WAN_TE_BERT_FLAG_INLOCK, &fe->te_param.bert_flag)){
		fe->te_param.bert_stats.inlock = 1;
		fe->te_param.bert_stats.inlock = 0;
	if (fe->fe_status != FE_CONNECTED){
		fe->te_param.bert_stats.inlock = 0;	/* Force */
	memcpy(bert_stats, &fe->te_param.bert_stats, sizeof(sdla_te_bert_stats_t));
	DEBUG_EVENT("%s: Stopping Bit-Error-Test ...\n", fe->name);
	wan_clear_bit(WAN_TE_BERT_FLAG_READY, &fe->te_param.bert_flag);
	memset(&fe->te_param.bert_cfg, 0, sizeof(sdla_te_bert_cfg_t));
	memset(&fe->te_param.bert_stats, 0, sizeof(sdla_te_bert_stats_t));
	if (bert->un.cfg.eib == WAN_TE_BERT_EIB_NONE) return 0;
	if (bert->cmd == WAN_TE_BERT_CMD_EIB){
		if (!wan_test_bit(WAN_TE_BERT_FLAG_READY, &fe->te_param.bert_flag)){
			return -EINVAL;
	}else if (bert->cmd != WAN_TE_BERT_CMD_START){
		return -EINVAL;
	switch(bert->un.cfg.eib){
	if (bert->cmd == WAN_TE_BERT_CMD_EIB){
				fe->name, WAN_TE_BERT_EIB_DECODE(bert->un.cfg.eib));
	DEBUG_EVENT("%s: Starting Bit-Error-Test ...\n", fe->name);
	if (bert->verbose){
		DEBUG_EVENT("%s: BERT command        : %s\n", fe->name, WAN_TE_BERT_CMD_DECODE(bert->cmd));
		DEBUG_EVENT("%s: BERT channel list   : %08X\n", fe->name, bert->un.cfg.chan_map); 
		DEBUG_EVENT("%s: BERT pattern type   : %s\n", fe->name, WAN_TE_BERT_PATTERN_DECODE(bert->un.cfg.pattern_type)); 
		DEBUG_EVENT("%s: BERT pattern length : %d\n", fe->name, bert->un.cfg.pattern_len); 
		DEBUG_EVENT("%s: BERT pattern        : %08X\n",fe->name, bert->un.cfg.pattern);
		DEBUG_EVENT("%s: BERT word count     : %d\n", fe->name, bert->un.cfg.count); 
		DEBUG_EVENT("%s: BERT loopback mode  : %s\n", fe->name, WAN_TE_BERT_LOOPBACK_DECODE(bert->un.cfg.lb_type)); 
		DEBUG_EVENT("%s: BERT EIB            : %s\n", fe->name, WAN_TE_BERT_EIB_DECODE(bert->un.cfg.eib)); 
	if (bert->un.cfg.chan_map == ENABLE_ALL_CHANNELS){
		bert->un.cfg.chan_map  = WAN_TE1_ACTIVE_CH(fe);
		if (wan_test_bit(i, (void*)&bert->un.cfg.chan_map) && wan_test_bit(i,(void*)&active_ch)){
			off = (i-1) / 8;
			shift = (i-1) % 8;
	/* BERT pattern (def. preusorandom 2e7-1) */
	switch(bert->un.cfg.pattern_type){
		if (bert->un.cfg.pattern_len > 32){
			DEBUG_EVENT("%s: ERROR: Invalid BERT pattern length %d bits (0-32)!\n",
							fe->name, bert->un.cfg.pattern_len);
			return -EINVAL;
		if (bert->un.cfg.count >= 256){
			DEBUG_EVENT("%s: ERROR: Invalid BERT Alternating Word Count %d (1-256)!\n",
							fe->name, bert->un.cfg.count);
			return -EINVAL;
				fe->name,
				WAN_TE_BERT_PATTERN_DECODE(bert->un.cfg.pattern_type));
		return -EINVAL;
	if (bert->un.cfg.pattern_type == WAN_TE_BERT_PATTERN_REPETITIVE){
		u_int32_t	pattern = bert->un.cfg.pattern;
		if (bert->un.cfg.pattern_len < 17){
			repeat = 32 / bert->un.cfg.pattern_len;
				bert->un.cfg.pattern |= (pattern << bert->un.cfg.pattern_len);
			bert->un.cfg.pattern_len *= repeat; 
		WRITE_REG(REG_BRP1, bert->un.cfg.pattern & 0xFF);
		WRITE_REG(REG_BRP2, (bert->un.cfg.pattern >> 8) & 0xFF);
		WRITE_REG(REG_BRP3, (bert->un.cfg.pattern >> 16) & 0xFF);
		WRITE_REG(REG_BRP4, (bert->un.cfg.pattern >> 24) & 0xFF);
		WRITE_REG(REG_BC2, value | (bert->un.cfg.pattern_len-17)); 
	} else if (bert->un.cfg.pattern_type == WAN_TE_BERT_PATTERN_WORD){
		WRITE_REG(REG_BRP1, bert->un.cfg.pattern & 0xFF);
		WRITE_REG(REG_BRP2, (bert->un.cfg.pattern >> 8) & 0xFF);
		WRITE_REG(REG_BRP3, (bert->un.cfg.pattern >> 16) & 0xFF);
		WRITE_REG(REG_BRP4, (bert->un.cfg.pattern >> 24) & 0xFF);
		WRITE_REG(REG_BAWC, bert->un.cfg.count); 
	wan_set_bit(WAN_TE_BERT_FLAG_READY, &fe->te_param.bert_flag);
	memcpy(&fe->te_param.bert_cfg, &bert->un.cfg, sizeof(sdla_te_bert_cfg_t));
	fe->te_param.bert_start = SYSTEM_TICKS;
	switch(bert->cmd){
		if (wan_test_bit(WAN_TE_BERT_FLAG_READY, &fe->te_param.bert_flag)){
						fe->name);
			bert->rc = WAN_TE_BERT_RC_RUNNING;
		if (!wan_test_bit(WAN_TE_BERT_FLAG_READY, &fe->te_param.bert_flag)){
						fe->name);
			bert->rc = WAN_TE_BERT_RC_STOPPED;
						fe->name, bert->cmd);
		bert->rc = WAN_TE_BERT_RC_EINVAL;
	if (bert->cmd == WAN_TE_BERT_CMD_STATUS){
		return sdla_ds_te1_bert_status(fe, &bert->un.stats);
	if (bert->cmd == WAN_TE_BERT_CMD_RESET){
	if (bert->cmd == WAN_TE_BERT_CMD_EIB){
	if (bert->cmd == WAN_TE_BERT_CMD_STOP){
		sdla_ds_te1_bert_status(fe, &bert->un.stop.stats);
		if (fe->te_param.bert_cfg.lb_type != WAN_TE_BERT_LOOPBACK_NONE){
			bert->un.stop.chan_map = fe->te_param.bert_cfg.chan_map;
			bert->un.stop.lb_type  = fe->te_param.bert_cfg.lb_type;
		bert->rc = WAN_TE_BERT_RC_EINVAL;
	switch(udp_cmd->wan_cmd_command){
		fe_media->media		= fe->fe_cfg.media;
		fe_media->sub_media	= fe->fe_cfg.sub_media;
		fe_media->chip_id	= WAN_TE_CHIP_DM;
		fe_media->max_ports	= fe->fe_max_ports;
		udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
		udp_cmd->wan_cmd_data_len = sizeof(wan_femedia_t); 
	    	udp_cmd->wan_cmd_data_len = sizeof(sdla_fe_lbmode_t);
	    	udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
	        memcpy(&data[0], &fe->fe_stats, sizeof(sdla_fe_stats_t));
		if (udp_cmd->wan_cmd_fe_force){
			DEBUG_EVENT("%s: Force to read Front-End alarms\n",
						fe->name);
			fe_stats->alarms = 
	        udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
	    	udp_cmd->wan_cmd_data_len = sizeof(sdla_fe_stats_t); 
	        udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
	    		&fe->fe_cfg,
	    	udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
    	    	udp_cmd->wan_cmd_data_len = sizeof(sdla_fe_cfg_t);
		switch(fe_debug->type){
			if (fe_debug->mode == WAN_FE_DEBUG_RBS_READ){
					fe->name);
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			}else if (fe_debug->mode == WAN_FE_DEBUG_RBS_PRINT){
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			}else if (fe_debug->mode == WAN_FE_DEBUG_RBS_RX_ENABLE){
					fe->name);
				fe->fe_debug |= WAN_FE_DEBUG_RBS_RX_ENABLE;
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			}else if (fe_debug->mode == WAN_FE_DEBUG_RBS_TX_ENABLE){
					fe->name);
				fe->fe_debug |= WAN_FE_DEBUG_RBS_TX_ENABLE;
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			}else if (fe_debug->mode == WAN_FE_DEBUG_RBS_RX_DISABLE){
					fe->name);
				fe->fe_debug &= ~WAN_FE_DEBUG_RBS_RX_ENABLE;
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			}else if (fe_debug->mode == WAN_FE_DEBUG_RBS_TX_DISABLE){
					fe->name);
				fe->fe_debug &= ~WAN_FE_DEBUG_RBS_TX_ENABLE;
	    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			}else if (fe_debug->mode == WAN_FE_DEBUG_RBS_SET){
					if (fe_debug->fe_debug_rbs.channel < 1 || 
					    fe_debug->fe_debug_rbs.channel > 24){
							fe->name,
							fe_debug->fe_debug_rbs.channel);
					if (fe_debug->fe_debug_rbs.channel < 0 || 
					    fe_debug->fe_debug_rbs.channel > 31){
							fe->name,
							fe_debug->fe_debug_rbs.channel);
				event.te_event.rbs_channel = fe_debug->fe_debug_rbs.channel;
				event.te_event.rbs_abcd	= fe_debug->fe_debug_rbs.abcd;
				udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
    			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			if (fe->te_param.reg_dbg_busy){
				if (fe_debug->fe_debug_reg.read == 2 && fe->te_param.reg_dbg_ready){
					fe_debug->fe_debug_reg.value = fe->te_param.reg_dbg_value;
					udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
					fe->te_param.reg_dbg_busy = 0;
			event.type		= (fe_debug->fe_debug_reg.read) ? 
			event.te_event.reg	= (u_int16_t)fe_debug->fe_debug_reg.reg;
			event.te_event.value	= fe_debug->fe_debug_reg.value;
			if (fe_debug->fe_debug_reg.read){
				fe->te_param.reg_dbg_busy = 1;
				fe->te_param.reg_dbg_ready = 0;
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
    	    	udp_cmd->wan_cmd_data_len = 0;
		switch(fe_debug->mode){
					fe->name);
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			DEBUG_EVENT("%s: Disable Transmitter (tx tri-state mode)!\n",
					fe->name);
			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
			udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
		    	udp_cmd->wan_cmd_data_len = 0;
			udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
			udp_cmd->wan_cmd_data_len = 0;
    	    	udp_cmd->wan_cmd_data_len = sizeof(sdla_te_bert_t);
		udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
		udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
	    	udp_cmd->wan_cmd_data_len = 0;
		"ALOS", WAN_TE_ALOS_ALARM(fe->fe_alarm), 
		"LOS", WAN_TE_LOS_ALARM(fe->fe_alarm));
		"RED", WAN_TE_RED_ALARM(fe->fe_alarm), 
		"AIS", WAN_TE_AIS_ALARM(fe->fe_alarm));
			"RAI", WAN_TE_RAI_ALARM(fe->fe_alarm),
			"OOF", WAN_TE_OOF_ALARM(fe->fe_alarm));
			"OOF", WAN_TE_OOF_ALARM(fe->fe_alarm), 
			"RAI", WAN_TE_RAI_ALARM(fe->fe_alarm));
	return m->count;	
			"Line Code Violation", fe->fe_stats.te_pmon.lcv_errors,
			"Bit Errors", fe->fe_stats.te_pmon.bee_errors);
			"Out of Frame Errors", fe->fe_stats.te_pmon.oof_errors,
			"Line Code Violation", fe->fe_stats.te_pmon.lcv_errors,
			"CRC4 Errors", fe->fe_stats.te_pmon.crc4_errors);
			"FAS Errors", fe->fe_stats.te_pmon.fas_errors,
			"Far End Block Errors", fe->fe_stats.te_pmon.feb_errors);
	return m->count;
./sdla_8te1.c
* Copyright:	(c) 1995-2003 Sangoma Technologies Inc.
* 			        conf->electrical_interfaces must be hardcoded, before
#define MAX_TRACE_BUFFER	(MAX_LGTH_UDP_MGNT_PKT - 	\
				 sizeof(iphdr_t) - 		\
	 			 sizeof(udphdr_t) - 		\
				 sizeof(wan_mgmt_t) - 		\
				 sizeof(wan_trace_info_t) - 	\
 * wpatm_init - Cisco HDLC protocol initialization routine.
 *  o initialize protocol-specific fields of the adapter data space.
	card->disable_comm = NULL;
	if (conf->config_id != WANCONFIG_ATM) {
				  card->devname, conf->config_id);
		return -EINVAL;
	card->mbox_off = PRI_BASE_ADDR_MB_STRUCT;
	mb = &card->wan_mbox;
	if (!card->configured){
			card->hw_iface.peek(card->hw, 
				card->mbox_off+offsetof(wan_mbox_t, wan_return_code),
			if ((jiffies - timeout) > 1*HZ) break;
				card->devname);
			return -EIO;
	memcpy(&card->u.atm.atm_cfg,&conf->u.atm,sizeof(wan_atm_conf_t));
	wan_atomic_set(&card->wandev.if_cnt,0);
	err = (card->hw_iface.check_mismatch) ? 
			card->hw_iface.check_mismatch(card->hw,conf->fe_cfg.media) : -EINVAL;
	if (IS_TE1_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_te_iface_init(&card->fe,&card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg	= card->hw_iface.fe_write;
		card->fe.read_fe_reg		= card->hw_iface.fe_read;
		card->wandev.fe_enable_timer = enable_timer;
		card->wandev.te_link_state = handle_front_end_state;
		conf->electrical_interface = 
		if (card->wandev.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
	}else if (IS_56K_MEDIA(&conf->fe_cfg)){
		memcpy(&card->fe.fe_cfg, &conf->fe_cfg, sizeof(sdla_fe_cfg_t));
		sdla_56k_iface_init(&card->fe,&card->wandev.fe_iface);
		card->fe.name		= card->devname;
		card->fe.card		= card;
		card->fe.write_fe_reg	= card->hw_iface.fe_write;
		card->fe.read_fe_reg		= card->hw_iface.fe_read;
		if (card->wandev.comm_port == WANOPT_PRI){
			conf->clocking = WANOPT_EXTERNAL;
		card->fe.fe_status = FE_CONNECTED;
	if (card->wandev.ignore_front_end_status == WANOPT_NO){
				card->devname);
				card->devname);
	card->wandev.clocking 			= conf->clocking;
	card->wandev.ignore_front_end_status 	= conf->ignore_front_end_status;
	card->wandev.ttl 			= conf->ttl;
	card->wandev.electrical_interface 			= conf->electrical_interface; 
	card->wandev.comm_port 			= conf->comm_port;
	card->wandev.udp_port   		= conf->udp_port;
	card->wandev.new_if_cnt 		= 0;
		return -EIO;
		card->devname, u.str); 
		return -EIO;
	card->isr			= &wpatm_isr;
	card->wandev.update		= &update;
 	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= &del_if;
	card->wandev.get_config_info 	= &get_config_info;
	card->wandev.get_status_info 	= &get_status_info;
	card->wandev.get_dev_config_info= &get_dev_config_info;
	card->wandev.get_if_info     	= &get_if_info;
	card->wandev.set_dev_config    	= &set_dev_config;
	card->wandev.set_if_info     	= &set_if_info;
	card->wandev.get_info     	= &wan_atm_get_info;
	if(card->wandev.clocking) {
		if(card->type == SDLA_S514){
			card->wandev.bps = wp_min(conf->bps,PHY_MAX_BAUD_RATE_S514);
			card->wandev.bps = wp_min(conf->bps,PHY_MAX_BAUD_RATE_S508);
				card->devname,card->wandev.bps);
        	card->wandev.bps = 0;
	if((card->wandev.comm_port == WANOPT_PRI)) {
		if (conf->mtu < MIN_WP_PRI_MTU){
					card->devname,MIN_WP_PRI_MTU);
			conf->mtu=MIN_WP_PRI_MTU;
		}else if (conf->mtu > MAX_WP_PRI_MTU){
					card->devname,MIN_WP_PRI_MTU);
			conf->mtu=MAX_WP_PRI_MTU;
					card->devname,MIN_WP_PRI_MTU);
		card->wandev.mtu = conf->mtu;
    	card->intr_type_off = 
			card->flags_off +
	card->intr_perm_off = 
			card->flags_off +
	card->fe_status_off = 
			card->flags_off + 
	card->wandev.state = WAN_DISCONNECTED;
	if (!card->wandev.piggyback){	
					card->devname, Intr_test_counter);
					card->devname);
			card->wandev.state = WAN_UNCONFIGURED;
			return -EIO;
				card->devname, Intr_test_counter);
		card->configured = 1;
			card->devname);
		card->wandev.state = WAN_UNCONFIGURED;
		return -EIO;	
	card->u.atm.trace_info = wan_malloc(sizeof(wan_trace_t));
	if (!card->u.atm.trace_info){
		card->wandev.state = WAN_UNCONFIGURED;
		return -ENOMEM;
	wan_trace_info_init(card->u.atm.trace_info,MAX_TRACE_QUEUE);
	skb_queue_head_init(&card->u.atm.wp_rx_free_list);
	skb_queue_head_init(&card->u.atm.wp_rx_used_list);
	skb_queue_head_init(&card->u.atm.wp_rx_data_list);
	skb_queue_head_init(&card->u.atm.wp_tx_prot_list);
			           card->devname,
				   &card->u.atm.atm_device,
				   &card->u.atm.wp_rx_data_list,
				   &card->u.atm.wp_tx_prot_list,
				   card->u.atm.trace_info);
		wan_free(card->u.atm.trace_info);
		card->wandev.state = WAN_UNCONFIGURED;
		return -EINVAL;
	WAN_TASKLET_INIT(((wan_tasklet_t*)&card->u.atm.wanpipe_rx_task), 
	wan_init_timer(&card->u.atm.atm_timer,atm_timer_poll,(unsigned long)card);
			while ((skb=wan_skb_dequeue(&card->u.atm.wp_rx_free_list)) != NULL){
			wp_sar_unregister_device(card->u.atm.atm_device);
			card->u.atm.atm_device=NULL;
			wan_free(card->u.atm.trace_info);
			card->u.atm.trace_info=NULL;
			card->wandev.state = WAN_UNCONFIGURED;
			return -ENOMEM;
		wan_skb_queue_tail(&card->u.atm.wp_rx_free_list,skb);
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	card->backup = conf->backup;
	card->u.atm.state = WAN_DISCONNECTED;
	card->disable_comm = &disable_comm;
	if (wan_test_bit(PERI_CRIT,&card->wandev.critical)){
				card->devname);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (!wan_atomic_read(&card->wandev.if_cnt) ||  !dev){
				card->devname);
	if (card->wandev.state != WAN_CONNECTED){
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (!(chan->sar_pvc)){
		err=wanpipe_sar_poll(chan->sar_pvc, ATM_TIMER_TIMEOUT);
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
	wan_add_timer(&card->u.atm.atm_timer, ATM_TIMER_TIMEOUT*HZ);
 * update - Update wanpipe device status & statistics
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
        if(!card->flags_off)
                return -ENODEV;
	if(wan_test_bit(PERI_CRIT, (void*)&card->wandev.critical))
                return -EAGAIN;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
	if((priv_area=dev->priv) == NULL)
		return -ENODEV;
       	if(card->update_comms_stats){
		return -EAGAIN;
	card->update_comms_stats = (IS_TE1_CARD(card) || IS_56K_CARD(card)) ? 3 : 2;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	card->timer_int_enabled = TMR_INT_ENABLED_UPDATE;
		if(card->update_comms_stats == 0)
                if ((jiffies - timeout) > (1 * HZ)){
    			card->update_comms_stats = 0;
 			card->timer_int_enabled &=
 			return -EAGAIN;
 * new_if - Create new logical channel.
 * to dev->priv pointer.  
 * Also the dev->init pointer should also be initialized
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
			card->devname, conf->name);
		WAN_MEM_ASSERT(card->devname);
		return -ENOMEM;
	strncpy(priv_area->if_name, conf->name, WAN_IFNAME_SZ);
	memcpy(&priv_area->cfg, &conf->u.atm, sizeof(wan_atm_conf_if_t));
	priv_area->card = card; 
	priv_area->dev = dev;
	priv_area->common.sk = NULL;
	priv_area->common.state = WAN_CONNECTING;
	priv_area->TracingEnabled = 0;
	priv_area->route_status = NO_ROUTE;
	priv_area->route_removed = 0;
	if(strcmp(conf->usedby, "WANPIPE") == 0) {
			wandev->name,conf->name);
		priv_area->common.usedby = WANPIPE;
		if (conf->if_down){
			wan_set_bit(DYN_OPT_ON,&priv_area->interface_down);
			   card->devname,priv_area->if_name);
	}else if( strcmp(conf->usedby, "API") == 0) {
		priv_area->common.usedby = API;
			wandev->name,priv_area->if_name);
	}else if (strcmp(conf->usedby, "BRIDGE") == 0) {
		priv_area->common.usedby = BRIDGE;
				card->devname,priv_area->if_name);
	}else if (strcmp(conf->usedby, "BRIDGE_N") == 0) {
		priv_area->common.usedby = BRIDGE_NODE;
				card->devname,priv_area->if_name);
				card->devname,priv_area->if_name);
		err=-EINVAL;
			card->devname,priv_area->if_name,
			priv_area->cfg.encap_mode,
			priv_area->cfg.vpi,
			priv_area->cfg.vci);
	err=wp_sar_register_pvc(card->u.atm.atm_device,
			        &priv_area->sar_pvc,
				(void **)&priv_area->tx_cells_skb,
				priv_area->if_name,
				&priv_area->cfg,
				card->wandev.mtu);
		err=-EBUSY;
	 *      is brought back up, we must know to re-astablish the
	if ((priv_area->gateway = conf->gateway) == WANOPT_YES){
			card->devname,priv_area->if_name);
	priv_area->mc = conf->mc;
	 * 	dev->if_init : function that will be called
	 * 	dev->priv    : private structure allocated above
	WAN_TASKQ_INIT((&priv_area->poll_task),0,frmw_poll,priv_area);
					   &priv_area->dent, 
					   priv_area->if_name, 
			card->devname, priv_area->if_name);
	dev->init = &if_init;
	dev->priv = priv_area;
	wan_atomic_inc(&card->wandev.if_cnt);
	if (priv_area->sar_pvc){
		wp_sar_unregister_pvc(card->u.atm.atm_device,
				      priv_area->sar_pvc,
				      priv_area->tx_cells_skb);
		priv_area->sar_pvc=NULL;
		priv_area->tx_cells_skb=NULL;
	dev->priv=NULL;
 * del_if - Delete logical channel.
 * NOTE: DO NOT deallocate dev->priv here! It will be
	private_area_t* 	priv_area = dev->priv;
	sdla_t*			card = wandev->priv;
	wan_atomic_dec(&card->wandev.if_cnt);
	wan_spin_lock_irq(&card->wandev.lock,&flags);
	card->u.atm.tx_dev=NULL;
	if (priv_area->sar_pvc){
		wp_sar_unregister_pvc(card->u.atm.atm_device,
				      priv_area->sar_pvc,
				      priv_area->tx_cells_skb);
		priv_area->sar_pvc=NULL;
		priv_area->tx_cells_skb=NULL;
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
 	wanrouter_proc_delete_interface(wandev, priv_area->if_name);
	if (wan_atomic_read(&card->wandev.if_cnt) <= 0){
		wan_del_timer(&card->u.atm.atm_timer);
 * if_init - Initialize Linux network interface.
	private_area_t* priv_area = dev->priv;
	sdla_t* card = priv_area->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->tx_timeout		= &if_tx_timeout;
	dev->watchdog_timeo	= TX_TIMEOUT;
	dev->do_ioctl		= if_do_ioctl;
	if (priv_area->cfg.encap_mode == RFC_MODE_BRIDGED_ETH_LLC ||
	    priv_area->cfg.encap_mode == RFC_MODE_BRIDGED_ETH_VC){
		memcpy(dev->dev_addr, "\xFE\xFC\x00\x00\x00\x00", 6);
		*(int *)(dev->dev_addr + 2) += hw_addr;
		/* Initialize media-specific parameters */
		dev->flags		|= IFF_POINTOPOINT;
		dev->flags		|= IFF_NOARP;
		if (priv_area->mc == WANOPT_YES){
			dev->flags 	|= IFF_MULTICAST;
		if (priv_area->true_if_encoding){
			dev->type	= ARPHRD_HDLC; /* This breaks the tcpdump */
			dev->type	= ARPHRD_PPP;
		dev->mtu		= card->wandev.mtu;
		dev->hard_header_len	= 0;
		dev->tx_queue_len = 100;
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start);
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end);
 * if_open - Open network interface.
	private_area_t* priv_area = dev->priv;
	sdla_t* card = priv_area->card;
		return -EBUSY;
	priv_area->router_start_time = tv.tv_sec;
	priv_area->common.state=WAN_CONNECTED;
	if (card->open_cnt == 1){
		wan_add_timer(&card->u.atm.atm_timer,ATM_TIMER_TIMEOUT*HZ);	
	if (!card->comm_enabled){
		card->timer_int_enabled |= TMR_INT_ENABLED_CONFIG;
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
 * if_close - Close network interface.
	private_area_t* priv_area = dev->priv;
	sdla_t* card = priv_area->card;
	dev->start=0;
 * disable_comm - Main shutdown function
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	if (card->comm_enabled){
		card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	WAN_TASKLET_KILL(((wan_tasklet_t*)&card->u.atm.wanpipe_rx_task));	
	wan_del_timer(&card->u.atm.atm_timer);
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	while ((skb=wan_skb_dequeue(&card->u.atm.wp_rx_free_list)) != NULL){
	while ((skb=wan_skb_dequeue(&card->u.atm.wp_rx_used_list)) != NULL){
	while ((skb=wan_skb_dequeue(&card->u.atm.wp_rx_data_list)) != NULL){
	while ((skb=wan_skb_dequeue(&card->u.atm.wp_tx_prot_list)) != NULL){
	if (card->u.atm.atm_device){
		wp_sar_unregister_device(card->u.atm.atm_device);
		card->u.atm.atm_device=NULL;
	if (card->u.atm.trace_info){
		wan_trace_purge(card->u.atm.trace_info);
		wan_free(card->u.atm.trace_info);
		card->u.atm.trace_info=NULL;
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
	/* TE1 - Unconfiging, only on shutdown */
		if (card->wandev.fe_iface.unconfig){
			card->wandev.fe_iface.unconfig(&card->fe);
    	private_area_t* chan = dev->priv;
	sdla_t *card = chan->card;
	 * kick start the device by making dev->tbusy = 0.  We expect
	++chan->if_stats.collisions;
	DEBUG_EVENT( "%s: Transmit timed out on %s\n", card->devname,dev->name);
 * if_send - Send a packet on a network interface.
 * 	Return a non-zero value to tell the stack
 *		non-0	packet may be re-transmitted 
	private_area_t *chan = dev->priv;
	sdla_t *card = chan->card;
			card->devname, dev->name);
	if (dev->tbusy){
		 * kick start the device by making dev->tbusy = 0.  We expect 
		if((jiffies - chan->tick_counter) < (5 * HZ)) {
   	if (ntohs(skb->protocol) != htons(PVC_PROT)){
				card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
                if(chan->common.usedby == WANPIPE && chk_bcast_mcast_addr(card, dev, skb)){
			++chan->if_stats.tx_dropped;
      	if(card->type != SDLA_S514){
	if(card->wandev.state != WAN_CONNECTED){
       		++chan->if_stats.tx_dropped;
	}else if(!skb->protocol){
        	++chan->if_stats.tx_errors;
		err=wanpipe_sar_tx(chan->sar_pvc, skb, (void*)chan->tx_cells_skb);
			++chan->if_stats.tx_errors;
				wan_skb_len(skb),wan_skb_len(chan->tx_cells_skb),
				wan_skb_len(chan->tx_cells_skb)%53);
		err=wp_handle_tx_packets(card,chan->tx_cells_skb);
			++chan->if_stats.tx_packets;
                        chan->if_stats.tx_bytes += wan_skb_len(skb);
	 * exiting with non-zero value.  
		chan->tick_counter = jiffies;
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
	/* End of critical area for re-entry and for S508 card */
	if(card->type != SDLA_S514){
 * chk_bcast_mcast_addr - Check for source broadcast addresses
	private_area_t *priv_area=dev->priv;
	if (priv_area->common.usedby != WANPIPE){
        in_dev = dev->ip_ptr;
                struct in_ifaddr *ifa= in_dev->ifa_list;
                        broadcast_ip_addr = ifa->ifa_broadcast;
        if((dev->flags & IFF_BROADCAST) && (src_ip_addr == broadcast_ip_addr)) {
				card->devname);
				card->devname);
	if ((priv_area=dev->priv) == NULL)
	return &priv_area->if_stats;
 * if_do_ioctl - Ioctl handler for fr
	private_area_t* chan= (private_area_t*)dev->priv;
		return -ENODEV;
	card=chan->card;
			if (wan_atomic_read(&chan->udp_pkt_len) != 0){
				return -EBUSY;
			wan_atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
			wan_udp_pkt=(wan_udp_pkt_t*)chan->udp_pkt_data;
			if (copy_from_user(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data,sizeof(wan_udp_hdr_t))){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			wan_spin_lock_irq(&card->wandev.lock, &smp_flags);
			if (wan_test_bit(0,&card->in_isr)) {
						card->devname,dev->name);
				wan_atomic_set(&chan->udp_pkt_len,0);
				wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
				return -EBUSY;
			wan_spin_unlock_irq(&card->wandev.lock, &smp_flags);
			if (wan_atomic_read(&chan->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
						card->devname,wan_atomic_read(&chan->udp_pkt_len));
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EINVAL;
			if (copy_to_user(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
				wan_atomic_set(&chan->udp_pkt_len,0);
				return -EFAULT;
			wan_atomic_set(&chan->udp_pkt_len,0);
			return -EOPNOTSUPP;
	wan_mbox_t *mb1=&card->wan_mbox;
	mb1->wan_data_len = 0;
	mb1->wan_command = READ_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb1);
		return -EIO;
	card->flags_off = ((PHY_CONFIGURATION_STRUCT *)mb1->wan_data)->
	wan_mbox_t* mb = &card->wan_mbox;
	ADAPTER_CONFIGURATION_STRUCT* cfg = (ADAPTER_CONFIGURATION_STRUCT*)mb->wan_data;
	card->hw_iface.getcfg(card->hw, SDLA_ADAPTERTYPE, &cfg->adapter_type); 
	cfg->adapter_config = 0x00; 
	cfg->operating_frequency = 00; 
	mb->wan_data_len = sizeof(ADAPTER_CONFIGURATION_STRUCT);
	mb->wan_command = SET_ADAPTER_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CODE_VERSION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		len = mb->wan_data_len;
		memcpy(str, mb->wan_data, len);
/*-----------------------------------------------------------------------------
	wan_mbox_t *mb = &card->wan_mbox;
	mb->wan_data_len = data_length;  
	memcpy(mb->wan_data, data, data_length);
	mb->wan_command = SET_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
 * Set interrupt mode -- HDLC Version.
	wan_mbox_t* mb = &card->wan_mbox;
		 (INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->interrupt_triggers 	= mode;
	card->hw_iface.getcfg(card->hw, SDLA_IRQ, &int_data->IRQ);
	int_data->interrupt_timer       = 1;
	mb->wan_data_len = sizeof(INT_TRIGGERS_STRUCT);
	mb->wan_command = SET_INTERRUPT_TRIGGERS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t* mb = &card->wan_mbox;
		 (INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->interrupt_triggers 	= 0;
	card->hw_iface.getcfg(card->hw, SDLA_IRQ, &int_data->IRQ);
	int_data->interrupt_timer	= 1;
	mb->wan_data_len = sizeof(INT_TRIGGERS_STRUCT);
	mb->wan_command = SET_INTERRUPT_TRIGGERS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	mb->wan_command = DISABLE_COMMUNICATIONS;
	mb->wan_data_len = 0;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card->comm_enabled = 0;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = ENABLE_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->comm_enabled = 1;
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_COMMS_ERROR_STATS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_OPERATIONAL_STATS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
	if(card->update_comms_stats == 3) {
			card->wandev.fe_iface.read_alarm(&card->fe, 0); 
			card->wandev.fe_iface.read_pmon(&card->fe, 0); 
			card->wandev.fe_iface.read_alarm(&card->fe, 0); 
		if(card->update_comms_stats == 2) {
			err_stats = (COMMS_ERROR_STATS_STRUCT *)mb->wan_data;
			card->wandev.stats.rx_over_errors = 
				err_stats->Rx_overrun_err_count;
			op_stats = (OPERATIONAL_STATS_STRUCT *)mb->wan_data;
			card->wandev.stats.rx_length_errors =
				op_stats->Rx_blocks_discard_count;
			card->wandev.stats.rx_crc_errors = 
				op_stats->Rx_bad_HEC_count;
			card->wandev.stats.rx_frame_errors = 
				op_stats->Rx_sync_failure_count;
			card->wandev.stats.rx_fifo_errors = 
				op_stats->Rx_hunt_timeout_count; 
			card->wandev.stats.rx_missed_errors =
				op_stats->Rx_resync_reception_loss_count;
			card->wandev.stats.tx_aborted_errors =
				op_stats->Tx_underrun_cell_count+
				op_stats->Tx_length_error_count;
 *	Return:	0 - o.k.
 *		1 - no transmit buffers available
	card->hw_iface.peek(card->hw, card->u.atm.txbuf_off, &txbuf, sizeof(txbuf));
	card->hw_iface.poke(card->hw, txbuf.ptr_data_bfr, data, len);
	card->hw_iface.poke(card->hw, card->u.atm.txbuf_off, &txbuf, sizeof(txbuf));
	card->u.atm.txbuf_off += sizeof(DATA_TX_STATUS_EL_STRUCT);
	if (card->u.atm.txbuf_off > card->u.atm.txbuf_last_off){
		card->u.atm.txbuf_off = card->u.atm.txbuf_base_off;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	DEBUG_EVENT( "%s: enabling timer %s\n",card->devname,
			dev ? dev->name:"No DEV");
	card->timer_int_enabled |= TMR_INT_ENABLED_TE;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_command;
			card->devname, cmd, err);
	if(card->wandev.clocking){
		cfg.baud_rate = card->wandev.bps;
	cfg.line_config_options = (card->wandev.electrical_interface == WANOPT_RS232) ?
	cfg.Tx_underrun_cell_GFC	= card->u.atm.atm_cfg.atm_cell_cfg;
	cfg.Tx_underrun_cell_PT		= card->u.atm.atm_cfg.atm_cell_pt;
	cfg.Tx_underrun_cell_CLP	= card->u.atm.atm_cfg.atm_cell_clp;
	cfg.Tx_underrun_cell_payload	= card->u.atm.atm_cfg.atm_cell_payload;
			card->devname,
	cfg.Rx_hunt_timer		= card->u.atm.atm_cfg.atm_hunt_timer;
	if (card->u.atm.atm_cfg.atm_sync_mode){
	cfg.Rx_sync_bytes = card->u.atm.atm_cfg.atm_sync_data;
	cfg.Rx_sync_offset = card->u.atm.atm_cfg.atm_sync_offset;
			card->devname,
			card->u.atm.atm_cfg.atm_sync_mode?"Manual":"Auto",
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	tx_config_off = ((PHY_CONFIGURATION_STRUCT *)mb->wan_data)->
	card->hw_iface.peek(card->hw, tx_config_off, &tx_config, sizeof(tx_config));
       	rx_config_off = ((PHY_CONFIGURATION_STRUCT *)mb->wan_data)->
	card->hw_iface.peek(card->hw, rx_config_off, &rx_config, sizeof(rx_config));
       	card->u.atm.txbuf_base_off = tx_config.base_addr_Tx_status_els;
       	card->u.atm.txbuf_last_off = 
               		card->u.atm.txbuf_base_off +
			(tx_config.number_Tx_status_els - 1) * sizeof(DATA_TX_STATUS_EL_STRUCT);
       	card->u.atm.rxbuf_base_off = rx_config.base_addr_Rx_status_els;
       	card->u.atm.rxbuf_last_off = 
               		card->u.atm.rxbuf_base_off +
			(rx_config.number_Rx_status_els - 1) * sizeof(DATA_RX_STATUS_EL_STRUCT);
       	card->u.atm.txbuf_off = tx_config.next_Tx_status_el_to_use;
	card->u.atm.rxmb_off = rx_config.next_Rx_status_el_to_use;
	wan_mbox_t* mb = &card->wan_mbox;
			mb->wan_data_len  = 0;
			mb->wan_command = READ_CODE_VERSION;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	if (wan_test_bit(PERI_CRIT, (void*)&card->wandev.critical)){
				card->devname);
		WAN_TASKLET_END(((wan_tasklet_t*)&card->u.atm.wanpipe_rx_task));
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (!card->u.atm.atm_device || !dev){
				card->devname);
		WAN_TASKLET_END(((wan_tasklet_t*)&card->u.atm.wanpipe_rx_task));
	while ((skb=wan_skb_dequeue(&card->u.atm.wp_rx_used_list))){
		err=wanpipe_sar_rx(card->u.atm.atm_device,skb);
		skb->len=1;
		wan_skb_queue_tail(&card->u.atm.wp_rx_free_list,skb);
		if (err < 0 && card->wandev.state==WAN_CONNECTED){
	while((skb=wan_skb_dequeue(&card->u.atm.wp_rx_data_list))){
	while((skb=wan_skb_dequeue(&card->u.atm.wp_tx_prot_list))){
			wan_skb_queue_head(&card->u.atm.wp_tx_prot_list,skb);
			card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
	WAN_TASKLET_END(((wan_tasklet_t*)&card->u.atm.wanpipe_rx_task));
	wan_mbox_t* mb = &card->wan_mbox;
	/* We should only try to re-sync if we are in
	 * in re-sync state already */
	if (card->u.atm.state != WAN_CONNECTED){
	DEBUG_EVENT("%s: ATM PHY out of sync, re-syncing!\n",
			card->devname);
		wan_spin_lock_irq(&card->wandev.lock,&flags);
	mb->wan_data_len = 0;
	mb->wan_command = PHY_RESYNCHRONIZE_RECEIVER;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		DEBUG_EVENT("%s: Error: Failed to re-syncing adapter !\n",
			card->devname);
		 * and let the rx sar trigger the re-sync again */
			wan_spin_unlock_irq(&card->wandev.lock,&flags);
		return -1;
	while ((skb=wan_skb_dequeue(&card->u.atm.wp_rx_used_list))){
		skb->len=1;
		wan_skb_queue_tail(&card->u.atm.wp_rx_free_list,skb);
	wan_skb_queue_purge(&card->u.atm.wp_rx_data_list);
	wan_skb_queue_purge(&card->u.atm.wp_tx_prot_list);
		wan_spin_unlock_irq(&card->wandev.lock,&flags);
	wan_spin_lock_irq(&card->wandev.lock,&flags);
	wan_spin_unlock_irq(&card->wandev.lock,&flags);
	private_area_t *chan = (private_area_t *)skb->dev;
		DEBUG_EVENT("%s:%d Error, Rx packet has no dev pointer (skb->dev==NULL)\n",
	card=chan->card;
	skb->dev=chan->dev;
	switch (chan->cfg.encap_mode){
		skb->protocol = eth_type_trans(skb, skb->dev);
		skb->protocol = htons(ETH_P_IP);
	++chan->if_stats.rx_packets;
	chan->if_stats.rx_bytes += skb->len;
	if (!card->hw){
	wan_set_bit(0,&card->in_isr);
	if(wan_test_bit(PERI_CRIT, (void*)&card->wandev.critical)) {
				card->devname);
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
			card->hw_iface.poke_byte(card->hw, card->fe_status_off, 0x01);
			card->devname,
	wan_clear_bit(0,&card->in_isr);
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
	if (card->u.atm.tx_dev == NULL){
		card->u.atm.tx_dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	dev = card->u.atm.tx_dev;
		chan = dev->priv;
			if (chan->common.usedby == API){
		if (++i >= wan_atomic_read(&card->wandev.if_cnt)){
	card->u.atm.tx_dev = dev;
		card->hw_iface.set_bit(card->hw, card->intr_perm_off, APP_INT_ON_TX_FRAME);
	if (wan_skb_queue_len(&card->u.atm.wp_tx_prot_list)){
		WAN_TASKLET_SCHEDULE(((wan_tasklet_t*)&card->u.atm.wanpipe_rx_task));	
	if (wan_atomic_read(&card->wandev.if_cnt) == 1){
	WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
		if (devle->dev == dev){
				dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	card->hw_iface.peek(card->hw, card->u.atm.rxmb_off, &rxbuf, sizeof(rxbuf));
			card->devname, card->u.atm.rxmb_off, rxbuf.opp_flag);
		DEBUG_EVENT( "%s: Critical router failure ...!!!\n", card->devname);
	if (card->wandev.state != WAN_CONNECTED){
		++card->wandev.stats.rx_dropped;
	skb = wan_skb_dequeue(&card->u.atm.wp_rx_free_list);
					card->devname);
		++card->wandev.stats.rx_dropped;
	card->hw_iface.peek(card->hw, addr, buf, len);
	wan_skb_queue_tail(&card->u.atm.wp_rx_used_list,skb);
	WAN_TASKLET_SCHEDULE(((wan_tasklet_t*)&card->u.atm.wanpipe_rx_task));
	card->hw_iface.poke(card->hw, card->u.atm.rxmb_off, &rxbuf, sizeof(rxbuf));
	card->u.atm.rxmb_off += sizeof(rxbuf);
	if(card->u.atm.rxmb_off > card->u.atm.rxbuf_last_off){
		card->u.atm.rxmb_off = card->u.atm.rxbuf_base_off;
 *    2) Reading board-level statistics for updating the proc file system.
	if (card->timer_int_enabled & TMR_INT_ENABLED_TE) {
		card->wandev.fe_iface.polling(&card->fe);
		card->timer_int_enabled &= ~TMR_INT_ENABLED_TE;
	if (card->timer_int_enabled & TMR_INT_ENABLED_CONFIG) {
		card->timer_int_enabled &= ~TMR_INT_ENABLED_CONFIG;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		card->timer_int_enabled=0;
        priv_area = dev->priv;
       	if(card->timer_int_enabled & TMR_INT_ENABLED_UDP) {
		card->timer_int_enabled &= ~TMR_INT_ENABLED_UDP;
	if(card->timer_int_enabled & TMR_INT_ENABLED_UPDATE) {
                if(!(-- card->update_comms_stats)) {
			card->timer_int_enabled &= 
        if(!card->timer_int_enabled) {
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, APP_INT_ON_TIMER);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_GLOBAL_EXCEPTION_CONDITION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		switch(mb->wan_return_code) {
				card->hw_iface.peek(card->hw,
					            card->fe_status_off,
				card->fe.fe_param.k56_param.RR8_reg_56k = 
				card->fe.fe_param.k56_param.RRA_reg_56k = 
				card->fe.fe_param.k56_param.RRC_reg_56k = 
				card->wandev.fe_iface.read_alarm(&card->fe, 0); 
				card->wandev.fe_iface.isr(&card->fe);
			if ((mb->wan_data[0] & (DCD_HIGH | CTS_HIGH)) == (DCD_HIGH | CTS_HIGH)){
				card->fe.fe_status = FE_CONNECTED;
				card->fe.fe_status = FE_DISCONNECTED;
				card->devname);
			switch(mb->wan_data[0] & (DCD_HIGH | CTS_HIGH)) {
                                        DEBUG_EVENT( "%s: DCD high, CTS high\n",card->devname);
					DEBUG_EVENT( "%s: DCD high, CTS low\n",card->devname);
                                        DEBUG_EVENT( "%s: DCD low, CTS high\n",card->devname); 
                                        DEBUG_EVENT( "%s: DCD low, CTS low\n",card->devname);
				card->devname); 
				card->devname, mb->wan_return_code);
	switch (rx_sync->Rx_sync_status){
		DEBUG_EVENT("%s: Phy state change: Rx sync lost \n",card->devname);
		DEBUG_EVENT("%s: Phy state change: Rx hunt \n",card->devname);
		DEBUG_EVENT("%s: Phy state change: Rx presync \n",card->devname);
		DEBUG_EVENT("%s: Phy state change: Rx sync successful \n",card->devname);
		card->u.atm.state=WAN_CONNECTED;
		if (card->fe.fe_status == FE_CONNECTED){
				card->devname, rx_sync->Rx_sync_status);
	card->u.atm.state=WAN_DISCONNECTED;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_EXCEPTION_CONDITION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			phy_sync_state_change(card,(PHY_RX_SYNC_EXCEP_STRUCT *)mb->wan_data);	
					card->devname); 	
					card->devname);
					card->devname);
					card->devname);
					card->devname, err);
	if(!wan_atomic_read(&priv_area->udp_pkt_len) &&
	  (skb->len <= MAX_LGTH_UDP_MGNT_PKT)) {
		wan_atomic_set(&priv_area->udp_pkt_len, skb->len);
		priv_area->udp_pkt_src = udp_pkt_src;
       		memcpy(priv_area->udp_pkt_data, skb->data, skb->len);
		card->timer_int_enabled = TMR_INT_ENABLED_UDP;
 * "wanpipemon" utility is a user-space program that 
	wan_mbox_t *mb = &card->wan_mbox;
	wan_udp_pkt = (wan_udp_pkt_t *) priv_area->udp_pkt_data;
	//	card->devname,wan_udp_pkt->wan_udp_command);
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
		if(priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK){
			switch(wan_udp_pkt->wan_udp_command) {
		wan_udp_pkt->wan_udp_data_len = 0;
		wan_udp_pkt->wan_udp_return_code = 0xCD;
			card->devname,wan_udp_pkt->wan_udp_command);
		wan_udp_hdr_t* udp_hdr = &wan_udp_pkt->wan_udp_hdr;
		wan_trace_t *trace_info = card->u.atm.trace_info;
				card->devname);
			wan_udp_pkt->wan_udp_data_len = 0;
			wan_udp_pkt->wan_udp_return_code = 0xCD;
		wan_udp_pkt->wan_udp_opp_flag = 0;
		switch(wan_udp_pkt->wan_udp_command) {
			udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
			udp_hdr->wan_udphdr_data_len = 0;
			if (!wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
				//DEBUG_EVENT("%s: ATM ENABLE_TRACING : mode %d\n", card->devname,
				//	udp_hdr->wan_udphdr_data[0]);
				switch(udp_hdr->wan_udphdr_data[0])
					wan_clear_bit(1,&trace_info->tracing_enabled);
						card->devname);
					wan_clear_bit(2,&trace_info->tracing_enabled);
					wan_set_bit(1,&trace_info->tracing_enabled);
						card->devname);
					wan_clear_bit(1,&trace_info->tracing_enabled);
					wan_set_bit(2,&trace_info->tracing_enabled);
					wan_set_bit(3,&trace_info->tracing_enabled);
						card->devname);
					wan_clear_bit(1,&trace_info->tracing_enabled);
					wan_set_bit(2,&trace_info->tracing_enabled);
						card->devname);
				wan_set_bit (0,&trace_info->tracing_enabled);
						card->devname);
				udp_hdr->wan_udphdr_return_code = 2;
			udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
			if(wan_test_bit(0,&trace_info->tracing_enabled)) {
				wan_clear_bit(0,&trace_info->tracing_enabled);
				wan_clear_bit(1,&trace_info->tracing_enabled);
				wan_clear_bit(2,&trace_info->tracing_enabled);
				wan_clear_bit(3,&trace_info->tracing_enabled);
							card->devname);
				udp_hdr->wan_udphdr_return_code = 1;
			if(wan_test_bit(0,&trace_info->tracing_enabled)){
				trace_info->trace_timeout = SYSTEM_TICKS;
						card->devname);
				udp_hdr->wan_udphdr_return_code = 1;
			udp_hdr->wan_udphdr_atm_num_frames = 0;	
			udp_hdr->wan_udphdr_atm_ismoredata = 0;
				WAN_IFQ_POLL(&trace_info->trace_queue, skb);
								card->devname);
				if ((WAN_MAX_DATA_SIZE - buffer_length) < skb->m_pkthdr.len){
					udp_hdr->wan_udphdr_atm_ismoredata = 0x01;
					   skb->m_pkthdr.len, 
					   &udp_hdr->wan_udphdr_data[buffer_length]);
				buffer_length += skb->m_pkthdr.len;
				WAN_IFQ_DEQUEUE(&trace_info->trace_queue, skb);
				udp_hdr->wan_udphdr_atm_num_frames++;
			if( (wan_test_bit(3,&trace_info->tracing_enabled)) ){
					trace_info->missed_idle_rx_counter++;
					if(trace_info->missed_idle_rx_counter > 10){
						trace_info->missed_idle_rx_counter = 0;
			while ((skb=skb_dequeue(&trace_info->trace_queue)) != NULL){
				if((MAX_TRACE_BUFFER - buffer_length) < wan_skb_len(skb)){
					udp_hdr->wan_udphdr_atm_ismoredata = 0x01;
						wan_skb_queue_head(&trace_info->trace_queue, skb);
						memcpy(&udp_hdr->wan_udphdr_atm_data[buffer_length], 
						udp_hdr->wan_udphdr_atm_num_frames++;
				memcpy(&udp_hdr->wan_udphdr_atm_data[buffer_length], 
				udp_hdr->wan_udphdr_atm_num_frames++;
			udp_hdr->wan_udphdr_data_len = buffer_length;
			udp_hdr->wan_udphdr_return_code = WAN_CMD_OK;
			((unsigned char *)wan_udp_pkt->wan_udp_data )[0] =
			((unsigned char *)wan_udp_pkt->wan_udp_data )[1] =
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
			wan_udp_pkt->wan_udp_data_len = 2;
			mb->wan_data_len = 2;
			priv_area->router_up_time = tv.tv_sec - 
					priv_area->router_start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
					priv_area->router_up_time;	
			mb->wan_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
			wan_udp_pkt->wan_udp_data[0] = (card->wandev.state==WAN_CONNECTED)?1:0;	
			wan_udp_pkt->wan_udp_data[1] = wanpipe_get_atm_state(priv_area->sar_pvc);
			wan_udp_pkt->wan_udp_data_len = 2;
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
	        	if ((wan_udp_pkt->wan_udp_data[0] & ENABLE_READ_FT1_STATUS) ||  
				(wan_udp_pkt->wan_udp_data[0] & ENABLE_READ_FT1_OP_STATS)) {
					wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
					mb->wan_data_len = 1;
	      		if( wan_udp_pkt->wan_udp_data[0] == 0) {
	      	   	     	if( --rCount != 0) {
		  			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
					mb->wan_data_len = 1;
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				card->wandev.fe_iface.process_udp(
						&card->fe, 
						&wan_udp_pkt->wan_udp_cmd,
						&wan_udp_pkt->wan_udp_data[0]);
				if (wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE){
		    			wan_udp_pkt->wan_udp_data_len = sizeof(wan_femedia_t); 
					wan_udp_pkt->wan_udp_return_code = CMD_OK;
					wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
		   	wan_udp_pkt->wan_udp_atm_num_frames = card->wandev.config_id;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
		    	wan_udp_pkt->wan_udp_data[0] = WAN_LINUX_PLATFORM;
		    	wan_udp_pkt->wan_udp_return_code = CMD_OK;
		    	mb->wan_data_len = wan_udp_pkt->wan_udp_data_len = 1;
				card->devname, wan_udp_pkt->wan_udp_command);
			mb->wan_command = wan_udp_pkt->wan_udp_command;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
			if (mb->wan_data_len) {
				memcpy(&mb->wan_data, (unsigned char *) wan_udp_pkt->
							wan_udp_data, mb->wan_data_len);
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
				wan_udp_pkt->wan_udp_return_code = mb->wan_return_code;
	         	memcpy(&wan_udp_pkt->wan_udp_hdr.wan_cmd, mb, sizeof(wan_cmd_t)); 
			if (mb->wan_data_len) {
	         		memcpy(&wan_udp_pkt->wan_udp_data, &mb->wan_data, 
								mb->wan_data_len); 
	wan_udp_pkt->wan_ip_ttl= card->wandev.ttl; 
		wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	len = reply_udp(priv_area->udp_pkt_data, mb->wan_data_len);
     	if(priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK){
	   	if (!wan_test_bit(SEND_CRIT,&card->wandev.critical)) {
			if(!frmw_send(card, priv_area->udp_pkt_data, len, 0)) {
				++ chan->if_stats.tx_packets;
				chan->if_stats.tx_bytes += len;
  	    		memcpy(buf, priv_area->udp_pkt_data, len);
	    		new_skb->protocol = htons(ETH_P_IP);
            		new_skb->dev = dev;
					card->devname);
	wan_atomic_set(&priv_area->udp_pkt_len,0);
		return -1;
		return -1;
			return -1;
        if (card->wandev.state != state)
                                card->devname);
                                card->devname);
                                card->devname);
                card->wandev.state = state;
		WAN_LIST_FOREACH(devle, &card->wandev.dev_head, dev_link){
			priv_area->common.state = state;
			if (priv_area->sar_pvc){
					wanpipe_set_atm_state(priv_area->sar_pvc,ATM_CONNECTED);
					wanpipe_set_atm_state(priv_area->sar_pvc,ATM_DISCONNECTED);
			if (priv_area->common.usedby == API){
			card->devname);
			card->devname);
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
		int	err = -EINVAL;
			card->devname, 
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
					card->devname,
			return -EINVAL;
		int	err = -EINVAL;
			card->devname);
		if (card->wandev.fe_iface.config){
			err = card->wandev.fe_iface.config(&card->fe);
				card->devname);
			return -EINVAL;
				card->devname);
		return -EINVAL;	
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, 
				card->devname);
		card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
		card->comm_enabled=0;
		return -EINVAL;
	card->u.atm.state = WAN_CONNECTING;
		card->wandev.fe_iface.read_alarm(&card->fe, 1); 
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, 
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	if (!priv_area || (dev=priv_area->dev) == NULL){
	card = priv_area->card;
	if (wan_test_bit(PERI_CRIT,&card->wandev.critical)){
		wan_clear_bit(POLL_CRIT,&card->wandev.critical);
	switch (card->wandev.state){
		if (wan_test_bit(DYN_OPT_ON,&priv_area->interface_down) && 
		    !wan_test_bit(DEV_DOWN,  &priv_area->interface_down) &&		
		    dev->flags & IFF_UP){	
				card->devname,dev->name);
			change_dev_flags(dev,(dev->flags&~IFF_UP));
			set_bit(DEV_DOWN,&priv_area->interface_down);
			priv_area->route_status = NO_ROUTE;
		if (wan_test_bit(DYN_OPT_ON,&priv_area->interface_down) &&
		    wan_test_bit(DEV_DOWN,  &priv_area->interface_down) &&
		    !(dev->flags & IFF_UP)){
				card->devname,dev->name);
			change_dev_flags(dev,(dev->flags|IFF_UP));
			wan_clear_bit(DEV_DOWN,&priv_area->interface_down);
		if (priv_area->gateway && check_gateway)
	wan_clear_bit(POLL_CRIT,&card->wandev.critical);
	if ((priv_area = dev->priv)==NULL)
	card = priv_area->card;
	if (wan_test_and_set_bit(POLL_CRIT,&card->wandev.critical)){
	if (wan_test_bit(PERI_CRIT,&card->wandev.critical)){
	WAN_TASKQ_SCHEDULE((&priv_area->poll_task));
 * S514-1/2/3:		V32/RS232/FT1 Front End
 * S514-4/5/7/8:	56K/T1/E1 Front End
 * 1. Front End State (card->wandev.front_end_status)
 * 2. Protocol State  (card->wandev.state)
 * 3. Interface State (dev->flags & IFF_UP)
	 *        the card into re-sync mode */
	if (card->fe.fe_status != FE_CONNECTED){
	if (card->wandev.ignore_front_end_status == WANOPT_YES){
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (card->fe.fe_status == FE_CONNECTED){
		if (card->u.atm.state == WAN_CONNECTED){
 * board commands.  If the non-interrupt process
 * the interrupt and non-interrupt kernel 
	wan_spin_lock_irq(&card->wandev.lock, smp_flags);
        if (card->next){
        	wan_spin_lock(&card->next->wandev.lock);
        if (card->next){
        	wan_spin_unlock(&card->next->wandev.lock);
        wan_spin_unlock_irq(&card->wandev.lock, smp_flags);
#define PROC_CFG_FRM	"%-15s| %-12s|\n"
#define PROC_STAT_FRM	"%-15s| %-12s| %-14s|\n"
	card = priv_area->card;
			    PROC_CFG_FRM, priv_area->if_name, card->devname));
	card = priv_area->card;
			    priv_area->if_name, card->devname, STATE_DECODE(priv_area->common.state)));
#define PROC_DEV_FR_S_FRM	"%-20s| %-14s|\n"
#define PROC_DEV_FR_D_FRM	"%-20s| %-14d|\n"
	card = (sdla_t*)wandev->priv;
		 wandev->name));
		 "Comm Port", COMPORT_DECODE(card->wandev.comm_port)));
		 "Interface", INT_DECODE(wandev->interface)));
		 "Clocking", CLK_DECODE(wandev->clocking)));
		 "BaudRate",wandev->bps));
		 "MTU", wandev->mtu));
		 "UDP Port",  wandev->udp_port));
		 "TTL", wandev->ttl));
	card = (sdla_t*)wandev->priv;
			wandev->name, buffer);
#define PROC_IF_FR_S_FRM	"%-30s\t%-14s\n"
#define PROC_IF_FR_D_FRM	"%-30s\t%-14d\n"
#define PROC_IF_FR_L_FRM	"%-30s\t%-14ld\n"
	private_area_t* 	priv_area = dev->priv;
	sdla_t*			card = priv_area->card;
	if (!offs && card->wandev.update) {
		rslt = card->wandev.update(&card->wandev);
			case -EAGAIN:
	if (dev == NULL || dev->priv == NULL)
	priv_area = (private_area_t*)dev->priv;
			priv_area->if_name, buffer);
	if (card->wandev.fe_iface.update_alarm_info){
		m->count = 
				&card->wandev, 
				(&card->fe, m, stop_cnt)); 
	if (card->wandev.fe_iface.update_pmon_info){
		m->count = 
				&card->wandev, 
				(&card->fe, m, stop_cnt)); 
	return m->count;
./sdla_atm.c
* Copyright:	(c) 2003-2006 Sangoma Technologies Inc.
	return -EFAULT;
	return -EFAULT;
		return -EINVAL; 
		return -EINVAL;
		return -EINVAL; 
	wp_cdev_global_cnt--;
		return -EINVAL;
		return -EINVAL;
		return -EINVAL;
		return -EINVAL;
		return -EINVAL;
		return -EINVAL;
./sdla_cdev.c
 *  o initialize protocol-specific fields of the adapter data space.
	if (conf->config_id != WANCONFIG_SDLC) {
				  card->devname, conf->config_id);
		return -EINVAL;
	if (conf->comm_port == WANOPT_PRI){
		card->u.sdlc.comm_port = conf->comm_port;
		printk(KERN_INFO "%s: ERROR - Invalid Port Selected!\n",
                			card->wandev.name);
		return -EINVAL;
	/* Initialize protocol-specific fields */
	card->mbox_off = BASE_ADDR_OF_MB_STRUCTS;
	card->rxmb_off = 0xE230;
	mb = &card->wan_mbox;
	mb1 = &card->wan_mbox;
	if (!card->configured){
        if (IS_TE1_MEDIA(&conf->fe_cfg) || IS_56K_MEDIA(&conf->fe_cfg)) {
				card->devname);
		return -EINVAL;
		return -EIO;
			card->devname,u.str); 
	card->isr			= &wp_sdlc_isr;
	card->poll			= NULL;
	card->exec			= NULL;
	card->wandev.update		= &update;
 	card->wandev.new_if		= &new_if;
	card->wandev.del_if		= &del_if;
	card->wandev.udp_port   	= conf->udp_port;
	card->wandev.new_if_cnt = 0;
	card->wandev.get_config_info 	= &chdlc_get_config_info;
	card->wandev.get_status_info 	= &chdlc_get_status_info;
	card->wandev.set_dev_config    	= &chdlc_set_dev_config;
	card->wandev.set_if_info     	= &chdlc_set_if_info;
	card->wandev.ttl = conf->ttl;
	card->wandev.electrical_interface = conf->electrical_interface; 
	card->wandev.clocking = conf->clocking;
	port_num = card->u.sdlc.comm_port;
	if(card->wandev.clocking) {
		if(conf->bps > MAX_PERMITTED_BAUD_RATE) {
			conf->bps = MAX_PERMITTED_BAUD_RATE;
				card->wandev.name);
				card->wandev.name, MAX_PERMITTED_BAUD_RATE);
		card->wandev.bps = conf->bps;
        	card->wandev.bps = 0;
	card->wandev.mtu = (conf->mtu >= MIN_PERMITTED_I_FIELD_LENGTH) ?
			    wp_min(conf->mtu, MAX_PERMITTED_I_FIELD_LENGTH) :
	card->flags_off = ADDR_INTERRUPT_REPORT_INTERFACE_BYTE;
    	card->intr_type_off = 
			card->flags_off +
	card->intr_perm_off = 
			card->flags_off +
	card->wandev.state = WAN_DUALPORT;
	card->u.sdlc.state = WAN_DISCONNECTED;
	if (card->u.sdlc.comm_enabled){
	memcpy(&card->wandev.sdlc_cfg,&conf->u.sdlc,sizeof(wan_sdlc_conf_t));
				card->devname,mb->wan_data_len);
		return -EINVAL;
	if (!card->wandev.piggyback){
		if(err || (card->timer_int_enabled < MAX_INTR_TEST_COUNTER)) { 
					card->devname, card->timer_int_enabled);
					card->devname);
			return  -EIO;
				card->devname, card->timer_int_enabled);
	sdla_t* card = wandev->priv;
	if((wandev == NULL) || (wandev->priv == NULL))
		return -EFAULT;
	if(wandev->state == WAN_UNCONFIGURED)
		return -ENODEV;
        if(!card->flags_off)
                return -ENODEV;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -ENODEV;
	if((sdlc_priv_area=dev->priv) == NULL)
		return -ENODEV;
       	if(sdlc_priv_area->update_comms_stats){
		return -EAGAIN;
	sdlc_priv_area->update_comms_stats = 2;
	card->hw_iface.set_bit(card->hw, card->intr_perm_off, INTERRUPT_ON_TIMER);
	sdlc_priv_area->timer_int_enabled = TMR_INT_ENABLED_UPDATE;
		if(sdlc_priv_area->update_comms_stats == 0)
                if ((jiffies - timeout) > (1 * HZ)){
    			sdlc_priv_area->update_comms_stats = 0;
 			sdlc_priv_area->timer_int_enabled &=
 			return -EAGAIN;
 * o parse media- and hardware-specific configuration
	sdla_t* card = wandev->priv;
	if ((conf->name[0] == '\0') || (strlen(conf->name) > WAN_IFNAME_SZ)) {
			card->devname);
		return -EINVAL;
		return -ENOMEM;
	sdlc_priv_area->card = card; 
	strcpy(card->u.sdlc.if_name, conf->name);
	sdlc_priv_area->common.sk = NULL;
	sdlc_priv_area->common.state = WAN_CONNECTING;
	sdlc_priv_area->common.dev = dev;
	if(card->wandev.new_if_cnt > 0) {
		err = -EEXIST;
	card->wandev.new_if_cnt++;
	sdlc_priv_area->TracingEnabled = 0;
		wandev->name);
	if(strcmp(conf->usedby, "STACK") == 0) {
			wandev->name);
		card->u.sdlc.usedby = STACK;
		sdlc_priv_area->common.usedby=STACK;
			wandev->name);
		card->u.sdlc.usedby = API;
		sdlc_priv_area->common.usedby =API;
	sdlc_priv_area->mc = conf->mc;
	dev->init = &if_init;
	dev->priv = sdlc_priv_area;
					   &sdlc_priv_area->dent, 
					   card->u.sdlc.if_name, 
			card->devname, card->u.sdlc.if_name);
	dev->priv=NULL;
	sdlc_private_area_t *sdlc_priv_area = dev->priv;
	sdla_t *card = sdlc_priv_area->card;
	//wanrouter_proc_delete_interface(wandev, card->u.sdlc.if_name);
	wan_spin_lock_irq(&wandev->lock,&smp_lock);
	dev->do_ioctl = NULL;
	if (card->u.sdlc.comm_enabled){
	wan_spin_unlock_irq(&wandev->lock,&smp_lock);
 *	if_do_ioctl - Ioctl handler for fr
	sdlc_private_area_t* chan= (sdlc_private_area_t*)dev->priv;
		return -ENODEV;
	card=chan->card;
	mb=&card->wan_mbox;
	if (chan->common.usedby == STACK){
		//if (ifr->ifr_flags != STACK_IF_REQ){
		//			card->devname,ifr->ifr_flags,STACK_IF_REQ);
		//	return -EINVAL;
		err = chan->common.state;
			err= -EINVAL;
		spin_lock_irqsave(&card->wandev.lock,smp_flags);
		err=wan_bind_api_to_svc(chan,ifr->ifr_data);
		spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
			err= -EINVAL;
		spin_lock_irqsave(&card->wandev.lock,smp_flags);
		err=wan_unbind_api_from_svc(chan,ifr->ifr_data);
		spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
		if (atomic_read(&chan->udp_pkt_len) != 0){
			return -EBUSY;
		atomic_set(&chan->udp_pkt_len,MAX_LGTH_UDP_MGNT_PKT);
		if (test_bit(0,&card->in_isr)){
			atomic_set(&chan->udp_pkt_len,0);
			return -EBUSY;
		wan_udp_pkt=(wan_udp_pkt_t*)chan->udp_pkt_data;
		if (copy_from_user(&wan_udp_pkt->wan_udp_hdr,
				   ifr->ifr_data,
			atomic_set(&chan->udp_pkt_len,0);
			return -EFAULT;
		spin_lock_irqsave(&card->wandev.lock, smp_flags);
		if (test_bit(0,&card->in_isr)) {
					card->devname,dev->name);
			atomic_set(&chan->udp_pkt_len,0);
			spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
			return -EBUSY;
		spin_unlock_irqrestore(&card->wandev.lock, smp_flags);
		if (atomic_read(&chan->udp_pkt_len) > sizeof(wan_udp_pkt_t)){
					card->devname,atomic_read(&chan->udp_pkt_len));
			atomic_set(&chan->udp_pkt_len,0);
			return -EINVAL;
		if (copy_to_user(ifr->ifr_data,&wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
			atomic_set(&chan->udp_pkt_len,0);
			return -EFAULT;
		atomic_set(&chan->udp_pkt_len,0);
		usr_mb=(wan_mbox_t*)ifr->ifr_ifru.ifru_data;
			card->devname, cmd);
			return -EINVAL;
			memcpy(&mb->wan_command,&usr_mb->wan_command,sizeof(wan_cmd_t)-1);
			if (copy_from_user(&mb->wan_command, &usr_mb->wan_command,sizeof(wan_cmd_t)-1)){
				printk(KERN_INFO "%s: SDLC Cmd: Failed to copy mb \n",card->devname);
				err = -EFAULT;
		if (mb->wan_data_len){
				memcpy(&mb->wan_data[0], &usr_mb->wan_data[0] ,mb->wan_data_len);
				if (copy_from_user(&mb->wan_data[0], &usr_mb->wan_data[0] ,mb->wan_data_len)){
							card->devname, mb->wan_data_len);
					err = -EFAULT;
		spin_lock_irqsave(&card->wandev.lock,smp_flags);
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
			spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
		spin_unlock_irqrestore(&card->wandev.lock,smp_flags);
				card->devname,
				mb->wan_command,mb->wan_return_code);
			memcpy(&usr_mb->wan_command, &mb->wan_command,sizeof(wan_cmd_t)-1);
			if (copy_to_user(&usr_mb->wan_command, &mb->wan_command,sizeof(wan_cmd_t)-1)){
				err= -EFAULT;
		if (mb->wan_data_len) {
				memcpy(&usr_mb->wan_data[0], &mb->wan_data[0], mb->wan_data_len);
				if (copy_to_user(&usr_mb->wan_data[0], &mb->wan_data[0], mb->wan_data_len)){
					err= -EFAULT;
		return -EOPNOTSUPP;
	sdlc_private_area_t* sdlc_priv_area = dev->priv;
	sdla_t* card = sdlc_priv_area->card;
	wan_device_t* wandev = &card->wandev;
	dev->open		= &if_open;
	dev->stop		= &if_close;
	dev->hard_start_xmit	= &if_send;
	dev->get_stats		= &if_stats;
	dev->tx_timeout		= NULL;
	dev->watchdog_timeo	= 0;
	dev->do_ioctl		= if_do_ioctl;
	dev->type		= ARPHRD_SDLC; /* This breaks the tcpdump */
	dev->mtu	= card->wandev.mtu+sizeof(wan_api_hdr_t);
	dev->irq	= wandev->irq;
	dev->dma	= wandev->dma;
	dev->base_addr	= wandev->ioport;
	card->hw_iface.getcfg(card->hw, SDLA_MEMBASE, &dev->mem_start); //ALEX_TODAY wandev->maddr;
	card->hw_iface.getcfg(card->hw, SDLA_MEMEND, &dev->mem_end); //ALEX_TODAY wandev->maddr + wandev->msize - 1;
        dev->tx_queue_len = 100;
	sdlc_private_area_t* sdlc_priv_area = dev->priv;
	sdla_t* card = sdlc_priv_area->card;
		return -EBUSY;
	sdlc_priv_area->router_start_time = tv.tv_sec;
	if (sdlc_priv_area->common.usedby==API){
	sdlc_private_area_t* sdlc_priv_area = dev->priv;
	sdla_t* card = sdlc_priv_area->card;
	dev->start=0;
 * o set tbusy flag (marks start of the transmission) to block a timer-based
 *		non-0	packet may be re-transmitted (tbusy must be set)
	sdlc_private_area_t *sdlc_priv_area = dev->priv;
	sdla_t *card = sdlc_priv_area->card;
		 * tx-done interrupt.
			card->devname, dev->name);
	if (dev->tbusy){
		 * kick start the device by making dev->tbusy = 0.  We expect 
		if((jiffies - sdlc_priv_area->tick_counter) < (5 * HZ)) {
		++card->wandev.stats.collisions;
		printk (KERN_INFO "%s: Transmit timed out on %s\n", card->devname,dev->name);
	sdlc_priv_area->tick_counter=jiffies;
    	if (test_and_set_bit(SEND_CRIT, (void*)&card->wandev.critical)){
					card->wandev.name,card->wandev.critical);
                ++card->wandev.stats.tx_dropped;
	if (card->wandev.state != WAN_CONNECTED){
		++card->wandev.stats.tx_dropped;
	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
	err=sdlc_send(card, skb->data, skb->len);
	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
		++card->wandev.stats.tx_packets;
       		card->wandev.stats.tx_bytes += skb->len;
		dev->trans_start = jiffies;
		if (test_bit(0,&sdlc_priv_area->trace_state)){
			DEBUG_EVENT("%s:%s: OUTPUT:\n",card->devname,dev->name);
			for (i=0; i < skb->len; i++){		
				printk("%02X ",skb->data[i]);
	clear_bit(SEND_CRIT, (void*)&card->wandev.critical);
 * Get ethernet-style interface statistics.
         * dev->priv pointer. This function, gets
	if ((sdlc_priv_area=dev->priv) == NULL)
	my_card = sdlc_priv_area->card;
	return &my_card->wandev.stats; 
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_CODE_VERSION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		len = mb->wan_data_len;
		memcpy(str, mb->wan_data, len);
/*-----------------------------------------------------------------------------
	wan_mbox_t *mb = &card->wan_mbox;
		mb->wan_data_len = data_length;  
		memcpy(mb->wan_data, data, data_length);
		mb->wan_command = SET_SDLC_CONFIGURATION;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	}while((err!=COMMAND_OK) && --retry);
/*-----------------------------------------------------------------------------
	wan_mbox_t *mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_SDLC_CONFIGURATION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
 * Set interrupt mode -- HDLC Version.
	wan_mbox_t* mb = &card->wan_mbox;
		 (SDLC_INT_TRIGGERS_STRUCT *)mb->wan_data;
	int_data->CHDLC_interrupt_triggers 	= mode;
	int_data->IRQ				= card->wandev.irq; // ALEX_TODAY card->hw.irq;
	int_data->interrupt_timer               = 1;
	int_data->misc_interrupt_bits		= 0;
	mb->wan_data_len = sizeof(SDLC_INT_TRIGGERS_STRUCT);
	mb->wan_command = SET_INTERRUPT_TRIGGERS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = ENABLE_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
		card->u.sdlc.comm_enabled=1;
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = DISABLE_COMMUNICATIONS;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_COMMS_ERR_STATISTICS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
        mb->wan_data_len = 0;
        mb->wan_command = READ_OPERATIONAL_STATISTICS;
        err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
        wan_mbox_t* mb = &card->wan_mbox;
	if(sdlc_priv_area->update_comms_stats == 2) {
		err_stats = (COMMS_ERROR_STATS_STRUCT *)mb->wan_data;
		card->wandev.stats.rx_over_errors = 
				err_stats->Rx_overrun_err_cnt;
		card->wandev.stats.rx_crc_errors = 
				err_stats->CRC_err_cnt;
		card->wandev.stats.rx_frame_errors = 
				err_stats->Rx_abort_cnt;
		card->wandev.stats.rx_fifo_errors = 
				err_stats->Rx_frm_lgth_err_cnt; 
		card->wandev.stats.rx_missed_errors =
				card->wandev.stats.rx_fifo_errors;
		card->wandev.stats.tx_aborted_errors =
				err_stats->msd_Tx_und_int_cnt;
		op_stats = (SDLC_OPERATIONAL_STATS_STRUCT *)mb->wan_data;
		card->wandev.stats.rx_length_errors =
			(op_stats->no_short_frames_Rx +
			op_stats->no_short_frames_Rx);
 *	Return:	0 - o.k.
 *		1 - no transmit buffers available
	wan_mbox_t *mb = &card->wan_mbox;
		mb->wan_command=LIST_STATIONS_WITH_I_FRMS_AVAILABLE;
		mb->wan_return_code=0;	
		mb->wan_data_len=0;
		err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	}while (err && --retry);
	wan_mbox_t *mb = &card->wan_mbox;
		mb->wan_command=SDLC_READ;
		mb->wan_return_code=0;	
		mb->wan_data_len=0;
		mb->wan_sdlc_address=station;
		err = card->hw_iface.cmd(card->hw, card->rxmb_off, mb);
	}while (err && --retry);
 *	Return:	0 - o.k.
 *		1 - no transmit buffers available
	wan_mbox_t *mb = &card->wan_mbox;
	if (mb->wan_opp_flag){
				card->devname);
	len -= sizeof(wan_api_hdr_t);
	mb->wan_command              =SDLC_WRITE;
	mb->wan_return_code          =0;	
	mb->wan_data_len 	     = len;
	mb->wan_sdlc_address 	     = wan_api->wan_api_sdlc_station;
	mb->wan_sdlc_poll_interval   = wan_api->wan_api_sdlc_poll_interval;
	mb->wan_sdlc_pf	     	     = wan_api->wan_api_sdlc_pf;
	mb->wan_sdlc_general_mb_byte = wan_api->wan_api_sdlc_general_mb_byte;
	memcpy(mb->wan_data,wan_api->data,len);
	return card->hw_iface.cmd(card->hw, card->mbox_off, mb);
 *	This routine is called whenever firmware command returns non-zero
	unsigned cmd = mb->wan_command;
			card->devname, cmd);
				card->devname);
			card->devname, cmd, err);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	card->in_isr = 1;
	card->hw_iface.peek(card->hw, card->flags_off, &flags, sizeof(flags));
	if ((!dev || !dev->priv) && flags.interrupt_type != COMMAND_COMPLETE_INTERRUPT_PENDING){
	if(test_bit(PERI_CRIT, (void*)&card->wandev.critical)) {
	if(card->type != SDLA_S514) {
		if(test_bit(0, (void*)&card->wandev.critical)) {
				card->devname, card->wandev.critical);
			card->hw_iface.clear_bit(card->hw, card->intr_perm_off, INTERRUPT_ON_TX_FRAME);
			++ card->timer_int_enabled;
				card->devname,
	card->hw_iface.poke_byte(card->hw, card->intr_type_off, 0x00);
	card->in_isr = 0;
	wan_mbox_t *mb    = &card->wan_mbox;
	wan_mbox_t *rxmb = &card->wan_rxmb;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (!dev->start){ 
	chan = dev->priv;
	station_cnt=mb->wan_data_len;
	memcpy(&station_list,mb->wan_data,station_cnt);
					card->devname, mb->wan_data[i]);
		card->hw_iface.peek(card->hw, card->rxmb_off, rxmb, sizeof(wan_cmd_t));
		len=rxmb->wan_data_len;
			card->hw_iface.peek(card->hw, 
					    card->rxmb_off+offsetof(wan_mbox_t, wan_data), 
					    rxmb->wan_data, len);
		if (len > card->wandev.mtu){
					card->devname,len,card->wandev.mtu);
							card->devname);
			++card->wandev.stats.rx_dropped;
		memcpy(buf,rxmb->wan_data,len);
		skb->protocol = htons(ETH_P_IP);
		card->wandev.stats.rx_packets++;
		card->wandev.stats.rx_bytes += skb->len;
		udp_type = wan_udp_pkt_type(card,skb->data);
		if (chan->common.usedby == API){
			api_hdr = (wan_api_hdr_t*)&skb->data[0];
			api_hdr->wan_apihdr_sdlc_station	=mb->wan_sdlc_address;
			api_hdr->wan_apihdr_sdlc_pf		=mb->wan_sdlc_pf;
			api_hdr->wan_apihdr_sdlc_poll_interval	=mb->wan_sdlc_poll_interval;
			api_hdr->wan_apihdr_sdlc_general_mb_byte=mb->wan_sdlc_general_mb_byte;
			skb->pkt_type = WAN_PACKET_DATA;
			if (chan->common.sk == NULL){
				++card->wandev.stats.rx_dropped;
				card->wandev.stats.rx_packets --;
				card->wandev.stats.rx_bytes -= skb->len;
				++card->wandev.stats.rx_dropped;
				card->wandev.stats.rx_packets --;
				card->wandev.stats.rx_bytes -= skb->len;
		}else if (chan->common.usedby == STACK) {
			api_hdr = (wan_api_hdr_t*)&skb->data[0];
			api_hdr->wan_apihdr_sdlc_station=mb->wan_data[i];
			skb->pkt_type = WAN_PACKET_DATA;
			if (!test_bit(REG_CRIT,&card->wandev.critical) ||
			    !chan->wp_sdlc_register.sdlc_stack_rx){
				++card->wandev.stats.rx_dropped;
				card->wandev.stats.rx_packets --;
				card->wandev.stats.rx_bytes -= skb->len;
			skb->dev = dev;
			if (chan->wp_sdlc_register.sdlc_stack_rx(skb) != 0){
				++card->wandev.stats.rx_dropped;
				card->wandev.stats.rx_packets --;
				card->wandev.stats.rx_bytes -= skb->len;
			skb->dev = dev;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if ((sdlc_priv_area=dev->priv) == NULL){
	if (sdlc_priv_area->common.usedby == API){
 *    2) Reading board-level statistics for updating the proc file system.
        dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head)); 
        sdlc_priv_area = dev->priv;
	if(sdlc_priv_area->timer_int_enabled & TMR_INT_ENABLED_UPDATE){
                        card->wandev.fe_iface.read_alarm(&card->fe, 0);
                        card->wandev.fe_iface.read_pmon(&card->fe, 0);
                        card->wandev.fe_iface.read_alarm(&card->fe, 1);
                if(!(-- sdlc_priv_area->update_comms_stats)) {
			sdlc_priv_area->timer_int_enabled &= 
        if(!sdlc_priv_area->timer_int_enabled) {
		card->hw_iface.clear_bit(card->hw, card->intr_perm_off, INTERRUPT_ON_TIMER);
/*------------------------------------------------------------------------------
	- set_sdlc_config() used to set configuration options on the board
------------------------------------------------------------------------------*/
	if(card->wandev.clocking){
		cfg.baud_rate = card->wandev.bps;
	cfg.station_configuration=card->wandev.sdlc_cfg.station_configuration;		
	if (card->wandev.sdlc_cfg.max_I_field_length){
		cfg.max_I_field_length	= card->wandev.mtu = card->wandev.sdlc_cfg.max_I_field_length;
		cfg.max_I_field_length	= card->wandev.mtu;
	cfg.general_operational_config_bits=card->wandev.sdlc_cfg.general_operational_config_bits;
	if (card->wandev.electrical_interface != WANOPT_RS232){
	cfg.protocol_config_bits=card->wandev.sdlc_cfg.protocol_config_bits;
	cfg.exception_condition_reporting_config=card->wandev.sdlc_cfg.exception_condition_reporting_config;
	cfg.modem_config_bits=card->wandev.sdlc_cfg.modem_config_bits;
	cfg.statistics_format=card->wandev.sdlc_cfg.statistics_format;
	cfg.pri_station_slow_poll_interval=card->wandev.sdlc_cfg.pri_station_slow_poll_interval;
	cfg.permitted_sec_station_response_TO=card->wandev.sdlc_cfg.permitted_sec_station_response_TO;
	cfg.no_consec_sec_TOs_in_NRM_before_SNRM_issued=card->wandev.sdlc_cfg.no_consec_sec_TOs_in_NRM_before_SNRM_issued;
	cfg.max_lgth_I_fld_pri_XID_frame=card->wandev.sdlc_cfg.max_lgth_I_fld_pri_XID_frame;		
	cfg.opening_flag_bit_delay_count=card->wandev.sdlc_cfg.opening_flag_bit_delay_count;		
	cfg.RTS_bit_delay_count=card->wandev.sdlc_cfg.RTS_bit_delay_count;
	cfg.CTS_timeout_1000ths_sec=card->wandev.sdlc_cfg.CTS_timeout_1000ths_sec;	
	cfg.SDLA_configuration=card->wandev.sdlc_cfg.SDLA_configuration;			
	DEBUG_EVENT("%s: SDLC Config:\n",card->devname);
			card->devname,cfg.station_configuration);		
			card->devname,cfg.baud_rate);
			card->devname,cfg.max_I_field_length);
			card->devname,cfg.general_operational_config_bits);
			card->devname,cfg.protocol_config_bits);
			card->devname,cfg.exception_condition_reporting_config);
			card->devname,cfg.modem_config_bits);
			card->devname,cfg.statistics_format);
			card->devname,cfg.pri_station_slow_poll_interval);
			card->devname,cfg.permitted_sec_station_response_TO);
			card->devname,cfg.no_consec_sec_TOs_in_NRM_before_SNRM_issued);
			card->devname,cfg.max_lgth_I_fld_pri_XID_frame);
			card->devname,cfg.opening_flag_bit_delay_count);
			card->devname,cfg.RTS_bit_delay_count);
			card->devname,cfg.CTS_timeout_1000ths_sec);
			card->devname,cfg.SDLA_configuration);
		INTERRUPT_INFORMATION_STRUCT *flags = card->u.sdlc.flags;
		(FRONT_END_STATUS_STRUCT *)&flags->FT1_info_struct.parallel_port_A_input;
		card->wandev.RR8_reg_56k = 
			FE_status->FE_U.stat_56k.RR8_56k;	
		card->wandev.RRA_reg_56k = 
			FE_status->FE_U.stat_56k.RRA_56k;	
		card->wandev.RRC_reg_56k = 
			FE_status->FE_U.stat_56k.RRC_56k;	
                card->wandev.fe_iface.read_alarm(&card->fe, 0);
		card->wandev.fe_iface.isr(&card->fe);
		card->devname);
	switch(mb->wan_data[0] & (DCD_HIGH | CTS_HIGH)) {
			printk(KERN_INFO "%s: DCD high, CTS low\n",card->devname);
			printk(KERN_INFO "%s: DCD low, CTS high\n",card->devname);
			printk(KERN_INFO "%s: DCD high, CTS high\n",card->devname);
			printk(KERN_INFO "%s: DCD low, CTS low\n",card->devname);
	SDLC_STATE_STRUCT *sdlc_state=(SDLC_STATE_STRUCT *)mb->wan_data;
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if ((sdlc_chan=dev->priv) == NULL)
	for (i=0;i<mb->wan_data_len;i+=sizeof(SDLC_STATE_STRUCT)){
				card->devname,
				sdlc_state->station,
				sdlc_state->state?"Connected (NRM)":"Disconnected (NDM)");
	if (sdlc_chan->common.usedby != WANPIPE){
	wan_mbox_t* mb = &card->wan_mbox;
	mb->wan_data_len = 0;
	mb->wan_command = READ_EXCEPTION_CONDITION;
	err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
					card->devname,err);
	wan_mbox_t *mb = &card->wan_mbox;
	wan_udp_pkt = (wan_udp_pkt_t *) sdlc_priv_area->udp_pkt_data;
	if(sdlc_priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK) {
		switch(wan_udp_pkt->wan_udp_command) {
		wan_udp_pkt->wan_udp_data_len = 0;
		wan_udp_pkt->wan_udp_return_code = 0xCD;
			card->devname,wan_udp_pkt->wan_udp_command);
		switch(wan_udp_pkt->wan_udp_command) {
			sdlc_priv_area->router_up_time = tv.tv_sec - 
					sdlc_priv_area->router_start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
					sdlc_priv_area->router_up_time;	
			mb->wan_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_return_code = COMMAND_OK;
			mb->wan_command = wan_udp_pkt->wan_udp_command;
			mb->wan_data_len = wan_udp_pkt->wan_udp_data_len;
			if (mb->wan_data_len) {
				memcpy(&mb->wan_data, (unsigned char *) wan_udp_pkt->
							wan_udp_data, mb->wan_data_len);
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	         	memcpy(&wan_udp_pkt->wan_udp_hdr.wan_cmd, mb, sizeof(wan_cmd_t)); 
			if (mb->wan_data_len) {
	         		memcpy(&wan_udp_pkt->wan_udp_data, &mb->wan_data, 
								mb->wan_data_len); 
	wan_udp_pkt->wan_ip_ttl = card->wandev.ttl; 
	len = wan_reply_udp(card, sdlc_priv_area->udp_pkt_data, mb->wan_data_len);
     	if(sdlc_priv_area->udp_pkt_src == UDP_PKT_FRM_NETWORK) {
		if(!sdlc_send(card, sdlc_priv_area->udp_pkt_data, len)) {
			++ card->wandev.stats.tx_packets;
			card->wandev.stats.tx_bytes += len;
  	    		memcpy(buf, sdlc_priv_area->udp_pkt_data, len);
	    		new_skb->protocol = htons(ETH_P_IP);
            		new_skb->dev = dev;
					card->devname);
	sdlc_priv_area->udp_pkt_lgth = 0;
	wan_mbox_t* mb = &card->wan_mbox;
	card->timer_int_enabled = 0;
			mb->wan_data_len  = 0;
			mb->wan_command = READ_CODE_VERSION;
			err = card->hw_iface.cmd(card->hw, card->mbox_off, mb);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (!dev || !dev->priv){
	sdlc_priv_area=dev->priv;
        if (card->u.sdlc.state != state)
                                card->devname);
                                card->devname);
                                card->devname);
                card->wandev.state = card->u.sdlc.state = state;
		sdlc_priv_area->common.state = state;
	wan_mbox_t *mb=&card->wan_mbox;
				card->devname);
		return -EINVAL;	
	card->hw_iface.clear_bit(card->hw, card->intr_perm_off, (INTERRUPT_ON_TIMER));
	while ((jiffies-timeout) < 2*HZ){
					card->devname);
		card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
		card->u.sdlc.comm_enabled=0;
		return -EINVAL;
			(SDLC_CONFIGURATION_STRUCT *)mb->wan_data;
				card->devname,sdla_cfg->baud_rate);
				card->devname);
		card->hw_iface.poke_byte(card->hw, card->intr_perm_off, 0x00);
		return -EINVAL;
#define PROC_CFG_FRM	"%-15s| %-12s|\n"
#define PROC_STAT_FRM	"%-15s| %-12s| %-14s|\n"
		return m->count;
	card = sdlc_priv_area->card;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		PROC_CFG_FRM, card->u.sdlc.if_name, card->devname);
	return m->count;
		return m->count;
	card = sdlc_priv_area->card;
	if ((m->from == 0 && m->count == 0) || (m->from && m->from == *stop_cnt)){
		card->u.sdlc.if_name, card->devname, STATE_DECODE(sdlc_priv_area->common.state));
	return m->count;
#define PROC_DEV_FR_S_FRM	"%-20s| %-14s|\n"
#define PROC_DEV_FR_D_FRM	"%-20s| %-14d|\n"
	card = (sdla_t*)wandev->priv;
			wandev->name, buffer);
#define PROC_IF_FR_S_FRM	"%-30s\t%-14s\n"
#define PROC_IF_FR_D_FRM	"%-30s\t%-14d\n"
#define PROC_IF_FR_L_FRM	"%-30s\t%-14ld\n"
	if (dev == NULL || dev->priv == NULL)
	sdlc_priv_area = (sdlc_private_area_t*)dev->priv;
	if (sdlc_priv_area->card == NULL)
	card = sdlc_priv_area->card;
			card->u.sdlc.if_name, buffer);
		return -ENODEV;
	if (dev->type != ARPHRD_SDLC){
				card->devname,dev->name,dev->type);
		return -EINVAL;
	if ((chan=dev->priv) == NULL){
		return -ENODEV;
	if ((card=chan->card) == NULL){
		return -ENODEV;	
	dev1 = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -EINVAL;
	if (chan->common.usedby != STACK){
				card->devname,dev->name);
		return -EINVAL;
	if (test_bit(REG_CRIT,&card->wandev.critical)){
				card->devname,dev->name);
		return -EBUSY;
	memcpy(&chan->wp_sdlc_register,wp_sdlc_reg,sizeof(wp_sdlc_reg_t));
	set_bit(REG_CRIT,&card->wandev.critical);
				card->devname,dev->name);
		return -ENODEV;
	if ((chan=dev->priv) == NULL){
		return -ENODEV;
	if ((card=chan->card) == NULL){
		return -ENODEV;	
	dev1 = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
		return -EINVAL;
	if (chan->common.usedby != STACK){
		printk(KERN_INFO "%s: Device %s doesn't support un-registration!\n",
				card->devname,dev->name);
		return -EINVAL;
	if (test_bit(REG_CRIT,&card->wandev.critical)){
		clear_bit(REG_CRIT,&card->wandev.critical);
				card->devname,dev->name);
	dev = WAN_DEVLE2DEV(WAN_LIST_FIRST(&card->wandev.dev_head));
	if (chan->common.usedby == WANPIPE){
	skb=dev_alloc_skb(sizeof(wan_api_hdr_t)+mb->wan_data_len+10);
				card->devname);
	wan_api=(wan_api_t *)skb_put(skb,sizeof(wan_api_hdr_t)+mb->wan_data_len);
	wan_api->wan_api_pktType = mb->wan_command;
	wan_api->wan_api_length=mb->wan_data_len;
	wan_api->wan_api_sdlc_station = 0;
	memcpy(wan_api->data,mb->wan_data,mb->wan_data_len);
	skb->dev=dev;
	skb->pkt_type = WAN_PACKET_CMD;	
	if (chan->common.usedby == API){
		if (chan->common.sk == NULL){
			++card->wandev.stats.rx_dropped;
			++card->wandev.stats.rx_dropped;
	}else if (chan->common.usedby == STACK) {
		if (!test_bit(REG_CRIT,&card->wandev.critical) ||
		    !chan->wp_sdlc_register.sdlc_stack_rx){
			++card->wandev.stats.rx_dropped;
		skb->dev = dev;
		if (chan->wp_sdlc_register.sdlc_stack_rx(skb) != 0){
			++card->wandev.stats.rx_dropped;
./sdla_sdlc.c
