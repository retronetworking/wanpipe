47a48,54
> #if !defined(__WINDOWS__)
> #if 1
> #define AFT_FUNC_DEBUG()
> #else
> #define AFT_FUNC_DEBUG()  DEBUG_EVENT("%s:%d\n",__FUNCTION__,__LINE__)
> #endif
> #endif
58a66,71
> #if 1
> # define AFT_API_SUPPORT
> #else
> # undef AFT_API_SUPPORT
> #endif
> 
65c78
< #define AUDIO_RINGCHECK
---
> #undef AUDIO_RINGCHECK
82c95
< #define WP_RM_POLL_TIMER	1000
---
> #define WP_RM_POLL_TIMER	100
92,93d104
< 	//WP_RM_POLL_RING,
< 	//WP_RM_POLL_RING_STOP,
109c120,122
< 	WP_RM_POLL_RING_DETECT
---
> 	WP_RM_POLL_RING_DETECT,
> 	WP_RM_POLL_READ,
> 	WP_RM_POLL_WRITE
111a125,150
> #define WP_RM_POLL_DECODE(type)				\
> 	((type) == WP_RM_POLL_TONE_DIAL) ? "Tone (dial)":		\
> 	((type) == WP_RM_POLL_TONE_BUSY) ? "Tone (busy)":		\
> 	((type) == WP_RM_POLL_TONE_RING) ? "Tone (ring)":		\
> 	((type) == WP_RM_POLL_TONE_CONGESTION) ? "Tone (congestion)":	\
> 	((type) == WP_RM_POLL_TONE_DONE) ? "Tone (done)":\
> 	((type) == WP_RM_POLL_TDMV) ? "TDMV":\
> 	((type) == WP_RM_POLL_EVENT) ? "RM-Event":\
> 	((type) == WP_RM_POLL_INIT) ? "Init":\
> 	((type) == WP_RM_POLL_POWER) ? "Power":\
> 	((type) == WP_RM_POLL_LC) ? "Loop closure":\
> 	((type) == WP_RM_POLL_RING_TRIP) ? "Ring Trip":\
> 	((type) == WP_RM_POLL_DTMF) ? "DTMF":\
> 	((type) == WP_RM_POLL_RING) ? "Ring":\
> 	((type) == WP_RM_POLL_TONE) ? "Tone":\
> 	((type) == WP_RM_POLL_TXSIG_KEWL) ? "TX Sig KEWL":\
> 	((type) == WP_RM_POLL_TXSIG_START) ? "TX Sig Start":\
> 	((type) == WP_RM_POLL_TXSIG_OFFHOOK) ? "TX Sig Off-hook":\
> 	((type) == WP_RM_POLL_TXSIG_ONHOOK) ? "TX Sig On-hook":\
> 	((type) == WP_RM_POLL_ONHOOKTRANSFER) ? "On-hook transfer":\
> 	((type) == WP_RM_POLL_SETPOLARITY) ? "Set polarity":\
> 	((type) == WP_RM_POLL_RING_DETECT) ? "Ring Detect":\
> 	((type) == WP_RM_POLL_READ) ? "FE Read":\
> 	((type) == WP_RM_POLL_WRITE) ? "FE Write":"Unknown RM poll event"
> 
> 
334a374
> static int acim2tiss[16] = { 0x0, 0x1, 0x4, 0x5, 0x7, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x2, 0x0, 0x3 };
346c386
< static int battdebounce = DEFAULT_BATT_DEBOUNCE;
---
> static int battdebounce = 64; //DEFAULT_BATT_DEBOUNCE;
357a398
> static int wp_remora_pre_release(void* pfe);
427a469,479
> 	
> #if 0
> {
> 	unsigned int	value;
> 	
> 	/* Enable Slow speed SPI */	
> 	card->hw_iface.bus_read_4(card->hw, 0x40, &data);
> 	data |= 0x00000020;
> 	card->hw_iface.bus_write_4(card->hw, 0x40, data);
> }	
> #endif
481c533
< 						fe->name, mod_no,
---
> 						fe->name, mod_no+1,
490c542
< 						fe->name, mod_no,
---
> 						fe->name, mod_no+1,
501c553
< 						fe->name, mod_no);
---
> 						fe->name, mod_no+1);
519c571
< 					fe->name, mod_no,mod_no+1);
---
> 					fe->name, mod_no+1,mod_no+2);
526c578
< 					fe->name, mod_no,mod_no+1);
---
> 					fe->name, mod_no+1,mod_no+2);
541c593
< 						fe->name, mod_no,mod_no+1);
---
> 						fe->name, mod_no+1,mod_no+2);
561c613
< 						fe->name, mod_no, byte);
---
> 						fe->name, mod_no+1, byte);
578c630
< 						fe->name, mod_no);
---
> 						fe->name, mod_no+1);
583c635
< 			fe->name, mod_no,mod_no+1,
---
> 			fe->name, mod_no+1,mod_no+2,
599c651
< 					mod_no,
---
> 					mod_no+1,
619c671
< 					fe->name, mod_no, value);
---
> 					fe->name, mod_no+1, value);
627c679
< 					fe->name, mod_no, value);
---
> 					fe->name, mod_no+1, value);
635c687
< 					fe->name, mod_no, value);
---
> 					fe->name, mod_no+1, value);
642d693
< 
654,656d704
< 	start_ticks = SYSTEM_TICKS;
< 	WRITE_RM_REG(mod_no, 14, 0x0);	/* DIFF DEMO 0x10 */
< 
660c708,711
< 	WRITE_RM_REG(mod_no, 93, 0x1F);
---
> 	//WRITE_RM_REG(mod_no, 93, 0x1F);
> 	WRITE_RM_REG(mod_no, 14, 0x0);	/* DIFF DEMO 0x10 */
> 
> 	start_ticks = SYSTEM_TICKS;
672c723
< 			"%s: Module %d: Failed to powerup within %d ms (%d mV only)!\n",
---
> 			"%s: Module %d: Failed to powerup within %d ms (%dV : %dV)!\n",
674c725
< 					mod_no,
---
> 					mod_no+1,
676c727
< 					vbat * 375);
---
> 					(vbat * 375)/1000, (0xc0 * 375)/1000);
680c731
< 					mod_no);
---
> 					mod_no+1);
688c739
< 					fe->name, mod_no,
---
> 					fe->name, mod_no+1,
697c748
< 		DEBUG_RM(
---
> 		DEBUG_EVENT(
699c750
< 					fe->name, mod_no);
---
> 					fe->name, mod_no+1);
708d758
< #if 1
714,716c764,766
< 			"%s: Module %d: Timeout waiting for DC-DC calibration\n",
< 						fe->name,
< 						mod_no);
---
> 			"%s: Module %d: Timeout waiting for DC-DC calibration (%02X)\n",
> 						fe->name, mod_no+1,
> 						READ_RM_REG(mod_no, 93));
721d770
< #endif
725c774
< static int wp_proslic_powerleak_test(sdla_fe_t *fe, int mod_no)
---
> static int wp_proslic_powerleak_test(sdla_fe_t *fe, int mod_no, int fast)
735,740c784,785
< 	while((vbat = READ_RM_REG(mod_no, 82)) >= 0x6){
< 		if ((SYSTEM_TICKS - start_ticks) > (HZ/2)){
< 			break;
< 		}
< 		wait_just_a_bit(HZ/10, 0);
< 	}
---
> 	wait_just_a_bit(HZ, fast);
> 	vbat = READ_RM_REG(mod_no, 82);
744c789
< 					fe->name, mod_no,
---
> 					fe->name, mod_no+1,
752c797
< 					mod_no,
---
> 					mod_no+1,
757a803,907
> static int wp_proslic_calibrate(sdla_fe_t *fe, int mod_no, int fast)
> {
> 	volatile unsigned long	start_ticks;
> 
> 	/* perform all calibration */
> 	WRITE_RM_REG(mod_no, 97, 0x1f);
> 	/* start */
> 	WRITE_RM_REG(mod_no, 96, 0x5f);
> 
> 	start_ticks = SYSTEM_TICKS;
> 	while(READ_RM_REG(mod_no, 96)){
> 		if ((SYSTEM_TICKS - start_ticks) > 2*HZ){
> 			DEBUG_EVENT(
> 			"%s: Module %d: Timeout on module calibration!\n",
> 					fe->name, mod_no+1);
> 			return -1;
> 		}
> 		wait_just_a_bit(HZ/10, fast);
> 	}
> 	return 0;
> }
> 
> static int wp_proslic_manual_calibrate(sdla_fe_t *fe, int mod_no, int fast)
> {
> 	volatile unsigned long	start_ticks;
> 	int			i=0;
> 
> 	WRITE_RM_REG(mod_no, 21, 0x00);
> 	WRITE_RM_REG(mod_no, 22, 0x00);
> 	WRITE_RM_REG(mod_no, 23, 0x00);
> 	WRITE_RM_REG(mod_no, 64, 0x00);
> 
> 	/* Step 14 */
> 	WRITE_RM_REG(mod_no, 97, 0x18);
> 	WRITE_RM_REG(mod_no, 96, 0x47);
> 
> 	/* Step 15 */
> 	start_ticks = SYSTEM_TICKS;
> 	while(READ_RM_REG(mod_no, 96) != 0){
> 		if ((SYSTEM_TICKS - start_ticks) > 800){
> 			DEBUG_EVENT(
> 			"%s: Module %d: Timeout on SLIC calibration (15)!\n",
> 					fe->name, mod_no+1);
> 			return -1;
> 		}
> 		wait_just_a_bit(HZ/10, fast);
> 	}
> 
> 	wait_just_a_bit(HZ/10, fast);
> 	WRITE_RM_REG(mod_no, 88, 0x00);
> 	WRITE_RM_REG(mod_no, 89, 0x00);
> 	WRITE_RM_REG(mod_no, 90, 0x00);
> 	WRITE_RM_REG(mod_no, 91, 0x00);
> 	WRITE_RM_REG(mod_no, 92, 0x00);
> 	WRITE_RM_REG(mod_no, 93, 0x00);
> 
> 	/* Step 16 */
> 	/* Insert manual calibration for sangoma Si3210 */
> 	WRITE_RM_REG(mod_no, 98, 0x10);
> 	WRITE_RM_REG(mod_no, 99, 0x10);
> 
> 	for (i = 0x1f; i > 0; i--){
> 		WRITE_RM_REG(mod_no, 98, i);
> 		wait_just_a_bit(4, fast);
> 		if ((READ_RM_REG(mod_no, 88)) == 0){
> 			break;
> 		}
> 	}
> 	for (i = 0x1f; i > 0; i--){
> 		WRITE_RM_REG(mod_no, 99, i);
> 		wait_just_a_bit(4, fast);
> 		if ((READ_RM_REG(mod_no, 89)) == 0){
> 			break;
> 		}
> 	}
> 	WRITE_RM_REG(mod_no, 64, 0x01);
> 	wait_just_a_bit(HZ, fast);
> 	WRITE_RM_REG(mod_no, 64, 0x00);
> 	/* Step 17 */
> 	WRITE_RM_REG(mod_no, 23, 0x04);
> 
> 	/* Step 18 */
> 	/* DAC offset and without common mode calibration. */
> 	WRITE_RM_REG(mod_no, 97, 0x01);	/* Manual after */
> 	/* Calibrate common mode and differential DAC mode DAC + ILIM */
> 	WRITE_RM_REG(mod_no, 96, 0x40);
> 
> 	/* Step 19 */
> 	wait_just_a_bit(HZ*2, fast);
> 	start_ticks = SYSTEM_TICKS;
> 	while(READ_RM_REG(mod_no, 96) != 0){
> 		if ((SYSTEM_TICKS - start_ticks) > 400){
> 			DEBUG_EVENT(
> 			"%s: Module %d: Timeout on SLIC calibration (%ld:%ld!\n",
> 				fe->name, mod_no+1,start_ticks,SYSTEM_TICKS);
> 			return -1;
> 		}
> 		wait_just_a_bit(HZ/10, fast);
> 	}
> 	DEBUG_RM("%s: Module %d: Calibration is done\n",
> 				fe->name, mod_no+1);
> 	/*READ_RM_REG(mod_no, 96);*/
> 
> 	return 0;
> }
762,765c912,914
< 	volatile unsigned long	start_ticks;
< 	unsigned short	tmp[5];
< 	unsigned char	value;
< 	volatile int		i, x;
---
> 	unsigned short		tmp[5];
> 	unsigned char		value;
> 	volatile int		x;
782a932,935
> 	if (!fast){
> 		fe->rm_param.mod[mod_no].u.fxs.proslic_power = PROSLIC_POWER_UNKNOWN;
> 	}
> 
788c941
< 							mod_no);
---
> 							mod_no+1);
811c964
< 					mod_no);
---
> 					mod_no+1);
817c970
< 		if (wp_proslic_powerleak_test(fe, mod_no)){
---
> 		if (wp_proslic_powerleak_test(fe, mod_no, fast)){
821c974
< 						mod_no);
---
> 						mod_no+1);
829c982
< 						mod_no);
---
> 						mod_no+1);
836,873c989,993
< 		/* Step 14 */
< 		WRITE_RM_REG(mod_no, 97, 0x1E);
< 		WRITE_RM_REG(mod_no, 96, 0x47);
< 
< 		/* Step 15 */
< 		start_ticks = SYSTEM_TICKS;
< 		while(READ_RM_REG(mod_no, 96) != 0){
< 			if ((SYSTEM_TICKS - start_ticks) > 400){
< 				DEBUG_EVENT(
< 				"%s: Module %d: Timeout on SLIC calibration (15)!\n",
< 						fe->name, mod_no);
< 				return -1;
< 			}
< 			wait_just_a_bit(HZ/10, fast);
< 		}
< 
< 		/* Step 16 */
< 		/* Insert manual calibration for sangoma Si3210 */
< 		WRITE_RM_REG(mod_no, 98, 0x10);
< 		//WRITE_RM_REG(mod_no, 98, 0x1F/*0x10*/);
< 		for (i = 0x1f; i > 0; i--){
< 
< 			WRITE_RM_REG(mod_no, 98, i);
< 			wait_just_a_bit(4, fast);
< 			if ((READ_RM_REG(mod_no, 88)) == 0){
< 				break;
< 			}
< 		}
< 
< 		WRITE_RM_REG(mod_no, 99, 0x10);
< 		//WRITE_RM_REG(mod_no, 99, 0x1F/*0x10*/);
< 		for (i = 0x1f; i > 0; i--){
< 
< 			WRITE_RM_REG(mod_no, 99, i);
< 			wait_just_a_bit(4, fast);
< 			if ((READ_RM_REG(mod_no, 89)) == 0){
< 				break;
< 			}
---
> 		//if (wp_proslic_calibrate(fe, mod_no, fast)){
> 		//	return -1;
> 		//}
> 		if (wp_proslic_manual_calibrate(fe, mod_no, fast)){
> 			return -1;
876,891c996,1002
< 		/* Step 17 */
< 		value = READ_RM_REG(mod_no, 23);
< 		WRITE_RM_REG(mod_no, 23, value | 0x04);
< 
< 		/* Step 18 */
< 		/* DAC offset and without common mode calibration. */
< 		WRITE_RM_REG(mod_no, 97, 0x01/*0x18*/);	/* Manual after */
< 		/* Calibrate common mode and differential DAC mode DAC + ILIM */
< 		WRITE_RM_REG(mod_no, 96, 0x40/*0x47*/);
< 
< 		/* Step 19 */
< 		start_ticks = SYSTEM_TICKS;
< 		while(READ_RM_REG(mod_no, 96) != 0){
< 			if ((SYSTEM_TICKS - start_ticks) > 2000/*400*/){
< 				DEBUG_EVENT(
< 				"%s: Module %d: Timeout on SLIC calibration (19:%02X)!\n",
---
> 		/* Perform DC-DC calibration */
> 		WRITE_RM_REG(mod_no,  93, 0x99);
> 		wait_just_a_bit(10, fast);
> 		value = READ_RM_REG(mod_no, 107);
> 		if ((value < 0x2) || (value > 0xd)) {
> 			DEBUG_EVENT(
> 			"%s: Module %d: DC-DC calibration has a surprising direct 107 of 0x%02x!\n",
893,897c1004,1006
< 						mod_no,
< 						READ_RM_REG(mod_no, 96));
< 				return -1;
< 			}
< 			wait_just_a_bit(HZ/10, fast);
---
> 						mod_no+1,
> 						value);
> 			WRITE_RM_REG(mod_no,  107, 0x8);
899,900c1008
< 		DEBUG_RM("%s: SLIC calibration complete (%ld)\n",
< 					fe->name, SYSTEM_TICKS-start_ticks);
---
> 
915,982d1022
< 	/* Step 20 */
< 	wp_proslic_setreg_indirect(fe, mod_no, 88, 0);
< 	wp_proslic_setreg_indirect(fe, mod_no, 89, 0);
< 	wp_proslic_setreg_indirect(fe, mod_no, 90, 0);
< 	wp_proslic_setreg_indirect(fe, mod_no, 91, 0);
< 	wp_proslic_setreg_indirect(fe, mod_no, 92, 0);
< 	wp_proslic_setreg_indirect(fe, mod_no, 93, 0);
< 	wp_proslic_setreg_indirect(fe, mod_no, 94, 0);
< 	wp_proslic_setreg_indirect(fe, mod_no, 95, 0);
< 
< 	if (!fast){
< 		/* Disable interrupt while full initialization */
< 		WRITE_RM_REG(mod_no, 21, 0);
< 		WRITE_RM_REG(mod_no, 22, 0);
< 		WRITE_RM_REG(mod_no, 23, 0);
< 		
< #if defined(AFT_RM_INTR_SUPPORT)
< 		fe->rm_param.mod[mod_no].u.fxs.imask1 = 0x00;
< 		fe->rm_param.mod[mod_no].u.fxs.imask2 = 0x03;
< 		fe->rm_param.mod[mod_no].u.fxs.imask3 = 0x01;
< #else		
< 		fe->rm_param.mod[mod_no].u.fxs.imask1 = 0x00;
< 		fe->rm_param.mod[mod_no].u.fxs.imask2 = 0x00;
< 		fe->rm_param.mod[mod_no].u.fxs.imask3 = 0x00;
< #endif		
< 	}
< 
< 	WRITE_RM_REG(mod_no, 64, 0);/* (0) */
< 
< 	//Alex Apr 3 - WRITE_RM_REG(mod_no, 64, 0x1);
< 
< 	value = READ_RM_REG(mod_no, 68); 
< 	/*
< 	** FIXME ???value = value & 0x03;
< 	** if (value & 4){
< 	**	printf("Module %d Timeout!\n", mod_no);
< 	**	return -1;
< 	** } */
< 
< #if 1
< 	WRITE_RM_REG(mod_no, 64, 0x00);
< 
< 	/* this is a singular calibration bit for longitudinal calibration */
< 	WRITE_RM_REG(mod_no, 97, 0x01);
< 	WRITE_RM_REG(mod_no, 96, 0x40);
< 
< 	value = READ_RM_REG(mod_no, 96); 
< 
< 	WRITE_RM_REG(mod_no, 18,0xff);
< 	WRITE_RM_REG(mod_no, 19,0xff);
< 	WRITE_RM_REG(mod_no, 20,0xff);
< 
< 	/* WRITE_RM_REG(mod_no, 64,0x1); */
< #endif
< 
< 	/* Perform DC-DC calibration */
< 	WRITE_RM_REG(mod_no,  93, 0x99);
< 	/*wait_just_a_bit(10, fast);*/
< 	value = READ_RM_REG(mod_no, 107);
< 	if ((value < 0x2) || (value > 0xd)) {
< 		DEBUG_EVENT(
< 		"%s: Module %d: DC-DC calibration has a surprising direct 107 of 0x%02x!\n",
< 					fe->name,
< 					mod_no,
< 					value);
< 		WRITE_RM_REG(mod_no,  107, 0x8);
< 	}
< 
991c1031
< 					mod_no);
---
> 					mod_no+1);
1015,1021c1055,1068
< #if 0
< 	/* Enable loopback */
< 	WRITE_RM_REG(mod_no, 8,  0x2);
< 	WRITE_RM_REG(mod_no, 14, 0x0);
< 	WRITE_RM_REG(mod_no, 64, 0x0);
< 	WRITE_RM_REG(mod_no, 1,  0x08);
< #endif
---
> 	if (!strcmp(fxo_modes[fe->fe_cfg.cfg.remora.opermode].name, "AUSTRALIA")) {
> 		value = acim2tiss[fxo_modes[fe->fe_cfg.cfg.remora.opermode].acim];
> 		WRITE_RM_REG(mod_no, 10, 0x8 | value);
> 		if (fxo_modes[fe->fe_cfg.cfg.remora.opermode].ring_osc){
> 			wp_proslic_setreg_indirect(
> 				fe, mod_no, 20,
> 				fxo_modes[fe->fe_cfg.cfg.remora.opermode].ring_osc);
> 		}
> 		if (fxo_modes[fe->fe_cfg.cfg.remora.opermode].ring_x){
> 			wp_proslic_setreg_indirect(
> 				fe, mod_no, 21,
> 				fxo_modes[fe->fe_cfg.cfg.remora.opermode].ring_x);
> 		}
> 	}
1023c1070,1073
< 	WRITE_RM_REG(mod_no, 64, 0x1);
---
> 	/* lowpower */
> 	if (fe->fe_cfg.cfg.remora.fxs_lowpower == WANOPT_YES){
> 		WRITE_RM_REG(mod_no, 72, 0x10);
> 	}
1024a1075,1166
> 	if (fe->fe_cfg.cfg.remora.fxs_fastringer == WANOPT_YES){
> 		/* Speed up Ringer */
> 		wp_proslic_setreg_indirect(fe, mod_no, 20, 0x7e6d);
> 		wp_proslic_setreg_indirect(fe, mod_no, 21, 0x01b9);
> 		/* Beef up Ringing voltage to 89V */
> 		if (!strcmp(fxo_modes[fe->fe_cfg.cfg.remora.opermode].name, "AUSTRALIA")) {
> 			WRITE_RM_REG(mod_no, 74, 0x3f);
> 			if (wp_proslic_setreg_indirect(fe, mod_no, 21, 0x247)){ 
> 				return -1;
> 			}
> 			DEBUG_EVENT("%s: Module %d: Boosting fast ringer (89V peak)\n",
> 					fe->name, mod_no + 1);
> 		} else if (fe->fe_cfg.cfg.remora.fxs_lowpower == WANOPT_YES){
> 			if (wp_proslic_setreg_indirect(fe, mod_no, 21, 0x14b)){ 
> 				return -1;
> 			}
> 			DEBUG_EVENT("%s: Module %d: Reducing fast ring power (50V peak)\n",
> 					fe->name, mod_no + 1);
> 		} else {
> 			DEBUG_EVENT("%s: Module %d: Speeding up ringer (25Hz)\n",
> 					fe->name, mod_no + 1);
> 		}
> 	}else{
> 		if (!strcmp(fxo_modes[fe->fe_cfg.cfg.remora.opermode].name, "AUSTRALIA")) {
> 			WRITE_RM_REG(mod_no, 74, 0x3f);
> 			if (wp_proslic_setreg_indirect(fe, mod_no, 21, 0x1d1)){
> 				return -1;
> 			} 
> 			DEBUG_EVENT("%s: Module %d: Boosting ringer (89V peak)\n",
> 						fe->name, mod_no+1);
> 		} else if (fe->fe_cfg.cfg.remora.fxs_lowpower == WANOPT_YES){
> 			if (wp_proslic_setreg_indirect(fe, mod_no, 21, 0x108)){
> 				return -1;
> 			} 
> 			DEBUG_EVENT("%s: Module %d: Reducing ring power (50V peak)\n",
> 						fe->name, mod_no+1);
> 		}
> 	}
> 
> 	/* Adjust RX/TX gains */
> 	if (fe->fe_cfg.cfg.remora.fxs_txgain || fe->fe_cfg.cfg.remora.fxs_rxgain) {
> 		DEBUG_EVENT("%s: Module %d: Adjust TX Gain to %s\n", 
> 					fe->name, mod_no+1,
> 					(fe->fe_cfg.cfg.remora.fxs_txgain == 35) ? "3.5dB":
> 					(fe->fe_cfg.cfg.remora.fxs_txgain == -35) ? "-3.5dB":"0dB");
> 		value = READ_RM_REG(mod_no, 9);
> 		switch (fe->fe_cfg.cfg.remora.fxs_txgain) {
> 		case 35:
> 			value |= 0x8;
> 			break;
> 		case -35:
> 			value |= 0x4;
> 			break;
> 		case 0: 
> 			break;
> 		}
> 	
> 		DEBUG_EVENT("%s: Module %d: Adjust RX Gain to %s\n", 
> 					fe->name, mod_no+1,
> 					(fe->fe_cfg.cfg.remora.fxs_rxgain == 35) ? "3.5dB":
> 					(fe->fe_cfg.cfg.remora.fxs_rxgain == -35) ? "-3.5dB":"0dB");
> 		switch (fe->fe_cfg.cfg.remora.fxs_rxgain) {
> 		case 35:
> 			value |= 0x2;
> 			break;
> 		case -35:
> 			value |= 0x01;
> 			break;
> 		case 0:
> 			break;
> 		}
> 		WRITE_RM_REG(mod_no, 9, value);
> 	}
> 
> 	if (!fast){
> 		/* Disable interrupt while full initialization */
> 		WRITE_RM_REG(mod_no, 21, 0);
> 		WRITE_RM_REG(mod_no, 22, 0xFC);
> 		WRITE_RM_REG(mod_no, 23, 0);
> 		
> #if defined(AFT_RM_INTR_SUPPORT)
> 		fe->rm_param.mod[mod_no].u.fxs.imask1 = 0x00;
> 		fe->rm_param.mod[mod_no].u.fxs.imask2 = 0x03;
> 		fe->rm_param.mod[mod_no].u.fxs.imask3 = 0x01;
> #else		
> 		fe->rm_param.mod[mod_no].u.fxs.imask1 = 0x00;
> 		fe->rm_param.mod[mod_no].u.fxs.imask2 = 0xFC;
> 		fe->rm_param.mod[mod_no].u.fxs.imask3 = 0x00;
> #endif		
> 	}
> 
> #if 0					
1026c1168
< 					fe->name, mod_no,
---
> 					fe->name, mod_no+1,
1031d1172
< #if 0					
1057a1199
> 	WRITE_RM_REG(mod_no, 64, 0x1);
1059,1063c1201,1209
< 	DEBUG_RM("%s: Module %d: Current Battery1 %dV, Battery2 %dV (%d)\n",
< 					fe->name, mod_no,
< 					READ_RM_REG(mod_no, 82)*375/1000,
< 					READ_RM_REG(mod_no, 83)*375/1000,
< 					__LINE__);
---
> 	wait_just_a_bit(HZ, fast);
> 	if (READ_RM_REG(mod_no, 81) < 0x0A){
> 		DEBUG_EVENT(
> 		"%s: Module %d: TIP/RING is too low on FXS %d!\n",
> 				fe->name,
> 				mod_no,
> 				READ_RM_REG(mod_no, 81) * 375 / 1000);
> 		return -1;
> 	}
1065,1067c1211,1214
< 	/* lowpower */
< 	//WRITE_RM_REG(mod_no, 72, 0x14);
< 	//todayWRITE_RM_REG(mod_no, 64, 0x1);
---
> 	DEBUG_RM("%s: Module %d: Current Battery1 %dV, Battery2 %dV\n",
> 					fe->name, mod_no+1,
> 					READ_RM_REG(mod_no, 82)*375/1000,
> 					READ_RM_REG(mod_no, 83)*375/1000);
1081c1228
< 				mod_no,
---
> 				mod_no+1,
1160c1307
< 						mod_no);
---
> 						mod_no+1);
1165c1312
< 				mod_no,
---
> 				mod_no+1,
1178a1326
> 	WRITE_RM_REG(mod_no, 2, 0x04 | 0x03);	/* Ring detect mode (begin/end) */
1181a1330,1374
> 	/* Take values for fxotxgain and fxorxgain and apply them to module */
> 	if (fe->fe_cfg.cfg.remora.fxo_txgain) {
> 		if (fe->fe_cfg.cfg.remora.fxo_txgain >= -150 && fe->fe_cfg.cfg.remora.fxo_txgain < 0) {
> 			DEBUG_EVENT("%s: Module %d: Adjust TX Gain to %2d.%d dB\n", 
> 					fe->name, mod_no+1,
> 					fe->fe_cfg.cfg.remora.fxo_txgain / 10,
> 					fe->fe_cfg.cfg.remora.fxo_txgain % -10);
> 			WRITE_RM_REG(mod_no, 38, 16 + (fe->fe_cfg.cfg.remora.fxo_txgain/-10));
> 			if(fe->fe_cfg.cfg.remora.fxo_txgain % 10) {
> 				WRITE_RM_REG(mod_no, 40, 16 + (-fe->fe_cfg.cfg.remora.fxo_txgain%10));
> 			}
> 		}
> 		else if (fe->fe_cfg.cfg.remora.fxo_txgain <= 120 && fe->fe_cfg.cfg.remora.fxo_txgain > 0) {
> 			DEBUG_EVENT("%s: Module %d: Adjust TX Gain to %2d.%d dB\n", 
> 					fe->name, mod_no+1,
> 					fe->fe_cfg.cfg.remora.fxo_txgain / 10,
> 					fe->fe_cfg.cfg.remora.fxo_txgain % 10);
> 			WRITE_RM_REG(mod_no, 38, fe->fe_cfg.cfg.remora.fxo_txgain/10);
> 			if (fe->fe_cfg.cfg.remora.fxo_txgain % 10){
> 				WRITE_RM_REG(mod_no, 40, (fe->fe_cfg.cfg.remora.fxo_txgain % 10));
> 			}
> 		}
> 	}
> 	if (fe->fe_cfg.cfg.remora.fxo_rxgain) {
> 		if (fe->fe_cfg.cfg.remora.fxo_rxgain >= -150 && fe->fe_cfg.cfg.remora.fxo_rxgain < 0) {
> 			DEBUG_EVENT("%s: Module %d: Adjust RX Gain to %2d.%d dB\n",
> 					fe->name, mod_no+1,
> 					fe->fe_cfg.cfg.remora.fxo_rxgain / 10,
> 					(-1) * (fe->fe_cfg.cfg.remora.fxo_rxgain % 10));
> 			WRITE_RM_REG(mod_no, 39, 16 + (fe->fe_cfg.cfg.remora.fxo_rxgain/-10));
> 			if(fe->fe_cfg.cfg.remora.fxo_rxgain%10) {
> 				WRITE_RM_REG(mod_no, 41, 16 + (-fe->fe_cfg.cfg.remora.fxo_rxgain%10));
> 			}
> 		}else if (fe->fe_cfg.cfg.remora.fxo_rxgain <= 120 && fe->fe_cfg.cfg.remora.fxo_rxgain > 0) {
> 			DEBUG_EVENT("%s: Module %d: Adjust RX Gain to %2d.%d dB\n",
> 					fe->name, mod_no+1,
> 					fe->fe_cfg.cfg.remora.fxo_rxgain / 10,
> 					fe->fe_cfg.cfg.remora.fxo_rxgain % 10);
> 			WRITE_RM_REG(mod_no, 39, fe->fe_cfg.cfg.remora.fxo_rxgain/10);
> 			if(fe->fe_cfg.cfg.remora.fxo_rxgain % 10) {
> 				WRITE_RM_REG(mod_no, 41, (fe->fe_cfg.cfg.remora.fxo_rxgain%10));
> 			}
> 		}
> 	}
> 
1186c1379
< 					mod_no);
---
> 					mod_no+1);
1199c1392
< int wp_remora_iface_init(void *pfe_iface)
---
> int wp_remora_iface_init(void *p_fe, void *pfe_iface)
1200a1394
> 	sdla_fe_t	*fe = (sdla_fe_t*)p_fe;
1207a1402
> 	fe_iface->pre_release	= &wp_remora_pre_release;
1218c1413
< #if defined(AFT_TDM_API_SUPPORT)
---
> #if defined(AFT_TDM_API_SUPPORT) || defined(AFT_API_SUPPORT)
1221a1417,1418
> 	WAN_LIST_INIT(&fe->event);
> 	wan_spin_lock_irq_init(&fe->lockirq);
1279a1477
> #if 0	
1282,1283c1480,1481
< 	wan_spin_lock_init(&fe->lock);
< 
---
> 	wan_spin_lock_init(&fe->lockirq);
> #endif
1308,1309c1506
< 					fe->name,
< 					mod_no);	
---
> 					fe->name, mod_no+1);	
1318c1515
< 						mod_no);
---
> 						mod_no+1);
1329,1330c1526
< 					fe->name,
< 					mod_no,
---
> 					fe->name, mod_no+1,
1339c1535
< 						mod_no);
---
> 						mod_no+1);
1348,1349c1544
< 					fe->name,
< 					mod_no);
---
> 					fe->name, mod_no+1);
1350a1546
> 			((sdla_t*)fe->card)->fe_no_intr = 0x1;
1355,1356c1551
< 						fe->name,
< 						mod_no);	
---
> 						fe->name, mod_no+1);	
1360,1361c1555,1560
< 			sane = 1;
< 			if (retry++ < 10) goto retry_cfg;
---
> 			if (!sane/*retry++ < 10*/){
> 				sane = 1;
> 				DEBUG_EVENT("%s: Module %d: Retry configuration...\n",
> 					fe->name, mod_no+1);
> 				goto retry_cfg;
> 			}
1363,1364c1562
< 				fe->name,
< 				mod_no,
---
> 				fe->name, mod_no+1,
1376c1574
< 
---
> 	
1435,1436d1632
< 	sdla_fe_timer_event_t	*fe_event;
< 	wan_smp_flag_t		smp_flags;
1446a1643,1668
> 	
> 	for(mod_no = 0; mod_no < MAX_REMORA_MODULES; mod_no++){
> 		if (wan_test_bit(mod_no, &fe->rm_param.module_map)) {
> 			wan_clear_bit(mod_no, &fe->rm_param.module_map);
> 		}
> 	}
> 	return 0;
> }
> 
> /*
>  ******************************************************************************
>  *			sdla_te_pre_release()	
>  *
>  * Description: T1/E1 pre release routines (not locked).
>  * Arguments:
>  * Returns:
>  ******************************************************************************
>  */
> static int wp_remora_pre_release(void* pfe)
> {
> 	sdla_fe_t		*fe = (sdla_fe_t*)pfe;
> 	sdla_fe_timer_event_t	*fe_event = NULL;
> 	wan_smp_flag_t		smp_flags;
> 	int			empty = 0;
> 	
> 	/* Kill TE timer poll command */
1454,1457c1676,1685
< 	wan_spin_lock_irq(&fe->lock,&smp_flags);
< 	while(!WAN_LIST_EMPTY(&fe->event)){
< 		fe_event = WAN_LIST_FIRST(&fe->event);
< 		WAN_LIST_REMOVE(fe_event, next);
---
> 	do{
> 		wan_spin_lock_irq(&fe->lockirq,&smp_flags);
> 		if (!WAN_LIST_EMPTY(&fe->event)){
> 			fe_event = WAN_LIST_FIRST(&fe->event);
> 			WAN_LIST_REMOVE(fe_event, next);
> 		}else{
> 			empty = 1;
> 		}
> 		wan_spin_unlock_irq(&fe->lockirq,&smp_flags);
> 		/* Free should be called not from spin_lock_irq (windows) !!!! */
1459,1460c1687,1688
< 	}
< 	wan_spin_unlock_irq(&fe->lock,&smp_flags);
---
> 		fe_event = NULL;
> 	}while(!empty);
1462,1466d1689
< 	for(mod_no = 0; mod_no < MAX_REMORA_MODULES; mod_no++){
< 		if (wan_test_bit(mod_no, &fe->rm_param.module_map)) {
< 			wan_clear_bit(mod_no, &fe->rm_param.module_map);
< 		}
< 	}
1610c1833
< 					fe->name, mod_no);
---
> 					fe->name, mod_no+1);
1615c1838
< 					fe->name, mod_no);
---
> 					fe->name, mod_no+1);
1645c1868
< 	DEBUG_RM("%s: RM timer!\n", fe->name);
---
> 	DEBUG_TEST("%s: RM timer!\n", fe->name);
1660c1883
< 	wan_spin_lock_irq(&fe->lock,&smp_flags);	
---
> 	wan_spin_lock_irq(&fe->lockirq,&smp_flags);	
1662c1885
< 	wan_spin_unlock_irq(&fe->lock,&smp_flags);	
---
> 	wan_spin_unlock_irq(&fe->lockirq,&smp_flags);	
1675c1898
< 		sdla_rm_add_timer(fe, 1000);
---
> 		sdla_rm_add_timer(fe, WP_RM_POLL_TIMER);
1693c1916
< 	DEBUG_RM("%s: Add new RM timer!\n", fe->name);
---
> 	DEBUG_TEST("%s: Add new RM timer!\n", fe->name);
1725c1948
< 	wan_spin_lock_irq(&fe->lock,&smp_flags);			
---
> 	wan_spin_lock_irq(&fe->lockirq,&smp_flags);			
1728c1951
< 		wan_spin_unlock_irq(&fe->lock,&smp_flags);	
---
> 		wan_spin_unlock_irq(&fe->lockirq,&smp_flags);	
1736c1959,1965
< 	wan_spin_unlock_irq(&fe->lock,&smp_flags);
---
> 	wan_spin_unlock_irq(&fe->lockirq,&smp_flags);
> 
> #if defined(__WINDOWS__)
> 	/* FIXME: Try to make common code for all OS */
> 	/* poll is NOT locked outside! */
> 	wan_spin_lock_irq(&card->wandev.lock,&smp_flags);
> #endif
1739,1740c1968,1969
< 	DEBUG_RM("%s: Module %d: RM Polling State=%s Cmd=0x%X!\n", 
< 			fe->name, mod_no,
---
> 	DEBUG_EVENT("[RM] %s: Module %d: RM Polling State=%s Cmd=%s(%X) Mode=%s!\n", 
> 			fe->name, mod_no+1,
1742c1971,1973
< 			fe_event->type);
---
> 			WP_RM_POLL_DECODE(fe_event->type), fe_event->type,
> 			WAN_EVENT_MODE_DECODE(fe_event->mode));
> 
1810,1811c2041,2042
< 			DEBUG_EVENT("%s: Module %d: %s %s events (%d)!\n",
< 					fe->name, mod_no,
---
> 			DEBUG_RM("%s: Module %d: %s %s events (%d)!\n",
> 					fe->name, mod_no+1,
1813c2044
< 					WAN_EVENT_TYPE_DECODE(fe_event->type),
---
> 					WP_RM_POLL_DECODE(fe_event->type),
1844c2075
< 					fe->name, mod_no);
---
> 					fe->name, mod_no+1);
1925c2156
< #if defined(__WINDOWS__)
---
> #if 0 /*defined(__WINDOWS__)*/
1946,1954c2177,2188
< 		imask = READ_RM_REG(mod_no, 3);
< 		if (fe_event->mode == WAN_EVENT_ENABLE){
< 			imask |= 0x80;
< 			wan_set_bit(WAN_RM_EVENT_RING_DETECT,
< 				&fe->rm_param.mod[mod_no].events);
< 		}else{
< 			imask &= ~0x80;
< 			wan_clear_bit(WAN_RM_EVENT_RING_DETECT,
< 				&fe->rm_param.mod[mod_no].events);
---
> 		if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
> 			imask = READ_RM_REG(mod_no, 3);
> 			if (fe_event->mode == WAN_EVENT_ENABLE){
> 				imask |= 0x80;
> 				wan_set_bit(WAN_RM_EVENT_RING_DETECT,
> 					&fe->rm_param.mod[mod_no].events);
> 			}else{
> 				imask &= ~0x80;
> 				wan_clear_bit(WAN_RM_EVENT_RING_DETECT,
> 					&fe->rm_param.mod[mod_no].events);
> 			}
> 			WRITE_RM_REG(mod_no, 3, imask);
1956d2189
< 		WRITE_RM_REG(mod_no, 3, imask);
1971a2205,2219
> 	case WP_RM_POLL_READ:
> 		DEBUG_EVENT("%s: Module %d: Reading %s register: Reg[%d]=%02X\n",
> 			fe->name, mod_no,
> 			WP_REMORA_DECODE_TYPE(fe->rm_param.mod[mod_no].type),
> 			fe_event->rm_event.reg,
> 			READ_RM_REG(mod_no,fe_event->rm_event.reg));
> 		break;
> 	case WP_RM_POLL_WRITE:
> 		DEBUG_EVENT("%s: Module %d: Writting %s register: Reg[%d]=%02X\n",
> 			fe->name, mod_no, 
> 			WP_REMORA_DECODE_TYPE(fe->rm_param.mod[mod_no].type),
> 			fe_event->rm_event.reg,
> 			fe_event->rm_event.value);
> 		WRITE_RM_REG(mod_no, fe_event->rm_event.reg, fe_event->rm_event.value);
> 		break;
1978a2227,2231
> 	/* poll is NOT locked outside! */
> 	wan_spin_unlock_irq(&card->wandev.lock,&smp_flags);
> #endif
> 
> #if 0/*defined(__WINDOWS__)*/
1999c2252
< 		sdla_rm_add_timer(fe, HZ);	
---
> 		sdla_rm_add_timer(fe, WP_RM_POLL_TIMER);	
2043c2296
< 	wan_spin_lock_irq(&fe->lock,&smp_flags);	
---
> 	wan_spin_lock_irq(&fe->lockirq,&smp_flags);	
2046a2300,2306
> #if defined(__WINDOWS__)
> 		/* only one event allowed at a time */
> 		DEBUG_RM("%s: returning EBUSY\n",
> 			fe->name);
> 		wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
> 		return EBUSY;
> #else
2053c2313
< 			wan_spin_unlock_irq(&fe->lock, &smp_flags);	
---
> 			wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
2056a2317
> #endif
2058c2319
< 	wan_spin_unlock_irq(&fe->lock, &smp_flags);	
---
> 	wan_spin_unlock_irq(&fe->lockirq, &smp_flags);	
2061a2323,2378
> /******************************************************************************
> *				wp_remora_event_verification()	
> *
> * Description: 
> * Arguments: mod_no -  Module number (1,2,3,... MAX_REMORA_MODULES)
> * Returns:
> ******************************************************************************/
> static int
> wp_remora_event_verification(sdla_fe_t *fe, wan_event_ctrl_t *ectrl)
> {
> 	int	mod_no = ectrl->mod_no-1;
> 
> 	/* Event verification */
> 	if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXS){
> 		switch(ectrl->type){
> 		case WAN_EVENT_RM_POWER:
> 		case WAN_EVENT_RM_LC:
> 		case WAN_EVENT_RM_DTMF:
> 		case WAN_EVENT_RM_RING_TRIP:
> 		case WAN_EVENT_RM_RING:
> 		case WAN_EVENT_RM_TONE:
> 		case WAN_EVENT_RM_TXSIG_KEWL:
> 		case WAN_EVENT_RM_TXSIG_START:
> 		case WAN_EVENT_RM_TXSIG_OFFHOOK:
> 		case WAN_EVENT_RM_TXSIG_ONHOOK:
> 		case WAN_EVENT_RM_ONHOOKTRANSFER:
> 		case WAN_EVENT_RM_SETPOLARITY:
> 			break;
> 		default:
> 			DEBUG_EVENT(
> 			"%s: Module %d: Remora RING Event is only valid for FXS module (%X)\n",
> 					fe->name,mod_no+1,
> 					ectrl->type);
> 			return -EINVAL;
> 		}
> 	}else if (fe->rm_param.mod[mod_no].type == MOD_TYPE_FXO){
> 		switch(ectrl->type){
> 		case WAN_EVENT_RM_RING_DETECT:
> 		case WAN_EVENT_RM_TXSIG_START:
> 		case WAN_EVENT_RM_TXSIG_OFFHOOK:
> 		case WAN_EVENT_RM_TXSIG_ONHOOK:
> 			break;
> 		default:
> 			DEBUG_EVENT(
> 			"%s: Module %d: Remora RING Event is only valid for FXO module(%X)\n",
> 					fe->name,mod_no+1,
> 					ectrl->type);
> 			return -EINVAL;
> 		}
> 	}else{
> 		DEBUG_EVENT(
> 		"%s: Module %d: Unknown Module type %X\n",
> 				fe->name,mod_no+1,
> 				fe->rm_param.mod[mod_no].type);
> 		return -EINVAL;	
> 	}
2062a2380,2381
> 	return 0;
> }
2074c2393
< 	int			mod_no, err = 0;
---
> 	int			mod_no = ectrl->mod_no-1, err = 0;
2077,2079c2396,2397
< 	mod_no = ectrl->mod_no;
< 
< 	if (mod_no >= MAX_REMORA_MODULES){
---
> 	
> 	if (mod_no+1 > MAX_REMORA_MODULES){
2081c2399
< 					fe->name, mod_no);
---
> 					fe->name, mod_no+1);
2090,2092c2408,2415
< 	DEBUG_RM("%s: Module %d: Scheduling %s event type!\n",
< 				fe->name, mod_no,
< 				WAN_EVENT_TYPE_DECODE(ectrl->type));
---
> 	if (wp_remora_event_verification(fe, ectrl)){
> 		return -EINVAL;
> 	}
> 		
> 	DEBUG_RM("%s: Module %d: Scheduling %s event (%s:%X)!\n",
> 				fe->name, mod_no+1,
> 				WAN_EVENT_TYPE_DECODE(ectrl->type),
> 				WAN_EVENT_MODE_DECODE(ectrl->mode), ectrl->mode);
2095c2418,2419
< 	fe_event.rm_event.mod_no= ectrl->mod_no;	
---
> 	fe_event.rm_event.mod_no= mod_no;
> 	fe_event.delay		= WP_RM_POLL_TIMER;
2103,2105d2426
< 	case WAN_EVENT_RM_RING_TRIP:
< 		fe_event.type		= WP_RM_POLL_RING_TRIP;
< 		break;
2108a2430,2432
> 	case WAN_EVENT_RM_RING_TRIP:
> 		fe_event.type		= WP_RM_POLL_RING_TRIP;
> 		break;
2111a2436,2438
> 	case WAN_EVENT_RM_RING_DETECT:
> 		fe_event.type		= WP_RM_POLL_RING_DETECT;
> 		break;
2135,2144c2462
< 	case WAN_EVENT_RM_RING_DETECT:
< 		fe_event.type		= WP_RM_POLL_RING_DETECT;
< 		break;
< 	default:
< 		DEBUG_EVENT("%s: Module %d: Invalid wan event type %X\n",
< 				fe->name,mod_no,
< 				ectrl->type);
< 		return -EINVAL;
< 	}		
< 
---
> 	}
2152,2153c2470,2471
< 	DEBUG_EVENT("%s: Module %d: Enable Dial tone\n",
< 				fe->name, mod_no);
---
> 	DEBUG_RM("%s: Module %d: Enable Dial tone\n",
> 				fe->name, mod_no+1);
2176,2177c2494,2495
< 	DEBUG_EVENT("%s: Module %d: Enable Busy tone\n",
< 				fe->name, mod_no);
---
> 	DEBUG_RM("%s: Module %d: Enable Busy tone\n",
> 				fe->name, mod_no+1);
2200,2201c2518,2519
< 	DEBUG_EVENT("%s: Module %d: Enable Ring tone\n",
< 				fe->name, mod_no);
---
> 	DEBUG_RM("%s: Module %d: Enable Ring tone\n",
> 				fe->name, mod_no+1);
2224,2225c2542,2543
< 	DEBUG_EVENT("%s: Module %d: Enable Congestion tone\n",
< 				fe->name, mod_no);
---
> 	DEBUG_RM("%s: Module %d: Enable Congestion tone\n",
> 				fe->name, mod_no+1);
2327,2329c2645,2648
< 	wan_cmd_t	*udp_cmd = (wan_cmd_t*)p_udp_cmd;
< 	sdla_fe_debug_t	*fe_debug;	
< 	int		err = -EINVAL;
---
> 	wan_cmd_t		*udp_cmd = (wan_cmd_t*)p_udp_cmd;
> 	sdla_fe_debug_t		*fe_debug;	
> 	sdla_fe_timer_event_t	event;
> 	int			err = -EINVAL;
2358,2384d2676
< #if 0		
< 		/* verify TIP/RING voltage */
< 		if (!fast){
< 			WRITE_RM_REG(mod_no, 8, 0x2);
< 			wait_just_a_bit(HZ, fast);
< 			start_ticks = SYSTEM_TICKS;
< 			while(READ_RM_REG(mod_no, 81) < 0x75){
< 				if ((SYSTEM_TICKS - start_ticks) > HZ*10){
< 					break;	
< 				}
< 				wait_just_a_bit(HZ, fast);
< 			}
< 			wait_just_a_bit(HZ, fast);
< 			if (READ_RM_REG(mod_no, 81) < 0x75){
< 				if (sane){
< 					DEBUG_EVENT(
< 					"%s: Module %d: TIP/RING is too low on FXS %d!\n",
< 							fe->name,
< 							mod_no,
< 							READ_RM_REG(mod_no, 81) * 375 / 1000);
< 				}
< 				WRITE_RM_REG(mod_no, 8, 0x0);
< 				return -1;
< 			}
< 			WRITE_RM_REG(mod_no, 8, 0x0);
< 		}
< #endif		
2393d2684
< #if 0
2395,2396c2686,2698
< 		case WAN_FE_DEBUG_VOLTAGE:
< 			/* FIXME: Add code */
---
> 		case WAN_FE_DEBUG_REG:
> 			event.type		= (fe_debug->fe_debug_reg.read) ? 
> 							WP_RM_POLL_READ : WP_RM_POLL_WRITE;
> 			event.rm_event.mod_no	= fe_debug->mod_no;
> 			event.rm_event.reg	= (u_int16_t)fe_debug->fe_debug_reg.reg;
> 			event.rm_event.value	= fe_debug->fe_debug_reg.value;
> 			event.delay		= WP_RM_POLL_TIMER;
> 			sdla_rm_add_event(fe, &event);
> 			udp_cmd->wan_cmd_return_code = WAN_CMD_OK;
> 			break;
> 		default:	
> 			udp_cmd->wan_cmd_return_code = WAN_UDP_INVALID_CMD;
> 		    	udp_cmd->wan_cmd_data_len = 0;
2399d2700
< #endif
2422c2723
< 					fe->name, mod_no);
---
> 					fe->name, mod_no+1);
2450c2751
< #if defined(AFT_TDM_API_SUPPORT)
---
> #if defined(AFT_TDM_API_SUPPORT) || defined(AFT_API_SUPPORT)
2452a2754,2756
> //#undef DEBUG_RM
> //#define DEBUG_RM DEBUG_EVENT
> 
2483a2788
> 
2488c2793
< 			fe->rm_param.mod[mod_no].u.fxo.ringdebounce += (WP_RM_CHUNKSIZE * 16);
---
> 			fe->rm_param.mod[mod_no].u.fxo.ringdebounce += (WP_RM_CHUNKSIZE * 4);
2506c2811
< 			fe->rm_param.mod[mod_no].u.fxo.ringdebounce -= WP_RM_CHUNKSIZE * 4;
---
> 			fe->rm_param.mod[mod_no].u.fxo.ringdebounce -= WP_RM_CHUNKSIZE * 2;
2557a2863,2865
> 			DEBUG_RM("%s: Module %d: On-Hook status!\n",
> 							fe->name,
> 							mod_no + 1);
2567a2876
> 
2568a2878
> 
2629,2632c2939,2940
< 				"%s: Module %d: %lu Polarity reversed (%d -> %d)\n",
< 						fe->name,
< 						mod_no + 1,
< 						SYSTEM_TICKS, 
---
> 				"%s: Module %d: Polarity reversed (%d -> %d) (%ul)\n",
> 						fe->name, mod_no + 1,
2634c2942,2943
< 						fe->rm_param.mod[mod_no].u.fxo.lastpol);
---
> 						fe->rm_param.mod[mod_no].u.fxo.lastpol,
> 						(unsigned int)SYSTEM_TICKS);
2643a2953,2954
> //#undef DEBUG_RM
> //#define DEBUG_RM DEBUG_TEST
2724c3035
< #if defined(AFT_TDM_API_SUPPORT)
---
> #if defined(AFT_TDM_API_SUPPORT) || defined(AFT_API_SUPPORT)
2735,2739c3046
< 	
< 	if (SYSTEM_TICKS - fe->rm_param.last_watchdog  < WP_RM_WATCHDOG_TIMEOUT) {
< 		return 0;
< 	}
< 	fe->rm_param.last_watchdog = SYSTEM_TICKS;
---
> 
2807a3115
> 	
2809,2810c3117,3122
< 	if (wp_remora_check_intr(fe)){
< 		wp_remora_intr(fe);
---
> 	if (SYSTEM_TICKS - fe->rm_param.last_watchdog  > WP_RM_WATCHDOG_TIMEOUT) {
> 		fe->rm_param.last_watchdog = SYSTEM_TICKS;
> 
> 		if (wp_remora_check_intr(fe)){
> 			wp_remora_intr(fe);
> 		}
2833c3145
< 					fe->name, mod_no);
---
> 					fe->name, mod_no+1);
2838c3150
< 					fe->name, mod_no);
---
> 					fe->name, mod_no+1);
2858c3170
< 					fe->name, mod_no, type);
---
> 					fe->name, mod_no+1, type);
2875c3187
< 					fe->name, mod_no, type);
---
> 					fe->name, mod_no+1, type);
2898c3210
< 				fe->name, mod_no);
---
> 				fe->name, mod_no+1);
2923d3234
< 	
2932,2933d3242
< 	//mod_no = fe->rm_param.intcount % MAX_REMORA_MODULES;
< 	
3010,3011d3318
< 	DEBUG_TDMAPI("mod_no: %d\n", mod_no);
< 
3025c3332
< 				fe->name, mod_no);
---
> 				fe->name, mod_no+1);
3037c3344
< 						fe->name, mod_no);
---
> 						fe->name, mod_no+1);
3043c3350
< 						fe->name, mod_no);
---
> 						fe->name, mod_no+1);
3056c3363
< 				fe->name, mod_no);
---
> 				fe->name, mod_no+1);
3074,3075c3381,3382
< 						fe->name, mod_no);
< 				event.rxhook	= WAN_EVENT_RING_TRIP_PRESENT;
---
> 						fe->name, mod_no+1);
> 				event.ring_mode	= WAN_EVENT_RING_TRIP_PRESENT;
3079,3080c3386,3387
< 						fe->name, mod_no);
< 				event.rxhook	= WAN_EVENT_RING_TRIP_STOP;
---
> 						fe->name, mod_no+1);
> 				event.ring_mode	= WAN_EVENT_RING_TRIP_STOP;
3085a3393,3416
> 		if (stat2 & 0x80) {
> 			DEBUG_EVENT("%s: Module %d: Power Alarm Q6!\n",
> 					fe->name, mod_no+1);
> 		}
> 		if (stat2 & 0x40) {
> 			DEBUG_EVENT("%s: Module %d: Power Alarm Q5!\n",
> 					fe->name, mod_no+1);
> 		}
> 		if (stat2 & 0x20) {
> 			DEBUG_EVENT("%s: Module %d: Power Alarm Q4!\n",
> 					fe->name, mod_no+1);
> 		}
> 		if (stat2 & 0x10) {
> 			DEBUG_EVENT("%s: Module %d: Power Alarm Q3!\n",
> 					fe->name, mod_no+1);
> 		}
> 		if (stat2 & 0x08) {
> 			DEBUG_EVENT("%s: Module %d: Power Alarm Q2!\n",
> 					fe->name, mod_no+1);
> 		}
> 		if (stat2 & 0x04) {
> 			DEBUG_EVENT("%s: Module %d: Power Alarm Q1!\n",
> 					fe->name, mod_no+1);
> 		}
3088c3419
< 			fe->name, mod_no,
---
> 			fe->name, mod_no+1,
3130c3461
< 			}else{
---
> 			} else {
3137c3468
< 		}else{
---
> 		} else {
3143a3475,3479
> #ifdef AUDIO_RINGCHECK
> /* If audio ringcheck is enabled, we use this code
>  * if disabled we use the check_hook code. 
>  * Right now we use the check_hook code because
>  * this code does not have debounce */
3146,3150c3482,3487
< 		}	
< 	}else if (status){
< 		DEBUG_RM(
< 		"%s: Module %d: Receive interrupt %02X!\n",
< 			fe->name, mod_no+1, status);
---
> 		}
> #endif	
> 	}
> 	if (status & 0x01){
> 		DEBUG_RM("%s: Module %d: Polarity reversed!\n", 
> 					fe->name, mod_no+1);
