

#if defined(__LINUX__)
# include <linux/wanpipe_includes.h>
# include <linux/wanpipe.h>
# include <linux/wanpipe_cfg.h>
#elif defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)
# include <net/wanpipe_includes.h>
# include <net/wanpipe.h>
# include <net/wanpipe_cfg.h>
#else
# error "This Operating System is not supported!"
#endif

#include "wan_aften.h"

/*#define DEBUG*/

static char	*wan_drvname = "wan_aften";
static int ncards; 

static sdla_t* card_list;	/* adapter data space */
extern wan_iface_t wan_iface;

static int wan_aften_init(void);
static int wan_aften_exit(void);
static int wan_aften_setup(sdla_t *card, netdevice_t *dev);
static int wan_aften_shutdown(sdla_t *card);
static int wan_aften_hwprobe(void);
static int wan_aften_open(netdevice_t *dev);
static int wan_aften_close(netdevice_t *dev);
static int wan_aften_ioctl (netdevice_t *dev, struct ifreq *ifr, int cmd);

WAN_MODULE_DEFINE(
	wan_aften, 
	"Alex Feldman <al.feldman@sangoma.com>",
	"WAN AFT Enable", 
	"GPL",
	wan_aften_init, wan_aften_exit,
	NULL);


static int wan_aften_init(void)
{
	struct wan_aften_priv	*priv = NULL;
	struct wan_dev_le	*devle;
	sdla_t			*card;
	static int		if_index = 0;
	int 			err = 0, i;
	
	ncards = sdla_hw_probe();
	if (!ncards){
		DEBUG_EVENT("No Sangoma cards found, unloading modules!\n");
		return -ENODEV;
	}

	for (i=0;i<ncards;i++){
		wan_device_t*	wandev;
		netdevice_t*	dev;

		card=wan_malloc(sizeof(sdla_t));
		if (!card){
			DEBUG_EVENT("%s: Failed allocate new card!\n", 
					wan_drvname);
			goto wanpipe_init_done;
		}
		memset(card, 0, sizeof(sdla_t));
		/* Allocate HDLC device */
		if (!wan_iface.alloc || (dev = wan_iface.alloc(1)) == NULL){
			goto wanpipe_init_done;
		}
		devle = wan_malloc(sizeof(struct wan_dev_le));
		if (devle == NULL){
			DEBUG_EVENT("%s: Failed allocate memory!\n",
					wan_drvname);
			goto wanpipe_init_done;
		}
		if ((priv = wan_malloc(sizeof(struct wan_aften_priv))) == NULL){
			DEBUG_EVENT("%s: Failed to allocate priv structure!\n",
				wan_drvname);
			goto wanpipe_init_done;
		}
		priv->common.is_netdev		= 1;
		priv->common.iface.open		= &wan_aften_open;
		priv->common.iface.close	= &wan_aften_close;
		priv->common.iface.ioctl	= &wan_aften_ioctl;
		priv->common.card		= card;
		wan_netif_set_priv(dev, priv);
#if defined(__LINUX__)
		/*sprintf(card->devname, "hdlc%d", if_index++);*/
		sprintf(card->devname, "wp%daft1", ++if_index);
#else
		sprintf(card->devname, "wp%caft1", 
			'a' + if_index++);

#endif
		/* Register in HDLC device */
		if (!wan_iface.attach || wan_iface.attach(dev, card->devname, 1)){
			wan_free(devle);
			if (wan_iface.free) wan_iface.free(dev);
			goto wanpipe_init_done;
		}
		wandev 			= &card->wandev;
		wandev->magic   	= ROUTER_MAGIC;
		wandev->name    	= card->devname;
		wandev->private 	= card;
		devle->dev		= dev;
		/* Set device pointer */
		WAN_LIST_INIT(&wandev->dev_head);
		WAN_LIST_INSERT_HEAD(&wandev->dev_head, devle, dev_link);
		card->list	= card_list;
		card_list	= card;
		if (wan_aften_setup(card, dev)){
			DEBUG_EVENT("%s: Failed setup new device!\n", 
					card->devname);
			WAN_LIST_REMOVE(devle, dev_link);
			wan_free(devle);
			if (wan_iface.detach) wan_iface.detach(dev, 1);
			if (wan_iface.free) wan_iface.free(dev);
			card_list	= card->list;
			wan_free(card);
		}
	}
	wan_aften_hwprobe();

wanpipe_init_done:
	if (err) wan_aften_exit();
	return err;
}

static int wan_aften_exit(void)
{
	struct wan_dev_le	*devle;
	sdla_t *card;
	int 	err = 0;

	for (card=card_list;card_list;){
		devle = WAN_LIST_FIRST(&card->wandev.dev_head);
		if (devle && devle->dev){
			struct wan_aften_priv	*priv = wan_netif_priv(devle->dev);
			DEBUG_EVENT("%s: Unregistering interface...\n", 
					wan_netif_name(devle->dev));
			if (wan_iface.detach) wan_iface.detach(devle->dev, 1);
			wan_free(priv);
			if (wan_iface.free) wan_iface.free(devle->dev);
			WAN_LIST_REMOVE(devle, dev_link);
			wan_free(devle);
		}
		DEBUG_EVENT("%s: Shutdown device\n", card->devname);
		wan_aften_shutdown(card);
		card_list = card->list;
		wan_free(card);
		card = card_list;
	}

	card_list=NULL;
	DEBUG_EVENT("\n");
	DEBUG_EVENT("%s: WANPIPE Generic Modules Unloaded.\n",
						wan_drvname);

#if defined(WAN_DEBUG_MEM)
	DEBUG_EVENT("%s: Total Mem %d\n",
			wan_drvname, atomic_read(&wan_debug_mem));
#endif	
	return err;
}

static int wan_aften_setup(sdla_t *card, netdevice_t *dev)
{
	struct wan_aften_priv	*priv = wan_netif_priv(dev);
	int			err;

	card->hw = sdla_register(&card->hw_iface, NULL, card->devname);
	if (card->hw == NULL){
		DEBUG_EVENT("%s: Failed to register hw device\n",
				card->devname);
		goto wan_aften_setup_error;
	}

	err = card->hw_iface.setup(card->hw, NULL);
	if (err){
		DEBUG_EVENT("%s: Hardware setup Failed %d\n",
				card->devname,err);
		sdla_unregister(&card->hw, card->devname);
		goto wan_aften_setup_error;
	}


	WAN_HWCALL(getcfg, (card->hw, SDLA_IRQ, &priv->irq));
	WAN_HWCALL(pci_read_config_dword, 
			(card->hw, 0x04, &priv->base_class));
	WAN_HWCALL(pci_read_config_dword, 
			(card->hw, PCI_IO_BASE_DWORD, &priv->base_addr0));
	WAN_HWCALL(pci_read_config_dword, 
			(card->hw, PCI_MEM_BASE0_DWORD, &priv->base_addr1));

	DEBUG_TEST("%s: BaseClass %X BaseAddr 0x%X IRQ %d\n", 
			wan_netif_name(dev),
			priv->base_class,
			priv->base_addr0,
			priv->irq);
	return 0;

wan_aften_setup_error:
	return -EINVAL;

}

static int wan_aften_shutdown(sdla_t *card)
{
	
	if (card->hw_iface.down){
		card->hw_iface.down(card->hw);
	}
	sdla_unregister(&card->hw, card->devname);

	return 0;
}

static int wan_aften_hwprobe(void)
{
	sdla_t		*card;
	unsigned char	*hwprobe;
	int		err;

	DEBUG_EVENT("\n\nList of available Sangoma devices:\n");
	for (card=card_list; card; card = card->list){
		struct wan_dev_le	*devle;
		devle = WAN_LIST_FIRST(&card->wandev.dev_head);
		if (devle && devle->dev){
			err = card->hw_iface.get_hwprobe(
					card->hw, 0, (void**)&hwprobe); 
			if (!err){
				hwprobe[strlen(hwprobe)] = '\0';
				DEBUG_EVENT("%s: %s\n",
						wan_netif_name(devle->dev),
						hwprobe);
			}
		}
	}
	return 0;
}


static int wan_aften_read_reg(sdla_t *card, wan_cmd_api_t *api_cmd)
{

	if (api_cmd->len == 1){
		if (api_cmd->offset <= 0x3C){
			card->hw_iface.pci_read_config_byte(
					card->hw,
					api_cmd->offset,
					(unsigned char*)&api_cmd->data[0]);
		}else{
			card->hw_iface.bus_read_1(
					card->hw,
				       	api_cmd->offset,
			       		(unsigned char*)&api_cmd->data[0]);
		}
		DEBUG_EVENT("%s: Reading Off=0x%08X Len=%i Data=0x%02X\n",
				card->devname,
				api_cmd->offset,
				api_cmd->len,
				*(unsigned char*)&api_cmd->data[0]);
	}else if (api_cmd->len == 2){
		if (api_cmd->offset <= 0x3C){
			card->hw_iface.pci_read_config_word(
					card->hw,
					api_cmd->offset,
					(unsigned short*)&api_cmd->data[0]);
		}else{
			card->hw_iface.bus_read_2(
					card->hw,
			       		api_cmd->offset,
				       	(unsigned short*)&api_cmd->data[0]);
		}
		DEBUG_EVENT("%s: Reading Off=0x%08X Len=%i Data=0x%04X\n",
				card->devname,
				api_cmd->offset,
				api_cmd->len,
				*(unsigned short*)&api_cmd->data[0]);
	}else if (api_cmd->len == 4){
		if (api_cmd->offset <= 0x3C){
			card->hw_iface.pci_read_config_dword(
					card->hw,
					api_cmd->offset,
					(unsigned int*)&api_cmd->data[0]);
		}else{
			card->hw_iface.bus_read_4(
					card->hw,
				       	api_cmd->offset,
				       	(unsigned int*)&api_cmd->data[0]);
		}
		DEBUG_EVENT("%s: Reading Off=0x%08X Len=%i Data=0x%04X\n",
				card->devname,
				api_cmd->offset,
				api_cmd->len,
				*(unsigned int*)&api_cmd->data[0]);
	}else{
		card->hw_iface.peek(
				card->hw,
				api_cmd->offset,
				(unsigned char*)&api_cmd->data[0],
				api_cmd->len);
#if 0
		memcpy_fromio((unsigned char*)&api_cmd.data[0],
				(unsigned char*)vector, api_cmd.len);
#endif
		DEBUG_EVENT("%s: Reading Off=0x%08X Len=%i\n",
				card->devname,
				api_cmd->offset,
				api_cmd->len);
	}
	
	return 0;	
}

static int wan_aften_all_read_reg(sdla_t *card_head, wan_cmd_api_t *api_cmd)
{
	sdla_t		*card;
	unsigned char	*data;
	
	data = wan_malloc(api_cmd->len);
	if (data == NULL){
		return -EINVAL;
	}

	for (card=card_list; card; card = card->list){
		wan_aften_read_reg(card, api_cmd);
		if (card == card_list){
			memcpy(data, api_cmd->data, api_cmd->len);
		}else if (strncmp(data, api_cmd->data, api_cmd->len)){
			memset(api_cmd->data, 0, api_cmd->len);
			break;
		}
	}

	if (data){
		wan_free(data);
	}
	return 0;	
}

static int wan_aften_write_reg(sdla_t *card, wan_cmd_api_t *api_cmd)
{
	if (api_cmd->len == 1){
		card->hw_iface.bus_write_1(
				card->hw,
				api_cmd->offset,
				*(unsigned char*)&api_cmd->data[0]);
		DEBUG_EVENT("%s: Write  Offset=0x%08X Data=0x%02X\n",
			card->devname,api_cmd->offset,
			*(unsigned char*)&api_cmd->data[0]);
	}else if (api_cmd->len == 2){
		card->hw_iface.bus_write_2(
				card->hw,
				api_cmd->offset,
				*(unsigned short*)&api_cmd->data[0]);
		DEBUG_EVENT("%s: Write  Offset=0x%08X Data=0x%04X\n",
			card->devname,api_cmd->offset,
			*(unsigned short*)&api_cmd->data[0]);
	}else if (api_cmd->len == 4){
		card->hw_iface.bus_write_4(
				card->hw,
				api_cmd->offset,
				*(unsigned int*)&api_cmd->data[0]);
		DEBUG_EVENT("%s: Write  Offset=0x%08X Data=0x%08X\n",
			card->devname,api_cmd->offset,
			*(unsigned int*)&api_cmd->data[0]);
	}else{
		card->hw_iface.poke(
				card->hw,
				api_cmd->offset,
				(unsigned char*)&api_cmd->data[0],
				api_cmd->len);
#if 0
		memcpy_toio((unsigned char*)vector,
			(unsigned char*)&api_cmd->data[0], api_cmd->len);
#endif
	}
	return 0;
}

static int wan_aften_all_write_reg(sdla_t *card_head, wan_cmd_api_t *api_cmd)
{
	sdla_t		*card;

	for (card=card_list; card; card = card->list){
		wan_aften_write_reg(card, api_cmd);
	}

	return 0;	
}


static int wan_aften_open(netdevice_t *dev)
{
	return 0;
}

static int wan_aften_close(netdevice_t *dev)
{
	return 0;
}

static int wan_aften_ioctl (netdevice_t *dev, struct ifreq *ifr, int cmd)
{
	sdla_t			*card;
	struct wan_aften_priv	*priv= wan_netif_priv(dev);
	wan_cmd_api_t	api_cmd;
	unsigned char		*str;
	int			err=-EINVAL;
		
	if (!priv || !priv->common.card){
		DEBUG_EVENT("%s: Invalid structures!\n", wan_netif_name(dev));
		return -ENODEV;
	}

	DEBUG_EVENT("%s: CMD=0x%X\n",__FUNCTION__,cmd);

	switch (cmd){
	case SIOC_WAN_READ_REG:
	case SIOC_WAN_WRITE_REG:
	case SIOC_WAN_ALL_READ_REG:
	case SIOC_WAN_ALL_WRITE_REG:
	case SIOC_WAN_SET_PCI_BIOS:
	case SIOC_WAN_HWPROBE:
	case SIOC_WAN_COREREV:
		break;
	default:
		DEBUG_EVENT("%s: Unsupported IOCTL call!\n", wan_netif_name(dev));
		return -EINVAL;
	}
	if (!ifr->ifr_data){
		DEBUG_EVENT("%s: No API data!\n", wan_netif_name(dev));
		return -EINVAL;
	}

	card = priv->common.card;
	if (WAN_COPY_FROM_USER(&api_cmd,ifr->ifr_data,sizeof(wan_cmd_api_t))){
		return -EFAULT;
	}

	/* Hardcode bar access FELD */
	switch (cmd){

	case SIOC_WAN_READ_REG:
		err = wan_aften_read_reg(card, &api_cmd);
		break;
	
	case SIOC_WAN_ALL_READ_REG:
		err = wan_aften_all_read_reg(card_list, &api_cmd);
		break;

	case SIOC_WAN_WRITE_REG:
		err = wan_aften_write_reg(card, &api_cmd);
		break;

	case SIOC_WAN_ALL_WRITE_REG:
		err = wan_aften_all_write_reg(card_list, &api_cmd);
		break;
		
	case SIOC_WAN_SET_PCI_BIOS:

		DEBUG_TEST("%s: Set PCI BaseClass %X BaseAddr0 %X BaseAddr1 %X IRQ %d\n",
				wan_netif_name(dev),
			       	priv->base_class,
			       	priv->base_addr0,
			       	priv->base_addr1,
				priv->irq);

		WP_DELAY(200);
		card->hw_iface.pci_write_config_dword(
				card->hw, 0x04, priv->base_class);
		card->hw_iface.pci_write_config_dword(
				card->hw, PCI_IO_BASE_DWORD, priv->base_addr0);
		card->hw_iface.pci_write_config_dword(
				card->hw, PCI_MEM_BASE0_DWORD, priv->base_addr1);
		card->hw_iface.pci_write_config_byte(
				card->hw, PCI_INT_LINE_BYTE, priv->irq);
		err = 0;
		break;
		
	case SIOC_WAN_HWPROBE:
		DEBUG_TEST("%s: Read list of Sangoma devices!\n",
					wan_netif_name(dev));
		memset(&api_cmd.data[0], 0, WAN_MAX_DATA_SIZE);
		if (card->hw_iface.get_hwprobe){
			err = card->hw_iface.get_hwprobe(
					card->hw, 0, (void**)&str); 
			if (err){
				break;
			}
			str[strlen(str)] = '\0';
			memcpy(api_cmd.data, str, strlen(str));
			api_cmd.len = strlen(str);	/* set to number of cards */
		}
		break;

	case SIOC_WAN_COREREV:
		if (card->hw_iface.getcfg){
			err = card->hw_iface.getcfg(
					card->hw,
				       	SDLA_COREREV,
					&api_cmd.data[0]);
			api_cmd.len = 1;
		}
		DEBUG_TEST("%s: Get core revision (rev %X)!\n", 
				wan_netif_name(dev), api_cmd.data[0]);
		break;
	}

	if (WAN_COPY_TO_USER(ifr->ifr_data,&api_cmd,sizeof(wan_cmd_api_t))){
		return -EFAULT;
	}
	
	return err;
}

