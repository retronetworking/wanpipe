/*****************************************************************************
 * libsangoma.c	AFT T1/E1: HDLC API Code Library
 *
 * Author(s):	Nenad Corbic <ncorbic@sangoma.com>
 *              David Rokhvarg <davidr@sangoma.com>
 *              Michael Jerris <mike@jerris.com>
 * 		Anthony Minessale II <anthmct@yahoo.com>
 *
 * Copyright:	(c) 2005-2008 Nenad Corbic <ncorbic@sangoma.com>
 *
 * * Redistribution and use in source and binary forms, with or without
 *   modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY <copyright holder> ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <copyright holder> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * ============================================================================
 *
 * Aug 15, 2006  David Rokhvarg <davidr@sangoma.com>	Ported to MS Windows 2000/XP
 * Sep 24, 2006  Michael Jerris <mike@jerris.com>		Windows port, standardize api, cleanup
 * 
 */

#include "libsangoma.h"
#define DFT_CARD "wanpipe1"

#ifndef WP_TDM_FEATURE_FE_ALARM
#warning "Warning: TDM FE ALARM not supported by driver"
#endif

#ifndef WP_TDM_FEATURE_DTMF_EVENTS
#warning "Warning: TDM DTMF not supported by driver"
#endif

#ifndef WP_TDM_FEATURE_EVENTS
#warning "Warning: TDM EVENTS not supported by driver"
#endif

#ifndef WP_TDM_FEATURE_LINK_STATUS
#warning "Warning: TDM LINK STATUS not supported by driver"
#endif


#if defined(WIN32)
//extern int	verbose;

#define DEV_NAME_LEN	100
char device_name[DEV_NAME_LEN];

#define RETRY_DELAY()		Sleep(50)
#define MAX_RETRY_COUNTER	8
 
#define DBG_IFACE	if(1)printf
#define INFO_IFACE	if(1)printf
#define ERR_IFACE	if(1)printf

#define WP_INIT_OVERLAPPED_STRUCT(o)\
{	\
	o->Internal = (ULONG_PTR)NULL; \
    o->InternalHigh = (ULONG_PTR)NULL; \
    o->Offset = 0; \
    o->OffsetHigh = 0;\
}

static void DecodeLastError(LPSTR lpszFunction) 
{ 
	LPVOID lpMsgBuf;
	DWORD dwLastErr = GetLastError();
	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dwLastErr,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);
	// Display the string.
	printf("Last Error: %s (GetLastError() returned: %d)\n", lpMsgBuf, dwLastErr);
	// Free the buffer.
	LocalFree( lpMsgBuf );
} 

static int handle_device_ioctl_result(int bResult)
{
	if(bResult == 0){
		/* check message log */
		printf("%s(): Line: %d: Error!!\n", __FUNCTION__, __LINE__);
		DecodeLastError(__FUNCTION__);
		return 1;
	}else{
		return 0;
	}
}

static int DoManagementCommand(HANDLE fd, wan_udp_hdr_t* wan_udp)
{
	DWORD ln, bIoResult;
	unsigned char id = 0;

	wan_udp->wan_udphdr_request_reply = 0x01;
	wan_udp->wan_udphdr_id = id;
   	wan_udp->wan_udphdr_return_code = WAN_UDP_TIMEOUT_CMD;

	bIoResult = DeviceIoControl(
			fd,
			IoctlManagementCommand,
			(LPVOID)wan_udp,
			sizeof(wan_udp_hdr_t),
			(LPVOID)wan_udp,
			sizeof(wan_udp_hdr_t),
			(LPDWORD)(&ln),
			(LPOVERLAPPED)NULL
			);

	return handle_device_ioctl_result(bIoResult);
}

static int DoTdmvApiCommand(HANDLE fd, wanpipe_tdm_api_cmd_t *api_cmd)
{
	DWORD ln, bIoResult;

	bIoResult = DeviceIoControl(
			fd,
			IoctlTdmApiCommand,
			(LPVOID)api_cmd,
			sizeof(wanpipe_tdm_api_cmd_t),
			(LPVOID)api_cmd,
			sizeof(wanpipe_tdm_api_cmd_t),
			(LPDWORD)(&ln),
			(LPOVERLAPPED)NULL
			);

	return handle_device_ioctl_result(bIoResult);
}

static int tdmv_api_ioctl(HANDLE fd, wanpipe_tdm_api_cmd_t *api_cmd)
{
	int		retry_counter = 0;

	do{
		if(DoTdmvApiCommand(fd, api_cmd)){
			return SANG_STATUS_GENERAL_ERROR;
		}

		if(api_cmd->result == SANG_STATUS_SUCCESS){
			break;
		}else if(api_cmd->result == SANG_STATUS_DEVICE_BUSY){
			retry_counter++;
			RETRY_DELAY();
			DBG_IFACE( "%s: %s(): Retrying...\n", device_name, __FUNCTION__);
		}else{
			ERR_IFACE("%s: %s(): Error: cmd result: %s(%d).\n", device_name, __FUNCTION__,
				SDLA_DECODE_SANG_STATUS(api_cmd->result), api_cmd->result);
			break;
		}

	}while(retry_counter < MAX_RETRY_COUNTER);

	return api_cmd->result;
}

// Blocking read command. If used after DoApiPollCommand(),
// it will return immediatly, without blocking.
static USHORT DoReadCommand(HANDLE drv, RX_DATA_STRUCT * pRx)
{
	DWORD ln;

	if (DeviceIoControl(
			drv,
			IoctlReadCommand,
			(LPVOID)NULL,
			0L,
			(LPVOID)pRx,
			sizeof(RX_DATA_STRUCT),
			(LPDWORD)(&ln),
			(LPOVERLAPPED)NULL
			) == FALSE){
		//check messages log
		prn(1, "Error: DoReadCommand(): DeviceIoControl failed!\n");
		return 1;
	}else{
		return 0;
	}
}

// Blocking write command. If used after DoApiPollCommand(),
// it will return immediatly, without blocking.
static UCHAR DoWriteCommand(HANDLE drv, TX_DATA_STRUCT * pTx)
{
	DWORD ln;

	if(DeviceIoControl(
			drv,
			IoctlWriteCommand,
			(LPVOID)pTx,
			(ULONG)sizeof(TX_DATA_STRUCT),
			(LPVOID)pTx,
			sizeof(TX_DATA_STRUCT),
			(LPDWORD)(&ln),
			(LPOVERLAPPED)NULL
			) == FALSE){
		//check messages log
		prn(1, "Error: DoWriteCommand(): DeviceIoControl failed!\n");
		return 1;
	}else{
		return 0;
	}
}

// Blocking API Poll command.
static USHORT DoApiPollCommand(HANDLE drv, API_POLL_STRUCT *api_poll_ptr, OVERLAPPED *overlapped)
{
	DWORD ln;

	WP_INIT_OVERLAPPED_STRUCT(overlapped);

	if (DeviceIoControl(
			drv,
			IoctlApiPoll,
			(LPVOID)NULL,
			0L,
			(LPVOID)api_poll_ptr,
			sizeof(API_POLL_STRUCT),
			(LPDWORD)(&ln),
			overlapped
			) == FALSE){
		//check messages log
		prn(1, "Error: DoApiPollCommand(): DeviceIoControl failed!\n");
		return 1;
	}else{
		return 0;
	}
}

#endif	/* WIN32 */

#define	DBG_POLL	if(1)printf

/*!
  \brief Device Close Method: User to close a file descriptor
  \param fd device file descriptor
  \return Non 0 = error, 0 = ok
*/

void sangoma_socket_close(sng_fd_t *fd) 
{
#if defined(WIN32)
	if(	*fd != INVALID_HANDLE_VALUE){
		CloseHandle(*fd);
		*fd = INVALID_HANDLE_VALUE;
	}
#else
    if (*fd >= 0) {
		close(*fd);
		*fd = -1;
    }
#endif
}


void sangoma_init_wait_obj(sangoma_wait_obj_t *sng_wait_obj, sng_fd_t fd, int span, int chan, int timeout, int flags_in)
{
	sng_wait_obj->fd		= fd;
	sng_wait_obj->timeout	= timeout;
	sng_wait_obj->flags_in	= flags_in;
	sng_wait_obj->span		= span;
	sng_wait_obj->chan		= chan;
#if defined(WIN32)
	sng_wait_obj->OverlappedApiPoll.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL);
#endif
}

#if defined(WIN32)
static int _SAPI_CALL sangoma_socket_get_state(sangoma_wait_obj_t *sng_wait_obj)
{
	DWORD	NumberOfBytesTransferred;
	BOOL	bOverlappedResult;

	bOverlappedResult = GetOverlappedResult(sng_wait_obj->fd,	
											&sng_wait_obj->OverlappedApiPoll,
											&NumberOfBytesTransferred,
											FALSE/* do NOT wait for IO to complete */);

	if(bOverlappedResult == FALSE){
		if(GetLastError() == ERROR_IO_INCOMPLETE){
			/* IO still in process */
			return 0;
		}else{
			/* Function call failed. Error. */
			return -1;
		}
	}else{
		if(GetLastError() == ERROR_SUCCESS){
			/* IO is complete. Sangoma "socket" is signaled. */
			return 1;
		}
		if(GetLastError() == ERROR_INVALID_PARAMETER){
			/* IO is complete, but with an error. */
			return -2;
		}
	}
	/* all other cases are errors */
	return -3;
}

static int _SAPI_CALL sangoma_socket_poll(sangoma_wait_obj_t *sng_wait_obj)
{
	API_POLL_STRUCT	*api_poll = &sng_wait_obj->api_poll;
#if 0
	DBG_POLL("%s(): span: %d, chan: %d\n", __FUNCTION__, sng_wait_obj->span, sng_wait_obj->chan);
#endif
	memset(api_poll, 0x00, sizeof(API_POLL_STRUCT));

	api_poll->timeout = sng_wait_obj->timeout;
	api_poll->user_flags_bitmap = sng_wait_obj->flags_in;

	/* This call will return immediatly because it is "overlapped"! 
	 * Caller of this function must implement the actual wait. */
	if(DoApiPollCommand(sng_wait_obj->fd, api_poll, &sng_wait_obj->OverlappedApiPoll)){
		//failed
		return -1;
	}
	return 0;
}
#endif


/*!
  \brief Device Wait Method: User to wait on MULTIPLE file descriptors
  \param sangoma_wait_objects - pointer to an array of sangoma_wait_obj_t structures
  \param number_of_sangoma_wait_objects - number of objects in sangoma_wait_objects array
  \param system_wait_timeout - SANGOMA_INFINITE_API_POLL_WAIT or other timeout in Milliseconds
  \return -1 = poll error, 0 = timeout, >0 ok
*/

int _SAPI_CALL sangoma_socket_waitfor_many(sangoma_wait_obj_t sangoma_wait_objects[], int number_of_sangoma_wait_objects, uint32_t system_wait_timeout)
{
	int	i;

#if defined(WIN32)
	HANDLE hEvents[MAXIMUM_WAIT_OBJECTS];

	if(number_of_sangoma_wait_objects > MAXIMUM_WAIT_OBJECTS){
		prn(1, "Error: %s(): Invalid 'number_of_sangoma_wait_objects': %d. Maximum is: %d\n", __FUNCTION__,
			number_of_sangoma_wait_objects, MAXIMUM_WAIT_OBJECTS);
		return -1;
	}

	for(i = 0; i < number_of_sangoma_wait_objects; i++){
		hEvents[i] = sangoma_wait_objects[i].OverlappedApiPoll.hEvent;
		sangoma_socket_poll(&sangoma_wait_objects[i]);
	}
	
	/* wait untill at least one of the events is signalled OR a timeout */
	if(WAIT_TIMEOUT == WaitForMultipleObjects(number_of_sangoma_wait_objects, &hEvents[0], FALSE, system_wait_timeout)){
		return 0;
	}

	/* find which overlapped IO was completed */
	for(i = 0; i < number_of_sangoma_wait_objects; i++){

		if(sangoma_socket_get_state(&sangoma_wait_objects[i]) > 0){

			if(sangoma_wait_objects[i].api_poll.operation_status == SANG_STATUS_SUCCESS){

				sangoma_wait_objects[i].flags_out = sangoma_wait_objects[i].api_poll.poll_events_bitmap;
			}else{
				prn(1, "Error: %s(): Invalid Operation Status: %s(%d)\n", __FUNCTION__,
					SDLA_DECODE_SANG_STATUS(sangoma_wait_objects[i].api_poll.operation_status), 
					sangoma_wait_objects[i].api_poll.operation_status);
				return -2;
			}
		}
	}

	return 1;
#else
    struct pollfd pfds[number_of_sangoma_wait_objects];
    int res;

	memset(pfds, 0, sizeof(pfds));

	for(i = 0; i < number_of_sangoma_wait_objects; i++){
	    pfds[i].fd = sangoma_wait_objects[i].fd;
		pfds[i].events = sangoma_wait_objects[i].flags_in;
	}

    res = poll(pfds, number_of_sangoma_wait_objects , sangoma_wait_objects[0].timeout);
    if (res > 0) {
		for(i = 0; i < number_of_sangoma_wait_objects; i++){
			sangoma_wait_objects[i].flags_out = pfds[i].revents;
		}
    }

    return res;
#endif
}


/*!
  \brief Device Wait Method: User to wait on a SINGLE file descriptor
  \param fd device file descriptor
  \param timeout wait timeout
  \param flags_in input poll flags
  \param flags_out return poll flags
  \return -1 = poll error, 0 = timeout, >0 ok
*/

int _SAPI_CALL sangoma_socket_waitfor(sng_fd_t fd, int timeout, int flags_in, unsigned int *flags_out)
{
#if defined(WIN32)
	API_POLL_STRUCT	api_poll;
	DWORD			NumberOfBytesTransferred;
	BOOL			bOverlappedResult;
	OVERLAPPED		OverlappedApiPoll;

	memset(&api_poll, 0x00, sizeof(API_POLL_STRUCT));

	api_poll.user_flags_bitmap = flags_in;

	/* This call will return immediatly because it is "overlapped"! 
	 * Caller of this function must implement the actual wait. */
	if(DoApiPollCommand(fd, &api_poll, &OverlappedApiPoll)){
		//failed
		return -1;
	}
		
	bOverlappedResult = GetOverlappedResult(fd,	&OverlappedApiPoll, &NumberOfBytesTransferred,
											TRUE /* wait (indefinitely) for IO to complete */);
	if(bOverlappedResult == FALSE){
		if(GetLastError() == ERROR_IO_INCOMPLETE){
			/* IO still in process */
			return 0;
		}else{
			/* Function call failed. Error. */
			return -1;
		}
	}else{
		if(GetLastError() == ERROR_SUCCESS){
			/* IO is complete. Sangoma "socket" is signaled. */
			if(api_poll.operation_status == SANG_STATUS_SUCCESS){

				*flags_out = api_poll.poll_events_bitmap;
				return 1;
			}else{
				prn(1, "Error: %s(): Invalid Operation Status: %s(%d)\n", __FUNCTION__,
					SDLA_DECODE_SANG_STATUS(api_poll.operation_status), api_poll.operation_status);
				return -3;
			}
		}
		if(GetLastError() == ERROR_INVALID_PARAMETER){
			/* IO is complete, but with an error. */
			return -2;
		}
	}
	return -1;
#else
    struct pollfd pfds[1];
    int res;

    memset(&pfds[0], 0, sizeof(pfds[0]));
    pfds[0].fd = fd;
    pfds[0].events = flags_in;
	*flags_out=0;

    res = poll(pfds, 1, timeout);
    if (res > 0) {
		*flags_out = pfds[0].revents;
    }

    return res;
#endif
}

int _SAPI_CALL sangoma_mgmt_cmd(sng_fd_t fd, wan_udp_hdr_t* wan_udp)
{
#if defined(__WINDOWS__)
	
	if(DoManagementCommand(fd, wan_udp)){
		return 1;
	}

	if(wan_udp->wan_udphdr_return_code != WAN_CMD_OK){
		return 2;
	}

#else
	unsigned char id = 0;
	int err=0;
	wan_udp->wan_udphdr_request_reply = 0x01;
	wan_udp->wan_udphdr_id = id;
	wan_udp->wan_udphdr_return_code = WAN_UDP_TIMEOUT_CMD;

	err=ioctl(fd,WANPIPE_IOCTL_PIPEMON,wan_udp);
	if (err < 0) {
		return 1;
	}
#endif
	return 0;
}

int _SAPI_CALL sangoma_span_chan_toif(int span, int chan, char *interface_name)
{
#if defined(WIN32)
/* FIXME: Not implemented */
	return -1;
#else
 	sprintf(interface_name,"s%ic%i",span,chan);
#endif
	return 0;
}

int _SAPI_CALL sangoma_interface_toi(char *interface_name, int *span, int *chan)
{
	char *p=NULL, *sp = NULL, *ch = NULL;
	int ret = 0;
	char data[FNAME_LEN];

	strncpy(data, interface_name, FNAME_LEN);
	if ((data[0])) {
		for (p = data; *p; p++) {
			if (sp && *p == 'g') {
				*p = '\0';
				ch = (p + 1);
				break;
			} else if (*p == 'w') {
				sp = (p + 1);
			}
		}

		if(ch && sp) {
			*span = atoi(sp);
			*chan = atoi(ch);
			ret = 1;
		} else {
			*span = -1;
			*chan = -1;
		}
	}

	return ret;
}

int _SAPI_CALL sangoma_span_chan_fromif(char *interface_name, int *span, int *chan)
{
	char *p = NULL, *sp = NULL, *ch = NULL;
	int ret = 0;
	char data[FNAME_LEN];

	strncpy(data, interface_name, FNAME_LEN);
	if ((data[0])) {
		for (p = data; *p; p++) {
			if (sp && *p == 'c') {
				*p = '\0';
				ch = (p + 1);
				break;
			} else if (*p == 's') {
				sp = (p + 1);
			}
		}

		if(ch && sp) {
			*span = atoi(sp);
			*chan = atoi(ch);
			ret = 1;
		} else {
			*span = -1;
			*chan = -1;
		}
	}

	return ret;
}

sng_fd_t sangoma_open_tdmapi_span_chan(int span, int chan) 
{
#if defined(WIN32)
	wan_udp_hdr_t	wan_udp;
	sng_fd_t		fd = INVALID_HANDLE_VALUE;

	if((fd = __sangoma_open_tdmapi_span_chan(span, chan)) == INVALID_HANDLE_VALUE){
		//prn(verbose, "Span: %d, chan: %d: is not running, consider 'busy'\n", span, chan);
		return fd;
	}

	//get the open handle counter
	wan_udp.wan_udphdr_command = GET_OPEN_HANDLES_COUNTER; 
	wan_udp.wan_udphdr_data_len = 0;

	DoManagementCommand(fd, &wan_udp);
	if(wan_udp.wan_udphdr_return_code){
		prn(1, "Error: command GET_OPEN_HANDLES_COUNTER failed! Span: %d, chan: %d\n", span, chan);
		//don't forget to close!! otherwize counter will stay incremented.
		sangoma_socket_close(&fd);
		return INVALID_HANDLE_VALUE;
	}

	//prn(verbose, "open handles counter: %d\n", *(int*)&wan_udp.wan_udphdr_data[0]);
	if(*(int*)&wan_udp.wan_udphdr_data[0] == 1){
		//this is the only process using this chan/span, so it is 'free'
		//prn(verbose, "Found 'free' Span: %d, chan: %d\n",span, i);
		return fd;
	}
	//we are NOT first!
	//don't forget to close!! otherwize counter will stay incremented.
	sangoma_socket_close(&fd);
		
	return INVALID_HANDLE_VALUE;

#else
	return __sangoma_open_tdmapi_span_chan(span, chan);
#endif
}            

/* no checks done for multiple open */
sng_fd_t __sangoma_open_tdmapi_span_chan(int span, int chan) 
{
   	char fname[FNAME_LEN], tmp_fname[FNAME_LEN];

	/* Form the Interface Name from span and chan number (i.e. wanpipe1_if1). */
	_snprintf(tmp_fname, DEV_NAME_LEN, WP_INTERFACE_NAME_FORM, span, chan);

#if defined(WIN32)
	_snprintf(fname , FNAME_LEN, "\\\\.\\%s", tmp_fname);
	return CreateFile(	fname, 
						GENERIC_READ | GENERIC_WRITE, 
						FILE_SHARE_READ | FILE_SHARE_WRITE,
						(LPSECURITY_ATTRIBUTES)NULL, 
						OPEN_EXISTING,
						FILE_FLAG_NO_BUFFERING | FILE_FLAG_WRITE_THROUGH | FILE_FLAG_OVERLAPPED,
						(HANDLE)NULL
						);
#else
	//sprintf(fname,"/dev/wptdm_s%dc%d",span,chan);
	sprintf(fname,"/dev/%s", tmp_fname);

	return open(fname, O_RDWR);
#endif
}            

sng_fd_t sangoma_open_tdmapi_ctrl(void)
{
#if defined(WIN32)
	sng_fd_t fd = INVALID_HANDLE_VALUE;

#pragma message("sangoma_open_tdmapi_ctrl: Not support on Windows")
#else
	sng_fd_t fd=-1;

	fd = open("/dev/wptdm_ctrl", O_RDWR);
#endif

    return fd;
}

sng_fd_t sangoma_create_socket_by_name(char *device, char *card) 
{
	int span,chan;
	sangoma_interface_toi(device,&span,&chan);
	
	return sangoma_open_tdmapi_span_chan(span,chan);
}

          
sng_fd_t sangoma_open_tdmapi_span(int span) 
{
    int i=0;
#if defined(WIN32)
	sng_fd_t fd = INVALID_HANDLE_VALUE;

	for(i = 1; i < 32; i++){

		fd = sangoma_open_tdmapi_span_chan(span, i);

		if(fd != INVALID_HANDLE_VALUE){
			//found free chan
			break;
		}

	}//for()

#else
    char fname[FNAME_LEN];
	int fd=0;
	for (i=1;i<32;i++){
		sprintf(fname,"/dev/wptdm_s%dc%d",span,i);
		fd = open(fname, O_RDWR);
		if (fd < 0){
         		continue;
		}
		break;
	}
#endif	
    return fd;  
}      

int _SAPI_CALL sangoma_readmsg_tdm(sng_fd_t fd, void *hdrbuf, int hdrlen, void *databuf, int datalen, int flag)
{
	int rx_len=0;

#if defined(WIN32)
	wp_api_hdr_t	*rx_hdr = (wp_api_hdr_t*)hdrbuf;

	if(hdrlen != sizeof(wp_api_hdr_t)){
		//error
		prn(1, "Error: %s(): invalid size of user's 'header buffer'. Should be 'sizeof(wp_api_hdr_t)'.\n", __FUNCTION__);
		return -1;
	}

	if(datalen != MAX_NO_DATA_BYTES_IN_FRAME /*sizeof(wp_api_element_t) - sizeof(wp_api_hdr_t)*/){
		//error
		prn(1, "Error: %s(): invalid size of user's 'data buffer'. Should be MAX_NO_DATA_BYTES_IN_FRAME (%d).\n", __FUNCTION__, MAX_NO_DATA_BYTES_IN_FRAME);
		return -2;
	}

	if(hdrbuf != (((u8*)databuf) - sizeof(wp_api_hdr_t))){
		//error/FIXME - currently hdrbuf MUST be followed by databuf!
		prn(1, "Error: %s(): user's 'header buffer' and 'data buffer' are NOT equal!.\n", __FUNCTION__);
		return -3;
	}

	if(DoReadCommand(fd, hdrbuf)){
		//error
		prn(1, "Error: %s(): DoReadCommand() failed! Check messages log.\n", __FUNCTION__);
		return -4;
	}

	switch(rx_hdr->operation_status)
	{
	case SANG_STATUS_RX_DATA_AVAILABLE:
		/* ok */
		break;
	default:
		prn(1, "Error: %s(): Operation Status: %s(%d)\n", __FUNCTION__, 
			SDLA_DECODE_SANG_STATUS(rx_hdr->operation_status), rx_hdr->operation_status);
		return -5;
	}

	rx_len = rx_hdr->data_length;

#else
	struct msghdr msg;
	struct iovec iov[2];

	memset(&msg,0,sizeof(struct msghdr));

	iov[0].iov_len=hdrlen;
	iov[0].iov_base=hdrbuf;

	iov[1].iov_len=datalen;
	iov[1].iov_base=databuf;

	msg.msg_iovlen=2;
	msg.msg_iov=iov;

	rx_len = read(fd,&msg,datalen+hdrlen);

	if (rx_len <= sizeof(wp_tdm_api_rx_hdr_t)){
		return -EINVAL;
	}

	rx_len-=sizeof(wp_tdm_api_rx_hdr_t);
#endif
    return rx_len;
}                    

int _SAPI_CALL sangoma_writemsg_tdm(sng_fd_t fd, void *hdrbuf, int hdrlen, void *databuf, unsigned short datalen, int flag)
{
	int bsent=-1;

#if defined(WIN32)
	wp_api_element_t	*tx_el; 

	if(hdrlen != sizeof(wp_api_hdr_t)){
		//error
		prn(1, "Error: %s(): invalid size of user's 'header buffer'. Should be 'sizeof(wp_api_hdr_t)'.\n", __FUNCTION__);
		return -1;
	}

	if(hdrbuf != (((u8*)databuf) - sizeof(wp_api_hdr_t))){
		//error/FIXME - currently hdrbuf MUST be followed by databuf!
		prn(1, "Error: %s(): user's 'header buffer' and 'data buffer' are NOT equal!.\n", __FUNCTION__);
		return -3;
	}

	tx_el = hdrbuf;

	//queue data for transmission
	if(DoWriteCommand(fd, hdrbuf)){
		//error
		prn(1, "Error: DoWriteCommand() failed!! Check messages log.\n");
		return -1;
	}

	bsent=0;
	//check that frame was transmitted
	switch(tx_el->hdr.operation_status)
	{
	case SANG_STATUS_SUCCESS:
		bsent = datalen;
		break;
	default:
		prn(1, "Error: %s(): Operation Status: %s(%d)\n", __FUNCTION__, 
			SDLA_DECODE_SANG_STATUS(tx_el->hdr.operation_status), tx_el->hdr.operation_status);
		break;
	}//switch()

#else
	struct msghdr msg;
	struct iovec iov[2];
	wp_api_hdr_t	*tx_el=hdrbuf;

	memset(&msg,0,sizeof(struct msghdr));

	iov[0].iov_len=hdrlen;
	iov[0].iov_base=hdrbuf;

	iov[1].iov_len=datalen;
	iov[1].iov_base=databuf;

	msg.msg_iovlen=2;
	msg.msg_iov=iov;

	bsent = write(fd,&msg,datalen+hdrlen);

	if (bsent == (datalen+hdrlen)){
		tx_el->wp_api_hdr_operation_status=SANG_STATUS_SUCCESS;
		bsent-=sizeof(wp_tdm_api_tx_hdr_t);
	} else if (errno == EBUSY){
		tx_el->wp_api_hdr_operation_status=SANG_STATUS_DEVICE_BUSY;
	} else {
		tx_el->wp_api_hdr_operation_status=SANG_STATUS_IO_ERROR;
	}
	tx_el->wp_api_hdr_data_length=bsent;
#endif
	return bsent;
}


#ifdef WANPIPE_TDM_API

/*========================================================
 * Execute TDM command
 *
 */
int _SAPI_CALL sangoma_tdm_cmd_exec(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api)
{
	int err;

#if defined(WIN32)
	err = tdmv_api_ioctl(fd, &tdm_api->wp_tdm_cmd);
#else
	err = ioctl(fd,SIOC_WANPIPE_TDM_API,&tdm_api->wp_tdm_cmd);
	if (err < 0){
		char tmp[50];
		sprintf(tmp,"TDM API: CMD: %i\n",tdm_api->wp_tdm_cmd.cmd);
		perror(tmp);
		return -1;
	}
#endif
	return err;
}

/*========================================================
 * Get Full TDM API configuration per channel
 *
 */
int _SAPI_CALL sangoma_get_full_cfg(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api)
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_GET_FULL_CFG;

	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

#if 1
	printf("TDM API CFG:\n");
	printf("\thw_tdm_coding:\t%d\n",tdm_api->wp_tdm_cmd.hw_tdm_coding);
	printf("\thw_mtu_mru:\t%d\n",tdm_api->wp_tdm_cmd.hw_mtu_mru);
	printf("\tusr_period:\t%d\n",tdm_api->wp_tdm_cmd.usr_period);
	printf("\ttdm_codec:\t%d\n",tdm_api->wp_tdm_cmd.tdm_codec);
	printf("\tpower_level:\t%d\n",tdm_api->wp_tdm_cmd.power_level);
	printf("\trx_disable:\t%d\n",tdm_api->wp_tdm_cmd.rx_disable);
	printf("\ttx_disable:\t%d\n",tdm_api->wp_tdm_cmd.tx_disable);
	printf("\tusr_mtu_mru:\t%d\n",tdm_api->wp_tdm_cmd.usr_mtu_mru);
	printf("\tidle flag:\t0x%02X\n",tdm_api->wp_tdm_cmd.idle_flag);

#ifdef WP_TDM_FEATURE_FE_ALARM
	printf("\tfe alarms:\t0x%02X\n",tdm_api->wp_tdm_cmd.fe_alarms);
#endif
	
	printf("\trx pkt\t%d\ttx pkt\t%d\n",tdm_api->wp_tdm_cmd.stats.rx_packets,
				tdm_api->wp_tdm_cmd.stats.tx_packets);
	printf("\trx err\t%d\ttx err\t%d\n",
				tdm_api->wp_tdm_cmd.stats.rx_errors,
				tdm_api->wp_tdm_cmd.stats.tx_errors);
#ifndef __WINDOWS__
	printf("\trx ovr\t%d\ttx idl\t%d\n",
				tdm_api->wp_tdm_cmd.stats.rx_fifo_errors,
				tdm_api->wp_tdm_cmd.stats.tx_carrier_errors);
#endif		
#endif		
	
	return 0;
}

/*========================================================
 * SET Codec on a particular Channel.
 * 
 * Available codecs are defined in 
 * /usr/src/linux/include/linux/wanpipe_cfg.h
 * 
 * enum wan_codec_format {
 *  	WP_NONE,
 *	WP_SLINEAR
 * }
 *
 */
int _SAPI_CALL sangoma_tdm_set_codec(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api, int codec)
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_CODEC;
	tdm_api->wp_tdm_cmd.tdm_codec = codec;

	err=sangoma_tdm_cmd_exec(fd,tdm_api);

	return err;
}

/*========================================================
 * GET Codec from a particular Channel.
 * 
 * Available codecs are defined in 
 * /usr/src/linux/include/linux/wanpipe_cfg.h
 * 
 * enum wan_codec_format {
 *  	WP_NONE,
 *	WP_SLINEAR
 * }
 *
 */
int _SAPI_CALL sangoma_tdm_get_codec(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api)
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_GET_CODEC;

	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return tdm_api->wp_tdm_cmd.tdm_codec;	
}

/*========================================================
 * SET Rx/Tx Hardware Period in milliseconds.
 * 
 * Available options are:
 *  10,20,30,40,50 ms      
 *
 */
int _SAPI_CALL sangoma_tdm_set_usr_period(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api, int period)
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_USR_PERIOD;
	tdm_api->wp_tdm_cmd.usr_period = period;

	err=sangoma_tdm_cmd_exec(fd,tdm_api);

	return err;
}

/*========================================================
 * GET Rx/Tx Hardware Period in milliseconds.
 * 
 * Available options are:
 *  10,20,30,40,50 ms      
 *
 */
int _SAPI_CALL sangoma_tdm_get_usr_period(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api)
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_GET_USR_PERIOD;

	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return tdm_api->wp_tdm_cmd.usr_period;
}

/*========================================================
 * GET Current User Hardware Coding Format
 *
 * Coding Format will be ULAW/ALAW based on T1/E1 
 */

int _SAPI_CALL sangoma_tdm_get_hw_coding(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api)
{
        int err;
        tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_GET_HW_CODING;
        err=sangoma_tdm_cmd_exec(fd,tdm_api);
        if (err){
                return err;
        }
        return tdm_api->wp_tdm_cmd.hw_tdm_coding;
}

#ifdef WP_TDM_FEATURE_DTMF_EVENTS
/*========================================================
 * GET Current User Hardware DTMF Enabled/Disabled
 *
 * Will return true if HW DTMF is enabled on Octasic
 */

int _SAPI_CALL sangoma_tdm_get_hw_dtmf(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api)
{
	int err;
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_GET_HW_DTMF;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}
	return tdm_api->wp_tdm_cmd.hw_dtmf;
}
#endif

/*========================================================
 * GET Current User MTU/MRU values in bytes.
 * 
 * The USER MTU/MRU values will change each time a PERIOD
 * or CODEC is adjusted.
 */
int _SAPI_CALL sangoma_tdm_get_usr_mtu_mru(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api)
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_GET_USR_MTU_MRU;

	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return tdm_api->wp_tdm_cmd.usr_mtu_mru;
}

/*========================================================
 * SET TDM Power Level
 * 
 * This option is not implemented yet
 *
 */
int _SAPI_CALL sangoma_tdm_set_power_level(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api, int power)
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_POWER_LEVEL;
	tdm_api->wp_tdm_cmd.power_level = power;

	err=sangoma_tdm_cmd_exec(fd,tdm_api);

	return err;
}

/*========================================================
 * GET TDM Power Level
 * 
 * This option is not implemented yet
 *
 */
int _SAPI_CALL sangoma_tdm_get_power_level(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api)
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_GET_POWER_LEVEL;

	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return tdm_api->wp_tdm_cmd.power_level;
}

int _SAPI_CALL sangoma_tdm_flush_bufs(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api)
{
#if 0
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_FLUSH_BUFFERS;

	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}
#endif
	return 0;
}

int _SAPI_CALL sangoma_tdm_enable_rbs_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api, int poll_in_sec) {
	
	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_ENABLE_RBS_EVENTS;
	tdm_api->wp_tdm_cmd.rbs_poll=poll_in_sec; 
	
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return tdm_api->wp_tdm_cmd.rbs_poll;
}


int _SAPI_CALL sangoma_tdm_disable_rbs_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) {

	int err;
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_DISABLE_RBS_EVENTS;
	
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}

int _SAPI_CALL sangoma_tdm_write_rbs(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api, unsigned char rbs) 
{
	
	int err;
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_WRITE_RBS_BITS;
	tdm_api->wp_tdm_cmd.rbs_tx_bits=rbs; 
	
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}        

int _SAPI_CALL sangoma_tdm_read_event(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) 
{

#ifdef WP_TDM_FEATURE_EVENTS
	wp_tdm_api_event_t *rx_event;
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_READ_EVENT;
	
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	rx_event = &tdm_api->wp_tdm_cmd.event;
	

	switch (rx_event->wp_tdm_api_event_type){
	
	case WP_TDMAPI_EVENT_RBS:
		if (tdm_api->wp_tdm_event.wp_rbs_event) {
			tdm_api->wp_tdm_event.wp_rbs_event(fd,rx_event->wp_tdm_api_event_rbs_bits);
		}
		
		break;
	
#ifdef WP_TDM_FEATURE_DTMF_EVENTS	
	case WP_TDMAPI_EVENT_DTMF:
		if (tdm_api->wp_tdm_event.wp_dtmf_event) {
			tdm_api->wp_tdm_event.wp_dtmf_event(fd,
						rx_event->wp_tdm_api_event_dtmf_digit,
						rx_event->wp_tdm_api_event_dtmf_type,
						rx_event->wp_tdm_api_event_dtmf_port);
		}
		break;
#endif
		
	case WP_TDMAPI_EVENT_RXHOOK:
		if (tdm_api->wp_tdm_event.wp_rxhook_event) {
			tdm_api->wp_tdm_event.wp_rxhook_event(fd,
						rx_event->wp_tdm_api_event_hook_state);
		}
		break;

	case WP_TDMAPI_EVENT_RING_DETECT:
		if (tdm_api->wp_tdm_event.wp_ring_detect_event) {
			tdm_api->wp_tdm_event.wp_ring_detect_event(fd,
						rx_event->wp_tdm_api_event_ring_state);
		}
		break;

	case WP_TDMAPI_EVENT_RING_TRIP_DETECT:
		if (tdm_api->wp_tdm_event.wp_ring_trip_detect_event) {
			tdm_api->wp_tdm_event.wp_ring_trip_detect_event(fd,
						rx_event->wp_tdm_api_event_ring_state);
		}
		break;

#ifdef WP_TDM_FEATURE_FE_ALARM
	case WP_TDMAPI_EVENT_ALARM:
		if (tdm_api->wp_tdm_event.wp_fe_alarm_event) {
			tdm_api->wp_tdm_event.wp_fe_alarm_event(fd,
						rx_event->wp_tdm_api_event_alarm);
		}   
		break; 
#endif

#ifdef WP_TDM_FEATURE_LINK_STATUS	
	/* Link Status */	
	case WP_TDMAPI_EVENT_LINK_STATUS:
		if(tdm_api->wp_tdm_event.wp_link_status_event){
			tdm_api->wp_tdm_event.wp_link_status_event(fd,
						rx_event->wp_tdm_api_event_link_status);
		}
		
		break;
#endif	
	default:
		printf("%d: Unknown TDM event!", (int)fd);
		break;
	}
	
	return 0;
#else
	printf("Error: Read Event not supported!\n");
	return -1;
#endif
}        

#ifdef WP_TDM_FEATURE_DTMF_EVENTS
int _SAPI_CALL sangoma_tdm_enable_dtmf_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api)
{
	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_DTMF;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_ENABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}

int _SAPI_CALL sangoma_tdm_disable_dtmf_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) 
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_DTMF;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_DISABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}

int _SAPI_CALL sangoma_tdm_enable_rm_dtmf_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) 
{
	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_RM_DTMF;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_ENABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}

int _SAPI_CALL sangoma_tdm_disable_rm_dtmf_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) 
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_RM_DTMF;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_DISABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}

int _SAPI_CALL sangoma_tdm_enable_rxhook_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) 
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_RXHOOK;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_ENABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}

int _SAPI_CALL sangoma_tdm_disable_rxhook_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) 
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_RXHOOK;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_DISABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}

int _SAPI_CALL sangoma_tdm_enable_ring_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) {
	
	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_RING;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_ENABLE;
	
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}


int _SAPI_CALL sangoma_tdm_disable_ring_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) {

	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_RING;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_DISABLE;
	
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}

int _SAPI_CALL sangoma_tdm_enable_ring_detect_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) {
	
	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_RING_DETECT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_ENABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return err;
}


int _SAPI_CALL sangoma_tdm_disable_ring_detect_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) {

	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_RING_DETECT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_DISABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}

int _SAPI_CALL sangoma_tdm_enable_ring_trip_detect_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) {
	
	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_RING_TRIP_DETECT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_ENABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return tdm_api->wp_tdm_cmd.rbs_poll;
}


int _SAPI_CALL sangoma_tdm_disable_ring_trip_detect_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) {

	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_RING_DETECT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_DISABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}

int _SAPI_CALL sangoma_tdm_txsig_kewl(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) {

	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_TXSIG_KEWL;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_ENABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}

int _SAPI_CALL sangoma_tdm_txsig_start(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) {

	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_TXSIG_START;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_ENABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}

int _SAPI_CALL sangoma_tdm_txsig_onhook(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) {

	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_TXSIG_ONHOOK;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_ENABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}

int _SAPI_CALL sangoma_tdm_txsig_offhook(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) {

	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_TXSIG_OFFHOOK;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_ENABLE;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return 0;
}


int _SAPI_CALL sangoma_tdm_enable_tone_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api, uint16_t tone_id) {
	
	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_TONE;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_ENABLE;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_tone_type = tone_id;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return tdm_api->wp_tdm_cmd.rbs_poll;
}

int _SAPI_CALL sangoma_tdm_disable_tone_events(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api) {
	
	int err;
	
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_EVENT;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_type = WP_TDMAPI_EVENT_TONE;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_mode = WP_TDMAPI_EVENT_DISABLE;
	tdm_api->wp_tdm_cmd.event.wp_tdm_api_event_tone_type = 0x00;
	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return tdm_api->wp_tdm_cmd.rbs_poll;
}

#endif

int _SAPI_CALL sangoma_tdm_enable_hwec(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api)
{
        int err;

        tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_ENABLE_HWEC;
        err=sangoma_tdm_cmd_exec(fd,tdm_api);
        if (err){
                return err;
        }

        return 0;
}

int _SAPI_CALL sangoma_tdm_disable_hwec(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api)
{
        int err;

        tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_DISABLE_HWEC;
        err=sangoma_tdm_cmd_exec(fd,tdm_api);
        if (err){
                return err;
        }

        return 0;
}


/*========================================================
 * GET Front End Alarms
 * 
 */                  
#ifdef WP_TDM_FEATURE_FE_ALARM
int _SAPI_CALL sangoma_tdm_get_fe_alarms(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api)
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_GET_FE_ALARMS;

	err=sangoma_tdm_cmd_exec(fd,tdm_api);
	if (err){
		return err;
	}

	return tdm_api->wp_tdm_cmd.fe_alarms;
}         

/* get current Line Connection state - Connected/Disconnected */
int _SAPI_CALL sangoma_tdm_get_fe_status(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api, unsigned char *current_status)
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_GET_FE_STATUS;
	err = sangoma_tdm_cmd_exec(fd, tdm_api);
	*current_status = tdm_api->wp_tdm_cmd.fe_status;

	return err;
}
#endif

/* get current Line Connection state - Connected/Disconnected */
#ifdef WP_TDM_FEATURE_LINK_STATUS
int _SAPI_CALL sangoma_tdm_get_link_status(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api, unsigned char *current_status)
{
	int err;

	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_GET_LINK_STATUS;
	err = sangoma_tdm_cmd_exec(fd, tdm_api);
	*current_status = tdm_api->wp_tdm_cmd.fe_status;

	return err;
}

/* set current Line Connection state - Connected/Disconnected. valid only for ISDN BRI */
int _SAPI_CALL sangoma_tdm_set_fe_status(sng_fd_t fd, wanpipe_tdm_api_t *tdm_api, unsigned char new_status)
{
	tdm_api->wp_tdm_cmd.cmd = SIOC_WP_TDM_SET_FE_STATUS;
	tdm_api->wp_tdm_cmd.fe_status = new_status;

	return sangoma_tdm_cmd_exec(fd, tdm_api);
}
#endif

#endif /* WANPIPE_TDM_API */
