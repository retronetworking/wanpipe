//////////////////////////////////////////////////////////////////////
// sangoma_interface.cpp: interface for Sangoma API driver.
//
// Author	:	David Rokhvarg	<davidr@sangoma.com>
//////////////////////////////////////////////////////////////////////

#include "sangoma_interface.h"

#define DBG_IFACE	if(1)printf
#define INFO_IFACE	if(1)printf
#define ERR_IFACE	if(1)printf

#define IFACE_FUNC() if(1)printf("%s():line:%d\n", __FUNCTION__, __LINE__)

#define DO_COMMAND(wan_udp)	DoManagementCommand(sangoma_wait_obj.fd, &wan_udp);

extern wp_program_settings_t	program_settings;

sangoma_interface::sangoma_interface(int wanpipe_number, int interface_number)
{
	DBG_IFACE( "sangoma_interface::sangoma_interface()\n");

	memset(device_name, 0x00, DEV_NAME_LEN);

	WanpipeNumber = wanpipe_number;
	InterfaceNumber = interface_number;

	//Form the Interface Name from Wanpipe Number and Interface Index (i.e. wanpipe1_if1).
	//(This Interface Name can be used for debugging.)
	_snprintf(device_name, DEV_NAME_LEN, WP_INTERFACE_NAME_FORM, wanpipe_number, interface_number);

	INFO_IFACE("1.Using Device Name: %s\n", device_name);

	//////////////////////////////////////////////////////////////////
	terminate_tx_rx_threads = 0;
	is_rbs_monitoring_enabled = 0;

	memset(&tdm_api, 0, sizeof(tdm_api));

	//////////////////////////////////////////////////////////////////
	//receive stuff
	rx_frames_count = 0;
	rx_bytes_count = 0;
	//for counting frames with CRC/Abort errors
	bad_rx_frames_count = 0;

	//////////////////////////////////////////////////////////////////
	//transmit stuff
	tx_bytes_count = 0;
	tx_frames_count = 0;
	tx_test_byte = 0;

	//////////////////////////////////////////////////////////////////
	//IOCTL management structures and variables
	protocol_cb_size = sizeof(wan_mgmt_t)+sizeof(wan_cmd_t)+1;
	wan_protocol = 0;
	adapter_type = 0;

#if USE_STELEPHONY_API
	stelObj = NULL;
#endif
	generate_bit_rev_table();

}

sangoma_interface::~sangoma_interface()
{
	DBG_IFACE( "sangoma_interface::~sangoma_interface()\n");
	cleanup();
}

int sangoma_interface::init(callback_functions_t *callback_functions_ptr)
{
#if defined(__WINDOWS__) && !defined(__FUNCTION__)
const char * __FUNCTION__ = "sangoma_interface::init";
#endif

	DBG_IFACE("sangoma_interface::init()\n");

	memcpy(&callback_functions, callback_functions_ptr, sizeof(callback_functions_t));

	////////////////////////////////////////////////////////////////////////////
	//open handle for reading and writing data, for events reception and other commands
	sng_fd_t tmp_dev_fd = open_api_device();
    if (tmp_dev_fd == INVALID_HANDLE_VALUE){
		ERR_IFACE( "Unable to open %s for Rx/Tx!\n", device_name);
		return 1;
	}

	if(sangoma_init_wait_obj(&sangoma_wait_obj, tmp_dev_fd, WanpipeNumber, InterfaceNumber, POLLIN | POLLPRI, SANGOMA_WAIT_OBJ)){
		ERR_IFACE("Failed to initialize 'sangoma_wait_object' for %s\n", device_name);
		return 1;
	}

	////////////////////////////////////////////////////////////////////////////
	//get current protocol
	if(get_wan_config() == WAN_FALSE){
		ERR_IFACE( "Failed to get current protocol!\n");
		return 1;
	}

	////////////////////////////////////////////////////////////////////////////
	//get Front End Type (T1/E1/Analog...)
	if (get_fe_type(&adapter_type) == WAN_FALSE){
		ERR_IFACE( "Failed to get Front End Type!\n");
		return 1;
	}

	////////////////////////////////////////////////////////////////////////////
	//may need interface configuration, so get it now
	if(get_interface_configuration(&wanif_conf_struct)){
		ERR_IFACE( "Failed to get Interface Configuration!\n");
		return 1;
	}

	////////////////////////////////////////////////////////////////////////////
#if USE_STELEPHONY_API
	////////////////////////////////////////////////////////////////////////////
	//Sangoma Telephony API (stelephony.dll) provides the following telephony services:
	//1. FSK Caller ID detection for Analog FXO.
	//2. Software DTMF detection.
	//3. Q931 decoding
	scf.FSKCallerIDEvent	= callback_functions.FSKCallerIDEvent;
	scf.DTMFEvent			= callback_functions.DTMFEvent;
	scf.Q931Event			= callback_functions.Q931Event;
	StelSetup(&stelObj, this, &scf);
	DBG_IFACE("%s(): stelObj: 0x%p\n", __FUNCTION__, stelObj);
	if(stelObj){
		stelephony_option_t codec = (program_settings.voice_codec_alaw == 1 ? STEL_OPTION_ALAW : STEL_OPTION_MULAW);
		if(scf.FSKCallerIDEvent){
			StelEventControl(stelObj, STEL_EVENT_FSK_CALLER_ID, STEL_CTRL_CODE_ENABLE, &codec);
		}
		if(scf.DTMFEvent){
			StelEventControl(stelObj, STEL_EVENT_DTMF, STEL_CTRL_CODE_ENABLE, &codec);
		}
		if(scf.Q931Event){
			StelEventControl(stelObj, STEL_EVENT_Q931, STEL_CTRL_CODE_ENABLE, NULL);
		}
    }else{
		/* Possible reasons:
		* 1.ToneDecoder.dll was not registered with COM.
		*	Resolution: in Command Line window run: regsvr32 ToneDecoder.dll.
		*/
		ERR_IFACE("Failed to initialize Stelephony.dll!\n");
		return 1;
	}
#endif

	IFACE_FUNC();
	return 0;
}

sng_fd_t sangoma_interface::open_api_device()
{
#if defined(__WINDOWS__) && !defined(__FUNCTION__)
const char * __FUNCTION__ = "sangoma_interface::open_api_device";
#endif

	DBG_IFACE("%s(): WanpipeNumber: %d, InterfaceNumber: %d\n", __FUNCTION__, WanpipeNumber, InterfaceNumber);

	return sangoma_open_api_span_chan(WanpipeNumber, InterfaceNumber);
}

void sangoma_interface::generate_bit_rev_table(void)
{
	unsigned char util_char;
	unsigned char misc_status_byte;
	int i;

	/* generate the bit-reversing table for all unsigned characters */
	for(util_char = 0;; util_char ++) {
		misc_status_byte = 0;			/* zero the character to be 'built' */
		/* process all 8 bits of the source byte and generate the */
		for(i = 0; i <= 7; i ++) {
		      	/* corresponding 'bit-flipped' character */
			if(util_char & (1 << i)) {
				misc_status_byte |= (1 << (7 - i));
			}
		}
		/* insert the 'bit-flipped' character into the table
		 * at the appropriate location */
		wp_brt[util_char] = misc_status_byte;

		/* exit when all unsigned characters have been processed */
		if(util_char == 0xFF) {
			break;
		}
	}
}

void sangoma_interface::bit_swap_a_buffer(unsigned char *data, int len)
{
	int i;
	for (i=0; i < len; i++){
		data[i]=wp_brt[data[i]];
	}
}

int sangoma_interface::get_wan_config()
{
	int err = WAN_TRUE;

	/* Get Protocol type */
	wan_udp.wan_udphdr_command	= WAN_GET_PROTOCOL;
	wan_udp.wan_udphdr_data_len = 0;

	DO_COMMAND(wan_udp);
	if (wan_udp.wan_udphdr_return_code){
		ERR_IFACE( "Error: Command WANPIPEMON_GET_PROTOCOL failed! return code: 0x%X",
			wan_udp.wan_udphdr_return_code);
		return WAN_FALSE;
	}

	wan_protocol = wan_udp.wan_udphdr_data[0];

	INFO_IFACE( "Device %s running protocol: %s \n",
		device_name, SDLA_DECODE_PROTOCOL(wan_protocol));

	return err;
}

int sangoma_interface::get_fe_type(unsigned char* adapter_type)
{
	int err = WAN_TRUE;

	/* Read Adapter Type */
	wan_udp.wan_udphdr_command = WAN_GET_MEDIA_TYPE;
	wan_udp.wan_udphdr_data[0] = WAN_MEDIA_NONE;
	wan_udp.wan_udphdr_data_len = 0;

	DO_COMMAND(wan_udp);
	if(wan_udp.wan_udphdr_return_code){
		ERR_IFACE( "Error: Command WANPIPEMON_GET_MEDIA_TYPE failed! return code: 0x%X",
			wan_udp.wan_udphdr_return_code);
		return WAN_FALSE;
	}

	*adapter_type =	get_wan_udphdr_data_byte(0);

	INFO_IFACE( "Front End Type: ");
	switch(*adapter_type)
	{
	case WAN_MEDIA_NONE:
		INFO_IFACE( "Serial");
		break;
	case WAN_MEDIA_T1:
		INFO_IFACE( "T1");
		break;
	case WAN_MEDIA_E1:
		INFO_IFACE( "E1");
		break;
	case WAN_MEDIA_56K:
		INFO_IFACE( "56K");
		break;
	case WAN_MEDIA_FXOFXS:
		INFO_IFACE( "Aanalog");
		break;
	case WAN_MEDIA_BRI:
		INFO_IFACE( "ISDN BRI");
		break;
	case WAN_MEDIA_SERIAL:
		INFO_IFACE("Serial");
		break;
	default:
		INFO_IFACE( "Unknown");
		err = WAN_FALSE;
	}
	INFO_IFACE( "\n");

	return err;
}

//return POINTER to data at offset 'off'
unsigned char* sangoma_interface::get_wan_udphdr_data_ptr(unsigned char off)
{
	unsigned char *p_data = (unsigned char*)&wan_udp.wan_udphdr_data[0];
	p_data += off;
	return p_data;
}

unsigned char sangoma_interface::set_wan_udphdr_data_byte(unsigned char off, unsigned char data)
{
	unsigned char *p_data = (unsigned char*)&wan_udp.wan_udphdr_data[0];
	p_data[off] = data;
	return 0;
}

//return DATA at offset 'off'
unsigned char sangoma_interface::get_wan_udphdr_data_byte(unsigned char off)
{
	unsigned char *p_data = (unsigned char*)&wan_udp.wan_udphdr_data[0];
	return p_data[off];
}

void sangoma_interface::get_te1_56k_stat(void)
{
	sdla_fe_stats_t	*fe_stats;

	switch(adapter_type)
	{
	case WAN_MEDIA_T1:
	case WAN_MEDIA_E1:
	case WAN_MEDIA_56K:
		;//do nothing
		break;

	default:
		ERR_IFACE( "Command invalid for Adapter Type %d.\n", adapter_type);
		return;
	}

	/* Read T1/E1/56K alarms and T1/E1 performance monitoring counters */
	wan_udp.wan_udphdr_command = WAN_FE_GET_STAT;
	wan_udp.wan_udphdr_data_len = 0;
   	wan_udp.wan_udphdr_return_code = 0xaa;
   	wan_udp.wan_udphdr_fe_force = 0;
	DO_COMMAND(wan_udp);
	if (wan_udp.wan_udphdr_return_code != 0){
		ERR_IFACE( "Failed to read T1/E1/56K statistics.\n");
		return;
	}

	fe_stats = (sdla_fe_stats_t*)get_wan_udphdr_data_ptr(0);

	if (adapter_type == WAN_MEDIA_T1 || adapter_type == WAN_MEDIA_E1){
		INFO_IFACE("***** %s: %s Alarms (Framer) *****\n\n",
			device_name, (adapter_type == WAN_MEDIA_T1) ? "T1" : "E1");
		INFO_IFACE("ALOS:\t%s\t| LOS:\t%s\n",
				WAN_TE_ALOS_ALARM(fe_stats->alarms),
				WAN_TE_LOS_ALARM(fe_stats->alarms));
		INFO_IFACE("RED:\t%s\t| AIS:\t%s\n",
				WAN_TE_RED_ALARM(fe_stats->alarms),
				WAN_TE_AIS_ALARM(fe_stats->alarms));
		if (adapter_type == WAN_MEDIA_T1){
			INFO_IFACE("RAI:\t%s\t| OOF:\t%s\n",
					WAN_TE_RAI_ALARM(fe_stats->alarms),
					WAN_TE_OOF_ALARM(fe_stats->alarms));
		}else{
			INFO_IFACE("OOF:\t%s\t| RAI:\t%s\n",
					WAN_TE_OOF_ALARM(fe_stats->alarms),
					WAN_TE_RAI_ALARM(fe_stats->alarms));
		}

		if (fe_stats->alarms & WAN_TE_BIT_LIU_ALARM){
			INFO_IFACE("\n***** %s: %s Alarms (LIU) *****\n\n",
				device_name, (adapter_type == WAN_MEDIA_T1) ? "T1" : "E1");
			INFO_IFACE("Short Circuit:\t%s\n",
					WAN_TE_LIU_ALARM_SC(fe_stats->alarms));
			INFO_IFACE("Open Circuit:\t%s\n",
					WAN_TE_LIU_ALARM_OC(fe_stats->alarms));
			INFO_IFACE("Loss of Signal:\t%s\n",
					WAN_TE_LIU_ALARM_LOS(fe_stats->alarms));
		}

	}else if (adapter_type == WAN_MEDIA_56K){
		INFO_IFACE("***** %s: 56K CSU/DSU Alarms *****\n\n\n", device_name);
	 	INFO_IFACE("In Service:\t\t%s\tData mode idle:\t\t%s\n",
			 	INS_ALARM_56K(fe_stats->alarms),
			 	DMI_ALARM_56K(fe_stats->alarms));

	 	INFO_IFACE("Zero supp. code:\t%s\tCtrl mode idle:\t\t%s\n",
			 	ZCS_ALARM_56K(fe_stats->alarms),
			 	CMI_ALARM_56K(fe_stats->alarms));

	 	INFO_IFACE("Out of service code:\t%s\tOut of frame code:\t%s\n",
			 	OOS_ALARM_56K(fe_stats->alarms),
			 	OOF_ALARM_56K(fe_stats->alarms));

	 	INFO_IFACE("Valid DSU NL loopback:\t%s\tUnsigned mux code:\t%s\n",
			 	DLP_ALARM_56K(fe_stats->alarms),
			 	UMC_ALARM_56K(fe_stats->alarms));

	 	INFO_IFACE("Rx loss of signal:\t%s\t\n",
			 	RLOS_ALARM_56K(fe_stats->alarms));

	}else{
		INFO_IFACE("***** %s: Unknown Front End 0x%X *****\n\n",
			device_name, adapter_type);
	}

	if (adapter_type == WAN_MEDIA_T1 || adapter_type == WAN_MEDIA_E1){
		sdla_te_pmon_t*	pmon = &fe_stats->te_pmon;

		INFO_IFACE("\n\n***** %s: %s Performance Monitoring Counters *****\n\n",
				device_name, (adapter_type == WAN_MEDIA_T1) ? "T1" : "E1");
		if (pmon->mask & WAN_TE_BIT_PMON_LCV){
			INFO_IFACE("Line Code Violation\t: %d\n",
						pmon->lcv_errors);
		}
		if (pmon->mask & WAN_TE_BIT_PMON_BEE){
			INFO_IFACE("Bit Errors (CRC6/Ft/Fs)\t: %d\n",
						pmon->bee_errors);
		}
		if (pmon->mask & WAN_TE_BIT_PMON_OOF){
			INFO_IFACE("Out of Frame Errors\t: %d\n",
						pmon->oof_errors);
		}
		if (pmon->mask & WAN_TE_BIT_PMON_FEB){
			INFO_IFACE("Far End Block Errors\t: %d\n",
						pmon->feb_errors);
		}
		if (pmon->mask & WAN_TE_BIT_PMON_CRC4){
			INFO_IFACE("CRC4 Errors\t\t: %d\n",
						pmon->crc4_errors);
		}
		if (pmon->mask & WAN_TE_BIT_PMON_FER){
			INFO_IFACE("Framing Bit Errors\t: %d\n",
						pmon->fer_errors);
		}
		if (pmon->mask & WAN_TE_BIT_PMON_FAS){
			INFO_IFACE("FAS Errors\t\t: %d\n",
						pmon->fas_errors);
		}
	}

	if (adapter_type == WAN_MEDIA_T1 || adapter_type == WAN_MEDIA_E1){
		if (strlen(fe_stats->u.te1_stats.rxlevel)){
			INFO_IFACE("\n\nRx Level\t: %s\n",
					fe_stats->u.te1_stats.rxlevel);
		}
	}

	return;
}

void sangoma_interface::set_lb_modes(unsigned char type, unsigned char mode)
{
	switch(adapter_type)
	{
	case WAN_MEDIA_T1:
	case WAN_MEDIA_E1:
	case WAN_MEDIA_56K:
		;//do nothing
		break;
	default:
		ERR_IFACE( "Command invalid for Adapter Type %d.\n", adapter_type);
		return;
	}
	wan_udp.wan_udphdr_command	= WAN_FE_LB_MODE;
	wan_udp.wan_udphdr_data_len	= 2;
	wan_udp.wan_udphdr_return_code	= 0xaa;

	set_wan_udphdr_data_byte(0,type);
	set_wan_udphdr_data_byte(1,mode);

	DO_COMMAND(wan_udp);

	if (adapter_type == WAN_MEDIA_T1 || adapter_type == WAN_MEDIA_E1){
		INFO_IFACE("%s %s mode ... %s!\n",
				WAN_TE1_LB_ACTION_DECODE(mode),
				WAN_TE1_LB_MODE_DECODE(type),
				(!wan_udp.wan_udphdr_return_code)?"Done":"Failed");
	}else if (adapter_type == WAN_MEDIA_DS3 || adapter_type == WAN_MEDIA_E3){
		INFO_IFACE("%s %s mode ... %s!\n",
				WAN_TE3_LB_ACTION_DECODE(mode),
				WAN_TE3_LB_TYPE_DECODE(type),
				(!wan_udp.wan_udphdr_return_code)?"Done":"Failed");
	}else{
		INFO_IFACE("%s %s mode ... %s (default)!\n",
				WAN_TE1_LB_ACTION_DECODE(mode),
				WAN_TE1_LB_MODE_DECODE(type),
				(!wan_udp.wan_udphdr_return_code)?"Done":"Failed");
	}
	return;
}

unsigned char sangoma_interface::get_adapter_type()
{
	return adapter_type;
}

unsigned int sangoma_interface::get_sub_media()
{
	return wanif_conf_struct.sub_media;
}

int sangoma_interface::get_operational_stats(wanpipe_chan_stats_t *stats)
{
	tdm_api_cmd.cmd = WP_API_CMD_GET_STATS;
	if(tdmv_api_ioctl(&tdm_api_cmd)){
		return 1;
	}

	memcpy(stats, &tdm_api_cmd.stats, sizeof(wanpipe_chan_stats_t));

	INFO_IFACE( "******* OPERATIONAL_STATS *******\n");

	INFO_IFACE("\trx_packets\t: %u\n",			stats->rx_packets);
	INFO_IFACE("\ttx_packets\t: %u\n",			stats->tx_packets);
	INFO_IFACE("\trx_bytes\t: %u\n",			stats->rx_bytes);
	INFO_IFACE("\ttx_bytes\t: %u\n",			stats->tx_bytes);
	INFO_IFACE("\trx_errors\t: %u\n",			stats->rx_errors);
	INFO_IFACE("\ttx_errors\t: %u\n",			stats->tx_errors);
	INFO_IFACE("\trx_dropped\t: %u\n",			stats->rx_dropped);
	INFO_IFACE("\ttx_dropped\t: %u\n",			stats->tx_dropped);
	INFO_IFACE("\tmulticast\t: %u\n",			stats->multicast);
	INFO_IFACE("\tcollisions\t: %u\n",			stats->collisions);

	INFO_IFACE("\trx_length_errors: %u\n",		stats->rx_length_errors);
	INFO_IFACE("\trx_over_errors\t: %u\n",		stats->rx_over_errors);
	INFO_IFACE("\trx_crc_errors\t: %u\n",		stats->rx_crc_errors);
	INFO_IFACE("\trx_frame_errors\t: %u\n",	stats->rx_frame_errors);
	INFO_IFACE("\trx_fifo_errors\t: %u\n",		stats->rx_fifo_errors);
	INFO_IFACE("\trx_missed_errors: %u\n",		stats->rx_missed_errors);

	INFO_IFACE("\ttx_aborted_errors: %u\n",	stats->tx_aborted_errors);
	INFO_IFACE("\tTx Idle Data\t: %u\n",		stats->tx_carrier_errors);

	INFO_IFACE("\ttx_fifo_errors\t: %u\n",		stats->tx_fifo_errors);
	INFO_IFACE("\ttx_heartbeat_errors: %u\n",	stats->tx_heartbeat_errors);
	INFO_IFACE("\ttx_window_errors: %u\n",		stats->tx_window_errors);

	INFO_IFACE("\ttx_packets_in_q: %u\n",	stats->current_number_of_frames_in_tx_queue);
	INFO_IFACE("\ttx_queue_size: %u\n",		stats->max_tx_queue_length);

	INFO_IFACE("\trx_packets_in_q: %u\n",	stats->current_number_of_frames_in_rx_queue);
	INFO_IFACE("\trx_queue_size: %u\n",		stats->max_rx_queue_length);


	INFO_IFACE( "*********************************\n");
	return 0;
}

int sangoma_interface::flush_operational_stats()
{
	tdm_api_cmd.cmd = WP_API_CMD_RESET_STATS;

	if(tdmv_api_ioctl(&tdm_api_cmd)){
		return 1;
	}

	INFO_IFACE( "Command FLUSH_OPERATIONAL_STATS was successful.\n");
	return 0;
}

int sangoma_interface::flush_tx_buffers()
{
	wan_udp.wan_udphdr_command = WP_API_CMD_FLUSH_BUFFERS;
	wan_udp.wan_udphdr_data_len = 0;

	DO_COMMAND(wan_udp);
	if(wan_udp.wan_udphdr_return_code){
		ERR_IFACE( "Error: command FLUSH_TX_BUFFERS failed!\n");
		return 1;
	}

	INFO_IFACE( "Command FLUSH_TX_BUFFERS was successful.\n");
	return 0;
}

int sangoma_interface::enable_rbs_monitoring()
{
	int rc;
	if(is_rbs_monitoring_enabled == 0){
		/* enable RBS monitoring one time per card */
		if(sangoma_tdm_enable_rbs_events(20)){
			ERR_IFACE("sangoma_tdm_enable_rbs_events() failed!\n");
			rc = 1;
		}else{
			is_rbs_monitoring_enabled = 1;
			INFO_IFACE("RBS Monitoring successfully enabled.\n");
			rc = 0;
		}
	}else{
		INFO_IFACE("RBS Monitoring already enabled!! Should be done only once.\n");
		rc = 0;
	}
	return rc;
}

void sangoma_interface::set_idle_tx_data_buffer(unsigned char idle_tx_test_byte)
{
	//set data in Idle Tx buffer in the driver
	tx_data.hdr.data_length = 512;//should be the same as MTU/MRU
	tx_data.hdr.operation_status = SANG_STATUS_TX_TIMEOUT;
	//set the actual data for transmission
	memset(tx_data.data, idle_tx_test_byte, tx_data.hdr.data_length);

	if(DoSetIdleTxBufferCommand(sangoma_wait_obj.fd, &tx_data)){
		//error
		ERR_IFACE("DoSetIdleTxBufferCommand() failed!! Check messages log.\n");
		return;
	}

	if(tx_data.hdr.operation_status != SANG_STATUS_SUCCESS){
		//error
		ERR_IFACE("DoSetIdleTxBufferCommand() failed!!.\n");
		return;
	}
}

//get RBS being received
char sangoma_interface::get_rbs(rbs_management_t *rbs_management_ptr)
{
	wan_udp.wan_udphdr_command = WANPIPEMON_GET_RBS_BITS;
	memcpy(&wan_udp.wan_udphdr_data[0], rbs_management_ptr, sizeof(rbs_management_t));
	wan_udp.wan_udphdr_data_len = sizeof(rbs_management_t);

	DO_COMMAND(wan_udp);
	if(wan_udp.wan_udphdr_return_code){
		ERR_IFACE( "Error: command WANPIPEMON_GET_RBS_BITS failed!\n");
		return 1;
	}

	memcpy(rbs_management_ptr, (rbs_management_t *)&wan_udp.wan_udphdr_data[0],
															sizeof(rbs_management_t));

	INFO_IFACE( "**** WANPIPEMON_GET_RBS_BITS OK ****\n");

	//INFO_IFACE( "ABCD_bits (HEX): 0x%02X\n", rbs_management_ptr->ABCD_bits);

	INFO_IFACE( "Channel: %d, RX RBS: A:%1d B:%1d C:%1d D:%1d\n",
			rbs_management_ptr->channel,
			(rbs_management_ptr->ABCD_bits & WAN_RBS_SIG_A) ? 1 : 0,
			(rbs_management_ptr->ABCD_bits & WAN_RBS_SIG_B) ? 1 : 0,
			(rbs_management_ptr->ABCD_bits & WAN_RBS_SIG_C) ? 1 : 0,
			(rbs_management_ptr->ABCD_bits & WAN_RBS_SIG_D) ? 1 : 0);
	return 0;
}

//set RBS to be transmitted
char sangoma_interface::set_rbs(rbs_management_t *rbs_management_ptr)
{
	wan_udp.wan_udphdr_command = WANPIPEMON_SET_RBS_BITS;
	memcpy(&wan_udp.wan_udphdr_data[0], rbs_management_ptr, sizeof(rbs_management_t));
	wan_udp.wan_udphdr_data_len = sizeof(rbs_management_t);

	DO_COMMAND(wan_udp);
	if(wan_udp.wan_udphdr_return_code){
		ERR_IFACE( "Error: command WANPIPEMON_SET_RBS_BITS failed!\n");
		return 1;
	}

	INFO_IFACE( "**** WANPIPEMON_SET_RBS_BITS OK ****\n");

	//INFO_IFACE( "ABCD_bits (HEX): 0x%02X\n", rbs_management_ptr->ABCD_bits);

	INFO_IFACE( "Channel: %d, TX RBS: A:%1d B:%1d C:%1d D:%1d\n",
			rbs_management_ptr->channel,
			(rbs_management_ptr->ABCD_bits & WAN_RBS_SIG_A) ? 1 : 0,
			(rbs_management_ptr->ABCD_bits & WAN_RBS_SIG_B) ? 1 : 0,
			(rbs_management_ptr->ABCD_bits & WAN_RBS_SIG_C) ? 1 : 0,
			(rbs_management_ptr->ABCD_bits & WAN_RBS_SIG_D) ? 1 : 0);
	return 0;
}

int sangoma_interface::get_interface_configuration(if_cfg_t *wanif_conf_ptr)
{
	wan_udp.wan_udphdr_command = WANPIPEMON_READ_CONFIGURATION;
	wan_udp.wan_udphdr_data_len = sizeof(if_cfg_t);

	memset(wanif_conf_ptr, 0x00, sizeof(if_cfg_t));

	DO_COMMAND(wan_udp);
	if(wan_udp.wan_udphdr_return_code){
		ERR_IFACE( "Error: command READ_CONFIGURATION failed!\n");
		return 1;
	}
	memcpy(wanif_conf_ptr, get_wan_udphdr_data_ptr(0), sizeof(if_cfg_t));

	INFO_IFACE( "**** READ_CONFIGURATION ****\n");
	INFO_IFACE( "Operational Mode\t: %s (%d)\n", SDLA_DECODE_USEDBY_FIELD(wanif_conf_ptr->usedby), wanif_conf_ptr->usedby);
	INFO_IFACE( "Active Channels \t: 0x%08X\n", wanif_conf_ptr->active_ch);
	INFO_IFACE( "Interface Number\t: %u\n", wanif_conf_ptr->interface_number);
	INFO_IFACE( "Media type\t\t: %u\n", wanif_conf_ptr->media);
	INFO_IFACE( "Line Mode\t\t: %s\n", wanif_conf_ptr->line_mode);

#if defined(__WINDOWS__)
	//make sure API driver is configred in correct mode
	switch(wanif_conf_ptr->usedby)
	{
	case TDM_SPAN_VOICE_API:
	case TDM_CHAN_VOICE_API:
	case API:
		//ok
		break;
	default:
		//this application can not run if driver is not in correct mode
		ERR_IFACE("Invalid API Driver Operational Mode: %s (%d)!\n",
			SDLA_DECODE_USEDBY_FIELD(wanif_conf_ptr->usedby), wanif_conf_ptr->usedby);
		return 2;
	}
#endif

	switch(wanif_conf_ptr->media)
	{
	case WAN_MEDIA_FXOFXS:
		switch(wanif_conf_ptr->sub_media)
		{
		case MOD_TYPE_FXS:
			INFO_IFACE( "Media sub-type\t\t: FXS\n");
			break;
		case MOD_TYPE_FXO:
			INFO_IFACE( "Media sub-type\t\t: FXO\n");
			break;
		default:
			INFO_IFACE( "Media sub-type\t\t: Unknown!!\n");
			break;
		}
		break;/* WAN_MEDIA_FXOFXS */

	case WAN_MEDIA_BRI:
		switch(wanif_conf_ptr->sub_media)
		{
		case MOD_TYPE_NT:
			INFO_IFACE( "Media sub-type\t\t: ISDN BRI NT\n");
			break;
		case MOD_TYPE_TE:
			INFO_IFACE( "Media sub-type\t\t: ISDN BRI TE\n");
			break;
		default:
			INFO_IFACE( "Media sub-type\t\t: Unknown!!\n");
			break;
		}
		break;/* WAN_MEDIA_BRI */

	case WAN_MEDIA_SERIAL:
		INFO_IFACE("Media sub-type\t\t: %s\n", INT_DECODE(wanif_conf_ptr->sub_media));
		break;
	}
	INFO_IFACE( "****************************\n");

	return 0;
}

void sangoma_interface::get_api_driver_version (PDRIVER_VERSION version)
{
	wan_udp.wan_udphdr_command = WANPIPEMON_READ_CODE_VERSION;
	wan_udp.wan_udphdr_data_len = 0;

	DO_COMMAND(wan_udp);
	if(wan_udp.wan_udphdr_return_code){
		ERR_IFACE("Error: command READ_CODE_VERSION failed!\n");
		return;
	}

	memcpy(version, (PDRIVER_VERSION)get_wan_udphdr_data_ptr(0), sizeof(DRIVER_VERSION));

	INFO_IFACE("\nAPI version\t: %d,%d,%d,%d\n",
		version->major, version->minor, version->minor1, version->minor2);
	INFO_IFACE("\n");

	INFO_IFACE("Command READ_CODE_VERSION was successful.\n");
}

void sangoma_interface::get_card_customer_id(u_int8_t *customer_id)
{
	wan_udp.wan_udphdr_command = WANPIPEMON_AFT_CUSTOMER_ID;
	wan_udp.wan_udphdr_data_len = 0;

	DO_COMMAND(wan_udp);
	if(wan_udp.wan_udphdr_return_code){
		ERR_IFACE("Error: command SIOC_AFT_CUSTOMER_ID failed!\n");
		return;
	}

	*customer_id = get_wan_udphdr_data_byte(0);

	INFO_IFACE("\nCard Customer ID\t: 0x%02X\n", *customer_id);

	INFO_IFACE("Command SIOC_AFT_CUSTOMER_ID was successful.\n");
}

int sangoma_interface::get_open_handles_counter()
{
	tdm_api_cmd.cmd = WP_API_CMD_OPEN_CNT;
	int err=tdmv_api_ioctl(&tdm_api_cmd);
	if (err) {
		ERR_IFACE( "Error: command GET_OPEN_HANDLES_COUNTER failed!\n");
		return -1;
	}

	return tdm_api_cmd.open_cnt;

#if 0
	wan_udp.wan_udphdr_command = WANPIPEMON_GET_OPEN_HANDLES_COUNTER;
	wan_udp.wan_udphdr_data_len = 0;

	DO_COMMAND(wan_udp);
	if(wan_udp.wan_udphdr_return_code){
		ERR_IFACE( "Error: command GET_OPEN_HANDLES_COUNTER failed!\n");
		return -1;
	}

	return *(int*)&wan_udp.wan_udphdr_data[0];
#endif
}


//It is very important to close ALL open
//handles, because the API will continue
//receive data until the LAST handel is closed.
void sangoma_interface::cleanup()
{
	INFO_IFACE("sangoma_interface::cleanup()\n");
#ifdef WIN32
	if(sangoma_wait_obj.fd != INVALID_HANDLE_VALUE){
		if(is_rbs_monitoring_enabled == 1){
			/* disable RBS monitoring one time per card */
			is_rbs_monitoring_enabled = 0;
			if(sangoma_tdm_disable_rbs_events()){
				ERR_IFACE("sangoma_tdm_disable_rbs_events() failed!\n");
			}
		}
	}
#endif

	if(sangoma_wait_obj.fd != INVALID_HANDLE_VALUE){
		INFO_IFACE( "Closing Rx/Tx fd.\n");
		sangoma_close(&sangoma_wait_obj.fd);
		sangoma_wait_obj.fd = INVALID_HANDLE_VALUE;
	}

#if USE_STELEPHONY_API
	if(stelObj){
		StelCleanup(stelObj);
		stelObj = NULL;
	}
#endif
}

int sangoma_interface::DoWriteCommand(sng_fd_t fd, wp_api_element_t * pTx)
{
	int err = sangoma_writemsg(fd, &pTx->hdr, sizeof(pTx->hdr), pTx->data, pTx->hdr.data_length, 0);
	if(err < 0){
		//error!
		return 1;
	}
	return 0;
}

int sangoma_interface::DoReadCommand(sng_fd_t fd, wp_api_element_t * pRx)
{
	int err = sangoma_readmsg(fd, &pRx->hdr, sizeof(pRx->hdr), pRx->data, MAX_NO_DATA_BYTES_IN_FRAME, 0);

	if(err <= 0){
		//error!
		return 1;
	}
	return 0;
}

// set data in Idle Transmit buffer (BitStream only).
UCHAR sangoma_interface::DoSetIdleTxBufferCommand(sng_fd_t drv, wp_api_element_t * pTx)
{
#if defined(__WINDOWS__)
	DWORD ln, bIoResult;

	bIoResult = DeviceIoControl(
			drv,
			IoctlSetIdleTxBuffer,
			(LPVOID)pTx,
			(ULONG)sizeof(wp_api_element_t),
			(LPVOID)pTx,
			sizeof(wp_api_element_t),
			(LPDWORD)(&ln),
			(LPOVERLAPPED)NULL
			);

	HANDLE_DEVICE_IOCTL_RESULT(bIoResult);
#else
	int err;
	err = ioctl(drv,WANPIPE_IOCTL_SET_IDLE_TX_BUFFER, pTx);
	if (err < 0) {
		return 1;
	}
#endif
	return 0;
}

int sangoma_interface::DoManagementCommand(sng_fd_t fd, wan_udp_hdr_t* wan_udp)
{
	return sangoma_mgmt_cmd(fd, wan_udp);
}

int sangoma_interface::tdmv_api_ioctl(wanpipe_api_cmd_t *api_cmd)
{
	wanpipe_api_t tmp;
	int err;

	memcpy(&tmp.wp_cmd, api_cmd, sizeof(wanpipe_api_cmd_t));

	err = sangoma_cmd_exec(sangoma_wait_obj.fd, &tmp);

	memcpy(api_cmd, &tmp.wp_cmd, sizeof(wanpipe_api_cmd_t));

	return err;
}

int sangoma_interface::sangoma_tdm_enable_ring_detect_events()
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_RING_DETECT;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_ENABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_disable_ring_detect_events()
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_RING_DETECT;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_DISABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_enable_ring_trip_detect_events()
{
	DBG_IFACE("%s()\n", __FUNCTION__);

	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_RING_TRIP_DETECT;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_ENABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_disable_ring_trip_detect_events()
{
	DBG_IFACE("%s()\n", __FUNCTION__);

	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_RING_DETECT;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_DISABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_enable_rm_dtmf_events()
{
	DBG_IFACE("%s()\n", __FUNCTION__);

	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_RM_DTMF;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_ENABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_disable_rm_dtmf_events()
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_RM_DTMF;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_DISABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_enable_dtmf_events(uint8_t channel)
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_DTMF;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_ENABLE;
	tdm_api_cmd.event.channel = channel;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_disable_dtmf_events(uint8_t channel)
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_DTMF;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_DISABLE;
	tdm_api_cmd.event.channel = channel;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_enable_rxhook_events()
{
	DBG_IFACE("%s()\n", __FUNCTION__);

	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_RXHOOK;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_ENABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_disable_rxhook_events()
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_RXHOOK;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_DISABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_enable_ring_events()
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_RING;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_ENABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_disable_ring_events()
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_RING;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_DISABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_txsig_onhook()
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_TXSIG_ONHOOK;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_ENABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_txsig_offhook()
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_TXSIG_OFFHOOK;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_ENABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_enable_tone_events(uint16_t tone_id)
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_TONE;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_ENABLE;
	tdm_api_cmd.event.wp_api_event_tone_type = tone_id;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_disable_tone_events()
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_TONE;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_DISABLE;
	tdm_api_cmd.event.wp_api_event_tone_type = 0x00;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_enable_bri_bchan_loopback(u_int8_t channel)
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.channel				= channel;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_BRI_CHAN_LOOPBACK;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_ENABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::sangoma_tdm_disable_bri_bchan_loopback(u_int8_t channel)
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_EVENT;
	tdm_api_cmd.event.channel				= channel;
	tdm_api_cmd.event.wp_api_event_type = WP_API_EVENT_BRI_CHAN_LOOPBACK;
	tdm_api_cmd.event.wp_api_event_mode = WP_API_EVENT_DISABLE;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

/* 1. Enable 'writing' of RBS bits on card.
   2. Enable monitoring change in state of RBS bits.
      'polls_per_second' - how many times per second API driver will check for
      change in state of RBS bits.
      Valid values are between 20 and 100 (including). */
int sangoma_interface::sangoma_tdm_enable_rbs_events(int polls_per_second)
{
	tdm_api_cmd.cmd = WP_API_CMD_ENABLE_RBS_EVENTS;
	tdm_api_cmd.rbs_poll = polls_per_second;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

/* Stop monitoring change in state of RBS bits */
int sangoma_interface::sangoma_tdm_disable_rbs_events()
{
	tdm_api_cmd.cmd = WP_API_CMD_DISABLE_RBS_EVENTS;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

/* Activate ISDN BRI line. */
int sangoma_interface::sangoma_tdm_front_end_activate()
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_FE_STATUS;
	tdm_api_cmd.fe_status = WAN_FE_CONNECTED;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

/* De-activate ISDN BRI line. */
int sangoma_interface::sangoma_tdm_front_end_deactivate()
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_FE_STATUS;
	tdm_api_cmd.fe_status = WAN_FE_DISCONNECTED;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

/* get current state of the line - is it Connected or Disconnected */
int sangoma_interface::sangoma_tdm_get_front_end_status(unsigned char *status)
{
	int rc;
	tdm_api_cmd.cmd = WP_API_CMD_GET_FE_STATUS;
	rc = tdmv_api_ioctl(&tdm_api_cmd);
	printf("rc: %d\n", rc);
	if(rc == 0){
		*status = tdm_api_cmd.fe_status;
	}
	return rc;
}

/* Milliseconds interval between receive of Voice Data */
int sangoma_interface::sangoma_tdm_set_user_period(unsigned int usr_period)
{
	tdm_api_cmd.cmd = WP_API_CMD_SET_USR_PERIOD;
	tdm_api_cmd.usr_period = usr_period;
	return tdmv_api_ioctl(&tdm_api_cmd);
}

int sangoma_interface::stop()
{
	int wait_counter = 0;
	DBG_IFACE("sangoma_interface::stop()\n");

	INFO_IFACE( "Stopping.");

	terminate_tx_rx_threads = 1;
	while(terminate_tx_rx_threads == 1 && wait_counter++ < 5){
		INFO_IFACE( ".");
		Sleep(500);
	}
	INFO_IFACE( "\n");

	switch(wanif_conf_struct.media)
	{
	case WAN_MEDIA_FXOFXS:
		switch(wanif_conf_struct.sub_media)
		{
		case MOD_TYPE_FXS:
			stop_all_tones();
			stop_ringing_phone();
			break;

		case MOD_TYPE_FXO:
			fxo_go_on_hook();
			break;
		}
		break;
	}

	return 0;
}

int sangoma_interface::run()
{
	DBG_IFACE("sangoma_interface::run()\n");

	switch(wanif_conf_struct.media)
	{
	case WAN_MEDIA_FXOFXS:
		switch(wanif_conf_struct.sub_media)
		{
		case MOD_TYPE_FXS:
			sangoma_tdm_enable_rxhook_events();
			sangoma_tdm_enable_rm_dtmf_events();
			sangoma_tdm_enable_ring_trip_detect_events();
			break;
		case MOD_TYPE_FXO:
			sangoma_tdm_enable_ring_detect_events();
			break;
		}
		break;
	}

	////////////////////////////////////////////////////////////////////////////
	//Start a thread for receiving data only
    if(this->CreateThread(1) == false){
		ERR_IFACE( "Failed to create Rx thread!!\n");
		return 1;
	}

	return 0;
}

unsigned long sangoma_interface::threadFunction (void *parameter)
{
	switch((int)parameter)
	{
	case 1:
		RxThreadFunc();
		return 0;//ok
	}
	return 1;//invalid thread function was requested
}

// Read Thread
void sangoma_interface::RxThreadFunc()
{
	int iResult;

	INFO_IFACE("\n%s: %s() - start\n", device_name, __FUNCTION__);
#if defined(__WINDOWS__)
	INFO_IFACE("ThreadID: %d - Start\n", ::GetCurrentThreadId());
#endif

	while(terminate_tx_rx_threads == 0){

		sangoma_wait_obj.flags_in = (POLLPRI | POLLIN); //only interested in Rx data and Events

		iResult = sangoma_socket_waitfor_many(&sangoma_wait_obj, 1 /* number of objects */, 2000 /* 2 sec timeout */);

		if(iResult < 0){
			//error
			ERR_IFACE("iResult: %d\n", iResult);
			break;
		}

		if(iResult == 0){
			//timeout. try again.
			DBG_IFACE("Timeout\n");
			continue;
		}

		if(sangoma_wait_obj.flags_out & POLLPRI){
			/* event */
			if(read_event()){
				ERR_IFACE("Error in read_event()!\n");
			}
		}

		if(sangoma_wait_obj.flags_out & POLLIN){
			/* data */
			if(read_data()){
				ERR_IFACE("Error in read_data()!\n");
			}
		}

	}//while()

	terminate_tx_rx_threads = 2;

	INFO_IFACE("\n%s: %s() - end\n", device_name, __FUNCTION__);
#if defined(__WINDOWS__)
	INFO_IFACE("ThreadID: %d - End\n", ::GetCurrentThreadId());
#endif
}

///////////////////////////////////////////////////////////////////////

int sangoma_interface::read_event()
{
	int err;
	wp_api_event_t *rx_event = &tdm_api.wp_cmd.event;

#if 0
	print_poll_event_bitmap(sangoma_wait_obj.flags_out);
	printf("\n");
#endif

	memset(&tdm_api, 0, sizeof(tdm_api));

	err = sangoma_read_event(sangoma_wait_obj.fd, &tdm_api);

	if(err){
		return err;
	}

	callback_functions.got_TdmApiEvent(this, rx_event);

	return 0;
}

///////////////////////////////////////////////////////////////////////

int sangoma_interface::read_data()
{
	int rc = 0;
	wp_api_hdr_t		*pri;

	if(receive(&rx_data) ){
		//error
		ERR_IFACE( "receive() failed!! Check messages log.\n");
		return 1;
	}

	//use our special buffer at rxdata to hold received data
	pri = &rx_data.hdr;

	switch(pri->operation_status)
	{
	case SANG_STATUS_RX_DATA_AVAILABLE:
#if USE_STELEPHONY_API
		if(stelObj){
			if(scf.FSKCallerIDEvent	|| scf.DTMFEvent || scf.Q931Event){
				//if at lease one event is enabled, Rx data is the input for decoder.
				wp_api_element_t* pRx = &rx_data;
				StelStreamInput(stelObj, pRx->data, pRx->hdr.data_length);
			}
		}
#endif
#if 0
		//Some useful information about API's internal receive queue
		//is available after each successful IoctlReadCommand:
		DBG_IFACE("max_rx_queue_length: %d current_number_of_frames_in_rx_queue: %d\n",
			rx_data.hdr.wp_api_rx_hdr_max_queue_length,
			rx_data.hdr.wp_api_rx_hdr_number_of_frames_in_queue);
#endif
		//INFO_IFACE("Rx Length = %i\n",rx_data.hdr.wp_api_hdr_data_length);

		callback_functions.got_rx_data(this, &rx_data);
		break;

	default:
		ERR_IFACE("%s: Rx Error: Operation Status: %s(%d)\n", device_name,
			SDLA_DECODE_SANG_STATUS(pri->operation_status), pri->operation_status);
		rc = 1;
		break;
	}//switch()
	return rc;
}

///////////////////////////////////////////////////////////////////////

int sangoma_interface::receive(wp_api_element_t *pRx)
{
	return DoReadCommand(sangoma_wait_obj.fd, pRx);
}

///////////////////////////////////////////////////////////////////////

int sangoma_interface::transmit(wp_api_element_t *pTx)
{
	int err;

	do{
		err = DoWriteCommand(sangoma_wait_obj.fd, pTx);
		if(err){
			//error
			printf("DoWriteCommand() failed!! Check messages log.\n");
			return err;
		}

		//check that frame was transmitted
		switch(pTx->hdr.operation_status)
		{
		case SANG_STATUS_SUCCESS:
			err = 0;
			//printf("Frame queued for transmission.\n");
#if 0
			//Some useful information about API's internal transmit queue
			//is available after each successful transmission:
			printf("max_tx_queue_length: %d current_number_of_frames_in_tx_queue: %d\n",
				pTx->hdr.tx_h.max_tx_queue_length,
				pTx->hdr.tx_h.current_number_of_frames_in_tx_queue);
#endif
			return SANG_STATUS_SUCCESS;

		case SANG_STATUS_DEVICE_BUSY:
			err = 0;
			break;

		default:
			err = 1;
			DBG_IFACE("Error: Return code: %s(%d) on transmission!\n",
				SDLA_DECODE_SANG_STATUS(pTx->hdr.operation_status),
				pTx->hdr.operation_status);
			break;
		}//switch()

	}while(err == 0);

	return pTx->hdr.operation_status;
}

///////////////////////////////////////////////////////////////////////
int sangoma_interface::start_ring_tone()
{
	DBG_IFACE( "%s:start_ring_tone()\n", device_name);
	return sangoma_tdm_enable_tone_events(WP_API_EVENT_TONE_RING);
}
///////////////////////////////////////////////////////////////////////
int sangoma_interface::start_congestion_tone()
{
	DBG_IFACE( "%s:start_congestion_tone()\n", device_name);
	return sangoma_tdm_enable_tone_events(WP_API_EVENT_TONE_CONGESTION);
}
///////////////////////////////////////////////////////////////////////
int sangoma_interface::start_busy_tone()
{
	DBG_IFACE( "%s:start_busy_tone()\n", device_name);
	return sangoma_tdm_enable_tone_events(WP_API_EVENT_TONE_BUSY);
}

///////////////////////////////////////////////////////////////////////
int sangoma_interface::start_dial_tone()
{
	DBG_IFACE( "%s:start_dial_tone()\n", device_name);
	return sangoma_tdm_enable_tone_events(WP_API_EVENT_TONE_DIAL);
}
///////////////////////////////////////////////////////////////////////
int sangoma_interface::stop_all_tones()
{
	DBG_IFACE( "%s:stop_all_tones()\n", device_name);
	return sangoma_tdm_disable_tone_events();
}

///////////////////////////////////////////////////////////////////////
int sangoma_interface::start_ringing_phone()
{
	DBG_IFACE( "%s:start_ringing_phone()\n", device_name);
	return sangoma_tdm_enable_ring_events();
}
int sangoma_interface::stop_ringing_phone()
{
	DBG_IFACE( "%s:stop_ringing_phone()\n", device_name);
	return sangoma_tdm_disable_ring_events();
}
///////////////////////////////////////////////////////////////////////
int sangoma_interface::fxo_go_off_hook()
{
	DBG_IFACE( "%s:fxo_go_off_hook()\n", device_name);

	if(wanif_conf_struct.sub_media != MOD_TYPE_FXO){
		ERR_IFACE( "%s: The 'Go Off Hook' command valid only for FXO!\n", device_name);
		return 1;
	}
	return sangoma_tdm_txsig_offhook();
}

int sangoma_interface::fxo_go_on_hook()
{
	DBG_IFACE( "%s:fxo_go_on_hook()\n", device_name);

	if(wanif_conf_struct.sub_media != MOD_TYPE_FXO){
		ERR_IFACE( "%s: The 'Go On Hook' command valid only for FXO!\n", device_name);
		return 1;
	}
	return sangoma_tdm_txsig_onhook();
}

//set a Telephony interface to it's default state
int sangoma_interface::reset_interface_state()
{
	DBG_IFACE("%s:reset_interface_state()\n", device_name);

	switch(wanif_conf_struct.media)
	{
	case WAN_MEDIA_FXOFXS:
		switch(wanif_conf_struct.sub_media)
		{
		case MOD_TYPE_FXS:
			stop_all_tones();
			stop_ringing_phone();
			break;

		case MOD_TYPE_FXO:
			fxo_go_on_hook();
			break;
		}
		break;
	}
	return 0;
}

