--- aftpipemon.orig.c	2007-03-05 18:06:36.000000000 -0500
+++ aftpipemon.c	2007-03-28 20:16:56.628841776 -0500
@@ -19,6 +19,7 @@
 #include <stdio.h>
 #include <stddef.h>	/* offsetof(), etc. */
 #include <ctype.h>
+#include <time.h>
 #include <sys/time.h>
 #include <sys/types.h>
 #include <unistd.h>
@@ -168,7 +169,7 @@
 	
 	while(gui_cmd_menu_lookup[i].cmd_menu_ptr != NULL){
 		if (strcmp(cmd_name,gui_cmd_menu_lookup[i].cmd_menu_name) == 0){
-			cmd_menu=gui_cmd_menu_lookup[i].cmd_menu_ptr;
+			cmd_menu=(char*)gui_cmd_menu_lookup[i].cmd_menu_ptr;
 			while (strcmp(cmd_menu[j],".") != 0){
 				j++;
 			}
@@ -437,6 +438,231 @@
 	return 0;
 }
 
+static int print_local_time (char *date_string)
+{
+	
+  	char tmp_time[50];
+	time_t time_val;
+	struct tm *time_tm;
+	
+	date_string[0]='\0';
+
+	time_val=time(NULL);
+		
+	/* Parse time and date */
+	time_tm=localtime(&time_val);
+
+	strftime(tmp_time,sizeof(tmp_time),"%b",time_tm);
+	sprintf(date_string, " %s ",tmp_time);
+
+	strftime(tmp_time,sizeof(tmp_time),"%d",time_tm);
+	sprintf(date_string+strlen(date_string), "%s ",tmp_time);
+
+	strftime(tmp_time,sizeof(tmp_time),"%H",time_tm);
+	sprintf(date_string+strlen(date_string), "%s:",tmp_time);
+
+	strftime(tmp_time,sizeof(tmp_time),"%M",time_tm);
+	sprintf(date_string+strlen(date_string), "%s:",tmp_time);
+
+	strftime(tmp_time,sizeof(tmp_time),"%S",time_tm);
+	sprintf(date_string+strlen(date_string), "%s",tmp_time);
+
+	return 0;
+}
+
+static int loop_rx_data(int passnum)
+{
+	unsigned int num_frames;
+	unsigned short curr_pos = 0;
+	wan_trace_pkt_t *trace_pkt;
+	unsigned int i;
+	struct timeval to;
+	int timeout=0;
+	unsigned char date_string[100];
+	
+	gettimeofday(&to, NULL);
+	to.tv_sec = 0;
+	to.tv_usec = 0;
+	
+	print_local_time(date_string);
+		
+	printf("%s | Test %04i | ",
+		date_string, passnum);
+	
+        for(;;) {
+	
+		select(1,NULL, NULL, NULL, &to);
+		
+		wan_udp.wan_udphdr_command = GET_TRACE_INFO;
+		wan_udp.wan_udphdr_return_code = 0xaa;
+		wan_udp.wan_udphdr_data_len = 0;
+		DO_COMMAND(wan_udp);
+		
+		if (wan_udp.wan_udphdr_return_code == 0 && wan_udp.wan_udphdr_data_len) { 
+		     
+			num_frames = wan_udp.wan_udphdr_aft_num_frames;
+
+		     	for ( i = 0; i < num_frames; i++) {
+				trace_pkt= (wan_trace_pkt_t *)&wan_udp.wan_udphdr_data[curr_pos];
+
+				/*  frame type */
+				if (trace_pkt->status & 0x01) {
+					trace_iface.status |= WP_TRACE_OUTGOING;
+				}else{
+					if (trace_pkt->status & 0x10) { 
+						trace_iface.status |= WP_TRACE_ABORT;
+					} else if (trace_pkt->status & 0x20) {
+						trace_iface.status |= WP_TRACE_CRC;
+					} else if (trace_pkt->status & 0x40) {
+						trace_iface.status |= WP_TRACE_OVERRUN;
+					}
+				}
+
+				trace_iface.len = trace_pkt->real_length;
+				trace_iface.timestamp=trace_pkt->time_stamp;
+				trace_iface.sec = trace_pkt->sec;
+				trace_iface.usec = trace_pkt->usec;
+				
+				curr_pos += sizeof(wan_trace_pkt_t);
+		
+				if (trace_pkt->real_length >= WAN_MAX_DATA_SIZE){
+					printf("\t:the frame data is to big (%u)!",
+									trace_pkt->real_length);
+					fflush(stdout);
+					continue;
+
+				}else if (trace_pkt->data_avail == 0) {
+
+					printf("\t: the frame data is not available" );
+					fflush(stdout);
+					continue;
+				} 
+
+				
+				/* update curr_pos again */
+				curr_pos += trace_pkt->real_length;
+			
+				trace_iface.trace_all_data=trace_all_data;
+				trace_iface.data=(unsigned char*)&trace_pkt->data[0];
+
+				
+				if (trace_pkt->status & 0x01){ 
+					continue;
+				}
+				
+				if (trace_iface.data[0] == (0xFF-0) &&
+				    trace_iface.data[1] == (0xFF-1) &&
+				    trace_iface.data[2] == (0xFF-2) &&
+				    trace_iface.data[3] == (0xFF-3)) {
+				 	printf("Successful (%s)!\n",
+						trace_iface.status & WP_TRACE_ABORT ? "Abort" :
+						trace_iface.status & WP_TRACE_CRC ? "Crc" :
+						trace_iface.status & WP_TRACE_OVERRUN ? "Overrun" : "Ok"
+						);   
+					return 0;
+				} 
+				
+				
+
+		   	} //for
+		} //if
+		curr_pos = 0;
+
+		if (!wan_udp.wan_udphdr_chdlc_ismoredata){
+			to.tv_sec = 0;
+			to.tv_usec = WAN_TRACE_DELAY;
+			timeout++;
+			if (timeout > 100) {
+				printf("Timeout!\n");
+				break;
+			}   
+		}else{
+			to.tv_sec = 0;
+			to.tv_usec = 0;
+		}
+	}
+	return 0;
+}
+
+
+static int aft_digital_loop_test( void )
+{
+	int passnum=0;
+	
+        /* Disable trace to ensure that the buffers are flushed */
+        wan_udp.wan_udphdr_command= DISABLE_TRACING;
+        wan_udp.wan_udphdr_return_code = 0xaa;
+        wan_udp.wan_udphdr_data_len = 0;
+        DO_COMMAND(wan_udp);
+
+        wan_udp.wan_udphdr_command= ENABLE_TRACING;
+        wan_udp.wan_udphdr_return_code = 0xaa;
+        wan_udp.wan_udphdr_data_len = 1;
+        wan_udp.wan_udphdr_data[0]=0;
+
+        DO_COMMAND(wan_udp);
+	if (wan_udp.wan_udphdr_return_code != 0 && 
+            wan_udp.wan_udphdr_return_code != 1) {
+		printf("Error: Failed to start loop test: failed to start tracing!\n");
+		return -1;
+	}
+	
+	printf("Starting Loop Test (press ctrl-c to exit)!\n\n");
+
+	while (1) {
+
+		wan_udp.wan_udphdr_command= DIGITAL_LOOPTEST;
+		wan_udp.wan_udphdr_return_code = 0xaa;
+		wan_udp.wan_udphdr_data[0] = 0xFF-0;
+		wan_udp.wan_udphdr_data[1] = 0xFF-1;
+		wan_udp.wan_udphdr_data[2] = 0xFF-2;
+		wan_udp.wan_udphdr_data[3] = 0xFF-3;
+		wan_udp.wan_udphdr_data_len = 100;
+		DO_COMMAND(wan_udp);	
+
+		switch (wan_udp.wan_udphdr_return_code) {
+		
+		case 0:
+			break;
+		case 1:
+	                printf("Error: Failed to start loop test: dev not found\n");
+			goto loop_rx_exit;
+		case 2:
+	                printf("Error: Failed to start loop test: dev state not connected\n");
+			goto loop_rx_exit;
+		case 3:
+	                printf("Error: Failed to start loop test: memory error\n");
+			goto loop_rx_exit;
+		case 4:
+	                printf("Error: Failed to start loop test: invalid operation mode\n");
+			goto loop_rx_exit;
+
+		default:
+			printf("Error: Failed to start loop test: unknown error (%i)\n",
+				wan_udp.wan_udphdr_return_code);
+			goto loop_rx_exit;
+		}
+
+
+		loop_rx_data(++passnum);
+		usleep(500000);
+		fflush(stdout);
+		
+		if (passnum >= 10) {
+			break;
+		}		
+	}
+
+loop_rx_exit:
+	
+	wan_udp.wan_udphdr_command= DISABLE_TRACING;
+        wan_udp.wan_udphdr_return_code = 0xaa;
+        wan_udp.wan_udphdr_data_len = 0;
+        DO_COMMAND(wan_udp);
+
+	return 0;
+}
+
 static void line_trace(int trace_mode) 
 {
 	unsigned int num_frames;
@@ -447,7 +673,6 @@
 	fd_set ready;
 	struct timeval to;
    
-
 	setsockopt( sock, SOL_SOCKET, SO_RCVBUF, &recv_buff, sizeof(int) );
 
 	/* Disable trace to ensure that the buffers are flushed */
@@ -780,7 +1005,8 @@
 	printf("\t   t         i       Trace and Interpret ALL frames\n");
 	printf("\t             r       Trace ALL frames, in RAW format\n");
 	printf("\tT1/E1 Configuration/Statistics\n");
-	printf("\t   T         a       Read T1/E1/56K alarms.\n");  
+	printf("\t   T         a       Read T1/E1/56K alarms.\n"); 
+	printf("\t             lt      Diagnostic Digital Loopback testing (T1/E1 card only)\n"); 
 	printf("\t             allb    Active Line Loopback mode (T1/E1 card only)\n");  
 	printf("\t             dllb    Deactive Line Loopback mode (T1/E1 card only)\n");  
 	printf("\t             aplb    Active Payload Loopback mode (T1/E1 card only)\n");  
@@ -871,7 +1097,7 @@
 	char		*opt=&command[1];
 	int		mod_no = 0, i, err;
 	sdla_fe_debug_t	fe_debug;
-
+			
 	switch(command[0]){
 
 		case 'x':
@@ -906,7 +1132,7 @@
 				raw_data = WAN_TRUE;
 				trace_iface.type=WP_OUT_TRACE_RAW;
 				line_trace(0);
-			}else if (!strcmp(opt, "rh")){
+                        }else if (!strcmp(opt, "rh")){
 				raw_data = WAN_TRUE;
 				trace_iface.type=WP_OUT_TRACE_HDLC;
 				line_trace(0);
@@ -948,6 +1174,8 @@
 		case 'T':
 			if (!strcmp(opt,"read")){
 				read_ft1_te1_56k_config();
+			}else if (!strcmp(opt,"lt")){
+ 				aft_digital_loop_test();
 			}else if (!strcmp(opt,"allb")){
 				set_lb_modes(WAN_TE1_LINELB_MODE, WAN_TE1_ACTIVATE_LB);
 			}else if (!strcmp(opt,"dllb")){
@@ -965,7 +1193,9 @@
 			}else if (!strcmp(opt,"sdlb")){
 				set_lb_modes(WAN_TE1_TX_LB_MODE, WAN_TE1_DEACTIVATE_LB);
 			}else if (!strcmp(opt,"a")){
-				read_te1_56k_stat();
+				read_te1_56k_stat(0);
+			}else if (!strcmp(opt,"af")){
+				read_te1_56k_stat(1);
 			}else if (!strcmp(opt,"txe")){
 				set_fe_tx_mode(WAN_FE_TXMODE_ENABLE);
 			}else if (!strcmp(opt,"txd")){
